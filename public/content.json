{"meta":{"title":"爱上猫的小鱼儿","subtitle":"--个人博客","description":"技术决定未来....","author":"jlynet","url":"https://jlynet.github.io","root":"/"},"pages":[],"posts":[{"title":"Unicode character issue 0 to 255","slug":"Unicode-character-issue-0-to-255","date":"2024-06-05T03:16:29.000Z","updated":"2024-06-05T03:31:43.435Z","comments":true,"path":"2024/06/05/Unicode-character-issue-0-to-255/","link":"","permalink":"https://jlynet.github.io/2024/06/05/Unicode-character-issue-0-to-255/","excerpt":"","text":"代码实现1response.sendRedirect(\"test.html?name=我是中文aaaa\"); 运行容器 Tomcat 8.5.100 出现的错误12345678910111213141516171819Caused by: java.lang.IllegalArgumentException: The Unicode character [Б] at code point [1,041] cannot be encoded as it is outside the permitted range of 0 to 255. at org.apache.coyote.http2.HPackHuffman.encode(HPackHuffman.java:452) at org.apache.coyote.http2.HpackEncoder.writeHuffmanEncodableValue(HpackEncoder.java:229) at org.apache.coyote.http2.HpackEncoder.encode(HpackEncoder.java:191) at org.apache.coyote.http2.Http2UpgradeHandler.doWriteHeaders(Http2UpgradeHandler.java:727) at org.apache.coyote.http2.Http2UpgradeHandler.writeHeaders(Http2UpgradeHandler.java:680) at org.apache.coyote.http2.Stream.writeHeaders(Stream.java:466) at org.apache.coyote.http2.StreamProcessor.prepareResponse(StreamProcessor.java:151) at org.apache.coyote.AbstractProcessor.action(AbstractProcessor.java:379) at org.apache.coyote.Response.action(Response.java:211) at org.apache.coyote.Response.sendHeaders(Response.java:440) at org.apache.coyote.http2.Http2OutputBuffer.doWrite(Http2OutputBuffer.java:57) at org.apache.coyote.Response.doWrite(Response.java:615) at org.apache.catalina.connector.OutputBuffer.realWriteBytes(OutputBuffer.java:340) at org.apache.catalina.connector.OutputBuffer.flushByteBuffer(OutputBuffer.java:784) at org.apache.catalina.connector.OutputBuffer.append(OutputBuffer.java:689) at org.apache.catalina.connector.OutputBuffer.writeBytes(OutputBuffer.java:388) at org.apache.catalina.connector.OutputBuffer.write(OutputBuffer.java:366) at org.apache.catalina.connector.CoyoteOutputStream.write(CoyoteOutputStream.java:96) 解决 参考 https://gitee.com/jlynet-openSrc/jlynet-Tomcat.git","categories":[{"name":"中间件","slug":"中间件","permalink":"https://jlynet.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"技术笔记","slug":"中间件/技术笔记","permalink":"https://jlynet.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://jlynet.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://jlynet.github.io/tags/Tomcat/"},{"name":"中间件","slug":"中间件","permalink":"https://jlynet.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"HAProxy 原理 & dash board 各指标含义","slug":"HAProxy-原理-dash-board-各指标含义","date":"2022-08-04T03:05:01.000Z","updated":"2022-08-04T08:30:00.000Z","comments":true,"path":"2022/08/04/HAProxy-原理-dash-board-各指标含义/","link":"","permalink":"https://jlynet.github.io/2022/08/04/HAProxy-%E5%8E%9F%E7%90%86-dash-board-%E5%90%84%E6%8C%87%E6%A0%87%E5%90%AB%E4%B9%89/","excerpt":"","text":"原理 HAProxy将客户端ip进行Hash计算并保存，由此确保相同IP访问时被转发到同一真实服务器上。 HAProxy依靠真实服务器发送给客户端的cookie信息进行回话保持。 HAProxy保存真实服务器的session及服务器标识，实现会话保持功能。 Frontend 负责client，Backend 负责server Dash board rate分了： connection rate per second ：clients连接至HAProxy的频率（还没有创建完整的sessions） session rate per second：session 作为一个持有端到端连接（client到HAProxy，HAProxy到后端服务器）状态的实体，被创建的速率 request rate per second：在建立的连接上，HTTP请求被接收的频率 Session rate 描述client连接到HAProxy的速率。 Cur： session 作为一个持有端到端连接（client到HAProxy，HAProxy到后端服务器）状态的实体，被创建的速率Max： 同一时刻，使用中的最多session数Limit： 前端每秒可接收的最大session数。设置在 rate-limit sessions. 如果这个限制被超过，多出来的连接将被pending在socket的backlog中（在系统buffer里） Sessions 负载均衡器上，使用中的sessions或完整client-to-server连接的数量。 Cur： 当前建完sessions 数量Max： 最多同时建过的sessions数Limit：最大并发的sessions数，定义在 frontend中的maxconn。达到这个限制后，前端将停止接收新的连接。如果maxconn 没有设置，Limit将和您的配置中global那一节的maxconn 值相同。若这个也没设，那么Limit将基于您的系统（tnnd，在公司呆久了，都变您了） Denied基于安全考虑，拒掉的request or response 数量 Errors Req：遇到错误的request数量 Conn：遇到错误的connection数量 Resp：遇到错误的responds数量Server对frontend而言，只有Status有值 Status：当Status为OPEN时，frontend处于正常运行状态，并且可以接收traffic。当你执行Runtime API 命令 disable frontend ，你可以disable frontend，这时status将变为STOP。对backend而言，Server 展示了关于 状态、健康程度、各server的权重。 Status：有如下的值 Status What it means UP The server is reporting as healthy. DOWN The server is reporting as unhealthy and unable to receive requests. NOLB You’ve added http-check disable-on-404 to the backend and the health checked URL has returned an HTTP 404 response. MAINT The server has been disabled or put into maintenance mode. DRAIN The server has been put into drain mode. no check Health checks are not enabled for this server. LastChk :会有一个值 like L7OK/200 in 1ms。 表示已经执行了一个Layer 7的健康检查，并返回了一个HTTP 200 OK的response，且这一系列动作耗时&lt;=1ms。 若您看到L4OK in 0ms，意味着Haproxy可以和server建立一个 Layer 4 connection Wght: traffic被接受的比例，as set by the weight parameter on the server line. Act：该server为active（标为Y）还是backup（标为 a -） Bck：该server为backup（标为Y） 还是 active（标为 a -） Chk： 失败的健康检查数 Dwn：从UP到DOWN的transitions数量 Dwntme：server 下线多久了 ：session rate(每秒的连接会话信息)中的指标有cur,max,limit;其中cur表示每秒的当前会话数量；max表示每秒的最大会话数量；limit表示每秒新的会话限制量；sessions(会话信息)，cur:表示当前会话量；max:表示最大会话量；limit: 表示限制会话量；Total:表示总共会话量； 参考文献： https://blog.51cto.com/superleedo/1895570 https://developer.aliyun.com/article/243184 https://www.haproxy.com/blog/exploring-the-haproxy-stats-page/ 来源： https://blog.csdn.net/qq_22498427/article/details/108736804","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"},{"name":"技术笔记","slug":"默认分类/技术笔记","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://jlynet.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"linux","slug":"linux","permalink":"https://jlynet.github.io/tags/linux/"},{"name":"随笔","slug":"随笔","permalink":"https://jlynet.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"网络","slug":"网络","permalink":"https://jlynet.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"GitHub博客hexo建站之设置SSH密钥","slug":"GitHub博客hexo建站之设置SSH密钥","date":"2022-06-30T06:27:23.000Z","updated":"2022-06-30T06:37:54.000Z","comments":true,"path":"2022/06/30/GitHub博客hexo建站之设置SSH密钥/","link":"","permalink":"https://jlynet.github.io/2022/06/30/GitHub%E5%8D%9A%E5%AE%A2hexo%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%AE%BE%E7%BD%AESSH%E5%AF%86%E9%92%A5/","excerpt":"","text":"我们十分建议大家在玩转GitHub时使用SSH连接。SSH keys是一种鉴定信任电脑的方式，同时不需要输入密码。以下步骤将会教你产生一个SSH keys并把这个公共的密钥添加到你的GitHub账户中。 Tips：我们建议你经常审查你的SSH keys列表并取消那些用了一段时间的账户。 第一步：检查SSH keys 首先，我们需要检查你的电脑中是否存在SSH keys。打开Git Bash 并输入： 12$ ls -al ~/.ssh# 列出你.ssh目录中的文件（如果存在文件的话） 检查一下目录列表查看一下是否有 id_rsa.pub 或者 id_dsa.pub. 如果这两个文件都没有，查看第二步。否则，看第三步。 第二步：创建一个新的SSH key 为了创建一个新的SSH key，复制粘贴下面的代码，一定要填上你的E-mail地址。默认的设置是非常棒的，所以你当你被提示“Enter a file in which to save the key”，仅仅按回车（Enter）继续。 1234$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;# 创建一个 ssh key, 用准备好的email作为标签Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 接下来，你将会被要求输入密码. Tips:我们强烈建议输入一个好的，安全的密码，更多信息查看 Working with SSH key passphrases. （译者注：这个密码需要记好，后面会用到） 12Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] 你将会看到以下提示： 1234Your identification has been saved in /c/Users/you/.ssh/id_rsa.Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.The key fingerprint is:01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 然后在你的ssh-代理上添加上你的新的密钥： 1234# start the ssh-agent in the background$ eval &quot;$(ssh-agent -s)&quot;# Agent pid 59566$ ssh-add ~/.ssh/id_rsa 第三步：在你的GitHub账户中添加上SSH key 运行下面的代码把key复制到你的粘贴板中： 12$ clip &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your clipboard 或者，用你最喜欢的编辑器，打开~/.ssh/id_rsa.pub 文件，手动把文件中的内容复制到粘贴板。 现在有了key的复制版，是时候添加到GitHub中了： 1.在任意页面的右上角用户栏中，点击 Account settings 2.左侧点击 SSH Keys. 3.点击 Add SSH key. 4.在标题框中，添加这个新key的描述标签。例如，如果你使用的是个人的Mac，你可以把这个key叫做“Personal MacBook Air”。 5.把你的key粘贴在 “Key” 标签下的文本框中. 6.点击 Add key. 7.输入你的GitHub 密码以确认身份. 第四步：测试everything 为了确保所有的操作都在工作，现在需要SSHing一下GitHub。当你这么做的时候，你将会被要求输入密码以证实你的行为，就是之前你创建的密码。 打开Git Bash并输入： 12$ ssh -T git@github.com# Attempts to ssh to github 你可能会看到这样的警告： 123The authenticity of host &#x27;github.com (207.97.227.239)&#x27; can&#x27;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 不要担心，这必然会发生。这是为了证实你上面提供的终端机器中的fingerprint（指纹），然后输入“yes” 12Hi username! You&#x27;ve successfully authenticated, but GitHub does notprovide shell access. 如果username是你的名字，那么说明你的SSH key成功安装！不用担心 “shell access” 这件事情，因为你根本用不到。 如果你收到的消息是”access denied,” 你可以read these instructions for diagnosing the issue. 如果你是将SSH转换为HTTPS，你将需要更新你的远端仓库中的URLs，更多信息查看Changing a remote’s URL. 翻译原文地址：https://help.github.com/articles/generating-ssh-keys","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"},{"name":"技术笔记","slug":"默认分类/技术笔记","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://jlynet.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"随笔","slug":"随笔","permalink":"https://jlynet.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"hexo","slug":"hexo","permalink":"https://jlynet.github.io/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-11-17T01:41:10.000Z","updated":"2021-07-28T04:45:24.000Z","comments":true,"path":"2021/11/17/hello-world/","link":"","permalink":"https://jlynet.github.io/2021/11/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"ssh端口转发笔记","slug":"ssh端口转发笔记","date":"2021-10-23T10:33:25.000Z","updated":"2021-10-23T10:36:20.000Z","comments":true,"path":"2021/10/23/ssh端口转发笔记/","link":"","permalink":"https://jlynet.github.io/2021/10/23/ssh%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E7%AC%94%E8%AE%B0/","excerpt":"","text":"ssh端口转发笔记：ssh反向代理(隧道)、动态代理、本地代理缩略词本机：ssh命令发起方，即运行ssh命令的那台机器。也可简称客户端远程机：ssh命令连接到的服务器，一般指运行ssh服务的那台机器。也可简称服务端本地机群：能直接与本机通迅的主机集合，包含本机自身。远程机群： 能直接与远程机通迅的主机集合，包含远程自身。 动态代理动态代理一般用于代理服务器，应用场景为：本地机群不能直接访问某些地址/端口，但远程机可以。本机通过建立一个指定本机端口，远程机端口不指定（动态）的连接，让本地机群可以通过该连接去访问那些地址（基于socks4和socks5协议）。 1ssh -o ServerAliveInterval=20 -g -Nf -D 6060 proxy@47.44.161.114 #动态代理 参数 说明 -o ServerAliveInterval=20 代表心跳包，ssh在一段时间没数据后会把连接给断开。 -g 允许其他主机连接到本机端口进行转发。 如果无效，要设置**本机*sshd_config文件:*gatewayports yes -N 不执行远程命令。 仅做端口转发（仅适用于协议版本2）。 -f 将ssh切换到后台 -D 6060 指定以本机哪个端口做为转发端口 &#x70;&#x72;&#111;&#x78;&#x79;&#64;&#x34;&#55;&#x2e;&#x34;&#x34;&#x2e;&#x31;&#54;&#x31;&#x2e;&#49;&#x31;&#x34; 以指定帐号连接远程机 反向代理反向代理一般用于内网穿透，应用场景为：本机在防火墙内，并且防火墙未向外开放本机（或本地网络内其他主机）端口，远程机有向外开放的可用端口，本机通过建立一个指定本机（或本地网络内其他主机）端口和远程机端口的连接（也可以理解成端口映射），让外部应用可以通过远程机端口访问本机（或本地网络内其他主机）端口。 1ssh -o ServerAliveInterval=20 -g -Nf -R 5001:localhost:6060 proxy@47.44.161.114 #反向代理 参数 说明 -o ServerAliveInterval=20 代表心跳包，ssh在一段时间没数据后会把连接给断开。 -g 允许其远程机群连接到远程机端口进行转发。 如果无效，要修改**远程机*sshd_config文件:*gatewayports yes -N 不执行远程命令。 仅做端口转发（仅适用于协议版本2）。 -f 将ssh切换到后台 -R 15001:localhost:6060 反向转发，用值用**:**分隔为三项,格式为： &lt;远程机端口&gt;:&lt;本地机群&gt;:&lt;端口&gt;。 &#112;&#x72;&#111;&#120;&#121;&#64;&#52;&#55;&#x2e;&#52;&#52;&#x2e;&#x31;&#54;&#49;&#x2e;&#x31;&#49;&#52; 以指定帐号连接远程机 本地代理本地代理应用场景一般是两类：一类是应用限制只能访问本机端口，而实际需要访问远程机端口；一类是某个网络环境只能允许一台主机访问远程机端口，而实际是网络区域内多台主机都有这个要求。 1ssh -o ServerAliveInterval=20 -g -Nf -L 5001:localhost:6060 proxy@47.44.161.114 参数 说明 -o ServerAliveInterval=20 代表心跳包，ssh在一段时间没数据后会把连接给断开。 -g 允许本地机群连接到本机端口进行转发。 如果无效，要修改**本机*sshd_config文件:*gatewayports yes -N 不执行远程命令。 仅做端口转发（仅适用于协议版本2）。 -f 将ssh切换到后台 -L 15001:localhost:6060 本地转发，用值用**:分隔为三项,格式为： &lt;本机端口&gt;:&lt;远程机群&gt;:&lt;端口&gt;。 示例里第二项localhost,代表的是远程机**，用这种写法一般代表远程主机也只能本机访问该端口 &#112;&#114;&#111;&#120;&#121;&#64;&#x34;&#x37;&#46;&#52;&#x34;&#x2e;&#49;&#54;&#49;&#x2e;&#x31;&#x31;&#52; 以指定帐号连接远程机 连接检测脚本ssh建立的连接有时候会因为网络原因断开，所以写了个定时任务脚本（基于centos) 123456789101112131415161718#!/bin/sh### reconnectproxy.sh ###cd ~pid=` ps aux|grep ssh|grep -E &quot;6060[[:space:]]+proxy@47.44.161.114&quot;|awk &#x27;&#123;print $2&#125;&#x27;`dt=`date`if [ -n &quot;$pid&quot; ]thenecho $&#123;dt&#125;&quot; INFO:proxy is connected&quot;&gt;&gt;~/chkconn.logelseecho $&#123;dt&#125;&quot; WARN:proxy is not connected&quot;&gt;&gt;~/chkconn.logecho $&#123;dt&#125;&quot; WARN:try to reconnect proxy &quot;&gt;&gt;~/chkconn.logssh -o ServerAliveInterval=20 -g -Nf -D 6060 proxy@47.44.161.114fi 再用crontab -e命令将脚本加入任务计划中 11 */5 * * * * sh /root/reconnectproxy.sh 文章转载：https://www.cnblogs.com/xinggg/p/8043227.html","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"},{"name":"技术笔记","slug":"默认分类/技术笔记","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://jlynet.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"linux","slug":"linux","permalink":"https://jlynet.github.io/tags/linux/"},{"name":"随笔","slug":"随笔","permalink":"https://jlynet.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"ssh","slug":"ssh","permalink":"https://jlynet.github.io/tags/ssh/"}]},{"title":"解决SpringBoot 2.3 MultipartFile为空的问题","slug":"解决SpringBoot-2-3-MultipartFile为空的问题","date":"2021-10-21T09:22:22.000Z","updated":"2021-10-21T09:23:14.000Z","comments":true,"path":"2021/10/21/解决SpringBoot-2-3-MultipartFile为空的问题/","link":"","permalink":"https://jlynet.github.io/2021/10/21/%E8%A7%A3%E5%86%B3SpringBoot-2-3-MultipartFile%E4%B8%BA%E7%A9%BA%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"原本用的2.0.x的版本上传文件是没有问题的，后来升级SpringBoot版本为2.3.3就无法上传文件了，我看到MultipartFile是为空的。 解决办法不使用Multipart自动配置，再排除原有的Multipart配置@EnableAutoConfiguration(exclude = &#123;MultipartAutoConfiguration.class&#125;)，然后显示声明CommonsMultipartResolver为mutipartResolver。 排除MultipartAutoConfiguration 1@SpringBootApplication(exclude = &#123;MultipartAutoConfiguration.class&#125;) 添加依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 显示声明CommonsMultipartResolver为mutipartResolver： 123456789101112131415161718192021222324@Configurationpublic class UploadResolverConfig &#123; /** * 显示声明CommonsMultipartResolver为mutipartResolver * * @return */ @Bean(name = &quot;multipartResolver&quot;) public MultipartResolver multipartResolver() &#123; CommonsMultipartResolver resolver = new CommonsMultipartResolver(); resolver.setDefaultEncoding(&quot;UTF-8&quot;); // resolveLazily属性启用是为了推迟文件解析，以在在UploadAction中捕获文件大小异常 resolver.setResolveLazily(true); // 设置了文件放入临时文件夹的大小限制 resolver.setMaxInMemorySize(40960); // 设置单个上传数据总大小25M resolver.setMaxUploadSizePerFile(25 * 1024 * 1024); // 设置总上传数据总大小50M resolver.setMaxUploadSize(5 * 1024 * 1024); return resolver; &#125;&#125; MultipartAutoConfiguration源码12345678910111213141516171819202122232425262728293031323334353637383940414243/** * &#123;@link EnableAutoConfiguration Auto-configuration&#125; for multi-part uploads. Adds a * &#123;@link StandardServletMultipartResolver&#125; if none is present, and adds a * &#123;@link javax.servlet.MultipartConfigElement multipartConfigElement&#125; if none is * otherwise defined. The &#123;@link ServletWebServerApplicationContext&#125; will associate the * &#123;@link MultipartConfigElement&#125; bean to any &#123;@link Servlet&#125; beans. * &lt;p&gt; * The &#123;@link javax.servlet.MultipartConfigElement&#125; is a Servlet API that&#x27;s used to * configure how the server handles file uploads. * * @author Greg Turnquist * @author Josh Long * @author Toshiaki Maki * @since 2.0.0 */@Configuration(proxyBeanMethods = false)@ConditionalOnClass(&#123; Servlet.class, StandardServletMultipartResolver.class, MultipartConfigElement.class &#125;)@ConditionalOnProperty(prefix = &quot;spring.servlet.multipart&quot;, name = &quot;enabled&quot;, matchIfMissing = true)@ConditionalOnWebApplication(type = Type.SERVLET)@EnableConfigurationProperties(MultipartProperties.class)public class MultipartAutoConfiguration &#123; private final MultipartProperties multipartProperties; public MultipartAutoConfiguration(MultipartProperties multipartProperties) &#123; this.multipartProperties = multipartProperties; &#125; @Bean @ConditionalOnMissingBean(&#123; MultipartConfigElement.class, CommonsMultipartResolver.class &#125;) public MultipartConfigElement multipartConfigElement() &#123; return this.multipartProperties.createMultipartConfig(); &#125; @Bean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME) @ConditionalOnMissingBean(MultipartResolver.class) public StandardServletMultipartResolver multipartResolver() &#123; StandardServletMultipartResolver multipartResolver = new StandardServletMultipartResolver(); multipartResolver.setResolveLazily(this.multipartProperties.isResolveLazily()); return multipartResolver; &#125;&#125; CommonsMultipartResolver源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164/** * Servlet-based &#123;@link MultipartResolver&#125; implementation for * &lt;a href=&quot;https://commons.apache.org/proper/commons-fileupload&quot;&gt;Apache Commons FileUpload&lt;/a&gt; * 1.2 or above. * * &lt;p&gt;Provides &quot;maxUploadSize&quot;, &quot;maxInMemorySize&quot; and &quot;defaultEncoding&quot; settings as * bean properties (inherited from &#123;@link CommonsFileUploadSupport&#125;). See corresponding * ServletFileUpload / DiskFileItemFactory properties (&quot;sizeMax&quot;, &quot;sizeThreshold&quot;, * &quot;headerEncoding&quot;) for details in terms of defaults and accepted values. * * &lt;p&gt;Saves temporary files to the servlet container&#x27;s temporary directory. * Needs to be initialized &lt;i&gt;either&lt;/i&gt; by an application context &lt;i&gt;or&lt;/i&gt; * via the constructor that takes a ServletContext (for standalone usage). * * @author Trevor D. Cook * @author Juergen Hoeller * @since 29.09.2003 * @see #CommonsMultipartResolver(ServletContext) * @see #setResolveLazily * @see org.apache.commons.fileupload.servlet.ServletFileUpload * @see org.apache.commons.fileupload.disk.DiskFileItemFactory */public class CommonsMultipartResolver extends CommonsFileUploadSupport implements MultipartResolver, ServletContextAware &#123; private boolean resolveLazily = false; /** * Constructor for use as bean. Determines the servlet container&#x27;s * temporary directory via the ServletContext passed in as through the * ServletContextAware interface (typically by a WebApplicationContext). * @see #setServletContext * @see org.springframework.web.context.ServletContextAware * @see org.springframework.web.context.WebApplicationContext */ public CommonsMultipartResolver() &#123; super(); &#125; /** * Constructor for standalone usage. Determines the servlet container&#x27;s * temporary directory via the given ServletContext. * @param servletContext the ServletContext to use */ public CommonsMultipartResolver(ServletContext servletContext) &#123; this(); setServletContext(servletContext); &#125; /** * Set whether to resolve the multipart request lazily at the time of * file or parameter access. * &lt;p&gt;Default is &quot;false&quot;, resolving the multipart elements immediately, throwing * corresponding exceptions at the time of the &#123;@link #resolveMultipart&#125; call. * Switch this to &quot;true&quot; for lazy multipart parsing, throwing parse exceptions * once the application attempts to obtain multipart files or parameters. */ public void setResolveLazily(boolean resolveLazily) &#123; this.resolveLazily = resolveLazily; &#125; /** * Initialize the underlying &#123;@code org.apache.commons.fileupload.servlet.ServletFileUpload&#125; * instance. Can be overridden to use a custom subclass, e.g. for testing purposes. * @param fileItemFactory the Commons FileItemFactory to use * @return the new ServletFileUpload instance */ @Override protected FileUpload newFileUpload(FileItemFactory fileItemFactory) &#123; return new ServletFileUpload(fileItemFactory); &#125; @Override public void setServletContext(ServletContext servletContext) &#123; if (!isUploadTempDirSpecified()) &#123; getFileItemFactory().setRepository(WebUtils.getTempDir(servletContext)); &#125; &#125; @Override public boolean isMultipart(HttpServletRequest request) &#123; return ServletFileUpload.isMultipartContent(request); &#125; @Override public MultipartHttpServletRequest resolveMultipart(final HttpServletRequest request) throws MultipartException &#123; Assert.notNull(request, &quot;Request must not be null&quot;); if (this.resolveLazily) &#123; return new DefaultMultipartHttpServletRequest(request) &#123; @Override protected void initializeMultipart() &#123; MultipartParsingResult parsingResult = parseRequest(request); setMultipartFiles(parsingResult.getMultipartFiles()); setMultipartParameters(parsingResult.getMultipartParameters()); setMultipartParameterContentTypes(parsingResult.getMultipartParameterContentTypes()); &#125; &#125;; &#125; else &#123; MultipartParsingResult parsingResult = parseRequest(request); return new DefaultMultipartHttpServletRequest(request, parsingResult.getMultipartFiles(), parsingResult.getMultipartParameters(), parsingResult.getMultipartParameterContentTypes()); &#125; &#125; /** * Parse the given servlet request, resolving its multipart elements. * @param request the request to parse * @return the parsing result * @throws MultipartException if multipart resolution failed. */ protected MultipartParsingResult parseRequest(HttpServletRequest request) throws MultipartException &#123; String encoding = determineEncoding(request); FileUpload fileUpload = prepareFileUpload(encoding); try &#123; List&lt;FileItem&gt; fileItems = ((ServletFileUpload) fileUpload).parseRequest(request); return parseFileItems(fileItems, encoding); &#125; catch (FileUploadBase.SizeLimitExceededException ex) &#123; throw new MaxUploadSizeExceededException(fileUpload.getSizeMax(), ex); &#125; catch (FileUploadBase.FileSizeLimitExceededException ex) &#123; throw new MaxUploadSizeExceededException(fileUpload.getFileSizeMax(), ex); &#125; catch (FileUploadException ex) &#123; throw new MultipartException(&quot;Failed to parse multipart servlet request&quot;, ex); &#125; &#125; /** * Determine the encoding for the given request. * Can be overridden in subclasses. * &lt;p&gt;The default implementation checks the request encoding, * falling back to the default encoding specified for this resolver. * @param request current HTTP request * @return the encoding for the request (never &#123;@code null&#125;) * @see javax.servlet.ServletRequest#getCharacterEncoding * @see #setDefaultEncoding */ protected String determineEncoding(HttpServletRequest request) &#123; String encoding = request.getCharacterEncoding(); if (encoding == null) &#123; encoding = getDefaultEncoding(); &#125; return encoding; &#125; @Override public void cleanupMultipart(MultipartHttpServletRequest request) &#123; if (!(request instanceof AbstractMultipartHttpServletRequest) || ((AbstractMultipartHttpServletRequest) request).isResolved()) &#123; try &#123; cleanupFileItems(request.getMultiFileMap()); &#125; catch (Throwable ex) &#123; logger.warn(&quot;Failed to perform multipart cleanup for servlet request&quot;, ex); &#125; &#125; &#125;&#125; 控制器使用 1234@PostMapping(&quot;/upload&quot;) public void bigStopFile(@RequestParam Map&lt;String, MultipartFile&gt; map,HttpServletRequest request, HttpServletResponse response) throws IOException &#123; ...... &#125; 注意 MultipartResolver 与 MultipartConfigElement 冲突，如果同时配置也会造成MultipartFile为空的情况，MultipartConfigElement配置方式如下： 12345678910@Bean public MultipartConfigElement multipartConfigElement() &#123; MultipartConfigFactory factory = new MultipartConfigFactory(); //factory.setLocation(&quot;/app/sinova/tmp&quot;); //文件最大 factory.setMaxFileSize(DataSize.of(50, DataUnit.MEGABYTES)); /// 设置总上传数据总大小 factory.setMaxRequestSize(DataSize.of(200, DataUnit.MEGABYTES)); return factory.createMultipartConfig(); &#125;","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"},{"name":"技术笔记","slug":"默认分类/技术笔记","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://jlynet.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"java","slug":"java","permalink":"https://jlynet.github.io/tags/java/"},{"name":"随笔","slug":"随笔","permalink":"https://jlynet.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"Spring","slug":"Spring","permalink":"https://jlynet.github.io/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://jlynet.github.io/tags/SpringBoot/"}]},{"title":"Linux网络基础，路由的追踪","slug":"Linux网络基础，路由的追踪","date":"2021-10-18T07:25:16.000Z","updated":"2021-10-18T07:51:22.000Z","comments":true,"path":"2021/10/18/Linux网络基础，路由的追踪/","link":"","permalink":"https://jlynet.github.io/2021/10/18/Linux%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%EF%BC%8C%E8%B7%AF%E7%94%B1%E7%9A%84%E8%BF%BD%E8%B8%AA/","excerpt":"","text":"一、 traceroute Linux traceroute命令用于显示数据包到主机间的路径。traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。 语法1traceroute [-46ndFT] [-f&lt;存活数值&gt;] [-g&lt;网关&gt;] [-i(--interface)&lt;device&gt;] [-I(--icmp)] [-m&lt;存活数值&gt;] [-N&lt;数据包数量&gt;] [-p&lt;通信端口&gt;] [-s&lt;来源地址&gt;] [-t&lt;服务类型&gt;] [-w&lt;超时秒数&gt;] 参数说明12345678910111213141516-4 ===&gt; IPV4-6 ===&gt; IPV6-d ===&gt; 使用Socket层级的排错功能-f ===&gt; 设置第一个检测数据包的存活数值TTL的大小-g ===&gt; 设置来源路由网关，最多可设置8个-i ===&gt; 指定traceroute应该通过哪个接口发送数据包；默认情况下，根据路由表选择接口-I ===&gt; 使用ICMP回应取代UDP资料信息-m ===&gt; 设置检测数据包的最大存活数值TTL的大小-p ===&gt; 设置UDP传输协议的通信端口-s ===&gt; 设置本地主机送出数据包的IP地址-t ===&gt; 对于IPV4来说是设置服务类型(TOS)和优先值；对于IPV6来说是设置流量控制值-T ===&gt; 使用TCP进行探测-w ===&gt; 设置等待远端主机回报的时间-F ===&gt; 不要分段探测数据包-n ===&gt; 在显示IP地址时，不要将它们映射到主机名-N ===&gt; 指定同时发送的探测包的数量;默认值是16 二、 tracepath tracepath命令用来追踪并显示报文到达目的主机所经过的路由信息，能够发现路由中的MTU值。tracepath使用套接字API来实现其所有功能，不需要root权限。 语法1tracepath [-n] [-b] [-l pktlen] [-m max_hops] [-p port] [目的地址] 参数说明12345-n ===&gt; 输出主要的IP地址-b ===&gt; 同时输出主机名和IP地址-l ===&gt; 设置数据包大小；默认65535-m ===&gt; 设置最大跳数；默认30-p ===&gt; 设置要使用的初始目标端口 三、 mtr MTR是一种简单的跨平台命令行网络诊断工具，它将常用的traceroute和ping程序的功能组合到一个工具中。 与traceroute类似， mtr输出关于数据包从运行mtr的主机到用户指定的目标主机的路由信息​​。 语法1mtr [-lxu(--udp)T(--tcp)46] [-r (--report)] [-w (--report-wide)] [-c (--report-cycles)] [-l (--raw)] [-x (--xml)] [-a (--addres] [-i (--interval)] [-m (--max-ttl)] [-f (--first-ttl)] [-B (--bitpattern)] [-Q (--tos)] [-s (--psize)] [-P (--port)] [--timeout] [目的地] [数据包大小] 参数说明12345678910111213141516-4 ===&gt; IPV4-6 ===&gt; IPV6-c ===&gt; 设置发送的ping的数量-r ===&gt; 进入report模式.此模式下，mtr将运行-c选项指定的周期数，然后输出统计信息并退出-w ===&gt; 进入wide report模式。在此模式下，mtr将不会删除报告中的主机名-s ===&gt; 设置探测包大小，字节数包括IP和ICMP头部信息-l ===&gt; 使用原始输出格式-x ===&gt; 使用xml输出格式-a ===&gt; 将发送数据包的插座绑定到特定的接口,这样任何数据包都可以通过这个接口发送-i ===&gt; 指定ICMP之间的请求间隔-m ===&gt; 指定最大跳数(最大生存时间值)默认30-f ===&gt; 指定开始跳数，默认为1-B ===&gt; 指定在有效负载中使用的位模式(0-255)-Q ===&gt; 指定IP报头中的服务字段（0-255）-P ===&gt; 指定TCP跟踪的目标端口号--timeout ===&gt; 在放弃连接之前，保持TCP套接字打开的秒数连接。这只会影响最后一跳 应用举例1 基本展示12345678910111213141516zt-web6:/app/sinova$ mtr -4 -6 -x -c 1 -n --report miniapp.yun.139.com -P 443Start: Mon Oct 18 15:50:53 2021HOST: zt-web6 Loss% Snt Last Avg Best Wrst StDev 1.|-- 2409:805c:5c00::102 0.0% 1 1.6 1.6 1.6 1.6 0.0 2.|-- 2409:805c:5cff:ffff:ffff: 0.0% 1 0.1 0.1 0.1 0.1 0.0 3.|-- 2409:805c:0:614c::2 0.0% 1 3.3 3.3 3.3 3.3 0.0 4.|-- 2409:805c:0:6108:: 0.0% 1 4.0 4.0 4.0 4.0 0.0 5.|-- 2409:805c:0:1003:: 0.0% 1 0.6 0.6 0.6 0.6 0.0 6.|-- 2409:8080:0:2:1903:1971:: 0.0% 1 0.9 0.9 0.9 0.9 0.0 7.|-- 2409:8080:0:1:305:1903:: 0.0% 1 12.0 12.0 12.0 12.0 0.0 8.|-- 2409:8080:0:2:305:362:1f0 0.0% 1 17.0 17.0 17.0 17.0 0.0 9.|-- 2409:8055:3008:1116::a0 0.0% 1 14.3 14.3 14.3 14.3 0.0 10.|-- 2409:8c54:813:5::1:0 0.0% 1 16.1 16.1 16.1 16.1 0.0 11.|-- ??? 100.0 1 0.0 0.0 0.0 0.0 0.0 12.|-- 2409:8c54:813:3::11 0.0% 1 19.2 19.2 19.2 19.2 0.0 13.|-- ??? 100.0 1 0.0 0.0 0.0 0.0 0.0 第一列：显示的是IP地址和本机域名；第二列 Loss%：是显示的每个对应IP的丢包率；第三列 snt：snt等于1，设置每秒发送数据包的数量，默认值是10 可以通过参数 -c来指定。第四列 Last：显示的最近一次的返回时延。第五列Avg：平均值，这个应该是发送ping包的平均时延。第六列Best：最好或者说时延最短的时间。第七列Wrst：最坏或者说时延最长的时间。第八列StDev：标准偏差。 应用举例二：设置每秒发送数据包的数量301mtr -r -c 30 www.xqblog.com 应用举例3：设置ping包大小为1024个字节1mtr -r -c 30 -s 1024 www.xqblog.com 四、 netstat Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。显示网络连接，路由表，接口状态，伪装连接，网络链路信息和组播成员组。 语法12345netstat [地址] [-t (--tcp)] [-u (--udp)] [-l (--listening)] [-a (--all)] [-n (--numeric)] [--numeric-hosts] [--numeric-ports] [-p (--program)] [-v (--verbose)] [-c (--continuous)] [delay]netstat &#123;-r (--route)&#125; [地址] [-e (--extend)] [-v (--verbose)] [-n (--numeric)] [--numeric-hosts] [--numeric-ports] [--numeric-ports] [-c (--continuous)] [delay]netstat &#123;-i (--interfaces)&#125; [iface] [-a (--all)] [-e (--extend)] [-v (--verbose)] [-p (--program)] [-n (--numeric)] [--numeric-hosts] [--numeric-ports] [--numeric-ports] [-c (--continuous)] [delay] 参数说明12345678910111213注意：[地址]无选项时,netstat显示打开的套接字.如果不指定任何地址族，那么打印出所有已配置地址族的有效套接字。-t ===&gt; 仅显示tcp连接-u ===&gt; 仅显示udp连接-l ===&gt; 只显示正在侦听的套接字(这是默认的选项)-a ===&gt; 显示所有正在或不在侦听的套接字。加上 --interfaces 选项将显示没有标记的接口-n ===&gt; 显示数字形式地址而不是去解析主机、端口或用户名--numeric-hosts ===&gt; 显示数字形式的主机但是不影响端口或用户名的解析--numeric-ports ===&gt; 显示数字端口号，但是不影响主机或用户名的解析-N ===&gt; delay === &gt; 每隔 delay 秒,循环输出统计信息-p ===&gt; 显示套接字所属进程的PID和名称-v ===&gt; 显示详细信息-c ===&gt; 将使 netstat 不断地每秒输出所选的信息 五、 route语法12345route [-CFvne]route [-v] [-A] add [-net|-host] target [netmask] [gw Gw] [metric] [mss] [window] [irtt ] [reject] [mod] [dyn] [reinstate] [[dev] If]route [-v] [-A] del [-net|-host] target [gw] [netmask] [metric] [[dev] If] 参数说明123456789101112131415161718192021-C ===&gt; 显示内核的路由缓存-F ===&gt; 显示内核的FIB选路表-n ===&gt; 以数字形式代替解释主机名形式来显示地址-e ===&gt; 用net‐stat(8)的格式来显示选路表-A ===&gt; 用指定的地址族(如`inet&#x27;，`inet6&#x27;)-v ===&gt; 选用细节操作模式-net ===&gt; 路由目标为网络-host ===&gt; 路由目标为主机add ===&gt; 添加一条路由del ===&gt; 删除一条路由target ===&gt; 指定目标网络或主机netmask ===&gt;为添加的路由指定网络掩码gw ===&gt; 为发往目标网络/主机的任何分组指定网关metric ===&gt; 设置路由值字段mss ===&gt; 设置基于此路由之上的连接的TCP最大报文段长度window ===&gt; 设置基于此路由之上的连接的TCP窗口长度irtt ===&gt; 设置基于此路由之上的TCP连接的初始往返时间reject ===&gt; 设置一条阻塞路由以使一条路由查找失败mod,dyn,reinstate ===&gt; 设置一条动态的或更改过的路由dev If ===&gt; 强制使路由与指定的设备关联","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"},{"name":"技术笔记","slug":"默认分类/技术笔记","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://jlynet.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"shell","slug":"shell","permalink":"https://jlynet.github.io/tags/shell/"},{"name":"linux","slug":"linux","permalink":"https://jlynet.github.io/tags/linux/"},{"name":"随笔","slug":"随笔","permalink":"https://jlynet.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"网络","slug":"网络","permalink":"https://jlynet.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"ngx_lua 模块详细讲解（基于openresty）","slug":"ngx-lua-模块详细讲解（基于openresty）","date":"2021-10-17T12:04:43.000Z","updated":"2021-10-17T12:05:08.000Z","comments":true,"path":"2021/10/17/ngx-lua-模块详细讲解（基于openresty）/","link":"","permalink":"https://jlynet.github.io/2021/10/17/ngx-lua-%E6%A8%A1%E5%9D%97%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%EF%BC%88%E5%9F%BA%E4%BA%8Eopenresty%EF%BC%89/","excerpt":"","text":"ngx_lua模块的原理： 1、每个worker（工作进程）创建一个Lua VM，worker内所有协程共享VM；2、将Nginx I/O原语封装后注入 Lua VM，允许Lua代码直接访问；3、每个外部请求都由一个Lua协程处理，协程之间数据隔离；4、Lua代码调用I/O操作等异步接口时，会挂起当前协程（并保护上下文数据），而不阻塞worker；5、I/O等异步操作完成时还原相关协程上下文数据，并继续运行； ngx_lua 模块提供的指令和API等： 指令名称 说明 lua_use_default_type 是否使用default_type指令定义的Content-Type默认值 lua_code_cache *_by_lua_file文件是否cache lua_regex_cache_max_entries lua_regex_match_limit lua_package_path 用Lua写的lua外部库路径（.lua文件） lua_package_cpath 用C写的lua外部库路径（.so文件） init_by_lua master进程启动时挂载的lua代码 init_by_lua_file init_worker_by_lua worker进程启动时挂载的lua代码，常用来执行一些定时器任务 init_worker_by_lua_file set_by_lua 设置变量 set_by_lua_file content_by_lua handler模块 content_by_lua_file rewrite_by_lua rewrite_by_lua_file access_by_lua access_by_lua_file header_filter_by_lua header filter模块 header_filter_by_lua_file body_filter_by_lua body filter模块，ngx.arg[1]代表输入的chunk，ngx.arg[2]代表当前chunk是否为last body_filter_by_lua_file log_by_lua log_by_lua_file lua_need_request_body 是否读请求体，跟ngx.req.read_body()函数作用类似 lua_shared_dict 创建全局共享的table（多个worker进程共享） lua_socket_connect_timeout TCP/unix 域socket对象connect方法的超时时间 lua_socket_send_timeout TCP/unix 域socket对象send方法的超时时间 lua_socket_send_lowat 设置cosocket send buffer的low water值 lua_socket_read_timeout TCP/unix 域socket对象receive方法的超时时间 lua_socket_buffer_size cosocket读buffer大小 lua_socket_pool_size cosocket连接池大小 lua_socket_keepalive_timeout cosocket长连接超时时间 lua_socket_log_errors 是否打开cosocket错误日志 lua_ssl_ciphers lua_ssl_crl lua_ssl_protocols lua_ssl_trusted_certificate lua_ssl_verify_depth lua_http10_buffering rewrite_by_lua_no_postpone lua_transform_underscores_in_response_headers lua_check_client_abort 是否监视client提前关闭请求的事件，如果打开监视，会调用ngx.on_abort()注册的回调 lua_max_pending_timers lua_max_running_timers table 说明 ngx.arg 指令参数，如跟在content_by_lua_file后面的参数 ngx.var 变量，ngx.var.VARIABLE引用某个变量 ngx.ctx 请求的lua上下文 ngx.header 响应头，ngx.header.HEADER引用某个头 ngx.status 响应码 API 说明 ngx.log 输出到error.log print 等价于 ngx.log(ngx.NOTICE, …) ngx.send_headers 发送响应头 ngx.headers_sent 响应头是否已发送 ngx.resp.get_headers 获取响应头 ngx.timer.at 注册定时器事件 ngx.is_subrequest 当前请求是否是子请求 ngx.location.capture 发布一个子请求 ngx.location.capture_multi 发布多个子请求 ngx.exec ngx.redirect ngx.print 输出响应 ngx.say 输出响应，自动添加’\\n’ ngx.flush 刷新响应 ngx.exit 结束请求 ngx.eof ngx.sleep 无阻塞的休眠（使用定时器实现） ngx.get_phase ngx.on_abort 注册client断开请求时的回调函数 ndk.set_var.DIRECTIVE ngx.req.start_time 请求的开始时间 ngx.req.http_version 请求的HTTP版本号 ngx.req.raw_header 请求头（包括请求行） ngx.req.get_method 请求方法 ngx.req.set_method 请求方法重载 ngx.req.set_uri 请求URL重写 ngx.req.set_uri_args ngx.req.get_uri_args 获取请求参数 ngx.req.get_post_args 获取请求表单 ngx.req.get_headers 获取请求头 ngx.req.set_header ngx.req.clear_header ngx.req.read_body 读取请求体 ngx.req.discard_body 扔掉请求体 ngx.req.get_body_data ngx.req.get_body_file ngx.req.set_body_data ngx.req.set_body_file ngx.req.init_body ngx.req.append_body ngx.req.finish_body ngx.req.socket ngx.escape_uri 字符串的url编码 ngx.unescape_uri 字符串url解码 ngx.encode_args 将table编码为一个参数字符串 ngx.decode_args 将参数字符串编码为一个table ngx.encode_base64 字符串的base64编码 ngx.decode_base64 字符串的base64解码 ngx.crc32_short 字符串的crs32_short哈希 ngx.crc32_long 字符串的crs32_long哈希 ngx.hmac_sha1 字符串的hmac_sha1哈希 ngx.md5 返回16进制MD5 ngx.md5_bin 返回2进制MD5 ngx.sha1_bin 返回2进制sha1哈希值 ngx.quote_sql_str SQL语句转义 ngx.today 返回当前日期 ngx.time 返回UNIX时间戳 ngx.now 返回当前时间 ngx.update_time 刷新时间后再返回 ngx.localtime ngx.utctime ngx.cookie_time 返回的时间可用于cookie值 ngx.http_time 返回的时间可用于HTTP头 ngx.parse_http_time 解析HTTP头的时间 ngx.re.match ngx.re.find ngx.re.gmatch ngx.re.sub ngx.re.gsub ngx.shared.DICT ngx.shared.DICT.get ngx.shared.DICT.get_stale ngx.shared.DICT.set ngx.shared.DICT.safe_set ngx.shared.DICT.add ngx.shared.DICT.safe_add ngx.shared.DICT.replace ngx.shared.DICT.delete ngx.shared.DICT.incr ngx.shared.DICT.flush_all ngx.shared.DICT.flush_expired ngx.shared.DICT.get_keys ngx.socket.udp udpsock:setpeername udpsock:send udpsock:receive udpsock:close udpsock:settimeout ngx.socket.tcp tcpsock:connect tcpsock:sslhandshake tcpsock:send tcpsock:receive tcpsock:receiveuntil tcpsock:close tcpsock:settimeout tcpsock:setoption tcpsock:setkeepalive tcpsock:getreusedtimes ngx.socket.connect ngx.thread.spawn ngx.thread.wait ngx.thread.kill coroutine.create coroutine.resume coroutine.yield coroutine.wrap coroutine.running coroutine.status ngx.config.debug 编译时是否有 –with-debug选项 ngx.config.prefix 编译时的 –prefix选项 ngx.config.nginx_version 返回nginx版本号 ngx.config.nginx_configure 返回编译时 ./configure的命令行选项 ngx.config.ngx_lua_version 返回ngx_lua模块版本号 ngx.worker.exiting 当前worker进程是否正在关闭（如reload、shutdown期间） ngx.worker.pid 返回当前worker进程的pid 常量 说明 Core constants ngx.OK (0) ngx.ERROR (-1) ngx.AGAIN (-2) ngx.DONE (-4) ngx.DECLINED (-5) ngx.nil HTTP method constants ngx.HTTP_GET ngx.HTTP_HEAD ngx.HTTP_PUT ngx.HTTP_POST ngx.HTTP_DELETE ngx.HTTP_OPTIONS ngx.HTTP_MKCOL ngx.HTTP_COPY ngx.HTTP_MOVE ngx.HTTP_PROPFIND ngx.HTTP_PROPPATCH ngx.HTTP_LOCK ngx.HTTP_UNLOCK ngx.HTTP_PATCH ngx.HTTP_TRACE HTTP status constants ngx.HTTP_OK (200) ngx.HTTP_CREATED (201) ngx.HTTP_SPECIAL_RESPONSE (300) ngx.HTTP_MOVED_PERMANENTLY (301) ngx.HTTP_MOVED_TEMPORARILY (302) ngx.HTTP_SEE_OTHER (303) ngx.HTTP_NOT_MODIFIED (304) ngx.HTTP_BAD_REQUEST (400) ngx.HTTP_UNAUTHORIZED (401) ngx.HTTP_FORBIDDEN (403) ngx.HTTP_NOT_FOUND (404) ngx.HTTP_NOT_ALLOWED (405) ngx.HTTP_GONE (410) ngx.HTTP_INTERNAL_SERVER_ERROR (500) ngx.HTTP_METHOD_NOT_IMPLEMENTED (501) ngx.HTTP_SERVICE_UNAVAILABLE (503) ngx.HTTP_GATEWAY_TIMEOUT (504) Nginx log level constants ngx.STDERR ngx.EMERG ngx.ALERT ngx.CRIT ngx.ERR ngx.WARN ngx.NOTICE ngx.INFO ngx.DEBUG","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"},{"name":"技术笔记","slug":"默认分类/技术笔记","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://jlynet.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"shell","slug":"shell","permalink":"https://jlynet.github.io/tags/shell/"},{"name":"linux","slug":"linux","permalink":"https://jlynet.github.io/tags/linux/"},{"name":"随笔","slug":"随笔","permalink":"https://jlynet.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"nginx","slug":"nginx","permalink":"https://jlynet.github.io/tags/nginx/"}]},{"title":"OpenResty 执行流程阶段","slug":"OpenResty-执行流程阶段","date":"2021-10-17T12:01:02.000Z","updated":"2021-10-17T12:14:34.000Z","comments":true,"path":"2021/10/17/OpenResty-执行流程阶段/","link":"","permalink":"https://jlynet.github.io/2021/10/17/OpenResty-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E9%98%B6%E6%AE%B5/","excerpt":"","text":"nginx有11个处理阶段，如下图所示： 指令 所处处理阶段 使用范围 解释 init_by_lua init_by_lua_file loading-config http nginx Master进程加载配置时执行；通常用于初始化全局配置/预加载Lua模块 init_worker_by_lua init_worker_by_lua_file starting-worker http 每个Nginx Worker进程启动时调用的计时器，如果Master进程不允许则只会在init_by_lua之后调用；通常用于定时拉取配置/数据，或者后端服务的健康检查 set_by_lua set_by_lua_file rewrite server,server if,location,location if 设置nginx变量，可以实现复杂的赋值逻辑；此处是阻塞的，Lua代码要做到非常快； rewrite_by_lua rewrite_by_lua_file rewrite tail http,server,location,location if rrewrite阶段处理，可以实现复杂的转发/重定向逻辑； access_by_lua access_by_lua_file access tail http,server,location,location if 请求访问阶段处理，用于访问控制 content_by_lua content_by_lua_file content location，location if 内容处理器，接收请求处理并输出响应 header_filter_by_lua header_filter_by_lua_file output-header-filter http，server，location，location if 设置header和cookie body_filter_by_lua body_filter_by_lua_file output-body-filter http，server，location，location if 对响应数据进行过滤，比如截断、替换。 log_by_lua log_by_lua_file log http，server，location，location if log阶段处理，比如记录访问量/统计平均响应时间 指令解释**init_by_lua***：初始化 nginx 和预加载 lua(nginx 启动和 reload 时执行)；**init_worker_by_lua***：每个工作进程(worker_processes)被创建时执行，用于启动一些定时任务，比如心跳检查，后端服务的健康检查，定时拉取服务器配置等；**ssl_certificate_by_lua***：对 https 请求的处理，即将启动下游 SSL（https）连接的 SSL 握手时执行，用例：按照每个请求设置 SSL 证书链和相应的私钥，按照 SSL 协议有选择的拒绝请求等；**set_by_lua***：设置 nginx 变量；**rewrite_by_lua***：重写请求（从原生 nginx 的 rewrite 阶段进入），执行内部 URL 重写或者外部重定向，典型的如伪静态化的 URL 重写；**access_by_lua***：处理请求（和 rewrite_by_lua 可以实现相同的功能，从原生 nginx 的 access阶段进入）；**content_by_lua***：执行业务逻辑并产生响应，类似于 jsp 中的 servlet；**balancer_by_lua***：负载均衡；**header_filter_by_lua***：处理响应头；**body_filter_by_lua***：处理响应体；**log_by_lua***：记录访问日志； 一般我们在开发过程中常用到的阶段如下： 1set_by_lua、rewrite_by_lua、access_by_lua、content_by_lua、header_filter_by_lua、body_filter_by_lua、log_by_lua、 1.set_by_lua 做流程分支判断，判断变量初始化 2.rewrite_by_lua 转发重定向，缓存功能 3.access_by_lua ip准入，接口合法权限判断，根据iptable做防火墙的功能 4.content_by_lua 内容生产 5.header_filter_by_lua 增加头部信息 6.body_filter_by_lua 内容过滤 7.log_by_lua 记录日志 文章转载：https://www.cnblogs.com/fly-kaka/p/11102849.html","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"},{"name":"技术笔记","slug":"默认分类/技术笔记","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://jlynet.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"shell","slug":"shell","permalink":"https://jlynet.github.io/tags/shell/"},{"name":"linux","slug":"linux","permalink":"https://jlynet.github.io/tags/linux/"},{"name":"随笔","slug":"随笔","permalink":"https://jlynet.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"nginx","slug":"nginx","permalink":"https://jlynet.github.io/tags/nginx/"}]},{"title":"从Clover到OpenCore","slug":"从Clover到OpenCore","date":"2021-10-09T21:46:25.000Z","updated":"2021-10-09T21:50:26.000Z","comments":true,"path":"2021/10/10/从Clover到OpenCore/","link":"","permalink":"https://jlynet.github.io/2021/10/10/%E4%BB%8EClover%E5%88%B0OpenCore/","excerpt":"","text":"由于是转载文章，文章中的我特指作者：SukkaW 随着 OpenCore 日渐成熟、acidanthera 团队宣布放弃旗下绝大部分内核驱动（包括 Lilu、VirtualSMC、WhateverGreen、AppleALC 等）对 Clover 的兼容性支持，与其届时被迫换到 OpenCore，不如主动开始迁移。 当然面对迁移，有的人会选择直接抛弃之前 Clover 的全部成果，直接从零开始配置 OpenCore。但是我相信对于大部分人来说更希望通过简简单单的修补，在现有的 EFI 的基础上迁移到 OpenCore，因此我开始撰写这篇文章。 然而不幸的是从 Clover 切换到 OpenCore 并不是一个简单的任务，因此这种迁移应该是渐进式的，不可能一蹴而就。那什么是「渐进式」呢？意思就是，如果你按照本文的步骤一步一步按顺序进行，那么大部分迁移步骤产生的修改，在 Clover 下一样可用，你不需要一下子就扔掉 Clover 。 序言以外应该写在最前面的话 OpenCore 丢掉了不少 Clover 的历史包袱。毫无疑问依然有不少 Clover 设置在 OpenCore 是没有可以直接替代的。因此 Clover 完全照搬到 OpenCore 是肯定行不通的。 在迁移到 OpenCore 之前，Clover 的大部分设置都要精简：用 SSDT 代替、改为注入设备属性（Device Properties）。这篇教程的主题就是教你这些事情。 如果你一开始在组织 Clover 的 EFI 时就有洁癖的话，你会发现迁移到 OpenCore 出人意料地简单。 只有完美的 Clover 的 EFI，在按照本文档的步骤精简后能获得完美的 OpenCore 的 EFI。如果你的 EFI 是不完美的，那么迁移到 OpenCore 也一定是不完美的。因此，如果你是为了解决不完美、才想迁移到 OpenCore，那么我建议先在 Clover 下完善。 独木难成林。这篇教程初次发布以后，Bat.bat 等许多大佬在远景论坛、Telegram 上提供了许多意见，正是在他们的帮助下，这篇教程得以不断完善。 修改 SSDT / DSDT 以搭配 OpenCoreOpenCore 和 Clover 最大的不同其实是，acidanthera 决定在 OpenCore 中设置的 SMBIOS 机型信息、DSDT 和 SSDT，都将一视同仁的对所有操作系统生效。这样做的目的是让黑苹果更像白苹果，但是却有可能导致在 macOS 上正常可用的 ACPI 表到了 Windows 上反而会出问题。因此，迁移的第一步我个人推荐从修改现有的 SSDT 和 DSDT 开始，因为在 OpenCore 下能用的 SSDT、DSDT，在 Clover 下是一定可用的。也就是说，当你完成这一步后，你可以继续使用 Clover 而不受影响。 这里主要介绍对 Method 函数的修改方法。以 GPRW（6D0D）补丁为例，在 Clover 上我们一般采用这种方法： 123456789101112131415161718192021222324252627282930//// In config ACPI, GPRW to XPRW// Find: 47505257 02// Replace: 58505257 02//DefinitionBlock (&quot;&quot;, &quot;SSDT&quot;, 2, &quot;SUKA&quot;, &quot;GPRW&quot;, 0)&#123; External(XPRW, MethodObj) Method (GPRW, 2, NotSerialized) &#123; If ((0x6D == Arg0)) &#123; Return (Package () &#123; 0x6D, Zero &#125;) &#125; If ((0x0D == Arg0)) &#123; Return (Package () &#123; 0x0D, Zero &#125;) &#125; Return (XPRW (Arg0, Arg1)) &#125;&#125; 这个 SSDT 的原理是，通过 DSDT 重命名将原始的 GPRW,2 函数重命名为 XPRW,2 ，然后通过 SSDT 新增一个 GPRW 函数，这样实际 ACPI 调用 GPRW 函数时就是调用的 SSDT 里添加的 GPRW 函数。 但是现在，OpenCore 将会对所有操作系统一视同仁，所有 SSDT、DSDT 重命名对包括 Windows 在内的所有操作系统生效，那么 SSDT 中的 GPRW 函数也会在 Windows 生效，可能就会导致未知的后果。所以，我们需要通过 OSI 函数，判断当前操作系统，确保函数的行为只对某一个操作系统生效： 1234567891011121314151617181920212223242526272829303132333435363738//// In config ACPI, GPRW to XPRW// Find: 47505257 02// Replace: 58505257 02//// 需要注意的是，ACPI 里不支持非 ASCII 字符注释，这里仅做示例，不可直接用于编译DefinitionBlock (&quot;&quot;, &quot;SSDT&quot;, 2, &quot;OCLT&quot;, &quot;GPRW&quot;, 0)&#123; External(XPRW, MethodObj) // 对 XPRW 函数的外部引用 Method (GPRW, 2, NotSerialized) &#123; If (_OSI (&quot;Darwin&quot;)) // 如果当前的操作系统是 macOS，生效以下行为 &#123; If ((0x6D == Arg0)) &#123; Return (Package () &#123; 0x6D, Zero &#125;) &#125; If ((0x0D == Arg0)) &#123; Return (Package () &#123; 0x0D, Zero &#125;) &#125; &#125; // 否则，直接返回 XPRW 函数。只有三种情况下会走到这一步： // 第一个参数不是 0x6D、第一个参数不是 0x0D、当前操作系统不是 macOS // XPRW 是 ` DSDT ` 中原始的 GPRW 函数重命名而来 // 所以这一步实际上是调用了原始 ` DSDT ` 中原始的 GPRW 方法 Return (XPRW (Arg0, Arg1)) &#125;&#125; 上面以 GPRW 为例介绍了相关思路，接下来我们以亮度快捷键补丁为例实际操作一下如何一步一步修改 SSDT。大部分亮度快捷键都是基于 EC Query 触发的，因此在 Clover 中我们的亮度快捷键 SSDT 可能是这样的： 1234567891011121314151617181920212223242526// In config ACPI, _Q14 renamed XQ14// Find: 5F 51 31 34// Replace: 58 51 31 34// In config ACPI, _Q15 renamed XQ15// Find: 5F 51 31 35// Replace: 58 51 31 35DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;SUKA&quot;, &quot;BrightFN&quot;, 0)&#123; External(_SB.PCI0.LPCB.KBD, DeviceObj) External(_SB.PCI0.LPCB.EC, DeviceObj) Scope (_SB.PCI0.LPCB.EC) &#123; Method (_Q14, 0, NotSerialized)//up &#123; Notify(\\_SB.PCI0.LPCB.KBD, 0x0406) &#125; Method (_Q15, 0, NotSerialized)//down &#123; Notify(\\_SB.PCI0.LPCB.KBD, 0x0405) &#125; &#125;&#125; 如果想知道亮度快捷键补丁的工作原理，请参看我的另一篇文章「黑苹果自定义键盘 Fn 快捷键」。 根据同样的思路，我们先在 Method 定义中添加 OSI 函数判断操作系统： 123456789101112131415161718192021222324DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;BrightFN&quot;, 0)&#123; External(_SB.PCI0.LPCB.KBD, DeviceObj) External(_SB.PCI0.LPCB.EC, DeviceObj) Scope (_SB.PCI0.LPCB.EC) &#123; Method (_Q14, 0, NotSerialized)//up &#123;+ If (_OSI (&quot;Darwin&quot;))+ &#123; Notify(\\_SB.PCI0.LPCB.KBD, 0x0406)+ &#125; &#125; Method (_Q15, 0, NotSerialized)//down &#123;+ If (_OSI (&quot;Darwin&quot;))+ &#123; Notify(\\_SB.PCI0.LPCB.KBD, 0x0405)+ &#125; &#125; &#125;&#125; 由于这里不是以 Return 结束的，所以我们要为 If 加上 Else： 12345678910111213141516171819202122232425262728DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;BrightFN&quot;, 0)&#123; External(_SB.PCI0.LPCB.KBD, DeviceObj) External(_SB.PCI0.LPCB.EC, DeviceObj) Scope (_SB.PCI0.LPCB.EC) &#123; Method (_Q14, 0, NotSerialized)//up &#123;+ If (_OSI (&quot;Darwin&quot;))+ &#123; Notify(\\_SB.PCI0.LPCB.KBD, 0x0406)+ &#125; Else &#123;++ &#125; &#125; Method (_Q15, 0, NotSerialized)//down &#123;+ If (_OSI (&quot;Darwin&quot;))+ &#123; Notify(\\_SB.PCI0.LPCB.KBD, 0x0405)+ &#125; Else &#123;++ &#125; &#125; &#125;&#125; 在 Else 区域中，调用原始 DSDT 中原始的 _Q14、_Q15 函数、也就是现在已经被重命名为 XQ14 和 XQ15 的函数。当然，别忘了在文件头部添加对 XQ14 和 XQ15 的函数的外部引用： 123456789101112131415161718192021222324252627282930DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;BrightFN&quot;, 0)&#123; External(_SB.PCI0.LPCB.KBD, DeviceObj) External(_SB.PCI0.LPCB.EC, DeviceObj)+ External(_SB.PCI0.LPCB.EC.XQ14, MethodObj)+ External(_SB.PCI0.LPCB.EC.XQ15, MethodObj) Scope (_SB.PCI0.LPCB.EC) &#123; Method (_Q14, 0, NotSerialized)//up &#123;+ If (_OSI (&quot;Darwin&quot;))+ &#123; Notify(\\_SB.PCI0.LPCB.KBD, 0x0406)+ &#125; Else &#123;+ \\_SB.PCI0.LPCB.EC.XQ14()+ &#125; &#125; Method (_Q15, 0, NotSerialized)//down &#123;+ If (_OSI (&quot;Darwin&quot;))+ &#123; Notify(\\_SB.PCI0.LPCB.KBD, 0x0405)+ &#125; Else &#123;+ \\_SB.PCI0.LPCB.EC.XQ15()+ &#125; &#125; &#125;&#125; 这样就大功告成了。 是不是有些头昏脑涨？实际上，和 Clover 现成的 SSDT 补丁库一样，OpenCore 也有现成的 SSDT 补丁库 OC-little，由资深黑苹果爱好者们维护。我也在其中贡献了一些补丁（如 PTWSAK 关机变重启修复）和说明。 你在 Clover 中使用的 SSDT 补丁，大部分都有对应的 OpenCore 下可用的 SSDT 替代，免去了你手动修改的痛苦。而且，你还可能通过 OC-little 库里的其他补丁修复了一些你之前的 SSDT 补丁没有解决的问题。 当然，对于一些 OC-little 中没有等价替代的补丁，你仍然需要手动修改、添加操作系统判断；对于直接修补的 DSDT，你也只能自己在 Method 中添加对应的判断。 如果你完成了对 SSDT、DSDT 的修改，现在备份你的 EFI、然后修改后的 SSDT、DSDT 放到 EFI/Clover/ACPI/patched 之中，然后以 -v 重启，看看能不能正常开机。如果可以正常开机，登录以后打开终端执行以下命令、查看日志中是否包括 ACPI Error： 1$ log show --last boot | grep -Ei &quot;ACPI&quot; 如果正常开机，没有 ACPI Error，那么恭喜你，你已经迈出了向 OpenCore 迁移的第一步，而且此时你依然还在继续使用 Clover ，你的黑苹果没有收到任何影响。 减少不必要的 DSDT 重命名acidanthera 团队认为，应该尽可能减少 DSDT 重命名、减少改动以避免对设备硬件造成伤害。 以下是一些不再需要的重命名，你可以参考这个表自己精简 DSDT 重命名、使用 SSDT 代替： EHC1 to EH01 和 EHC2 to EH02 ：建议由 OpenCore 官方的 SSDT-EHCx_OFF 关闭 EHC 控制器。Skylake 这类六代以上已经没有 EHC 控制器了，可以直接删除。 SAT0 to SATA 和 SAT1 to SATA ：实质上完全没用。 HECI to IMEI、HEC1 to IMEI、MEI to IMEI 和 IDER to MEID：WhateverGreen 能够处理这个问题。 GFX0 to IGPU、PEG0 to GFX0、PEGP to GFX0 和 SL01 to PEGP：WhateverGreen 能够处理这个问题。 EC0 to EC、H_EC to EC、ECDV to EC 和 PGEC to EC ：虽然 macOS 的 USB 电源管理需要名称为 EC 的控制器，但是你完全可以在 OC-little 中找到「仿冒 EC」的相关 SSDT 补丁。 HDAS to HDEF、CAVS to HDEF 和 AZAL to HDEF ：AppleALC 能够处理这个问题，除非你在用 VoodooHDA 万能声卡。 STAS to Noop ：建议由 OC-little 中的 SSDT-AWAC 相关补丁替代。 经 Bat.bat 大佬指出，由于新的时钟设备 AWAC 的普及，用 Noop 会导致同时启用两个时钟设备，在 macOS 下只有一个能正常工作、但是在 Windows 下面暴露两个设备无疑对系统有害，同时也严重违反 ACPI 规范。STAS 这个变量的意义使 AWAC 和 RTC 互锁以避免这种危害。因此，使用 SSDT-AWAC 是更理想的办法。 PXSX to ANS1 和 PXSX to ANS2 ：建议用 NVMeFix 这个 kext 修复 NVMe SSD 的电源管理。 LPC0 to LPCB ：如果你要添加 SMBUS 支持，OC-little 中分别有 SBUS 的 SSDT 注入补丁和 MCHC 设备补丁。 顺便提醒一下，使用 OC-little 的补丁的时候，需要注意设备的原始 DSDT 中的 LPC 总线名称，并且要自己修改 SSDT 以使 LPC 总线匹配。 PC00 to PCIO、FPU to MATH、TMR to TIMR、GBE1 to ETH0 和 PIC to IPIC ：这些重命名也是实质上是完全没用的。 _OSI to XOSI 和 OSID to XSID ：除非你的某些硬件设备只能在 Windows 下工作（比如 I2C 触摸板只能在 Windows 下使用，再比如 ThinkPad 对 FreeBSD 的特殊优化），否则完全没有必要使用 SSDT-XOSI 补丁来伪装操作系统。而且大部分情况下，直接定制 SSDT 也可以解除某些硬件的操作系统限制。 关于「定制 SSDT 以解除限制」，Bat.bat 大佬做了一些说明：一种方法是通过「预置变量法」（详见 OC-little 的「总述」章节）禁用原始设备的函数如 _STA，另一种方法是通过重命名实现对相关 _STA 的函数的精确重命名，然后通过 SSDT 添加新的 _STA 函数（SSDT 中可以添加 OSI 操作系统判断函数）。 _DSM to XDSM ：首先遍历一下你的 SSDT 补丁中没有依赖 _DSM 的，如果没有，这个重命名也应该删除，因为这个重命名涉及的范围实在太大了、太过于危险。 我的建议是，尽可能只添加和 Method 名称有关的重命名（如 GPRW to XPRW、_Q14 to XQ14），而且随后要通过 SSDT 确保在非 macOS 操作系统下要调用并返回原始函数，确保在非 macOS 操作系统下的原始 DSDT 行为不会被改变。如果万不得已要添加其它重命名（如通过重命名禁用某些设备），那么就要权衡这一重命名的后果。 如果你完成了精简 DSDT 重命名并保存了 config，接下来的操作还是一样的，备份原始 EFI、然后以 -v 重启，看看能不能正常开机。如果可以正常开机，登录以后打开终端执行以下命令、查看日志中是否包括 ACPI Error： 1$ log show --last boot | grep -Ei &quot;ACPI&quot; 完成这一步，你依然没有必要离开 Clover 。我说过了，「渐进式」地迁移，嗯？ 摆脱对 Clover ACPI Quirks 的依赖Clover 实在是非常方便。一个开关，关机变重启就修复了；三个开关，HPET、IRQ、TIMR 就修复了；等等等等。但是 OpenCore 是没有内置这些 ACPI 修复的，所以在 Clover 下用开关实现的 ACPI 修复现在都必须用 SSDT 实现。所幸的是，我们依然可以从 OC-little 里找到绝大部分我们需要的补丁。 FixIPIC：参考 OC-little 的「声卡 IRQ 补丁」章节 FixSBUS：参考 OC-little 的「注入 SBUS 设备」 FixShutdown：参考 OC-little 的「PTSWAK 综合补丁章节」，需要添加其中的 EXT1 插件补丁（该补丁由我贡献） FixDisplay：使用 WhateverGreen 和定制缓冲帧补丁解决 AddMCHC：参考 OC-little 的「注入缺失的 MCHC」章节 FixHDA：使用 AppleALC 即可 FixHPET：参考 OC-little 的「声卡 IRQ 补丁」章节 FixSATA：这个先不管它，OpenCore 中有个 ExternalDiskIcons 的 Quirk，也可以使用 innie.kext 解决。 FixADP1：使用 DSDT 重命名 AC0_ to ADP1，可能还要额外注入 Name (_PRW, Package (0x02) &#123;0x1C,0x03&#125;)。 FixRTC：参考 OC-little 的「声卡 IRQ 补丁」章节 FixTIMR：参考 OC-little 的「声卡 IRQ 补丁」章节 AddPNLF：参考 OC-little 的「注入 PNLF」章节 AddIMEI：使用 WhateverGreen 即可 FixIntelGfx：使用 WhateverGreen 即可 AddHDMI：使用 WhateverGreen 即可 除了这些开关以外，Clover 还有一些其它的 ACPI 设定，也有与之对应的替代。 DisableASPM：没有很好的代替方法，可以在设备属性（DeviceProperties）中分别添加相关设备的 PCI 总线位置并注入属性 pci-aspm-default | DATA | &lt;00&gt;。 PluginType：参考 OC-little 的「注入 X86」章节 Generate P States 和 Generate C States：这些是六代以前 CPU 才需要的设置，可以用 ssdtPRGen.sh 生成对应的 SSDT。 当然之后的事情还是一样的，以 -v 重启，正常开机后打开终端查看日志中是否包括 ACPI Error： 1$ log show --last boot | grep -Ei &quot;ACPI&quot; 当你把所有 Clover 的开关都用 SSDT 代替以后，你离迁移到 OpenCore 就越来越近了。 更新设备属性使用缓冲帧补丁驱动 Intel 核显如果你还在用 Clover 的 InjectIntel 的方式来驱动 Intel 核显的话，是时候更换到 WhateverGreen 和缓冲帧补丁的方式了。 建议参考以下几篇文章： 使用 WhateverGreen 驱动 Intel 核显 | 醉渔小站 Hackintool(原Intel FB-Patcher)使用教程及插入姿势 | 黑果小兵的部落阁 Intel 核显驱动常见问题 | WhateverGreen （务必看英文版，中文翻译严重过时） 新的声卡 layout-id 注入方式大部分黑苹果的声卡教程都已经推荐此处留空、直接在设备属性中注入 layout-id 了，不过我还是再冗笔一下。 下载 acidanthera 开发的工具 gfxutils，使用下述命令找出声卡的 PCI 总线位置： 123$ path/to/gfxutils -f HDEF$ path/to/gfxutils -f HDAS$ path/to/gfxutils -f HDAU 然后在设备属性中添加 PCI 总线位置、注入 layout-id 属性。 至于 AFGLowPowerState，需要额外为声卡设备注入 AFGLowPowerState 属性，值为 DATA | &lt;01000000&gt;、至于 ResetHDA，推荐安装 JackFix。 开始组织 OpenCore 目录终于是时候了，所有的准备工作都做完了！你可以抽出一天（最好占卜一下是否是吉日），沐浴更衣，然后开始组织你的 OpenCore 目录。 下载 OpenCore 所需文件 OpenCorePkg - OpenCore 本体、一些 SSDT 补丁、目录结构 MacInfoPkg - 导出你当前的三码、以及生成新的三码 AppleSupportPkg - 包括三个 EFI 驱动，ApfsDriverLoader、VBoxHfs、AudioDxe OcBinaryData - 包含两个闭源驱动 1HfsPlus.efi 和 1ExFatDxe.efi ，以及 1OpenCore 官方主题的图标文件。 非常推荐安装 OpenCore 官方做的主题，和真 Mac 的 BootPicker 一模一样（除了没有网络图标）。不过那可能是另一篇文章的主题了。 决定你使用的配置文件编辑器 ProperTree：一个 Python 编写的 plist 编辑器，专门优化了 OpenCore 和 Clover 配置文件编写。 Xcode：非常不推荐，Xcode 11 不仅花里胡哨、而且处理 plist data 和大整数方面存在问题。 简单来说，Apple 没有再开放旧版的 Xcode 10 下载、而且 Apple 的 CDN 还有防盗链。因此如果我要写一篇从 Apple 官方下载 Xcode 10 的教程，那么会比你现在看的这篇的「从 Clover 到 OpenCore」要长得多。 如果你和我一样成功下载了 Xcode 10 或者就没有升级到 Xcode 11：我刚才什么都没写，你什么都没看见。 OpenCore Configurator ：Clover Configurator 作者的新作品。很适合新手使用。 OpenCore 的配置文件变更非常频繁，因此只应该用 最新版的 OpenCore Configurator 搭配 **最新的正式版的 OpenCore**，否则配置文件格式错误将会导致无法引导。 OpenCore Configurator 有不少低级 Bug（后来更新时都修复了），比如之前有一个版本，在应对 VoodooPS2Controller 和 VooooI2C 这种嵌套 kext 时，会只添加内部 kext 的 dsYM 签名文件、却不添加内部 kext 本体。 反正就是，使用后果自负。 生成目录结构解压下载的 OpenCore 并解压，将其中的 EFI 目录 复制出来到别处。 直到配置好以后，再将这个目录合并进硬盘上的 EFI 分区。 将 Docs 目录下的 Sample.list 复制到 EFI/OC 目录下、并重命名为 config.plist。 如果你下载的是 OpenCore 0.5.7 版本，还需要额外将 Reources 目录复制到 EFI/OC 目录之中。 解压下载的 AppleSupportPkg，将其中的 Drivers 目录和 Tools 目录中的文件复制到 EFI/OC/Drivers 目录和 EFI/OC/Tools 目录中。 解压下载的 OcBinaryData，将其中 Drivers 目录复制到 EFI/OC/Drivers 目录中。 删除不需要的文件删除 Drivers 目录中的这些文件： ExFatDxe 和 ExFatDxeLegacy：除非你的 EFI 分区或者某个系统分区是 ExFAT 分区格式的，否则不需要保留。 HfsPlus、HfsPlusLegacy 和 VBoxHfs：三者只要留其中一个即可。一般推荐用 HfsPlus，比 VBoxHfs 速度快三倍。在四代以前机型上应该用 HfsPlusLegcay 而不是 HfsPlus。 AppleUsbKbDxe 或 OpenUsbKbDxe：这是为三代以前机型使用的，现代的机器应该使用 OpenCore 中的 KeySupport 这个 Quirk。 NvmExpressDxe：这是为四代以前机型使用的 NVMe 硬盘加载驱动，现代的机器已经不需要了。 XhciDxe：为二代以前的主板提供 XHCI 支持的，现代的机器已经不需要了。 HiiDatabase：为四代以前的设备提供 UEFI 界面字体渲染支持的，现代的机器已经不需要了。 删除 Tools 目录中的这些文件： BootKicker：调用 Mac 内置的引导界面，是用于给白苹果安装 OpenCore 时用的，黑苹果用不上。 现在，你的 OpenCore EFI 目录的结构应该是这样的： 123456789101112131415161718EFI├── BOOT│ └── BOOTx64.efi└── OC ├── ACPI ├── Drivers │ ├── ApfsDriverLoader.efi │ ├── AudioDxe.efi │ ├── HfsPlus.efi │ ├── OpenCanopy.efi │ └── OpenRuntime.efi ├── Kexts ├── OpenCore.efi ├── Resources └── Tools ├── ChipTune.efi ├── ...... └── VerifyMsrE2.efi 现在，你可以把你的 SSDT、DSDT 从 Clover 里的 Clover/ACPI/Patched 复制出来、粘贴进 EFI/OC/ACPI 目录中；将 Kext 从 Clover/Kexts/*/ 中复制出来粘贴进 EFI/OC/Kexts 目录中。 开始配置 OpenCore这里我就不再赘述 OpenCore 的配置教程了。这里推荐几个写的不错的教程和足够有用的参考资料。 OpenCore 参考文档。当你解压下载的 OpenCore 时，Docs/Configuration.pdf 文件就是 OpenCore 的官方文档。这是最权威的 OpenCore 参考资料、没有之一。 OpenCore 简体中文参考手册。OpenCore 参考手册的翻译，由我和一些黑苹果爱好者们共同在维护。 上面两份参考资料资料适合你在配置时不知道某个选项的具体作用、具体副作用时参考用，但是不适合直接对着它们配置 config.plist。如果想要快速上手 OpenCore 配置，应该参考下面的教程： OpenCore Vanilla Guide。OpenCore 官方认可写得较好的新手教程。这篇教程受众是第一次接触黑苹果就想用 OpenCore 的人，因此内容写得非常浅显 精解 OpenCore | 黑果小兵的部落阁。国内最早的 OpenCore 介绍文档之一，提供了不少配置思路和 Quirks 的推荐配置。 使用 OpenCore 引导黑苹果 | XJN’s Blog。比较详细的 OpenCore 配置介绍，但是这篇文章的排版我实在是欣赏不来。 OpenCore 引导迁移折腾记录 | 宇宙よりも遠い場所。内容详细的 OpenCore 配置介绍，提供了不少 Quirks 的推荐配置。 Clover 中的部分配置，如 DSDT 重命名，由于在之前已经精简，因此可以将 Find 和 Replace 的十六进制字符串逐对复制到 OpenCore 的配置文件中。 Clover 中的设置在 OpenCore 的等效配置现在你开始跟着我推荐的教程和参考资料开始配置 OpenCore 了。接下来我会写一些 Clover 中一些选项在 OpenCore 的对应等效配置，在配置 OpenCore 时别忘了跟着看看。 Boot 的相关设置 引导参数：OpenCore 中 NVRAM -&gt; Add -&gt; 7C436110-AB2A-4BBB-A880-FE41995C9F82 -&gt; boot-args NeverHibernate 123： Misc -&gt; Boot -&gt; HibernateMode -&gt; None 12345 - 其实不再建议禁用休眠，由于 `OpenCore` 的行为和白苹果更加接近，以至于已经可以实现 macOS 的完美休眠。- Default Boot Volume： OpenCore 1234567 中 Misc - Security - AllowSetDefaults - true 12345678 - 然后在 `OpenCore` 的引导菜单处使用 Ctrl + Enter 按键进行选择 - 你也可以直接用「系统偏好设置」中的「启动磁盘」设置- DefaultBackgroundColor：`OpenCore` 中的 `NVRAM -&gt; Add -&gt; 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14-&gt; DefaultBackgroundColor` ，需要自己将 RGB 转换为 HEX。- EFILoginHiDPI： OpenCore 1234567 中 NVRAM -&gt; Add -&gt; 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14 -&gt; EFILoginHiDPI | Data | &lt;&gt; 123456 - 0 -&gt; `&lt;00000000&gt;` - 1 -&gt; `&lt;01000000&gt;`- flagstate： OpenCore 1234567 中 NVRAM -&gt; Add -&gt; 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14 -&gt; flagstate | Data | &lt;&gt; 123456 - 0 -&gt; `&lt;00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000&gt;` - 注意自行判断 NVRAM 键值对位置- UIScale： NVRAM -&gt; Add -&gt; 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14 -&gt; UIScale | Data | &lt;&gt; 12345678910 - 1 -&gt; `&lt;01&gt;` - 2 -&gt; `Data | &lt;02&gt;`### CPU 相关配置- Type：在 OpenCore 1234567 中有对应的 Platforminfo -&gt; SMBIOS -&gt; ProcessorType 12345678910111213141516171819202122232425 可以设置处理器类型 - 在 [这个文件](https://github.com/[acidanthera](https://github.com/acidanthera)/EfiPkg/blob/master/Include/IndustryStandard/AppleSmBios.h) 查看可以选用的值- HWPEnable：如果你真的要依赖 `MSR 0x770` （注意这里说的不是原生电源管理 `MSR 0xe2`）的 HWP 电源管理，建议安装 headkaze 开发的 [`HWPEnable.kext`](https://github.com/headkaze/HWPEnable/tree/master/binary)。HackinTool 也是他开发的。- QEMU：`OpenCore` 已经完整支持虚拟机，因此 `OpenCore` 中不包含这一选项。- TurboDisable：建议用 CPUFriend 或者 [ssdtPRGen.sh](http://ssdtprgen.sh/) 来修复电源管理。### 设备属性相关设置#### USB- FixOwnership：`OpenCore` 中 `UEFI -&gt; Quirk -&gt; ReleaseUsbOwnership`- ClockID：需要自己注入对应的设备属性（Device Properties），属性为 `AAPL,clock-id`- HighCurrent：需要自己注入对应的设备属性（Device Properties），属性为 AAPL,HighCurrent 123456789101112131415161718192021222324252627282930313233343536373839 - 对于 macOS 10.11 来说 HighCurrent 已经没啥用了。对于更新版的 macOS，推荐用 OC-little 中的 `SSDT-USBX` 补丁。#### FakeID同样使用 gfxutils 工具找到 PCI 总线位置，然后分别注入相关属性：- USB - `device-id` - `device_type` - `device_type`- IMEI - `device-id` - `vendor-id`- WIFI - `name` - `compatible`- LAN - `device-id` - `compatible` - `vendor-id`- XHCI - `device-id` - `device_type: UHCI` - `device_type: OHCI` - ``` device_type: EHCI - `device-id` - `AAPL,current-available` - `AAPL,current-extra` - `AAPL,current-available` - `AAPL,current-extra` - `AAPL,current-in-sleep` - `built-in` - ``` device_type: XHCI 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 - `device-id` - `AAPL,current-available` - `AAPL,current-extra` - `AAPL,current-available` - `AAPL,current-in-sleep` - `built-in`### Clover 中相关的图形设置和前文一样，这些在 `Clover` 中设置的属性都需要改为注入对应的设备属性即可。- InjectAti : - `DeviceProperties -&gt; Add -&gt; PCIRoot... -&gt; deviceID` - `DeviceProperties -&gt; Add -&gt; PCIRoot... -&gt; Connectors`- InjectNvidia : - `DeviceProperties -&gt; Add -&gt; PCIRoot... -&gt; DeviceID` - `DeviceProperties -&gt; Add -&gt; PCIRoot... -&gt; Family`- FakeAti : - `DeviceProperties -&gt; Add -&gt; PCIRoot... -&gt; device-id` - `DeviceProperties -&gt; Add -&gt; PCIRoot... -&gt; ATY,DeviceID` - `DeviceProperties -&gt; Add -&gt; PCIRoot... -&gt; @0,compatible` - `DeviceProperties -&gt; Add -&gt; PCIRoot... -&gt; vendor-id` - `DeviceProperties -&gt; Add -&gt; PCIRoot... -&gt; ATY,VendorID`- BootDisplay : - `DeviceProperties -&gt; Add -&gt; PCIRoot... -&gt; @0,AAPL,boot-display`&gt; Intel 核显推荐使用 WhateverGreen 和缓冲帧补丁驱动。一般的，在注入仿造显卡或仿造 VBIOS 的时候，更推荐使用 `SSDT` 搭配 WhateverGreen 的方式。至于 EDID 注入，WhateverGreen 的文档中有 [详细介绍](https://github.com/[acidanthera](https://github.com/acidanthera)/WhateverGreen/blob/master/Manual/FAQ.IntelHD.en.md#edid)。### 内核扩展驱动（Kext）相关- **KernelPm** 和 **AppleIntelCPUPM**：对应 `OpenCore` 中 `Kernel -&gt; Quirks -&gt; AppleXcpmCfgLock -&gt; YES` 和 `Kernel -&gt; Quirks -&gt; AppleCpuPmCfgLock -&gt; YES`。- DellSMBIOSPatch ：在 OpenCore 12345678910111213141516171819202122232425262728293031 中对应了两个 Quirk： - `Kernel -&gt; Quirks -&gt; CustomSMBIOSGuid -&gt; YES` - `PlatformInfo -&gt; UpdateSMBIOSMode -&gt; Custom`- **Kernel LAPIC** 和 **KernelXCPM**：分别对应 `OpenCore` 中的 `Kernel -&gt; Quirks -&gt; LapicKernelPanic -&gt; YES` 和 `Kernel -&gt; Quirks -&gt; AppleXcpmExtraMsrs -&gt; YES`- AppleRTC ： - Comment：Disable RTC checksum update on poweroff - Enabled：YES - Count：1 - Base：`__ZN8AppleRTC14updateChecksumEv` - Identifier：`com.apple.driver.AppleRTC` - Limit：0 - Find： - Replace：c3- **FakeCPUID**：`OpenCore` 提供了专门的 Emulate 功能。除此以外，一些常用的 Kext Patch 在 `OpenCore` 中也有了对应了 Quirk。- 解除 USB 15 端口限制，以前根据不同的系统需要打不同的 Kext Patch，现在只需要 `OpenCore` 一个 Quirk：`Kernel -&gt; Quirks -&gt; XhciPortLimit -&gt; YES`- 内置硬盘变外置硬盘，也只需要一个 Quirk： kernel -&gt; Quirks -&gt; ExternalDiskIcons -&gt; YES 123456789101112131415161718192021222324252627282930313233343536373839404142434445 - 和前面的 FixSATA 不同，FixSATA 顾名思义只修复 SATA 硬盘，而 `OpenCore` 这个 Quirks 会修复所有的硬盘。- 为 SATA SSD 提供 TRIM 现在也只需要启用一个 Quirk：`Kernel -&gt; Quirks -&gt; ThirdPartyDrive`### SMBIOS 机型信息和系统参数- **Product Name**：`PlatformInfo -&gt; Generic -&gt; SystemProductName`- **Serial Number**：`PlatformInfo --&gt; Generic -&gt; SystemSerialNumber`- **Board Serial Number**：`PlatformInfo -&gt; Generic -&gt; MLB`- **SmUUID**：`PlatformInfo -&gt; Generic -&gt; SystemUUID`- Slots AAPL Injection ：需要注入到设备属性中 - `DeviceProperties -&gt; Add -&gt; PCIRoot... -&gt; APPL,slot-name | string | Add slot`- **CustomUUID**：就连 `Clover` 都不推荐配置这一项，`OpenCore` 直接就不提供硬件 UUID 配置功能- **InjectSystemID**：兼容变色龙的历史遗留配置，`OpenCore` 也不再提供- BacklightLevel ：需要注入到 NVRAM 中 - `NVRAM -&gt; Add -&gt; 7C436110-AB2A-4BBB-A880-FE41995C9F82 -&gt; backlight-level | Data | &lt;Insert value&gt;`- NvidiaWeb ：需要注入到 NVRAM 中 - `NVRAM -&gt; Add -&gt; 7C436110-AB2A-4BBB-A880-FE41995C9F82 -&gt; nvda_drv: &lt;31&gt;`------配置好 `OpenCore` 以后，可以将 `OpenCore` 复制到 U 盘或者硬盘中。需要注意的是，`EFI/BOOT/BOOTx64.efi` 需要直接替换。在添加引导项时，`OpenCore` **必须** 从 `EFI/BOOT/BOOTx64.efi` 启动而不是从 `EFI/OC/OpenCore.efi` 启动。如果启动项中添加的不是 `EFI/BOOT/BOOTx64.efi`，那么有很大的概率你会遇到各种奇怪的问题。## 清理 `Clover` 残余重启到 `OpenCore` 引导之前，务必清理掉 `Clover` 的残留文件： sudo rm -rf /Library/PreferencePanes/Clover.prefPane # 删除 `Clover` 位于系统偏好设置中的面板 # 删除 `Clover` 的自动脚本 rm -rf &quot;/etc/rc.clover.lib&quot; rm -rf &quot;/etc/rc.boot.d/10.save_and_rotate_boot_log.local&quot; rm -rf &quot;/etc/rc.boot.d/20.mount_ESP.local&quot; rm -rf &quot;/etc/rc.boot.d/70.disable_sleep_proxy_client.local.disabled&quot; rm -rf &quot;/etc/rc.boot.d/80.save_nvram_plist.local&quot; rm -rf &quot;/etc/rc.shutdown.local&quot; rm -rf &quot;/etc/rc.boot.d&quot; rm -rf &quot;/etc/rc.shutdown.d&quot; # 删除 `Clover` 的守护进程 launchctl unload &#39;/Library/LaunchDaemons/com.slice.CloverDaemonNew.plist&#39; rm -rf &#39;/Library/LaunchDaemons/com.slice.CloverDaemonNew.plist&#39; rm -rf &#39;/Library/Application Support/Clover/CloverDaemonNew&#39; rm -rf &#39;/Library/Application Support/Clover/CloverLogOut&#39; rm -rf &#39;/Library/Application Support/Clover/CloverWrapper.sh&#39; 除此以外，还要删除 EFI 分区中的 nvram.plist 文件。 在 OpenCore 中还需要重置 NVRAM。可以在 OpenCore 引导菜单中，按下空格键显示隐藏条目，最后一个条目就是 OpenCore 的重置 NVRAM 功能。 原文链接：https://blog.skk.moe/post/from-clover-to-opencore/ 感谢名单 Apple 的 macOS RehabMan维护的项目：OS-X-Clover-Laptop-Config Laptop-DSDT-Patch OS-X-USB-Inject-All等 Acidanthera 维护的项目：OpenCorePkg lilu AirportBrcmFixup WhateverGreen VirtualSMC AppleALC BrcmPatchRAM MaciASL 等 headkaze 提供的工具：hackintool PinConfigurator BrcmPatchRAM CloverHackyColor维护的项目：CloverBootloader CloverThemes 宪武整理的：P-little OC-little chris1111维护的项目：VoodooHDA Wireless USB Adapter Clover zxystd开发的itlwm IntelBluetoothFirmware lihaoyun6提供的工具：CPU-S macOS-Displays-icon SidecarPatcher sukka更新维护的从 Clover 到 OpenCore —— Clover 迁移 OpenCore 指南 xzhih提供的工具：one-key-hidpi Bat.bat更新维护的精解OpenCore shuiyunxc 更新维护的OpenCore配置错误、故障与解决办法 athlonreg更新维护的OpenCore 0.5+ 部件补丁 Common-patches-for-hackintosh github.com 码云 gitee.io 扣钉 coding.net 参考及引用： https://deviwiki.com/wiki/Dell https://deviwiki.com/wiki/Dell_Wireless_1820A_(DW1820A) Hervé 更新的Broadcom 4350:https://osxlatitude.com/forums/topic/12169-bcm4350-cards-registry-of-cardslaptops-interop/ Hervé 更新的DW1820A支持机型列表:https://osxlatitude.com/forums/topic/11322-broadcom-bcm4350-cards-under-high-sierramojave/ nickhx 提供的蓝牙驱动：https://osxlatitude.com/forums/topic/11540-dw1820a-for-7490-help/?do=findComment&amp;comment=92833 xjn819： 使用OpenCore引导黑苹果 300系列主板正确使用AptioMemoryFix.efi的姿势(重写版） insanelymac.com tonymacx86.com 远景论坛 applelife.ru olarila.com 文章转载：https://blog.daliansky.net/From-Clover-To-OpenCore.html","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"},{"name":"技术笔记","slug":"默认分类/技术笔记","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://jlynet.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"随笔","slug":"随笔","permalink":"https://jlynet.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Portainer安装配置","slug":"Portainer安装配置","date":"2021-10-09T04:09:14.000Z","updated":"2021-10-09T21:51:18.000Z","comments":true,"path":"2021/10/09/Portainer安装配置/","link":"","permalink":"https://jlynet.github.io/2021/10/09/Portainer%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","excerpt":"","text":"什么是portainer 安装过程 添加Endpoints 什么是portainer官网：https://www.portainer.io/ Portainer（基于 Go） 是一个轻量级的Web管理界面，可让您轻松管理 Docker 主机 或 Swarm 集群。Portainer 的使用意图是简单部署。 它包含可以在任何 Docker 引擎上运行的单个容器（Docker for Linux 和 Docker for Windows）。Portainer 允许您管理 Docker 容器、image、volume、network 等。 它与独立的 Docker 引擎和 Docker Swarm 兼容。 Portainer简化了Swarm和Kubernetes环境中的容器管理。它被软件工程师和DevOps团队用来简化和加速软件部署。 安装过程服务器A上安装docker 和 portainer，服务器A的IP是192.168.31.88 1、安装dockerhttps://www.cnblogs.com/wudequn/p/11515610.html2、容器安装portainer 12345678docker pull portainer/portainerdocker run -d -p 9000:9000 -v /root/portainer:/data -v /var/run/docker.sock:/var/run/docker.sock --name portainer portainer/portainer-d #容器在后台运行-p 9000:9000 # 宿主机9000端口映射容器中的9000端口-v /var/run/docker.sock:/var/run/docker.sock # 把宿主机的Docker守护进程(docker daemon)默认监听的Unix域套接字挂载到容器中-v /root/portainer:/data # 把宿主机目录 /root/portainer 挂载到容器 /data 目录；–name portainer # 指定运行容器的名称 注意： 在启动容器时必须挂载本地 /var/run/docker.socker与容器内的/var/run/docker.socker连接。 3、访问 192.168.31.88:9000 第一次需要初始化密码，账号是admin 单机版这里选择local即可，选择完毕，点击Connect即可连接到本地docker： 注意：该页面上有提示需要挂载本地 /var/run/docker.socker与容器内的/var/run/docker.socker连接。因此，在启动时必须指定该挂载文件。 添加Endpoints上面安装后只是添加了本地的docker对应的Endpoints，现在添加一个其他服务器B的docker。 服务器B的ip 192.168.31.101 docker配置文件为/etc/docker/daemon.json 12345678910111213141516insecure-registries：私有镜像仓库&quot;insecure-registries&quot;:[&quot;ip:端口&quot;,&quot;ip:端口&quot;,]registry-mirrors：镜像加速地址，一般改为国内的&quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;] Docker 官方中国区: https://registry.docker-cn.com网易: http://hub-mirror.c.163.com中科大: https://docker.mirrors.ustc.edu.cn &quot;registry-mirrors&quot; : [ &quot;http://ovfftd6p.mirror.aliyuncs.com&quot;, &quot;http://registry.docker-cn.com&quot;, &quot;http://docker.mirrors.ustc.edu.cn&quot;, &quot;http://hub-mirror.c.163.com&quot; ]&quot;hosts&quot;: [&quot;tcp://0.0.0.0:2375&quot;, &quot;unix:///var/run/docker.sock&quot;] 1、配置Docker主机，允许远程连接 1&#123;&quot;hosts&quot;: [&quot;tcp://0.0.0.0:2375&quot;, &quot;unix:///var/run/docker.sock&quot;]&#125; 或者 编辑docker.service123vim /usr/lib/systemd/system/docker.service找到 ExecStart字段修改如下ExecStart=/usr/bin/dockerd-current -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock 重启docker重新读取配置文件，重新启动docker服务12systemctl daemon-reloadsystemctl restart docker 2、重启docker引擎，使配置生效 12systemctl daemon-reload systemctl restart docker 3、Portainer添加endpoints 添加完后。 文章转载： https://www.cnblogs.com/wudequn/p/13419922.html","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"},{"name":"技术笔记","slug":"默认分类/技术笔记","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://jlynet.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"shell","slug":"shell","permalink":"https://jlynet.github.io/tags/shell/"},{"name":"linux","slug":"linux","permalink":"https://jlynet.github.io/tags/linux/"},{"name":"docker","slug":"docker","permalink":"https://jlynet.github.io/tags/docker/"},{"name":"随笔","slug":"随笔","permalink":"https://jlynet.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Docker 私有仓库搭建","slug":"Docker-私有仓库搭建","date":"2021-10-09T04:01:07.000Z","updated":"2021-10-09T21:51:10.000Z","comments":true,"path":"2021/10/09/Docker-私有仓库搭建/","link":"","permalink":"https://jlynet.github.io/2021/10/09/Docker-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/","excerpt":"","text":"一、简介 二、registry 的搭建 1. 搭建 2. 验证 二、harbor 的搭建 1.搭建 下载 配置 2. 使用 3. 上传镜像 一、简介在 Docker 中，当我们执行 docker pull xxx 的时候 ，它实际上是从 registry.hub.docker.com 这个地址去查找，这就是Docker公司为我们提供的公共仓库。在工作中，我们不可能把企业项目push到公有仓库进行管理。所以为了更好的管理镜像，Docker不仅提供了一个中央仓库，同时也允许我们搭建本地私有仓库。这一篇介绍registry、harbor两种私有仓库搭建。 二、registry 的搭建1. 搭建Docker 官方提供了一个搭建私有仓库的镜像 registry ，只需把镜像下载下来，运行容器并暴露5000端口，就可以使用了。 12docker pull registry:2docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 --name myregistry registry:2 Registry服务默认会将上传的镜像保存在容器的/var/lib/registry，我们将主机的/opt/registry目录挂载到该目录，即可实现将镜像保存到主机的/opt/registry目录了。 浏览器访问http://127.0.0.1:5000/v2，出现下面情况说明registry运行正常。 2. 验证现在通过push镜像到registry来验证一下。 查看本地镜像： 12345$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx latest 568c4670fa80 5 weeks ago 109MBubuntu latest 93fd78260bd1 7 weeks ago 86.2MBelasticsearch 6.5.1 32f93c89076d 7 weeks ago 773MB 要通过docker tag将该镜像标志为要推送到私有仓库： 1docker tag nginx:latest localhost:5000/nginx:latest 通过 docker push 命令将 nginx 镜像 push到私有仓库中： 1docker push localhost:5000/nginx:latest 访问 http://127.0.0.1:5000/v2/_catalog 查看私有仓库目录，可以看到刚上传的镜像了： 下载私有仓库的镜像，使用如下命令： 123docker pull localhost:5000/镜像名:版本号例如docker pull localhost:5000/nginx:latest 二、harbor 的搭建docker 官方提供的私有仓库 registry，用起来虽然简单 ，但在管理的功能上存在不足。 Harbor是一个用于存储和分发Docker镜像的企业级Registry服务器，harbor使用的是官方的docker registry(v2命名是distribution)服务去完成。harbor在docker distribution的基础上增加了一些安全、访问控制、管理的功能以满足企业对于镜像仓库的需求。 1.搭建下载地址：https://github.com/goharbor/harbor/releases 本文是有 v1.2.2 配置解压下载的安装包 harbor-offline-installer-v1.2.2.tgz 1tar -xvf harbor-offline-installer-v1.2.2.tgz 修改 harbor.cfg 1234#hostname 改为本地ip，非 Mac OS系统 可以不指定端口hostname = 192.168.31.143:9090#设置secretkey_path 的路径为 当前目录的data下secretkey_path = ./data 需要注意的是，非 Mac 用户只需要 修改 harbor.cfg 中的 hostname ，就可以直接通过./install.sh 就可以构建镜像，并把服务启动起来。不需要 secretkey_path 和 下面 docker-compose.yml 的修改 修改 docker-compose.yml 因为harbor使用了很多目录挂载，Mac有很多目录是不允许挂载的，所以如果是Mac用户，需要修改docker-compose.yml 中的挂载目录，修改后的 docker-compose.yml 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136version: &#x27;2&#x27;services: log: image: vmware/harbor-log:v1.2.2 container_name: harbor-log restart: always volumes: - ./log/:/var/log/docker/:z ports: - 127.0.0.1:1514:514 networks: - harbor registry: image: vmware/registry:2.6.2-photon container_name: registry restart: always volumes: - ./data/registry:/storage:z - ./common/config/registry/:/etc/registry/:z networks: - harbor environment: - GODEBUG=netdns=cgo command: [&quot;serve&quot;, &quot;/etc/registry/config.yml&quot;] depends_on: - log logging: driver: &quot;syslog&quot; options: syslog-address: &quot;tcp://127.0.0.1:1514&quot; tag: &quot;registry&quot; mysql: image: vmware/harbor-db:v1.2.2 container_name: harbor-db restart: always volumes: - ./data/database:/var/lib/mysql:z networks: - harbor env_file: - ./common/config/db/env depends_on: - log logging: driver: &quot;syslog&quot; options: syslog-address: &quot;tcp://127.0.0.1:1514&quot; tag: &quot;mysql&quot; adminserver: image: vmware/harbor-adminserver:v1.2.2 container_name: harbor-adminserver env_file: - ./common/config/adminserver/env restart: always volumes: - ./data/config/:/etc/adminserver/config/:z - ./data/secretkey:/etc/adminserver/key:z - ./data/:/data/:z networks: - harbor depends_on: - log logging: driver: &quot;syslog&quot; options: syslog-address: &quot;tcp://127.0.0.1:1514&quot; tag: &quot;adminserver&quot; ui: image: vmware/harbor-ui:v1.2.2 container_name: harbor-ui env_file: - ./common/config/ui/env restart: always volumes: - ./common/config/ui/app.conf:/etc/ui/app.conf:z - ./common/config/ui/private_key.pem:/etc/ui/private_key.pem:z - ./data/secretkey:/etc/ui/key:z - ./data/ca_download/:/etc/ui/ca/:z - ./data/psc/:/etc/ui/token/:z networks: - harbor depends_on: - log - adminserver - registry logging: driver: &quot;syslog&quot; options: syslog-address: &quot;tcp://127.0.0.1:1514&quot; tag: &quot;ui&quot; jobservice: image: vmware/harbor-jobservice:v1.2.2 container_name: harbor-jobservice env_file: - ./common/config/jobservice/env restart: always volumes: - ./data/job_logs:/var/log/jobs:z - ./common/config/jobservice/app.conf:/etc/jobservice/app.conf:z - ./data/secretkey:/etc/jobservice/key:z networks: - harbor depends_on: - ui - adminserver logging: driver: &quot;syslog&quot; options: syslog-address: &quot;tcp://127.0.0.1:1514&quot; tag: &quot;jobservice&quot; proxy: image: vmware/nginx-photon:1.11.13 container_name: nginx restart: always volumes: - ./common/config/nginx:/etc/nginx:z networks: - harbor ports: - 9090:80 - 443:443 - 4443:4443 depends_on: - mysql - registry - ui - log logging: driver: &quot;syslog&quot; options: syslog-address: &quot;tcp://127.0.0.1:1514&quot; tag: &quot;proxy&quot;networks: harbor: external: false 通过运行 install.sh 构建镜像，并把服务启动起来： 1./install.sh 2. 使用访问 http://127.0.0.1:9090/ 如下： 默认 admin 用户的密码为 Harbor12345 ，可以在 harbor.cfg 进行修改。登录后如下： 图中的项目是之前上传的 ，新部署的 Harbor 登录后项目下是空的。 可以创建项目，创建用户，给项目分配用户等等，操作都很简单 。 3. 上传镜像首先登录私有仓库，可以使用 admin 用户 ，也可以使用我们自己创建的具有上传权限的用户： 1docker login -u admin -p Harbor12345 127.0.0.1:9090 要通过docker tag将该镜像标志为要推送到私有仓库，例如： 1docker tag nginx:latest 127.0.0.1:9090/library/nginx:latest 上传镜像： 1docker push 127.0.0.1:9090/library/nginx:latest 访问 http://127.0.0.1:9090/harbor/projects ，在 library 项目下可以看见刚上传的 nginx镜像了： 文章转载： https://www.cnblogs.com/huanchupkblog/p/10843800.html","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"},{"name":"技术笔记","slug":"默认分类/技术笔记","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://jlynet.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"shell","slug":"shell","permalink":"https://jlynet.github.io/tags/shell/"},{"name":"linux","slug":"linux","permalink":"https://jlynet.github.io/tags/linux/"},{"name":"docker","slug":"docker","permalink":"https://jlynet.github.io/tags/docker/"},{"name":"随笔","slug":"随笔","permalink":"https://jlynet.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"etCache 缓存框架的使用以及源码分析","slug":"etCache-缓存框架的使用以及源码分析","date":"2021-10-01T02:41:48.000Z","updated":"2021-10-01T02:54:00.000Z","comments":true,"path":"2021/10/01/etCache-缓存框架的使用以及源码分析/","link":"","permalink":"https://jlynet.github.io/2021/10/01/etCache-%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"一、简介 为什么使用缓存？ 使用场景 使用规范 二、如何使用 引入maven依赖 添加配置 配置说明 注解说明 @EnableCreateCacheAnnotation @EnableMethodCache @Cached @CacheInvalidate @CacheUpdate @CacheRefresh @CachePenetrationProtect @CreateCache 使用示例 三、源码解析 项目的各个子模块 常用注解与变量 缓存API Cache接口 AbstractCache抽象类 AbstractEmbeddedCache本地缓存 LinkedHashMapCache Cleaner清理器 CaffeineCache AbstractExternalCache远程缓存 RedisCache RedisLettuceCache MultiLevelCache两级缓存 RefreshCache 解析配置 初始化构造器 AbstractCacheAutoInit EmbeddedCacheAutoInit LinkedHashMapAutoConfiguration CaffeineAutoConfiguration ExternalCacheAutoInit RedisAutoInit RedisLettuceAutoInit JetCacheAutoConfiguration自动配置 CacheBuilder构造器 AOP 启用JetCache @EnableMethodCache @EnableCreateCacheAnnotation 拦截器 ConfigProvider CacheContext JetCacheInterceptor CacheHandler 一、简介JetCache是一个基于Java的缓存系统封装，提供统一的API和注解来简化缓存的使用。 JetCache提供了比SpringCache更加强大的注解，可以原生的支持TTL、两级缓存、分布式自动刷新，还提供了Cache接口用于手工缓存操作。 当前有四个实现：RedisCache、RedisLettuceCache、CaffeineCache、LinkedHashMapCache。 特性： 通过统一的API访问Cache系统 通过注解实现声明式的方法缓存，支持TTL和两级缓存 通过注解创建并配置Cache实例 针对所有Cache实例和方法缓存的自动统计 Key的生成策略和Value的序列化策略支持自定义配置 分布式缓存自动刷新，分布式锁 异步Cache API (使用Redis的Lettuce客户端时) 缓存类型： 本地 LinkedHashMap：使用LinkedHashMap做LUR方式淘汰Caffeine：基于Java8开发的提供了近乎最佳命中率的高性能的缓存库 远程（访问Redis的客户端） Redis：使用Jedis客户端，Redis官方首选的Java客户端RedisSpringData：使用SpringData访问Redis（官网未作介绍）RedisLettuce：使用Lettuce客户端，一个高性能基于Java的Redis驱动框架，支持线程安全的同步、异步操作，底层集成了Project Reactor，提供反应式编程，参考：Redis高级客户端Lettuce详解 为什么使用缓存？在高并发、大流量等场景下，降低系统延迟，缓解数据库压力，提高系统整体的性能，让用户有更好的体验。 使用场景读多写少、不追求强一致性、请求入参不易变化 使用规范选择了远程缓存请设置keyPrefix，保证存放至Redis的缓存key规范化，避免与其他系统出现冲突，例如这样设计：系统简称:所属名字:，这样存储到Redis的缓存key为：系统简称:所属名字:缓存key 选择了本地缓存请设置limit，全局默认设置了100，本地缓存的数据存放于内存，减轻内存的损耗，如果使用了Caffeine，缓存的key过多可能导致内存溢出 请勿滥用缓存注解，对于非必要添加缓存的方法我们尽量不使用缓存 二、如何使用说明：以下使用方式是基于SpringBoot引入JetCache缓存框架的，如果不是SpringBoot工程，请参考JetCache官网使用 引入maven依赖1234567891011121314&lt;dependencies&gt; &lt;!-- 使用 jedis 客户端添加以下依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alicp.jetcache&lt;/groupId&gt; &lt;artifactId&gt;jetcache-starter-redis&lt;/artifactId&gt; &lt;version&gt;$&#123;version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 使用 lettuce 客户端添加以下依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alicp.jetcache&lt;/groupId&gt; &lt;artifactId&gt;jetcache-starter-redis-lettuce&lt;/artifactId&gt; &lt;version&gt;$&#123;version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 添加配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849jetcache: statIntervalMinutes: 60 areaInCacheName: false penetrationProtect: false enableMethodCache: true hiddenPackages: com.xxx.xxx,com.xxx.xxx local: default: type: caffeine # 支持的类型：linkedhashmap、caffeine limit: 100 keyConvertor: fastjson # 支持的类型：fastjson，可自定义转换器函数 expireAfterWriteInMillis: 600000 expireAfterAccessInMillis: 300000 remote: default: type: redis.lettuce # 支持的类型：redis、redis.lettuce keyPrefix: &#x27;系统简称:所属名字:&#x27; keyConvertor: fastjson valueEncoder: java # 支持的类型：kryo、java，可自定义编码器 valueDecoder: java # 支持的类型：kryo、java，可自定义解码器 expireAfterWriteInMillis: 3600000 #readFrom: slavePreferred # 优先从Slave节点中读取 uri: redis-sentinel://host1:26379,host2:26379,host3:26379/?sentinelMasterId=mymaster # 哨兵模式 #uri: redis://127.0.0.1:6379/ # 单节点模式 #mode: masterslave # 设置为主从模式 #uri: # 集群模式 #- redis://127.0.0.1:7000 #- redis://127.0.0.1:7001 #- redis://127.0.0.1:7002 example: keyPrefix: &#x27;系统简称:所属名字:&#x27; type: redis keyConvertor: fastjson valueEncoder: java valueDecoder: java expireAfterWriteInMillis: 3600000 poolConfig: minIdle: 10 maxIdle: 20 maxTotal: 50 #password: xxx # 连接密码 #timeout: 2000 # 连接的超时时间，读取数据的超时时间 #database: 0 # 连接的数据库 #clientName: null # 客户端名称 #ssl: 是否使用SSL host: $&#123;redis.host&#125; port: $&#123;redis.port&#125; #sentinel: host1:26379,host2:26379,host3:26379 # 哨兵模式 #masterName: mymaster 配置说明jetcache的全局配置 属性 默认值 说明 jetcache.statIntervalMinutes 0 用于统计缓存调用相关信息的统计间隔（分钟），0表示不统计。 jetcache.areaInCacheName true 缓存实例名称cacheName会作为缓存key的前缀，2.4.3以前的版本总是把areaName加在cacheName中，因此areaName也出现在key前缀中。我们一般设置为false。 jetcache.penetrationProtect false 当缓存访问未命中的情况下，对并发进行的加载行为进行保护。 当前版本实现的是单JVM内的保护，即同一个JVM中同一个key只有一个线程去加载，其它线程等待结果。这是全局配置，如果缓存实例没有指定则使用全局配置。 jetcache.enableMethodCache true 是否使用jetcache缓存。 jetcache.hiddenPackages 无 自动生成缓存实例名称时，为了不让名称太长，hiddenPackages指定的包名前缀会被截掉，多个包名使用逗号分隔。我们一般会指定每个缓存实例的名称。 本地缓存的全局配置 属性 默认值 说明 jetcache.local.${area}.type 无 本地缓存类型，支持 linkedhashmap、caffeine。 jetcache.local.${area}.limit 100 每个缓存实例存储的缓存数量的全局配置，仅本地缓存需要配置，如果缓存实例没有指定则使用全局配置，请结合实例的业务场景进行配置该参数。 jetcache.local.${area}.keyConvertor 无 缓存key转换器的全局配置，支持的类型：fastjson。仅当使用@CreateCache且缓存类型为LOCAL时可以指定为none，此时通过equals方法来识别key。方法缓存必须指定keyConvertor。支持自定义转换器函数，可设置为：bean:beanName，然后会从spring容器中获取该bean。 jetcache.local.${area}.expireAfterWriteInMillis 无穷大 本地缓存超时时间的全局配置（毫秒）。 jetcache.local.${area}.expireAfterAccessInMillis 0 多长时间没访问就让缓存失效的全局配置（毫秒），仅支持本地缓存。0表示不使用这个功能。 远程缓存的全局配置 属性 默认值 说明 jetcache.remote.${area}.type 无 连接Redis的客户端类型，支持 redis、redis.lettuce、redis.springdata。 jetcache.remote.${area}.keyPrefix 无 保存至远程缓存key的前缀，请规范使用。 jetcache.remote.${area}.keyConvertor 无 参考上述说明。 jetcache.remote.${area}.valueEncoder java 保存至远程缓存value的编码函数，支持：java、kryo。支持自定义编码函数，可设置为：bean:beanName，然后会从spring容器中获取该bean。 jetcache.remote.${area}.valueDecoder java 保存至远程缓存value的解码函数，支持：java、kryo。支持自定义解码函数，可设置为：bean:beanName，然后会从spring容器中获取该bean。 jetcache.remote.${area}.expireAfterWriteInMillis 无穷大 远程缓存超时时间的全局配置（毫秒）。 jetcache.remote.${area}.uri 无 redis节点信息。 上表中${area}对应@Cached和@CreateCache的area属性，如果注解上没有指定area，默认值是”default”。 关于缓存的超时时间： put等方法上指定了超时时间，则以此时间为准； put等方法上未指定超时时间，使用Cache实例的默认超时时间； Cache实例的默认超时时间，通过在@CreateCache和@Cached上的expire属性指定，如果没有指定，使用yml中定义的全局配置，例如@Cached(cacheType=local)使用jetcache.local.default.expireAfterWriteInMillis，如果仍未指定则是无穷大。 注解说明如果需要使用jetcache缓存，启动类添加两个注解：@EnableCreateCacheAnnotation、@EnableMethodCache @EnableCreateCacheAnnotation开启可通过@CreateCache注解创建Cache实例功能。 @EnableMethodCache开启可通过@Cached注解创建Cache实例功能，初始化spring aop，注解说明： 属性 默认值 说明 basePackages 无 jetcache需要拦截的包名，只有这些包名下的Cache实例才会生效 order Ordered.LOWEST_PRECEDENCE 指定AOP切面执行过程的顺序，默认最低优先级 mode AdviceMode.PROXY Spring AOP的模式，目前就提供默认值让你修改 proxyTargetClass false 无 @Cached为一个方法添加缓存，创建对应的缓存实例，注解可以添加在接口或者类的方法上面，该类必须是spring bean，注解说明： 属性 默认值 说明 area “default” 如果在配置中配置了多个缓存area，在这里指定使用哪个area。 name 未定义 指定缓存实例名称，如果没有指定，会根据类名+方法名自动生成。name会被用于远程缓存的key前缀。另外在统计中，一个简短有意义的名字会提高可读性。 enabled true 是否激活缓存。 timeUnit TimeUnit.SECONDS 指定expire的单位。 expire 未定义 超时时间。如果注解上没有定义，会使用全局配置，如果此时全局配置也没有定义，则为无穷大。 localExpire 未定义 仅当cacheType为BOTH时适用，为本地缓存指定一个不一样的超时时间，通常应该小于expire。如果没有设置localExpire且cacheType为BOTH，那么本地缓存的超时时间和远程缓存保持一致。 cacheType CacheType.REMOTE 缓存的类型，支持：REMOTE、LOCAL、BOTH，如果定义为BOTH，会使用LOCAL和REMOTE组合成两级缓存。 localLimit 未定义 如果cacheType为LOCAL或BOTH，这个参数指定本地缓存的最大元素数量，以控制内存占用。如果注解上没有定义，会使用全局配置，如果此时你没有定义全局配置，则使用默认的全局配置100。请结合实际业务场景进行设置该值。 serialPolicy 未定义 指定远程缓存VALUE的序列化方式，支持SerialPolicy.JAVA、SerialPolicy.KRYO。如果注解上没有定义，会使用全局配置，如果你没有定义全局配置，则使用默认的全局配置SerialPolicy.JAVA。 keyConvertor 未定义 指定KEY的转换方式，用于将复杂的KEY类型转换为缓存实现可以接受的类型，支持：KeyConvertor.FASTJSON、KeyConvertor.NONE。NONE表示不转换，FASTJSON可以将复杂对象KEY转换成String。如果注解上没有定义，会使用全局配置。 key 未定义 使用SpEL指定缓存key，如果没有指定会根据入参自动生成。 cacheNullValue false 当方法返回值为null的时候是否要缓存。 condition 未定义 使用SpEL指定条件，如果表达式返回true的时候才去缓存中查询。 postCondition 未定义 使用SpEL指定条件，如果表达式返回true的时候才更新缓存，该评估在方法执行后进行，因此可以访问到#result。 @CacheInvalidate用于移除缓存，配置说明： 配置 默认值 说明 area “default” 如果在配置中配置了多个缓存area，在这里指定使用哪个area。 name 无 指定缓存的唯一名称，一般指向对应的@Cached定义的name。 key 未定义 使用SpEL指定key，如果没有指定会根据入参自动生成。 condition 未定义 使用SpEL指定条件，如果表达式返回true才执行删除，可访问方法结果#result。删除缓存实例中key的元素。 multi false 如果根据SpEL指定的key是一个集合，是否从缓存实例中删除对应的每个缓存。如果设置为true，但是key不是集合，则不会删除缓存。 @CacheUpdate用于更新缓存，配置说明： 配置 默认值 说明 area “default” 如果在配置中配置了多个缓存area，在这里指定使用哪个area。 name 无 指定缓存的唯一名称，一般指向对应的@Cached定义的name。 key 未定义 使用SpEL指定key，如果没有指定会根据入参自动生成。 value 无 使用SpEL指定value。 condition 未定义 使用SpEL指定条件，如果表达式返回true才执行更新，可访问方法结果#result。更新缓存实例中key的元素。 multi false 如果根据SpEL指定key和value都是集合并且元素的个数相同，则是否更新缓存实例中的对应的每个元素。如果设置为true，但是key不是集合或者value不是集合或者它们的元素的个数不相同，也不会更新缓存。 @CacheRefresh用于自定刷新缓存，配置说明： 配置 默认值 说明 refresh 无 刷新间隔 stopRefreshAfterLastAccess 未定义 指定该key多长时间没有访问就停止刷新，如果不指定会一直刷新。 refreshLockTimeout 60秒 类型为BOTH/REMOTE的缓存刷新时，同时只会有一台服务器在刷新，这台服务器会在远程缓存放置一个分布式锁，此配置指定该锁的超时时间。 timeUnit TimeUnit.SECONDS 指定refresh时间单位。 @CachePenetrationProtect当缓存访问未命中的情况下，对并发进行的加载行为进行保护。 当前版本实现的是单JVM内的保护，即同一个JVM中同一个key只有一个线程去加载，其它线程等待结果，配置说明： 配置 默认值 说明 value true 是否开启保护模式。 timeout 未定义 其他线程的等待超时时间，如果超时则自己执行方法直接返回结果。 timeUnit TimeUnit.SECONDS 指定timeout时间单位。 @CreateCache在Spring Bean中使用该注解可创建一个Cache实例，配置说明： 配置 默认值 说明 area “default” 如果在配置中配置了多个缓存area，在这里指定使用哪个area。 name 未定义 指定缓存实例名称，如果没有指定，会根据类名+方法名自动生成。name会被用于远程缓存的key前缀。另外在统计中，一个简短有意义的名字会提高可读性。 timeUnit TimeUnit.SECONDS 指定expire的单位。 expire 未定义 超时时间。如果注解上没有定义，会使用全局配置，如果此时全局配置也没有定义，则为无穷大。 localExpire 未定义 仅当cacheType为BOTH时适用，为本地缓存指定一个不一样的超时时间，通常应该小于expire。如果没有设置localExpire且cacheType为BOTH，那么本地缓存的超时时间和远程缓存保持一致。 cacheType CacheType.REMOTE 缓存的类型，支持：REMOTE、LOCAL、BOTH，如果定义为BOTH，会使用LOCAL和REMOTE组合成两级缓存。 localLimit 未定义 如果cacheType为LOCAL或BOTH，这个参数指定本地缓存的最大元素数量，以控制内存占用。如果注解上没有定义，会使用全局配置，如果此时你没有定义全局配置，则使用默认的全局配置100。请结合实际业务场景进行设置该值。 serialPolicy 未定义 指定远程缓存VALUE的序列化方式，支持SerialPolicy.JAVA、SerialPolicy.KRYO。如果注解上没有定义，会使用全局配置，如果你没有定义全局配置，则使用默认的全局配置SerialPolicy.JAVA。 keyConvertor 未定义 指定KEY的转换方式，用于将复杂的KEY类型转换为缓存实现可以接受的类型，支持：KeyConvertor.FASTJSON、KeyConvertor.NONE。NONE表示不转换，FASTJSON可以将复杂对象KEY转换成String。如果注解上没有定义，会使用全局配置。 使用示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 启动类 */@SpringBootApplication@EnableCreateCacheAnnotation@EnableMethodCache(basePackages = &quot;com.xxx.xxx&quot;)public class Application &#123; public static void main(String[] args)&#123; SpringApplication.run(Application.class, args); &#125;&#125;/** * 接口 */public interface JetCacheExampleService &#123; User getValue(long userId); void updateValue(User user); void deleteValue(User user);&#125;/** * 实现类 */@Servicepublic class JetCacheExampleServiceImpl implements JetCacheExampleService &#123; @CreateCache(name = &quot;JetCacheExampleServiceImpl.exampleCache&quot; , localLimit = 50 ,cacheType = CacheType.LOCAL) @CachePenetrationProtect private Cache&lt;Long, User&gt; exampleCache; @Override @Cached(name = &quot;JetCacheExampleService.getValue&quot;, expire = 3600 * 6, localLimit = 50, cacheType = CacheType.BOTH) @CacheRefresh(refresh = 3600, stopRefreshAfterLastAccess = 3600 * 2) @CachePenetrationProtect public User getValue(long userId)&#123; String result = new User(); // ... 处理逻辑 return result; &#125; @Override @CacheUpdate(name = &quot;JetCacheExampleService.getValue&quot;, key=&quot;#user.userId&quot;, value=&quot;#user&quot;) public void updateValue(User user)&#123; // 处理逻辑 &#125; @Override @CacheInvalidate(name = &quot;JetCacheExampleService.getValue&quot;, key=&quot;#user.userId&quot;) public void deleteValue(User user)&#123; // 处理逻辑 &#125; &#125; 如上述所示 getValue方法会创建一个缓存实例，通过@Cached注解可以看到缓存实例名称cacheName为’JetCacheExampleService.getValue’，缓存的有效时长为6小时，本地缓存的数量最多为50，缓存类型为BOTH（优先从本地缓存获取）；通过@CacheRefresh注解可以看到会为该缓存实例设置一个刷新策略，刷新间隔为1小时，2个小时没访问后不再刷新，需要刷新的缓存实例会为其每一个缓存数据创建一个RefreshTask周期性任务；@CachePenetrationProtect注解表示该缓存实例开启保护模式，当缓存未命中，同一个JVM中同一个key只有一个线程去加载数据，其它线程等待结果。 updateValue方法可以更新缓存，通过@CacheUpdate注解可以看到会更新缓存实例’JetCacheExampleService.getValue’中缓存key为#user.userId的缓存value为#user。 deleteValue方法可以删除缓存，通过@CacheInvalidate注解可以看到会删除缓存实例’JetCacheExampleService.getValue’中缓存key为#user.userId缓存数据。 exampleCache字段会作为一个缓存实例对象，通过@CreateCache注解可以看到，会将该字段作为cacheName为’JetCacheExampleService.getValue’缓存实例对象，本地缓存的数量最多为50，缓存类型为LOCAL，@CachePenetrationProtect注解表示该缓存实例开启保护模式。 我的业务场景是使用上述的getValue方法创建缓存实例即可。 注意： @Cached注解不能和@CacheUpdate或者@CacheInvalidate同时使用 @CacheInvalidate可以多个同时使用 另外通过@CreateCache注解创建缓存实例也可以这样初始化： 1234567891011121314@Servicepublic class JetCacheExampleServiceImpl implements JetCacheExampleService &#123; @CreateCache(name = &quot;JetCacheExampleServiceImpl.exampleCache&quot; , localLimit = 50 ,cacheType = CacheType.LOCAL) private Cache&lt;Long, User&gt; exampleCache; @PostConstruct public exampleCacheInit()&#123; RefreshPolicy policy = RefreshPolicy.newPolicy(60, TimeUnit.MINUTES) .stopRefreshAfterLastAccess(120, TimeUnit.MINUTES); exampleCache.config().setLoader(this::loadFromDatabase); exampleCache.config().setRefreshPolicy(policy); &#125;&#125; 更加详细的使用方法请参考JetCache官方地址。 三、源码解析参考本人Git仓库中的JetCache项目，已做详细的注释。 简单概括：利用Spring AOP功能，在调用需要缓存的方法前，通过解析注解获取缓存配置，根据这些配置创建不同的实例对象，进行缓存等操作。 JetCache分为两部分，一部分是Cache API以及实现，另一部分是注解支持。 项目的各个子模块 jetcache-anno-api：定义JetCache注解和常量。 jetcache-core：核心API，Cache接口的实现，提供各种缓存实例的操作，不依赖于Spring。 jetcache-autoconfigure：完成初始化，解析application.yml配置文件中的相关配置，以提供不同缓存实例的CacheBuilder构造器 jetcache-anno：基于Spring提供@Cached和@CreateCache注解支持，初始化Spring AOP以及JetCache注解等配置。 jetcache-redis：使用Jedis提供Redis支持。 jetcache-redis-lettuce：使用Lettuce提供Redis支持，实现了JetCache异步访问缓存的的接口。 jetcache-redis-springdata：使用Spring Data提供Redis支持。 jetcache-starter-redis：提供pom文件，Spring Boot方式的Starter，基于Jedis。 jetcache-starter-redis-lettuce：提供pom文件，Spring Boot方式的Starter，基于Lettuce。 jetcache-starter-redis-springdata：提供pom文件，Spring Boot方式的Starter，基于Spring Data。 jetcache-test：提供相关测试。 常用注解与变量 在jetcache-anno-api模块中定义了需要用的缓存注解与常量，在上述已经详细的讲述过，其中@CacheInvalidateContainer注解定义value为@CacheInvalidate数组，然后通过jdk8新增的@Repeatable注解，在@CacheInvalidate注解上面添加@Repeatable(CacheInvalidateContainer.class)，即可支持同一个地方可以使用多个@CacheInvalidate注解。 缓存API主要查看jetcache-core子模块，提供各种Cache缓存，以支持不同的缓存类型 Cache接口的子关系，结构如下图： 主要对象描述： Cache：缓存接口，定义基本方法 AbstractCache：抽象类，缓存接口的继承者，提供基本实现，具体实现交由不同的子类 LinkedHashMapCache：基于LinkedHashMap设计的简易内存缓存 CaffeineCache：基于Caffeine工具设计的内存缓存 RedisCache：Redis实现，使用Jedis客户端 RedisLettuceCache：Redis实现，使用Lettuce客户端 MultiLevelCache：两级缓存，用于封装EmbeddedCache（本地缓存）和ExternalCache（远程缓存） RefreshCache：基于装饰器模式Decorator，提供自动刷新功能 LazyInitCache：用于@CreateCache注解创建的缓存实例，依赖于Spring Cache接口com.alicp.jetcache.Cache接口，定义了缓存实例的操作方法（部分有默认实现），以及获取分布式锁（非严格，用于刷新远程缓存）的实现，因为继承了java.io.Closeable接口，所以也提供了close方法的默认实现，空方法，交由不同缓存实例的实现去实现该方法用于释放资源，在com.alicp.jetcache.anno.support.ConfigProvider.doShutdown()方法中会调用每个缓存实例对象的close方法进行资源释放。主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187public interface Cache&lt;K, V&gt; extends Closeable &#123; Logger logger = LoggerFactory.getLogger(Cache.class); //-----------------------------JSR 107 style API------------------------------------------------ default V get(K key) throws CacheInvokeException &#123; CacheGetResult&lt;V&gt; result = GET(key); if (result.isSuccess()) &#123; return result.getValue(); &#125; else &#123; return null; &#125; &#125; default Map&lt;K, V&gt; getAll(Set&lt;? extends K&gt; keys) throws CacheInvokeException &#123; MultiGetResult&lt;K, V&gt; cacheGetResults = GET_ALL(keys); return cacheGetResults.unwrapValues(); &#125; default void put(K key, V value) &#123; PUT(key, value); &#125; default void putAll(Map&lt;? extends K, ? extends V&gt; map) &#123; PUT_ALL(map); &#125; default boolean putIfAbsent(K key, V value) &#123; // 多级缓存MultiLevelCache不支持此方法 CacheResult result = PUT_IF_ABSENT(key, value, config().getExpireAfterWriteInMillis(), TimeUnit.MILLISECONDS); return result.getResultCode() == CacheResultCode.SUCCESS; &#125; default boolean remove(K key) &#123; return REMOVE(key).isSuccess(); &#125; default void removeAll(Set&lt;? extends K&gt; keys) &#123; REMOVE_ALL(keys); &#125; &lt;T&gt; T unwrap(Class&lt;T&gt; clazz); @Override default void close() &#123; &#125; //--------------------------JetCache API--------------------------------------------- CacheConfig&lt;K, V&gt; config(); default AutoReleaseLock tryLock(K key, long expire, TimeUnit timeUnit) &#123; if (key == null) &#123; return null; &#125; // 随机生成一个值 final String uuid = UUID.randomUUID().toString(); // 过期时间 final long expireTimestamp = System.currentTimeMillis() + timeUnit.toMillis(expire); final CacheConfig config = config(); AutoReleaseLock lock = () -&gt; &#123; // 创建一把会自动释放资源的锁，实现其 close() 方法 int unlockCount = 0; while (unlockCount++ &lt; config.getTryLockUnlockCount()) &#123; if(System.currentTimeMillis() &lt; expireTimestamp) &#123; // 这把锁还没有过期，则删除 // 删除对应的 Key 值 // 出现的结果：成功，失败，Key 不存在 CacheResult unlockResult = REMOVE(key); if (unlockResult.getResultCode() == CacheResultCode.FAIL || unlockResult.getResultCode() == CacheResultCode.PART_SUCCESS) &#123; // 删除对应的 Key 值过程中出现了异常，则重试 logger.info(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] unlock failed. Key=&#123;&#125;, msg = &#123;&#125;&quot;, unlockCount, config.getTryLockUnlockCount(), uuid, key, unlockResult.getMessage()); // retry &#125; else if (unlockResult.isSuccess()) &#123; // 释放成功 logger.debug(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] successfully release the lock. Key=&#123;&#125;&quot;, unlockCount, config.getTryLockUnlockCount(), uuid, key); return; &#125; else &#123; // 锁已经被释放了 logger.warn(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] unexpected unlock result: Key=&#123;&#125;, result=&#123;&#125;&quot;, unlockCount, config.getTryLockUnlockCount(), uuid, key, unlockResult.getResultCode()); return; &#125; &#125; else &#123; // 该锁已失效 logger.info(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] lock already expired: Key=&#123;&#125;&quot;, unlockCount, config.getTryLockUnlockCount(), uuid, key); return; &#125; &#125; &#125;; int lockCount = 0; Cache cache = this; while (lockCount++ &lt; config.getTryLockLockCount()) &#123; // 往 Redis（或者本地） 中存放 Key 值（_#RL#结尾的Key） // 返回的结果：成功、已存在、失败 CacheResult lockResult = cache.PUT_IF_ABSENT(key, uuid, expire, timeUnit); if (lockResult.isSuccess()) &#123; // 成功获取到锁 logger.debug(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] successfully get a lock. Key=&#123;&#125;&quot;, lockCount, config.getTryLockLockCount(), uuid, key); return lock; &#125; else if (lockResult.getResultCode() == CacheResultCode.FAIL || lockResult.getResultCode() == CacheResultCode.PART_SUCCESS) &#123; logger.info(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] cache access failed during get lock, will inquiry &#123;&#125; times. Key=&#123;&#125;, msg=&#123;&#125;&quot;, lockCount, config.getTryLockLockCount(), uuid, config.getTryLockInquiryCount(), key, lockResult.getMessage()); // 尝试获取锁的过程中失败了，也就是往 Redis 中存放 Key 值出现异常 // 这个时候可能 Key 值已经存储了，但是由于其他原因导致返回的结果表示执行失败 int inquiryCount = 0; while (inquiryCount++ &lt; config.getTryLockInquiryCount()) &#123; CacheGetResult inquiryResult = cache.GET(key); if (inquiryResult.isSuccess()) &#123; if (uuid.equals(inquiryResult.getValue())) &#123; logger.debug(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] successfully get a lock after inquiry. Key=&#123;&#125;&quot;, inquiryCount, config.getTryLockInquiryCount(), uuid, key); return lock; &#125; else &#123; logger.debug(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] not the owner of the lock, return null. Key=&#123;&#125;&quot;, inquiryCount, config.getTryLockInquiryCount(), uuid, key); return null; &#125; &#125; else &#123; logger.info(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] inquiry failed. Key=&#123;&#125;, msg=&#123;&#125;&quot;, inquiryCount, config.getTryLockInquiryCount(), uuid, key, inquiryResult.getMessage()); // retry inquiry &#125; &#125; &#125; else &#123; // 已存在表示该锁被其他人占有 // others holds the lock logger.debug(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] others holds the lock, return null. Key=&#123;&#125;&quot;, lockCount, config.getTryLockLockCount(), uuid, key); return null; &#125; &#125; logger.debug(&quot;[tryLock] [&#123;&#125;] return null after &#123;&#125; attempts. Key=&#123;&#125;&quot;, uuid, config.getTryLockLockCount(), key); return null; &#125; default boolean tryLockAndRun(K key, long expire, TimeUnit timeUnit, Runnable action)&#123; // Release the lock use Java 7 try-with-resources. try (AutoReleaseLock lock = tryLock(key, expire, timeUnit)) &#123; // 尝试获取锁 if (lock != null) &#123; // 获取到锁则执行下面的任务 action.run(); return true; &#125; else &#123; return false; &#125; // 执行完锁的操作后会进行资源释放，调用 AutoCloseable 的 close() 方法 &#125; &#125; CacheGetResult&lt;V&gt; GET(K key); MultiGetResult&lt;K, V&gt; GET_ALL(Set&lt;? extends K&gt; keys); default V computeIfAbsent(K key, Function&lt;K, V&gt; loader) &#123; return computeIfAbsent(key, loader, config().isCacheNullValue()); &#125; V computeIfAbsent(K key, Function&lt;K, V&gt; loader, boolean cacheNullWhenLoaderReturnNull); V computeIfAbsent(K key, Function&lt;K, V&gt; loader, boolean cacheNullWhenLoaderReturnNull, long expireAfterWrite, TimeUnit timeUnit); default void put(K key, V value, long expireAfterWrite, TimeUnit timeUnit) &#123; PUT(key, value, expireAfterWrite, timeUnit); &#125; default CacheResult PUT(K key, V value) &#123; if (key == null) &#123; return CacheResult.FAIL_ILLEGAL_ARGUMENT; &#125; return PUT(key, value, config().getExpireAfterWriteInMillis(), TimeUnit.MILLISECONDS); &#125; CacheResult PUT(K key, V value, long expireAfterWrite, TimeUnit timeUnit); default void putAll(Map&lt;? extends K, ? extends V&gt; map, long expireAfterWrite, TimeUnit timeUnit) &#123; PUT_ALL(map, expireAfterWrite, timeUnit); &#125; default CacheResult PUT_ALL(Map&lt;? extends K, ? extends V&gt; map) &#123; if (map == null) &#123; return CacheResult.FAIL_ILLEGAL_ARGUMENT; &#125; return PUT_ALL(map, config().getExpireAfterWriteInMillis(), TimeUnit.MILLISECONDS); &#125; CacheResult PUT_ALL(Map&lt;? extends K, ? extends V&gt; map, long expireAfterWrite, TimeUnit timeUnit); CacheResult REMOVE(K key); CacheResult REMOVE_ALL(Set&lt;? extends K&gt; keys); CacheResult PUT_IF_ABSENT(K key, V value, long expireAfterWrite, TimeUnit timeUnit);&#125; com.alicp.jetcache.Cache定义的方法大都是关于缓存的获取、删除和存放操作 其中大写的方法返回JetCache自定义的CacheResult（完整的返回值，可以清晰的知道执行结果，例如get返回null的时候，无法断定是对应的key不存在，还是访问缓存发生了异常） 小写的方法默认实现就是调用大写的方法 computeIfAbsent方法最为核心，交由子类去实现 tryLockAndRun方法会非堵塞的尝试获取一把AutoReleaseLock分布式锁（非严格）,获取过程： 尝试往Redis中设置（已存在无法设置）一个键值对，key为缓存key_#RL#，value为UUID，并设置这个键值对的过期时间为60秒（默认） 如果获取到锁后进行加载任务，也就是重新加载方法并更新远程缓存 该锁实现了java.lang.AutoCloseable接口，使用try-with-resource方式，在执行完加载任务后会自动释放资源，也就是调用close方法将获取锁过程中设置的键值对从Redis中删除 在RefreshCache中会调用该方法，因为如果存在远程缓存需要刷新则需要采用分布式锁的方式 AbstractCache抽象类com.alicp.jetcache.AbstractCache抽象类，实现了Cache接口，主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196public abstract class AbstractCache&lt;K, V&gt; implements Cache&lt;K, V&gt; &#123; /** * 当缓存未命中时，并发情况同一个Key是否只允许一个线程去加载，其他线程等待结果（可以设置timeout，超时则自己加载并直接返回） * 如果是的话则由获取到Key对应的 LoaderLock.signal（采用了 CountDownLatch）的线程进行加载 * loaderMap临时保存 Key 对应的 LoaderLock 对象 */ private volatile ConcurrentHashMap&lt;Object, LoaderLock&gt; loaderMap; ConcurrentHashMap&lt;Object, LoaderLock&gt; initOrGetLoaderMap() &#123; if (loaderMap == null) &#123; synchronized (this) &#123; if (loaderMap == null) &#123; loaderMap = new ConcurrentHashMap&lt;&gt;(); &#125; &#125; &#125; return loaderMap; &#125; @Override public final V computeIfAbsent(K key, Function&lt;K, V&gt; loader, boolean cacheNullWhenLoaderReturnNull) &#123; return computeIfAbsentImpl(key, loader, cacheNullWhenLoaderReturnNull, 0, null, this); &#125; @Override public final V computeIfAbsent(K key, Function&lt;K, V&gt; loader, boolean cacheNullWhenLoaderReturnNull, long expireAfterWrite, TimeUnit timeUnit) &#123; return computeIfAbsentImpl(key, loader, cacheNullWhenLoaderReturnNull, expireAfterWrite, timeUnit, this); &#125; private static &lt;K, V&gt; boolean needUpdate(V loadedValue, boolean cacheNullWhenLoaderReturnNull, Function&lt;K, V&gt; loader) &#123; if (loadedValue == null &amp;&amp; !cacheNullWhenLoaderReturnNull) &#123; return false; &#125; if (loader instanceof CacheLoader &amp;&amp; ((CacheLoader&lt;K, V&gt;) loader).vetoCacheUpdate()) &#123; return false; &#125; return true; &#125; static &lt;K, V&gt; V computeIfAbsentImpl(K key, Function&lt;K, V&gt; loader, boolean cacheNullWhenLoaderReturnNull, long expireAfterWrite, TimeUnit timeUnit, Cache&lt;K, V&gt; cache) &#123; // 获取内部的 Cache 对象 AbstractCache&lt;K, V&gt; abstractCache = CacheUtil.getAbstractCache(cache); // 封装 loader 函数成一个 ProxyLoader 对象，主要在重新加载缓存后发出一个 CacheLoadEvent 到 CacheMonitor CacheLoader&lt;K, V&gt; newLoader = CacheUtil.createProxyLoader(cache, loader, abstractCache::notify); CacheGetResult&lt;V&gt; r; if (cache instanceof RefreshCache) &#123; // 该缓存实例需要刷新 RefreshCache&lt;K, V&gt; refreshCache = ((RefreshCache&lt;K, V&gt;) cache); /* * 从缓存中获取数据 * 如果是多级缓存（先从本地缓存获取，获取不到则从远程缓存获取） * 如果缓存数据是从远程缓存获取到的数据则会更新至本地缓存，并且如果本地缓存没有设置 localExpire 则使用远程缓存的到期时间作为自己的到期时间 * 我一般不设置 localExpire ，因为可能导致本地缓存的有效时间比远程缓存的有效时间更长 * 如果设置 localExpire 了记得设置 expireAfterAccessInMillis */ r = refreshCache.GET(key); // 添加/更新当前 RefreshCache 的刷新缓存任务，存放于 RefreshCache 的 taskMap 中 refreshCache.addOrUpdateRefreshTask(key, newLoader); &#125; else &#123; // 从缓存中获取数据 r = cache.GET(key); &#125; if (r.isSuccess()) &#123; // 缓存命中 return r.getValue(); &#125; else &#123; // 缓存未命中 // 创建当缓存未命中去更新缓存的函数 Consumer&lt;V&gt; cacheUpdater = (loadedValue) -&gt; &#123; if(needUpdate(loadedValue, cacheNullWhenLoaderReturnNull, newLoader)) &#123; /* * 未在缓存注解中配置 key 的生成方式则默认取入参作为缓存 key * 在进入当前方法时是否可以考虑为 key 创建一个副本？？？？ * 因为缓存未命中然后通过 loader 重新加载方法时，如果方法内部对入参进行了修改，那么生成的缓存 key 也会被修改 * 从而导致相同的 key 进入该方法时一直与缓存中的 key 不相同，一直出现缓存未命中 */ if (timeUnit != null) &#123; cache.PUT(key, loadedValue, expireAfterWrite, timeUnit).waitForResult(); &#125; else &#123; cache.PUT(key, loadedValue).waitForResult(); &#125; &#125; &#125;; V loadedValue; if (cache.config().isCachePenetrationProtect()) &#123; // 添加了 @CachePenetrationProtect 注解 // 一个JVM只允许一个线程执行 loadedValue = synchronizedLoad(cache.config(), abstractCache, key, newLoader, cacheUpdater); &#125; else &#123; // 执行方法 loadedValue = newLoader.apply(key); // 将新的结果异步缓存 cacheUpdater.accept(loadedValue); &#125; return loadedValue; &#125; &#125; static &lt;K, V&gt; V synchronizedLoad(CacheConfig config, AbstractCache&lt;K,V&gt; abstractCache, K key, Function&lt;K, V&gt; newLoader, Consumer&lt;V&gt; cacheUpdater) &#123; ConcurrentHashMap&lt;Object, LoaderLock&gt; loaderMap = abstractCache.initOrGetLoaderMap(); Object lockKey = buildLoaderLockKey(abstractCache, key); while (true) &#123; // 为什么加一个 create[] 数组 疑问？？ boolean create[] = new boolean[1]; LoaderLock ll = loaderMap.computeIfAbsent(lockKey, (unusedKey) -&gt; &#123; create[0] = true; LoaderLock loaderLock = new LoaderLock(); loaderLock.signal = new CountDownLatch(1); loaderLock.loaderThread = Thread.currentThread(); return loaderLock; &#125;); if (create[0] || ll.loaderThread == Thread.currentThread()) &#123; try &#123; // 加载该 Key 实例的方法 V loadedValue = newLoader.apply(key); ll.success = true; ll.value = loadedValue; // 将重新加载的数据更新至缓存 cacheUpdater.accept(loadedValue); return loadedValue; &#125; finally &#123; // 标记已完成 ll.signal.countDown(); if (create[0]) &#123; loaderMap.remove(lockKey); &#125; &#125; &#125; else &#123; // 等待其他线程加载，如果出现异常或者超时则自己加载返回数据，但是不更新缓存 try &#123; Duration timeout = config.getPenetrationProtectTimeout(); if (timeout == null) &#123; ll.signal.await(); &#125; else &#123; boolean ok = ll.signal.await(timeout.toMillis(), TimeUnit.MILLISECONDS); if(!ok) &#123; logger.info(&quot;loader wait timeout:&quot; + timeout); return newLoader.apply(key); &#125; &#125; &#125; catch (InterruptedException e) &#123; logger.warn(&quot;loader wait interrupted&quot;); return newLoader.apply(key); &#125; if (ll.success) &#123; return (V) ll.value; &#125; else &#123; continue; &#125; &#125; &#125; &#125; private static Object buildLoaderLockKey(Cache c, Object key) &#123; if (c instanceof AbstractEmbeddedCache) &#123; return ((AbstractEmbeddedCache) c).buildKey(key); &#125; else if (c instanceof AbstractExternalCache) &#123; byte bytes[] = ((AbstractExternalCache) c).buildKey(key); return ByteBuffer.wrap(bytes); &#125; else if (c instanceof MultiLevelCache) &#123; c = ((MultiLevelCache) c).caches()[0]; return buildLoaderLockKey(c, key); &#125; else if(c instanceof ProxyCache) &#123; c = ((ProxyCache) c).getTargetCache(); return buildLoaderLockKey(c, key); &#125; else &#123; throw new CacheException(&quot;impossible&quot;); &#125; &#125; /** * 重新加载数据锁 */ static class LoaderLock &#123; /** * 栅栏 */ CountDownLatch signal; /** * 持有的线程 */ Thread loaderThread; /** * 是否加载成功 */ boolean success; /** * 加载出来的数据 */， Object value; &#125;&#125; com.alicp.jetcache.AbstractCache实现了Cache接口的大写方法，内部调用自己定义的抽象方法（以DO_开头，交由不同的子类实现），操作缓存后发送相应的事件CacheEvent，也就是调用自己定义的notify方法，遍历每个CacheMonitor对该事件进行后置操作，用于统计信息。 computeIfAbsentImpl方法实现了Cache接口的核心方法，从缓存实例中根据缓存key获取缓存value，逻辑如下： 获取cache的targetCache，因为我们通过@CreateCache注解创建的缓存实例将生成LazyInitCache对象，需要调用其getTargetCache方法才会完成缓存实例的初始化 loader函数是对加载原有方法的封装，这里再进行一层封装，封装成ProxyLoader类型，目的是在加载原有方法后将发送CacheLoadEvent事件 从缓存实例中获取对应的缓存value，如果缓存实例对象是RefreshCache类型（在com.alicp.jetcache.anno.support.CacheContext.buildCache方法中会将cache包装成CacheHandlerRefreshCache），则调用RefreshCache.addOrUpdateRefreshTask方法，判断是否应该为它添加一个定时的刷新任务 如果缓存未命中，则执行loader函数，如果开启了保护模式，则调用自定义的synchronizedLoad方法，大致逻辑：根据缓存key从自己的loaderMap（线程安全）遍历中尝试获取（不存在则创建）LoaderLock加载锁，获取到这把加载锁才可以执行loader函数，如果已被其他线程占有则进行等待（没有设置超时时间则一直等待），通过CountDownLatch计数器实现 AbstractEmbeddedCache本地缓存com.alicp.jetcache.embedded.AbstractEmbeddedCache抽象类继承AbstractCache抽象类，定义了本地缓存的存放缓存数据的对象为com.alicp.jetcache.embedded.InnerMap接口和一个初始化该接口的createAreaCache抽象方法，基于InnerMap接口实现以DO_开头的方法，完成缓存实例各种操作的具体实现，主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126public abstract class AbstractEmbeddedCache&lt;K, V&gt; extends AbstractCache&lt;K, V&gt; &#123; protected EmbeddedCacheConfig&lt;K, V&gt; config; /** * 本地缓存的 Map */ protected InnerMap innerMap; protected abstract InnerMap createAreaCache(); public AbstractEmbeddedCache(EmbeddedCacheConfig&lt;K, V&gt; config) &#123; this.config = config; innerMap = createAreaCache(); &#125; @Override public CacheConfig&lt;K, V&gt; config() &#123; return config; &#125; public Object buildKey(K key) &#123; Object newKey = key; Function&lt;K, Object&gt; keyConvertor = config.getKeyConvertor(); if (keyConvertor != null) &#123; newKey = keyConvertor.apply(key); &#125; return newKey; &#125; @Override protected CacheGetResult&lt;V&gt; do_GET(K key) &#123; Object newKey = buildKey(key); CacheValueHolder&lt;V&gt; holder = (CacheValueHolder&lt;V&gt;) innerMap.getValue(newKey); return parseHolderResult(holder); &#125; protected CacheGetResult&lt;V&gt; parseHolderResult(CacheValueHolder&lt;V&gt; holder) &#123; long now = System.currentTimeMillis(); if (holder == null) &#123; return CacheGetResult.NOT_EXISTS_WITHOUT_MSG; &#125; else if (now &gt;= holder.getExpireTime()) &#123; return CacheGetResult.EXPIRED_WITHOUT_MSG; &#125; else &#123; synchronized (holder) &#123; long accessTime = holder.getAccessTime(); if (config.isExpireAfterAccess()) &#123; long expireAfterAccess = config.getExpireAfterAccessInMillis(); if (now &gt;= accessTime + expireAfterAccess) &#123; return CacheGetResult.EXPIRED_WITHOUT_MSG; &#125; &#125; // 设置该缓存数据的最后一次访问时间 holder.setAccessTime(now); &#125; return new CacheGetResult(CacheResultCode.SUCCESS, null, holder); &#125; &#125; @Override protected MultiGetResult&lt;K, V&gt; do_GET_ALL(Set&lt;? extends K&gt; keys) &#123; ArrayList&lt;K&gt; keyList = new ArrayList&lt;K&gt;(keys.size()); ArrayList&lt;Object&gt; newKeyList = new ArrayList&lt;Object&gt;(keys.size()); keys.stream().forEach((k) -&gt; &#123; Object newKey = buildKey(k); keyList.add(k); newKeyList.add(newKey); &#125;); Map&lt;Object, CacheValueHolder&lt;V&gt;&gt; innerResultMap = innerMap.getAllValues(newKeyList); Map&lt;K, CacheGetResult&lt;V&gt;&gt; resultMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; keyList.size(); i++) &#123; K key = keyList.get(i); Object newKey = newKeyList.get(i); CacheValueHolder&lt;V&gt; holder = innerResultMap.get(newKey); resultMap.put(key, parseHolderResult(holder)); &#125; MultiGetResult&lt;K, V&gt; result = new MultiGetResult&lt;&gt;(CacheResultCode.SUCCESS, null, resultMap); return result; &#125; @Override protected CacheResult do_PUT(K key, V value, long expireAfterWrite, TimeUnit timeUnit) &#123; CacheValueHolder&lt;V&gt; cacheObject = new CacheValueHolder(value ,timeUnit.toMillis(expireAfterWrite)); innerMap.putValue(buildKey(key), cacheObject); return CacheResult.SUCCESS_WITHOUT_MSG; &#125; @Override protected CacheResult do_PUT_ALL(Map&lt;? extends K, ? extends V&gt; map, long expireAfterWrite, TimeUnit timeUnit) &#123; HashMap newKeyMap = new HashMap(); for (Map.Entry&lt;? extends K, ? extends V&gt; en : map.entrySet()) &#123; CacheValueHolder&lt;V&gt; cacheObject = new CacheValueHolder(en.getValue(), timeUnit.toMillis(expireAfterWrite)); newKeyMap.put(buildKey(en.getKey()), cacheObject); &#125; innerMap.putAllValues(newKeyMap); final HashMap resultMap = new HashMap(); map.keySet().forEach((k) -&gt; resultMap.put(k, CacheResultCode.SUCCESS)); return CacheResult.SUCCESS_WITHOUT_MSG; &#125; @Override protected CacheResult do_REMOVE(K key) &#123; innerMap.removeValue(buildKey(key)); return CacheResult.SUCCESS_WITHOUT_MSG; &#125; @Override protected CacheResult do_REMOVE_ALL(Set&lt;? extends K&gt; keys) &#123; Set newKeys = keys.stream().map((key) -&gt; buildKey(key)).collect(Collectors.toSet()); innerMap.removeAllValues(newKeys); final HashMap resultMap = new HashMap(); keys.forEach((k) -&gt; resultMap.put(k, CacheResultCode.SUCCESS)); return CacheResult.SUCCESS_WITHOUT_MSG; &#125; @Override protected CacheResult do_PUT_IF_ABSENT(K key, V value, long expireAfterWrite, TimeUnit timeUnit) &#123; CacheValueHolder&lt;V&gt; cacheObject = new CacheValueHolder(value, timeUnit.toMillis(expireAfterWrite)); if (innerMap.putIfAbsentValue(buildKey(key), cacheObject)) &#123; return CacheResult.SUCCESS_WITHOUT_MSG; &#125; else &#123; return CacheResult.EXISTS_WITHOUT_MSG; &#125; &#125;&#125; com.alicp.jetcache.embedded.AbstractEmbeddedCache抽象类实现了操作本地缓存的相关方法 定义了缓存实例对象本地缓存的配置信息EmbeddedCacheConfig对象 定义了缓存实例对象本地缓存基于内存操作缓存数据的InnerMap对象，它的初始化过程交由不同的内存缓存实例（LinkedHashMapCache和CaffeineCache） LinkedHashMapCachecom.alicp.jetcache.embedded.LinkedHashMapCache基于LinkedHashMap完成缓存实例对象本地缓存基于内存操作缓存数据的InnerMap对象的初始化工作，主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156public class LinkedHashMapCache&lt;K, V&gt; extends AbstractEmbeddedCache&lt;K, V&gt; &#123; private static Logger logger = LoggerFactory.getLogger(LinkedHashMapCache.class); public LinkedHashMapCache(EmbeddedCacheConfig&lt;K, V&gt; config) &#123; super(config); // 将缓存实例添加至 Cleaner addToCleaner(); &#125; protected void addToCleaner() &#123; Cleaner.add(this); &#125; @Override protected InnerMap createAreaCache() &#123; return new LRUMap(config.getLimit(), this); &#125; public void cleanExpiredEntry() &#123; ((LRUMap) innerMap).cleanExpiredEntry(); &#125; /** * 用于本地缓存类型为 linkedhashmap 缓存实例存储缓存数据 */ final class LRUMap extends LinkedHashMap implements InnerMap &#123; /** * 允许的最大缓存数量 */ private final int max; /** * 缓存实例锁 */ private Object lock; public LRUMap(int max, Object lock) &#123; super((int) (max * 1.4f), 0.75f, true); this.max = max; this.lock = lock; &#125; /** * 当元素大于最大值时移除最老的元素 * * @param eldest 最老的元素 * @return 是否删除 */ @Override protected boolean removeEldestEntry(Map.Entry eldest) &#123; return size() &gt; max; &#125; /** * 清理过期的元素 */ void cleanExpiredEntry() &#123; synchronized (lock) &#123; // 占有当前缓存实例这把锁 for (Iterator it = entrySet().iterator(); it.hasNext();) &#123; Map.Entry en = (Map.Entry) it.next(); Object value = en.getValue(); if (value != null &amp;&amp; value instanceof CacheValueHolder) &#123; CacheValueHolder h = (CacheValueHolder) value; /* * 缓存的数据已经失效了则删除 * 为什么不对 expireAfterAccess 进行判断，取最小值，疑问？？？？ */ if (System.currentTimeMillis() &gt;= h.getExpireTime()) &#123; it.remove(); &#125; &#125; else &#123; // assert false if (value == null) &#123; logger.error(&quot;key &quot; + en.getKey() + &quot; is null&quot;); &#125; else &#123; logger.error(&quot;value of key &quot; + en.getKey() + &quot; is not a CacheValueHolder. type=&quot; + value.getClass()); &#125; &#125; &#125; &#125; &#125; @Override public Object getValue(Object key) &#123; synchronized (lock) &#123; return get(key); &#125; &#125; @Override public Map getAllValues(Collection keys) &#123; Map values = new HashMap(); synchronized (lock) &#123; for (Object key : keys) &#123; Object v = get(key); if (v != null) &#123; values.put(key, v); &#125; &#125; &#125; return values; &#125; @Override public void putValue(Object key, Object value) &#123; synchronized (lock) &#123; put(key, value); &#125; &#125; @Override public void putAllValues(Map map) &#123; synchronized (lock) &#123; Set&lt;Map.Entry&gt; set = map.entrySet(); for (Map.Entry en : set) &#123; put(en.getKey(), en.getValue()); &#125; &#125; &#125; @Override public boolean removeValue(Object key) &#123; synchronized (lock) &#123; return remove(key) != null; &#125; &#125; @Override public void removeAllValues(Collection keys) &#123; synchronized (lock) &#123; for (Object k : keys) &#123; remove(k); &#125; &#125; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public boolean putIfAbsentValue(Object key, Object value) &#123; /* * 如果缓存 key 不存在，或者对应的 value 已经失效则放入，否则返回 false */ synchronized (lock) &#123; CacheValueHolder h = (CacheValueHolder) get(key); if (h == null || parseHolderResult(h).getResultCode() == CacheResultCode.EXPIRED) &#123; put(key, value); return true; &#125; else &#123; return false; &#125; &#125; &#125; &#125;&#125; com.alicp.jetcache.embedded.LinkedHashMapCache自定义LRUMap继承LinkedHashMap并实现InnerMap接口 自定义max字段，存储元素个数的最大值，并设置初始容量为(max * 1.4f) 自定义lock字段，每个缓存实例的锁，通过synchronized关键词保证线程安全，所以性能相对来说不好 覆盖LinkedHashMap的removeEldestEntry方法，当元素大于最大值时移除最老的元素 自定义cleanExpiredEntry方法，遍历Map，根据缓存value（被封装成的com.alicp.jetcache.CacheValueHolder对象，包含缓存数据、失效时间戳和第一次访问的时间），清理过期的元素 该对象初始化时会被添加至com.alicp.jetcache.embedded.Cleaner清理器中，Cleaner会周期性（每隔60秒）遍历LinkedHashMapCache缓存实例，调用其cleanExpiredEntry方法 Cleaner清理器com.alicp.jetcache.embedded.Cleaner用于清理缓存类型为LinkedHashMapCache的缓存数据，请查看相应注释，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 执行任务：定时清理（每分钟） LinkedHashMapCache 缓存实例中过期的缓存数据 */class Cleaner &#123; /** * 存放弱引用对象，以防内存溢出 * 如果被弱引用的对象只被当前弱引用对象关联时，gc 时被弱引用的对象则会被回收（取决于被弱引用的对象是否还与其他强引用对象关联） * * 个人理解：当某个 LinkedHashMapCache 强引用对象没有被其他对象（除了这里）引用时，我们应该让这个对象被回收， * 但是由于这里使用的也是强引用，这个对象被其他强引用对象关联了，不可能被回收，存在内存溢出的危险， * 所以这里使用了弱引用对象，如果被弱引用的对象没有被其他对象（除了这里）引用时，这个对象会被回收 * * 举个例子：如果我们往一个 Map&lt;Object, Object&gt; 中存放一个key-value键值对 * 假设对应的键已经不再使用被回收了，那我们无法再获取到对应的值，也无法被回收，占有一定的内存，存在风险 */ static LinkedList&lt;WeakReference&lt;LinkedHashMapCache&gt;&gt; linkedHashMapCaches = new LinkedList&lt;&gt;(); static &#123; // 创建一个线程池，1个核心线程 ScheduledExecutorService executorService = JetCacheExecutor.defaultExecutor(); // 起一个循环任务一直清理 linkedHashMapCaches 过期的数据（每隔60秒） executorService.scheduleWithFixedDelay(() -&gt; run(), 60, 60, TimeUnit.SECONDS); &#125; static void add(LinkedHashMapCache cache) &#123; synchronized (linkedHashMapCaches) &#123; // 创建一个弱引用对象，并添加到清理对象中 linkedHashMapCaches.add(new WeakReference&lt;&gt;(cache)); &#125; &#125; static void run() &#123; synchronized (linkedHashMapCaches) &#123; Iterator&lt;WeakReference&lt;LinkedHashMapCache&gt;&gt; it = linkedHashMapCaches.iterator(); while (it.hasNext()) &#123; WeakReference&lt;LinkedHashMapCache&gt; ref = it.next(); // 获取被弱引用的对象（强引用） LinkedHashMapCache c = ref.get(); if (c == null) &#123; // 表示被弱引用的对象被标记成了垃圾，则移除 it.remove(); &#125; else &#123; c.cleanExpiredEntry(); &#125; &#125; &#125; &#125;&#125; CaffeineCachecom.alicp.jetcache.embedded.CaffeineCache基于Caffeine完成缓存实例对象本地缓存基于内存操作缓存数据的InnerMap对象的初始化工作，主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class CaffeineCache&lt;K, V&gt; extends AbstractEmbeddedCache&lt;K, V&gt; &#123; /** * 缓存实例对象 */ private com.github.benmanes.caffeine.cache.Cache cache; public CaffeineCache(EmbeddedCacheConfig&lt;K, V&gt; config) &#123; super(config); &#125; /** * 初始化本地缓存的容器 * * @return Map对象 */ @Override @SuppressWarnings(&quot;unchecked&quot;) protected InnerMap createAreaCache() &#123; Caffeine&lt;Object, Object&gt; builder = Caffeine.newBuilder(); // 设置缓存实例的最大缓存数量 builder.maximumSize(config.getLimit()); final boolean isExpireAfterAccess = config.isExpireAfterAccess(); final long expireAfterAccess = config.getExpireAfterAccessInMillis(); // 设置缓存实例的缓存数据的失效策略 builder.expireAfter(new Expiry&lt;Object, CacheValueHolder&gt;() &#123; /** * 获取缓存的有效时间 * * @param value 缓存数据 * @return 有效时间 */ private long getRestTimeInNanos(CacheValueHolder value) &#123; long now = System.currentTimeMillis(); long ttl = value.getExpireTime() - now; /* * 如果本地缓存设置了多长时间没访问缓存则失效 */ if(isExpireAfterAccess)&#123; // 设置缓存的失效时间 // 多长时间没访问缓存则失效 and 缓存的有效时长取 min ttl = Math.min(ttl, expireAfterAccess); &#125; return TimeUnit.MILLISECONDS.toNanos(ttl); &#125; @Override public long expireAfterCreate(Object key, CacheValueHolder value, long currentTime) &#123; return getRestTimeInNanos(value); &#125; @Override public long expireAfterUpdate(Object key, CacheValueHolder value, long currentTime, long currentDuration) &#123; return currentDuration; &#125; @Override public long expireAfterRead(Object key, CacheValueHolder value, long currentTime, long currentDuration) &#123; return getRestTimeInNanos(value); &#125; &#125;); // 构建 Cache 缓存实例 cache = builder.build(); return new InnerMap() &#123; @Override public Object getValue(Object key) &#123; return cache.getIfPresent(key); &#125; @Override public Map getAllValues(Collection keys) &#123; return cache.getAllPresent(keys); &#125; @Override public void putValue(Object key, Object value) &#123; cache.put(key, value); &#125; @Override public void putAllValues(Map map) &#123; cache.putAll(map); &#125; @Override public boolean removeValue(Object key) &#123; return cache.asMap().remove(key) != null; &#125; @Override public void removeAllValues(Collection keys) &#123; cache.invalidateAll(keys); &#125; @Override public boolean putIfAbsentValue(Object key, Object value) &#123; return cache.asMap().putIfAbsent(key, value) == null; &#125; &#125;; &#125;&#125; com.alicp.jetcache.embedded.CaffeineCache通过Caffeine构建一个com.github.benmanes.caffeine.cache.Cache缓存对象，然后实现InnerMap接口，调用这个缓存对象的相关方法 构建时设置每个元素的过期时间，也就是根据每个元素（com.alicp.jetcache.CacheValueHolder）的失效时间戳来设置，底层如何实现的可以参考Caffeine官方地址 调用com.github.benmanes.caffeine.cache.Cache的put方法我有遇到过’unable to create native thread’内存溢出的问题，所以请结合实际业务场景合理的设置缓存相关配置 AbstractExternalCache远程缓存com.alicp.jetcache.embedded.AbstractExternalCache抽象类继承AbstractCache抽象类，定义了缓存实例对象远程缓存的配置信息ExternalCacheConfig对象，提供了将缓存key转换成字节数组的方法，代码比较简单。 RedisCachecom.alicp.jetcache.redis.RedisCache使用Jedis连接Redis，对远程的缓存数据进行操作，代码没有很复杂，可查看我的注释 定义了com.alicp.jetcache.redis.RedisCacheConfig配置对象，包含Redis连接池的相关信息 实现了以DO_开头的方法，也就是通过Jedis操作缓存数据 RedisLettuceCachecom.alicp.jetcache.redis.lettuce.RedisLettuceCache使用Lettuce连接Redis，对远程的缓存数据进行操作，代码没有很复杂，可查看我的注释 定义了com.alicp.jetcache.redis.lettuce.RedisLettuceCacheConfig配置对象，包含Redis客户端、与Redis建立的安全连接等信息，因为底层是基于Netty实现的，所以无需配置线程池 使用com.alicp.jetcache.redis.lettuce.LettuceConnectionManager自定义管理器将与Redis连接的相关信息封装成LettuceObjects对象，并管理RedisClient与LettuceObjects对应关系 相比Jedis更加安全高效 对Lettuce不了解的可以参考我写的测试类com.alicp.jetcache.test.external.LettuceTest MultiLevelCache两级缓存当你设置了缓存类型为BOTH两级缓存，那么创建的实例对象会被封装成com.alicp.jetcache.MultiLevelCache对象 定义了caches字段类型为Cache[]，用于保存AbstractEmbeddedCache本地缓存实例和AbstractExternalCache远程缓存实例，本地缓存存放于远程缓存前面 实现了do_GET方法，遍历caches数组，也就是先从本地缓存获取，如果获取缓存不成功则从远程缓存获取，成功获取到缓存后会调用checkResultAndFillUpperCache方法 从checkResultAndFillUpperCache方法的逻辑可以看到，将获取到的缓存数据更新至更底层的缓存中，也就是说如果缓存数据是从远程获取到的，那么进入这个方法后会将获取到的缓存数据更新到本地缓存中去，这样下次请求可以直接从本地缓存获取，避免与Redis之间的网络消耗 实现了do_PUT方法，遍历caches数组，通过CompletableFuture进行异步编程，将所有的操作绑定在一条链上执行。 实现的了PUT(K key, V value)方法，会先判断是否单独配置了本地缓存时间localExipre，配置了则单独为本地缓存设置过期时间，没有配置则到期时间和远程缓存的一样 覆盖tryLock方法，调用caches[caches.length-1].tryLock方法，也就是只会调用最顶层远程缓存的这个方法 主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253public class MultiLevelCache&lt;K, V&gt; extends AbstractCache&lt;K, V&gt; &#123; private Cache[] caches; private MultiLevelCacheConfig&lt;K, V&gt; config; @SuppressWarnings(&quot;unchecked&quot;) @Deprecated public MultiLevelCache(Cache... caches) throws CacheConfigException &#123; this.caches = caches; checkCaches(); CacheConfig lastConfig = caches[caches.length - 1].config(); config = new MultiLevelCacheConfig&lt;&gt;(); config.setCaches(Arrays.asList(caches)); config.setExpireAfterWriteInMillis(lastConfig.getExpireAfterWriteInMillis()); config.setCacheNullValue(lastConfig.isCacheNullValue()); &#125; @SuppressWarnings(&quot;unchecked&quot;) public MultiLevelCache(MultiLevelCacheConfig&lt;K, V&gt; cacheConfig) throws CacheConfigException &#123; this.config = cacheConfig; this.caches = cacheConfig.getCaches().toArray(new Cache[]&#123;&#125;); checkCaches(); &#125; private void checkCaches() &#123; if (caches == null || caches.length == 0) &#123; throw new IllegalArgumentException(); &#125; for (Cache c : caches) &#123; if (c.config().getLoader() != null) &#123; throw new CacheConfigException(&quot;Loader on sub cache is not allowed, set the loader into MultiLevelCache.&quot;); &#125; &#125; &#125; public Cache[] caches() &#123; return caches; &#125; @Override public MultiLevelCacheConfig&lt;K, V&gt; config() &#123; return config; &#125; @Override public CacheResult PUT(K key, V value) &#123; if (config.isUseExpireOfSubCache()) &#123; // 本地缓存使用自己的失效时间 // 设置了TimeUnit为null，本地缓存则使用自己的到期时间 return PUT(key, value, 0, null); &#125; else &#123; return PUT(key, value, config().getExpireAfterWriteInMillis(), TimeUnit.MILLISECONDS); &#125; &#125; @Override public CacheResult PUT_ALL(Map&lt;? extends K, ? extends V&gt; map) &#123; if (config.isUseExpireOfSubCache()) &#123; return PUT_ALL(map, 0, null); &#125; else &#123; return PUT_ALL(map, config().getExpireAfterWriteInMillis(), TimeUnit.MILLISECONDS); &#125; &#125; @Override protected CacheGetResult&lt;V&gt; do_GET(K key) &#123; // 遍历多级缓存（远程缓存排在后面） for (int i = 0; i &lt; caches.length; i++) &#123; Cache cache = caches[i]; CacheGetResult result = cache.GET(key); if (result.isSuccess()) &#123; CacheValueHolder&lt;V&gt; holder = unwrapHolder(result.getHolder()); /* * 这个遍历是从低层的缓存开始获取，获取成功则将该值设置到更低层的缓存中 * 情景： * 本地没有获取到缓存，远程获取到了缓存，这里会将远程的缓存数据设置到本地中， * 这样下次请求则直接从本次获取，减少了远程获取的时间 */ checkResultAndFillUpperCache(key, i, holder); return new CacheGetResult(CacheResultCode.SUCCESS, null, holder); &#125; &#125; return CacheGetResult.NOT_EXISTS_WITHOUT_MSG; &#125; private CacheValueHolder&lt;V&gt; unwrapHolder(CacheValueHolder&lt;V&gt; h) &#123; // if @Cached or @CacheCache change type from REMOTE to BOTH (or from BOTH to REMOTE), // during the dev/publish process, the value type which different application server put into cache server will be different // (CacheValueHolder&lt;V&gt; and CacheValueHolder&lt;CacheValueHolder&lt;V&gt;&gt;, respectively). // So we need correct the problem at here and in CacheGetResult. Objects.requireNonNull(h); if (h.getValue() instanceof CacheValueHolder) &#123; return (CacheValueHolder&lt;V&gt;) h.getValue(); &#125; else &#123; return h; &#125; &#125; private void checkResultAndFillUpperCache(K key, int i, CacheValueHolder&lt;V&gt; h) &#123; Objects.requireNonNull(h); long currentExpire = h.getExpireTime(); long now = System.currentTimeMillis(); if (now &lt;= currentExpire) &#123; if(config.isUseExpireOfSubCache())&#123; // 如果使用本地自己的缓存过期时间 // 使用本地缓存自己的过期时间 PUT_caches(i, key, h.getValue(), 0, null); &#125; else &#123; // 使用远程缓存的过期时间 long restTtl = currentExpire - now; if (restTtl &gt; 0) &#123; // 远程缓存数据还未失效，则重新设置本地的缓存 PUT_caches(i, key, h.getValue(), restTtl, TimeUnit.MILLISECONDS); &#125; &#125; &#125; &#125; @Override protected MultiGetResult&lt;K, V&gt; do_GET_ALL(Set&lt;? extends K&gt; keys) &#123; HashMap&lt;K, CacheGetResult&lt;V&gt;&gt; resultMap = new HashMap&lt;&gt;(); Set&lt;K&gt; restKeys = new HashSet&lt;&gt;(keys); for (int i = 0; i &lt; caches.length; i++) &#123; if (restKeys.size() == 0) &#123; break; &#125; Cache&lt;K, CacheValueHolder&lt;V&gt;&gt; c = caches[i]; MultiGetResult&lt;K, CacheValueHolder&lt;V&gt;&gt; allResult = c.GET_ALL(restKeys); if (allResult.isSuccess() &amp;&amp; allResult.getValues() != null) &#123; for (Map.Entry&lt;K, CacheGetResult&lt;CacheValueHolder&lt;V&gt;&gt;&gt; en : allResult.getValues().entrySet()) &#123; K key = en.getKey(); CacheGetResult result = en.getValue(); if (result.isSuccess()) &#123; CacheValueHolder&lt;V&gt; holder = unwrapHolder(result.getHolder()); checkResultAndFillUpperCache(key, i, holder); resultMap.put(key, new CacheGetResult(CacheResultCode.SUCCESS, null, holder)); restKeys.remove(key); &#125; &#125; &#125; &#125; for (K k : restKeys) &#123; resultMap.put(k, CacheGetResult.NOT_EXISTS_WITHOUT_MSG); &#125; return new MultiGetResult&lt;&gt;(CacheResultCode.SUCCESS, null, resultMap); &#125; @Override protected CacheResult do_PUT(K key, V value, long expireAfterWrite, TimeUnit timeUnit) &#123; return PUT_caches(caches.length, key, value, expireAfterWrite, timeUnit); &#125; @Override protected CacheResult do_PUT_ALL(Map&lt;? extends K, ? extends V&gt; map, long expireAfterWrite, TimeUnit timeUnit) &#123; CompletableFuture&lt;ResultData&gt; future = CompletableFuture.completedFuture(null); for (Cache c : caches) &#123; CacheResult r; if(timeUnit == null) &#123; r = c.PUT_ALL(map); &#125; else &#123; r = c.PUT_ALL(map, expireAfterWrite, timeUnit); &#125; future = combine(future, r); &#125; return new CacheResult(future); &#125; private CacheResult PUT_caches(int lastIndex, K key, V value, long expire, TimeUnit timeUnit) &#123; CompletableFuture&lt;ResultData&gt; future = CompletableFuture.completedFuture(null); for (int i = 0; i &lt; lastIndex; i++) &#123; Cache cache = caches[i]; CacheResult r; if (timeUnit == null) &#123; // 表示本地缓存使用自己过期时间 r = cache.PUT(key, value); &#125; else &#123; r = cache.PUT(key, value, expire, timeUnit); &#125; // 将多个 PUT 操作放在一条链上 future = combine(future, r); &#125; return new CacheResult(future); &#125; private CompletableFuture&lt;ResultData&gt; combine(CompletableFuture&lt;ResultData&gt; future, CacheResult result) &#123; return future.thenCombine(result.future(), (d1, d2) -&gt; &#123; if (d1 == null) &#123; return d2; &#125; if (d1.getResultCode() != d2.getResultCode()) &#123; return new ResultData(CacheResultCode.PART_SUCCESS, null, null); &#125; return d1; &#125;); &#125; @Override protected CacheResult do_REMOVE(K key) &#123; CompletableFuture&lt;ResultData&gt; future = CompletableFuture.completedFuture(null); for (Cache cache : caches) &#123; CacheResult r = cache.REMOVE(key); future = combine(future, r); &#125; return new CacheResult(future); &#125; @Override protected CacheResult do_REMOVE_ALL(Set&lt;? extends K&gt; keys) &#123; CompletableFuture&lt;ResultData&gt; future = CompletableFuture.completedFuture(null); for (Cache cache : caches) &#123; CacheResult r = cache.REMOVE_ALL(keys); future = combine(future, r); &#125; return new CacheResult(future); &#125; @Override public &lt;T&gt; T unwrap(Class&lt;T&gt; clazz) &#123; Objects.requireNonNull(clazz); for (Cache cache : caches) &#123; try &#123; T obj = (T) cache.unwrap(clazz); if (obj != null) &#123; return obj; &#125; &#125; catch (IllegalArgumentException e) &#123; // ignore &#125; &#125; throw new IllegalArgumentException(clazz.getName()); &#125; @Override public AutoReleaseLock tryLock(K key, long expire, TimeUnit timeUnit) &#123; if (key == null) &#123; return null; &#125; return caches[caches.length - 1].tryLock(key, expire, timeUnit); &#125; @Override public boolean putIfAbsent(K key, V value) &#123; throw new UnsupportedOperationException(&quot;putIfAbsent is not supported by MultiLevelCache&quot;); &#125; @Override protected CacheResult do_PUT_IF_ABSENT(K key, V value, long expireAfterWrite, TimeUnit timeUnit) &#123; throw new UnsupportedOperationException(&quot;PUT_IF_ABSENT is not supported by MultiLevelCache&quot;); &#125; @Override public void close() &#123; for (Cache c : caches) &#123; c.close(); &#125; &#125;&#125; RefreshCachecom.alicp.jetcache.RefreshCache为缓存实例添加刷新任务，前面在AbstractCache抽象类中讲到了，在com.alicp.jetcache.anno.support.CacheContext.buildCache方法中会将cache包装成CacheHandlerRefreshCache，所以说每个缓存实例都会调用一下addOrUpdateRefreshTask方法，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041public class RefreshCache&lt;K, V&gt; extends LoadingCache&lt;K, V&gt; &#123; protected CacheConfig&lt;K, V&gt; config; /** * 用于保存刷新任务 */ private ConcurrentHashMap&lt;Object, RefreshTask&gt; taskMap = new ConcurrentHashMap&lt;&gt;(); protected void addOrUpdateRefreshTask(K key, CacheLoader&lt;K, V&gt; loader) &#123; // 获取缓存刷新策略 RefreshPolicy refreshPolicy = config.getRefreshPolicy(); if (refreshPolicy == null) &#123; // 没有则不进行刷新 return; &#125; // 获取刷新时间间隔 long refreshMillis = refreshPolicy.getRefreshMillis(); if (refreshMillis &gt; 0) &#123; // 获取线程任务的ID Object taskId = getTaskId(key); // 获取对应的RefreshTask，不存在则创建一个 RefreshTask refreshTask = taskMap.computeIfAbsent(taskId, tid -&gt; &#123; logger.debug(&quot;add refresh task. interval=&#123;&#125;, key=&#123;&#125;&quot;, refreshMillis, key); RefreshTask task = new RefreshTask(taskId, key, loader); task.lastAccessTime = System.currentTimeMillis(); /* * 获取 ScheduledExecutorService 周期/延迟线程池，10个核心线程，创建的线程都是守护线程 * scheduleWithFixedDelay(Runnable command, long initialDelay, long period, TimeUnit unit) * 运行的任务task、多久延迟后开始执行、后续执行的周期间隔多长，时间单位 * 通过其创建一个循环任务，用于刷新缓存数据 */ ScheduledFuture&lt;?&gt; future = JetCacheExecutor.heavyIOExecutor().scheduleWithFixedDelay(task, refreshMillis, refreshMillis, TimeUnit.MILLISECONDS); task.future = future; return task; &#125;); // 设置最后一次访问时间 refreshTask.lastAccessTime = System.currentTimeMillis(); &#125; &#125;&#125; 如果缓存实例配置了刷新策略并且刷新间隔大于0，则会从taskMap（线程安全）中尝试获取对应的刷新任务RefreshTask，如果不存在则创建一个任务放入线程池周期性的执行 com.alicp.jetcache.RefreshCache.RefreshTask代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187public class RefreshCache&lt;K, V&gt; extends LoadingCache&lt;K, V&gt; &#123; protected Cache concreteCache() &#123; Cache c = getTargetCache(); while (true) &#123; if (c instanceof ProxyCache) &#123; c = ((ProxyCache) c).getTargetCache(); &#125; else if (c instanceof MultiLevelCache) &#123; Cache[] caches = ((MultiLevelCache) c).caches(); // 如果是两级缓存则返回远程缓存 c = caches[caches.length - 1]; &#125; else &#123; return c; &#125; &#125; &#125; class RefreshTask implements Runnable &#123; /** * 唯一标志符，也就是Key转换后的值 */ private Object taskId; /** * 缓存的Key */ private K key; /** * 执行方法的CacheLoader对象 */ private CacheLoader&lt;K, V&gt; loader; /** * 最后一次访问时间 */ private long lastAccessTime; /** * 该 Task 的执行策略 */ private ScheduledFuture future; RefreshTask(Object taskId, K key, CacheLoader&lt;K, V&gt; loader) &#123; this.taskId = taskId; this.key = key; this.loader = loader; &#125; private void cancel() &#123; logger.debug(&quot;cancel refresh: &#123;&#125;&quot;, key); // 尝试中断当前任务 future.cancel(false); // 从任务列表中删除 taskMap.remove(taskId); &#125; /** * 重新加载数据 * * @throws Throwable 异常 */ private void load() throws Throwable &#123; CacheLoader&lt;K, V&gt; l = loader == null ? config.getLoader() : loader; if (l != null) &#123; // 封装 CacheLoader 成 ProxyLoader，加载后会发起 Load 事件 l = CacheUtil.createProxyLoader(cache, l, eventConsumer); // 加载 V v = l.load(key); if (needUpdate(v, l)) &#123; // 将重新加载的数据放入缓存 cache.PUT(key, v); &#125; &#125; &#125; /** * 远程加载数据 * * @param concreteCache 缓存对象 * @param currentTime 当前时间 * @throws Throwable 异常 */ private void externalLoad(final Cache concreteCache, final long currentTime) throws Throwable &#123; // 获取 Key 转换后的值 byte[] newKey = ((AbstractExternalCache) concreteCache).buildKey(key); // 创建分布式锁对应的Key byte[] lockKey = combine(newKey, &quot;_#RL#&quot;.getBytes()); // 分布式锁的存在时间 long loadTimeOut = RefreshCache.this.config.getRefreshPolicy().getRefreshLockTimeoutMillis(); // 刷新间隔 long refreshMillis = config.getRefreshPolicy().getRefreshMillis(); // Key对应的时间戳Key（用于存放上次刷新时间） byte[] timestampKey = combine(newKey, &quot;_#TS#&quot;.getBytes()); // AbstractExternalCache buildKey method will not convert byte[] // 获取Key上一次刷新时间 CacheGetResult refreshTimeResult = concreteCache.GET(timestampKey); boolean shouldLoad = false; // 是否需要重新加载 if (refreshTimeResult.isSuccess()) &#123; // 当前时间与上一次刷新的时间间隔是否大于或等于刷新间隔 shouldLoad = currentTime &gt;= Long.parseLong(refreshTimeResult.getValue().toString()) + refreshMillis; &#125; else if (refreshTimeResult.getResultCode() == CacheResultCode.NOT_EXISTS) &#123; // 无缓存 shouldLoad = true; &#125; if (!shouldLoad) &#123; if (multiLevelCache) &#123; // 将顶层的缓存数据更新至低层的缓存中，例如将远程的缓存数据放入本地缓存 // 因为如果是多级缓存，创建刷新任务后，我们只需更新远程的缓存，然后从远程缓存获取缓存数据更新低层的缓存，保证缓存一致 refreshUpperCaches(key); &#125; return; &#125; // 重新加载 Runnable r = () -&gt; &#123; try &#123; load(); // AbstractExternalCache buildKey method will not convert byte[] // 保存一个key-value至redis，其中的信息为该value的生成时间，刷新缓存 concreteCache.put(timestampKey, String.valueOf(System.currentTimeMillis())); &#125; catch (Throwable e) &#123; throw new CacheException(&quot;refresh error&quot;, e); &#125; &#125;; // AbstractExternalCache buildKey method will not convert byte[] // 分布式缓存没有一个全局分配的功能，这里尝试获取一把非严格的分布式锁，获取锁的超时时间默认60秒，也就是获取到这把锁最多可以拥有60秒 // 只有获取Key对应的这把分布式锁，才执行重新加载的操作 boolean lockSuccess = concreteCache.tryLockAndRun(lockKey, loadTimeOut, TimeUnit.MILLISECONDS, r); if (!lockSuccess &amp;&amp; multiLevelCache) &#123; // 没有获取到锁并且是多级缓存 // 这个时候应该有其他实例在刷新缓存，所以这里设置过一会直接获取远程的缓存数据更新到本地 // 创建一个延迟任务（1/5刷新间隔后），将最顶层的缓存数据更新至每一层 JetCacheExecutor.heavyIOExecutor().schedule(() -&gt; refreshUpperCaches(key), (long) (0.2 * refreshMillis), TimeUnit.MILLISECONDS); &#125; &#125; private void refreshUpperCaches(K key) &#123; MultiLevelCache&lt;K, V&gt; targetCache = (MultiLevelCache&lt;K, V&gt;) getTargetCache(); Cache[] caches = targetCache.caches(); int len = caches.length; // 获取多级缓存中顶层的缓存数据 CacheGetResult cacheGetResult = caches[len - 1].GET(key); if (!cacheGetResult.isSuccess()) &#123; return; &#125; // 将缓存数据重新放入低层缓存 for (int i = 0; i &lt; len - 1; i++) &#123; caches[i].PUT(key, cacheGetResult.getValue()); &#125; &#125; /** * 刷新任务的具体执行 */ @Override public void run() &#123; try &#123; if (config.getRefreshPolicy() == null || (loader == null &amp;&amp; !hasLoader())) &#123; // 取消执行 cancel(); return; &#125; long now = System.currentTimeMillis(); long stopRefreshAfterLastAccessMillis = config.getRefreshPolicy().getStopRefreshAfterLastAccessMillis(); if (stopRefreshAfterLastAccessMillis &gt; 0) &#123; // 最后一次访问到现在时间的间隔超过了设置的 stopRefreshAfterLastAccessMillis，则取消当前任务执行 if (lastAccessTime + stopRefreshAfterLastAccessMillis &lt; now) &#123; logger.debug(&quot;cancel refresh: &#123;&#125;&quot;, key); cancel(); return; &#125; &#125; logger.debug(&quot;refresh key: &#123;&#125;&quot;, key); // 获取缓存实例对象，如果是多层则返回顶层，也就是远程缓存 Cache concreteCache = concreteCache(); if (concreteCache instanceof AbstractExternalCache) &#123; // 远程缓存刷新 externalLoad(concreteCache, now); &#125; else &#123; // 本地缓存刷新 load(); &#125; &#125; catch (Throwable e) &#123; logger.error(&quot;refresh error: key=&quot; + key, e); &#125; &#125; &#125;&#125; 刷新逻辑： 判断是否需要停止刷新了，需要的话调用其future的cancel方法取消执行，并从taskMap中删除 获取缓存实例对象，如果是多层则返回顶层，也就是远程缓存实例对象 如果是本地缓存，则调用load方法，也就是执行loader函数加载原有方法，将获取到的数据更新至缓存实例中（如果是多级缓存，则每级缓存都会更新） 如果是远程缓存对象，则调用externalLoad方法，刷新后会往Redis中存放一个键值对，key为key_#TS#，value为上一次刷新时间 先从Redis中获取上一次刷新时间的键值对，根据上一次刷新的时间判断是否大于刷新间隔，大于（或者没有上一次刷新时间）表示需要重新加载数据，否则不需要重新加载数据 如果不需要重新加载数据，但是又是多级缓存，则获取远程缓存数据更新至本地缓存，保证两级缓存的一致性 如果需要重新加载数据，则调用tryLockAndRun方法，尝试获取分布式锁，执行刷新任务（调用load方法，并往Redis中重新设置上一次的刷新时间），如果没有获取到分布式锁，则创建一个延迟任务（1/5刷新间隔后）将最顶层的缓存数据更新至每一层 解析配置主要查看jetcache-autoconfigure子模块，解析application.yml中jetcache相关配置，初始化不同缓存类型的CacheBuilder构造器，用于生产缓存实例，也初始化以下对象： com.alicp.jetcache.anno.support.ConfigProvider：缓存管理器，注入了全局配置GlobalCacheConfig、缓存实例管理器SimpleCacheManager、缓存上下文CacheContext等大量信息 com.alicp.jetcache.autoconfigure.AutoConfigureBeans：存储CacheBuilder构造器以及Redis的相关信息 com.alicp.jetcache.anno.support.GlobalCacheConfig：全局配置类，保存了一些全局信息 初始化构造器通过@Conditional注解将需要使用到的缓存类型对应的构造器初始化类注入到Spring容器并执行初始化过程，也就是创建CacheBuilder构造器 初始化构造器类的类型结构如下图所示： 主要对象描述： AbstractCacheAutoInit：抽象类，实现Spring的InitializingBean接口，注入至Spring容器时完成初始化 EmbeddedCacheAutoInit：抽象类，继承AbstractCacheAutoInit，解析本地缓存独有的配置 LinkedHashMapAutoConfiguration：初始化LinkedHashMapCacheBuilder构造器 CaffeineAutoConfiguration：初始化CaffeineCacheBuilder构造器 ExternalCacheAutoInit：抽象类，继承AbstractCacheAutoInit，解析远程缓存独有的配置 RedisAutoInit：初始化RedisCacheBuilder构造器 RedisLettuceAutoInit：初始化RedisLettuceCacheBuilder构造器 AbstractCacheAutoInitcom.alicp.jetcache.autoconfigure.AbstractCacheAutoInit抽象类主要实现了Spring的InitializingBean接口，在注入Spring容器时，Spring会调用其afterPropertiesSet方法，完成本地缓存类型和远程缓存类型CacheBuilder构造器的初始化，主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public abstract class AbstractCacheAutoInit implements InitializingBean &#123; @Autowired protected ConfigurableEnvironment environment; @Autowired protected AutoConfigureBeans autoConfigureBeans; @Autowired protected ConfigProvider configProvider; protected String[] typeNames; private boolean inited = false; public AbstractCacheAutoInit(String... cacheTypes) &#123; Objects.requireNonNull(cacheTypes,&quot;cacheTypes can&#x27;t be null&quot;); Assert.isTrue(cacheTypes.length &gt; 0, &quot;cacheTypes length is 0&quot;); this.typeNames = cacheTypes; &#125; /** * 初始化方法 */ @Override public void afterPropertiesSet() &#123; if (!inited) &#123; synchronized (this) &#123; if (!inited) &#123; // 这里我们有两个指定前缀 &#x27;jetcache.local&#x27; &#x27;jetcache.remote&#x27; process(&quot;jetcache.local.&quot;, autoConfigureBeans.getLocalCacheBuilders(), true); process(&quot;jetcache.remote.&quot;, autoConfigureBeans.getRemoteCacheBuilders(), false); inited = true; &#125; &#125; &#125; &#125; private void process(String prefix, Map cacheBuilders, boolean local) &#123; // 创建一个配置对象（本地或者远程） ConfigTree resolver = new ConfigTree(environment, prefix); // 获取本地或者远程的配置项 Map&lt;String, Object&gt; m = resolver.getProperties(); // 获取本地或者远程的 area ，这里我一般只有默认的 default Set&lt;String&gt; cacheAreaNames = resolver.directChildrenKeys(); for (String cacheArea : cacheAreaNames) &#123; // 获取本地或者远程存储类型，例如 caffeine，redis.lettuce final Object configType = m.get(cacheArea + &quot;.type&quot;); // 缓存类型是否和当前 CacheAutoInit 的某一个 typeName 匹配（不同的 CacheAutoInit 会设置一个或者多个 typename） boolean match = Arrays.stream(typeNames).anyMatch((tn) -&gt; tn.equals(configType)); /* * 因为有很多 CacheAutoInit 继承者，都会执行这个方法，不同的继承者解析不同的配置 * 例如 CaffeineAutoConfiguration 只解析 jetcache.local.default.type=caffeine 即可 * RedisLettuceAutoInit 只解析 jetcache.remote.default.type=redis.lettuce 即可 */ if (!match) &#123; continue; &#125; // 获取本地或者远程的 area 的子配置项 ConfigTree ct = resolver.subTree(cacheArea + &quot;.&quot;); logger.info(&quot;init cache area &#123;&#125; , type= &#123;&#125;&quot;, cacheArea, typeNames[0]); // 根据配置信息构建本地或者远程缓存的 CacheBuilder 构造器 CacheBuilder c = initCache(ct, local ? &quot;local.&quot; + cacheArea : &quot;remote.&quot; + cacheArea); // 将 CacheBuilder 构造器存放至 AutoConfigureBeans cacheBuilders.put(cacheArea, c); &#125; &#125; /** * 设置公共的配置到 CacheBuilder 构造器中 * * @param builder 构造器 * @param ct 配置信息 */ protected void parseGeneralConfig(CacheBuilder builder, ConfigTree ct) &#123; AbstractCacheBuilder acb = (AbstractCacheBuilder) builder; // 设置 Key 的转换函数 acb.keyConvertor(configProvider.parseKeyConvertor(ct.getProperty(&quot;keyConvertor&quot;))); // 设置超时时间 String expireAfterWriteInMillis = ct.getProperty(&quot;expireAfterWriteInMillis&quot;); if (expireAfterWriteInMillis == null) &#123; // compatible with 2.1 兼容老版本 expireAfterWriteInMillis = ct.getProperty(&quot;defaultExpireInMillis&quot;); &#125; if (expireAfterWriteInMillis != null) &#123; acb.setExpireAfterWriteInMillis(Long.parseLong(expireAfterWriteInMillis)); &#125; // 多长时间没有访问就让缓存失效，0表示不使用该功能（注意：只支持本地缓存） String expireAfterAccessInMillis = ct.getProperty(&quot;expireAfterAccessInMillis&quot;); if (expireAfterAccessInMillis != null) &#123; acb.setExpireAfterAccessInMillis(Long.parseLong(expireAfterAccessInMillis)); &#125; &#125; /** * 初始化 CacheBuilder 构造器交由子类去实现 * * @param ct 配置信息 * @param cacheAreaWithPrefix 配置前缀 * @return CacheBuilder 构造器 */ protected abstract CacheBuilder initCache(ConfigTree ct, String cacheAreaWithPrefix);&#125; 在afterPropertiesSet()方法中可以看到会调用process方法分别初始化本地缓存和远程缓存的构造器 定义的 1process 方法： 首先会从当前环境中解析出JetCache的相关配置到ConfigTree对象中 然后遍历缓存区域，获取对应的缓存类型type，进行不同类型的缓存实例CacheBuilder构造器初始化过程 不同CacheBuilder构造器的初始化方法initCache交由子类实现 获取到CacheBuilder构造器后会将其放入AutoConfigureBeans对象中去 另外也定义了parseGeneralConfig方法解析本地缓存和远程缓存都有的配置至CacheBuilder构造器中 EmbeddedCacheAutoInitcom.alicp.jetcache.autoconfigure.EmbeddedCacheAutoInit抽象类继承了AbstractCacheAutoInit，主要是覆盖父类的parseGeneralConfig，解析本地缓存单有的配置limit，代码如下： 1234567891011121314public abstract class EmbeddedCacheAutoInit extends AbstractCacheAutoInit &#123; public EmbeddedCacheAutoInit(String... cacheTypes) &#123; super(cacheTypes); &#125; @Override protected void parseGeneralConfig(CacheBuilder builder, ConfigTree ct) &#123; super.parseGeneralConfig(builder, ct); EmbeddedCacheBuilder ecb = (EmbeddedCacheBuilder) builder; // 设置本地缓存每个缓存实例的缓存数量个数限制（默认100） ecb.limit(Integer.parseInt(ct.getProperty(&quot;limit&quot;, String.valueOf(CacheConsts.DEFAULT_LOCAL_LIMIT)))); &#125;&#125; LinkedHashMapAutoConfigurationcom.alicp.jetcache.autoconfigure.LinkedHashMapAutoConfiguration继承了EmbeddedCacheAutoInit，实现了initCache方法，先通过LinkedHashMapCacheBuilder创建一个默认实现类，然后解析相关配置至构造器中完成初始化，代码如下： 1234567891011121314151617181920212223@Component@Conditional(LinkedHashMapAutoConfiguration.LinkedHashMapCondition.class)public class LinkedHashMapAutoConfiguration extends EmbeddedCacheAutoInit &#123; public LinkedHashMapAutoConfiguration() &#123; super(&quot;linkedhashmap&quot;); &#125; @Override protected CacheBuilder initCache(ConfigTree ct, String cacheAreaWithPrefix) &#123; // 创建一个 LinkedHashMapCacheBuilder 构造器 LinkedHashMapCacheBuilder builder = LinkedHashMapCacheBuilder.createLinkedHashMapCacheBuilder(); // 解析相关配置至 LinkedHashMapCacheBuilder 的 CacheConfig 中 parseGeneralConfig(builder, ct); return builder; &#125; public static class LinkedHashMapCondition extends JetCacheCondition &#123; // 配置了缓存类型为 linkedhashmap 当前类才会被注入 Spring 容器 public LinkedHashMapCondition() &#123; super(&quot;linkedhashmap&quot;); &#125; &#125;&#125; 这里我们注意到@Conditional注解，这个注解的作用是：满足SpringBootCondition条件这个Bean才会被Spring容器管理 他的条件是LinkedHashMapCondition，继承了JetCacheCondition，也就是说配置文件中配置了缓存类型为linkedhashmap时这个类才会被Spring容器管理，才会完成LinkedHashMapCacheBuilder构造器的初始化 JetCacheCondition逻辑并不复杂，可自行查看 CaffeineAutoConfigurationcom.alicp.jetcache.autoconfigure.CaffeineAutoConfiguration继承了EmbeddedCacheAutoInit，实现了initCache方法，先通过CaffeineCacheBuilder创建一个默认实现类，然后解析相关配置至构造器中完成初始化，代码如下： 1234567891011121314151617181920212223@Component@Conditional(CaffeineAutoConfiguration.CaffeineCondition.class)public class CaffeineAutoConfiguration extends EmbeddedCacheAutoInit &#123; public CaffeineAutoConfiguration() &#123; super(&quot;caffeine&quot;); &#125; @Override protected CacheBuilder initCache(ConfigTree ct, String cacheAreaWithPrefix) &#123; // 创建一个 CaffeineCacheBuilder 构造器 CaffeineCacheBuilder builder = CaffeineCacheBuilder.createCaffeineCacheBuilder(); // 解析相关配置至 CaffeineCacheBuilder 的 CacheConfig 中 parseGeneralConfig(builder, ct); return builder; &#125; public static class CaffeineCondition extends JetCacheCondition &#123; // 配置了缓存类型为 caffeine 当前类才会被注入 Spring 容器 public CaffeineCondition() &#123; super(&quot;caffeine&quot;); &#125; &#125;&#125; 同样使用了@Conditional注解，这个注解的作用是：满足SpringBootCondition条件这个Bean才会被Spring容器管理 他的条件是CaffeineCondition，继承了JetCacheCondition，也就是说配置文件中配置了缓存类型为caffeine时这个类才会被Spring容器管理，才会完成LinkedHashMapCacheBuilder构造器的初始化 ExternalCacheAutoInitcom.alicp.jetcache.autoconfigure.ExternalCacheAutoInit抽象类继承了AbstractCacheAutoInit，主要是覆盖父类的parseGeneralConfig，解析远程缓存单有的配置keyPrefix、valueEncoder和valueDecoder，代码如下： 123456789101112131415161718192021222324public abstract class ExternalCacheAutoInit extends AbstractCacheAutoInit &#123; public ExternalCacheAutoInit(String... cacheTypes) &#123; super(cacheTypes); &#125; /** * 设置远程缓存 CacheBuilder 构造器的相关配置 * * @param builder 构造器 * @param ct 配置信息 */ @Override protected void parseGeneralConfig(CacheBuilder builder, ConfigTree ct) &#123; super.parseGeneralConfig(builder, ct); ExternalCacheBuilder ecb = (ExternalCacheBuilder) builder; // 设置远程缓存 key 的前缀 ecb.setKeyPrefix(ct.getProperty(&quot;keyPrefix&quot;)); /* * 根据配置创建缓存数据的编码函数和解码函数 */ ecb.setValueEncoder(configProvider.parseValueEncoder(ct.getProperty(&quot;valueEncoder&quot;, CacheConsts.DEFAULT_SERIAL_POLICY))); ecb.setValueDecoder(configProvider.parseValueDecoder(ct.getProperty(&quot;valueDecoder&quot;, CacheConsts.DEFAULT_SERIAL_POLICY))); &#125;&#125; RedisAutoInitcom.alicp.jetcache.autoconfigure.RedisAutoInit继承了ExternalCacheAutoInit，实现initCache方法，完成了通过Jedis连接Redis的初始化操作，主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111@Configuration@Conditional(RedisAutoConfiguration.RedisCondition.class)public class RedisAutoConfiguration &#123; public static final String AUTO_INIT_BEAN_NAME = &quot;redisAutoInit&quot;; @Bean(name = AUTO_INIT_BEAN_NAME) public RedisAutoInit redisAutoInit() &#123; return new RedisAutoInit(); &#125; public static class RedisCondition extends JetCacheCondition &#123; // 配置了缓存类型为 redis 当前类才会被注入 Spring 容器 public RedisCondition() &#123; super(&quot;redis&quot;); &#125; &#125; public static class RedisAutoInit extends ExternalCacheAutoInit &#123; public RedisAutoInit() &#123; // 设置缓存类型 super(&quot;redis&quot;); &#125; @Autowired private AutoConfigureBeans autoConfigureBeans; @Override protected CacheBuilder initCache(ConfigTree ct, String cacheAreaWithPrefix) &#123; Pool jedisPool = parsePool(ct); Pool[] slavesPool = null; int[] slavesPoolWeights = null; // 是否只从 Redis 的从节点读取数据 boolean readFromSlave = Boolean.parseBoolean(ct.getProperty(&quot;readFromSlave&quot;, &quot;False&quot;)); // 获取从节点的配置信息 ConfigTree slaves = ct.subTree(&quot;slaves.&quot;); Set&lt;String&gt; slaveNames = slaves.directChildrenKeys(); // 依次创建每个从节点的连接池 if (slaveNames.size() &gt; 0) &#123; slavesPool = new Pool[slaveNames.size()]; slavesPoolWeights = new int[slaveNames.size()]; int i = 0; for (String slaveName: slaveNames) &#123; ConfigTree slaveConfig = slaves.subTree(slaveName + &quot;.&quot;); slavesPool[i] = parsePool(slaveConfig); slavesPoolWeights[i] = Integer.parseInt(slaveConfig.getProperty(&quot;weight&quot;,&quot;100&quot;)); i++; &#125; &#125; // 创建一个 RedisCacheBuilder 构造器 ExternalCacheBuilder externalCacheBuilder = RedisCacheBuilder.createRedisCacheBuilder() .jedisPool(jedisPool) .readFromSlave(readFromSlave) .jedisSlavePools(slavesPool) .slaveReadWeights(slavesPoolWeights); // 解析相关配置至 RedisCacheBuilder 的 CacheConfig 中 parseGeneralConfig(externalCacheBuilder, ct); // eg: &quot;jedisPool.remote.default&quot; autoConfigureBeans.getCustomContainer().put(&quot;jedisPool.&quot; + cacheAreaWithPrefix, jedisPool); return externalCacheBuilder; &#125; /** * 创建 Redis 连接池 * * @param ct 配置信息 * @return 连接池 */ private Pool&lt;Jedis&gt; parsePool(ConfigTree ct) &#123; // 创建连接池配置对象 GenericObjectPoolConfig poolConfig = parsePoolConfig(ct); String host = ct.getProperty(&quot;host&quot;, (String) null); int port = Integer.parseInt(ct.getProperty(&quot;port&quot;, &quot;0&quot;)); int timeout = Integer.parseInt(ct.getProperty(&quot;timeout&quot;, String.valueOf(Protocol.DEFAULT_TIMEOUT))); String password = ct.getProperty(&quot;password&quot;, (String) null); int database = Integer.parseInt(ct.getProperty(&quot;database&quot;, String.valueOf(Protocol.DEFAULT_DATABASE))); String clientName = ct.getProperty(&quot;clientName&quot;, (String) null); boolean ssl = Boolean.parseBoolean(ct.getProperty(&quot;ssl&quot;, &quot;false&quot;)); String masterName = ct.getProperty(&quot;masterName&quot;, (String) null); String sentinels = ct.getProperty(&quot;sentinels&quot;, (String) null);//ip1:port,ip2:port Pool&lt;Jedis&gt; jedisPool; if (sentinels == null) &#123; Objects.requireNonNull(host, &quot;host/port or sentinels/masterName is required&quot;); if (port == 0) &#123; throw new IllegalStateException(&quot;host/port or sentinels/masterName is required&quot;); &#125; // 创建一个 Jedis 连接池 jedisPool = new JedisPool(poolConfig, host, port, timeout, password, database, clientName, ssl); &#125; else &#123; Objects.requireNonNull(masterName, &quot;host/port or sentinels/masterName is required&quot;); String[] strings = sentinels.split(&quot;,&quot;); HashSet&lt;String&gt; sentinelsSet = new HashSet&lt;&gt;(); for (String s : strings) &#123; if (s != null &amp;&amp; !s.trim().equals(&quot;&quot;)) &#123; sentinelsSet.add(s.trim()); &#125; &#125; // 创建一个 Jedis Sentine 连接池 jedisPool = new JedisSentinelPool(masterName, sentinelsSet, poolConfig, timeout, password, database, clientName); &#125; return jedisPool; &#125; &#125;&#125; com.alicp.jetcache.autoconfigure.RedisAutoInit是com.alicp.jetcache.autoconfigure.RedisAutoConfiguration内部的静态类，在RedisAutoConfiguration内通过redisAutoInit()方法定义RedisAutoInit作为Spring Bean 同样RedisAutoConfiguration使用了@Conditional注解，满足SpringBootCondition条件这个Bean才会被Spring容器管理，内部的RedisAutoInit也不会被管理，也就是说配置文件中配置了缓存类型为redis时RedisLettuceAutoInit才会被Spring容器管理，才会完成RedisLettuceCacheBuilder构造器的初始化 实现了initCache方法 先解析Redis的相关配置 通过Jedis创建Redis连接池 通过RedisCacheBuilder创建一个默认实现类 解析相关配置至构造器中完成初始化 将Redis连接保存至AutoConfigureBeans中 RedisLettuceAutoInitcom.alicp.jetcache.autoconfigure.RedisLettuceAutoInit继承了ExternalCacheAutoInit，实现initCache方法，完成了通过Lettuce连接Redis的初始化操作，主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131@Configuration@Conditional(RedisLettuceAutoConfiguration.RedisLettuceCondition.class)public class RedisLettuceAutoConfiguration &#123; public static final String AUTO_INIT_BEAN_NAME = &quot;redisLettuceAutoInit&quot;; /** * 注入 spring 容器的条件 */ public static class RedisLettuceCondition extends JetCacheCondition &#123; // 配置了缓存类型为 redis.lettuce 当前类才会被注入 Spring 容器 public RedisLettuceCondition() &#123; super(&quot;redis.lettuce&quot;); &#125; &#125; @Bean(name = &#123;AUTO_INIT_BEAN_NAME&#125;) public RedisLettuceAutoInit redisLettuceAutoInit() &#123; return new RedisLettuceAutoInit(); &#125; public static class RedisLettuceAutoInit extends ExternalCacheAutoInit &#123; public RedisLettuceAutoInit() &#123; // 设置缓存类型 super(&quot;redis.lettuce&quot;); &#125; /** * 初始化 RedisLettuceCacheBuilder 构造器 * * @param ct 配置信息 * @param cacheAreaWithPrefix 配置前缀 * @return 构造器 */ @Override protected CacheBuilder initCache(ConfigTree ct, String cacheAreaWithPrefix) &#123; Map&lt;String, Object&gt; map = ct.subTree(&quot;uri&quot;/*there is no dot*/).getProperties(); // 数据节点偏好设置 String readFromStr = ct.getProperty(&quot;readFrom&quot;); // 集群模式 String mode = ct.getProperty(&quot;mode&quot;); // 异步获取结果的超时时间，默认1s long asyncResultTimeoutInMillis = Long.parseLong( ct.getProperty(&quot;asyncResultTimeoutInMillis&quot;, Long.toString(CacheConsts.ASYNC_RESULT_TIMEOUT.toMillis()))); ReadFrom readFrom = null; if (readFromStr != null) &#123; /* * MASTER：只从Master节点中读取。 * MASTER_PREFERRED：优先从Master节点中读取。 * SLAVE_PREFERRED：优先从Slave节点中读取。 * SLAVE：只从Slave节点中读取。 * NEAREST：使用最近一次连接的Redis实例读取。 */ readFrom = ReadFrom.valueOf(readFromStr.trim()); &#125; AbstractRedisClient client; StatefulConnection connection = null; if (map == null || map.size() == 0) &#123; throw new CacheConfigException(&quot;lettuce uri is required&quot;); &#125; else &#123; // 创建对应的 RedisURI List&lt;RedisURI&gt; uriList = map.values().stream().map((k) -&gt; RedisURI.create(URI.create(k.toString()))) .collect(Collectors.toList()); if (uriList.size() == 1) &#123; // 只有一个 URI，集群模式只给一个域名怎么办 TODO 疑问？？ RedisURI uri = uriList.get(0); if (readFrom == null) &#123; // 创建一个 Redis 客户端 client = RedisClient.create(uri); // 设置失去连接时的行为，拒绝命令，默认为 DEFAULT ((RedisClient) client).setOptions(ClientOptions.builder(). disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS).build()); &#125; else &#123; // 创建一个 Redis 客户端 client = RedisClient.create(); ((RedisClient) client).setOptions(ClientOptions.builder(). disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS).build()); // 创建一个安全连接并设置数据节点偏好 StatefulRedisMasterSlaveConnection c = MasterSlave.connect( (RedisClient) client, new JetCacheCodec(), uri); c.setReadFrom(readFrom); connection = c; &#125; &#125; else &#123; // 多个 URI，集群模式 if (mode != null &amp;&amp; mode.equalsIgnoreCase(&quot;MasterSlave&quot;)) &#123; client = RedisClient.create(); ((RedisClient) client).setOptions(ClientOptions.builder(). disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS).build()); StatefulRedisMasterSlaveConnection c = MasterSlave.connect( (RedisClient) client, new JetCacheCodec(), uriList); if (readFrom != null) &#123; c.setReadFrom(readFrom); &#125; connection = c; &#125; else &#123; // 创建一个 Redis 客户端 client = RedisClusterClient.create(uriList); ((RedisClusterClient) client).setOptions(ClusterClientOptions.builder(). disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS).build()); if (readFrom != null) &#123; StatefulRedisClusterConnection c = ((RedisClusterClient) client).connect(new JetCacheCodec()); c.setReadFrom(readFrom); connection = c; &#125; &#125; &#125; &#125; // 创建一个 RedisLettuceCacheBuilder 构造器 ExternalCacheBuilder externalCacheBuilder = RedisLettuceCacheBuilder.createRedisLettuceCacheBuilder() .connection(connection) .redisClient(client) .asyncResultTimeoutInMillis(asyncResultTimeoutInMillis); // 解析相关配置至 RedisLettuceCacheBuilder 的 CacheConfig 中 parseGeneralConfig(externalCacheBuilder, ct); // eg: &quot;remote.default.client&quot; autoConfigureBeans.getCustomContainer().put(cacheAreaWithPrefix + &quot;.client&quot;, client); // 开始将 Redis 客户端和安全连接保存至 LettuceConnectionManager 管理器中 LettuceConnectionManager m = LettuceConnectionManager.defaultManager(); // 初始化 Lettuce 连接 Redis m.init(client, connection); // 初始化 Redis 连接的相关信息保存至 LettuceObjects 中，并将相关信息保存至 AutoConfigureBeans.customContainer autoConfigureBeans.getCustomContainer().put(cacheAreaWithPrefix + &quot;.connection&quot;, m.connection(client)); autoConfigureBeans.getCustomContainer().put(cacheAreaWithPrefix + &quot;.commands&quot;, m.commands(client)); autoConfigureBeans.getCustomContainer().put(cacheAreaWithPrefix + &quot;.asyncCommands&quot;, m.asyncCommands(client)); autoConfigureBeans.getCustomContainer().put(cacheAreaWithPrefix + &quot;.reactiveCommands&quot;, m.reactiveCommands(client)); return externalCacheBuilder; &#125; &#125;&#125; com.alicp.jetcache.autoconfigure.RedisLettuceAutoInit是com.alicp.jetcache.autoconfigure.RedisLettuceAutoConfiguration内部的静态类，在RedisLettuceAutoConfiguration内通过redisLettuceAutoInit()方法定义RedisLettuceAutoInit作为Spring Bean 同样RedisLettuceAutoConfiguration使用了@Conditional注解，满足SpringBootCondition条件这个Bean才会被Spring容器管理，内部的RedisLettuceAutoInit也不会被管理，也就是说配置文件中配置了缓存类型为redis.lettuce时RedisLettuceAutoInit才会被Spring容器管理，才会完成RedisLettuceCacheBuilder构造器的初始化 实现了initCache方法 先解析Redis的相关配置 通过Lettuce创建Redis客户端和与Redis的连接 通过RedisLettuceCacheBuilder创建一个默认实现类 解析相关配置至构造器中完成初始化 获取LettuceConnectionManager管理器，将通过Lettuce创建Redis客户端和与Redis的连接保存 将Redis客户端、与Redis的连接、同步命令、异步命令和反应式命令相关保存至AutoConfigureBeans中 JetCacheAutoConfiguration自动配置上面的初始化构造器的类需要被Spring容器管理，就需被扫描到，我们一般会设置扫描路径，但是别人引入JetCache肯定是作为其他包不能够被扫描到的，这些Bean也就不会被Spring管理，这里我们查看jetcache-autoconfigure模块下src/main/resources/META-INF/spring.factories文件，内容如下： 1org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.alicp.jetcache.autoconfigure.JetCacheAutoConfiguration 这应该是一种SPI机制，这样这个项目以外的JetCache包里面的com.alicp.jetcache.autoconfigure.JetCacheAutoConfiguration就会被Spring容器扫描到，我们来看看他的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 该 Bean 将会被 Spring 容器注入，依次注入下面几个 Bean * SpringConfigProvider -&gt; AutoConfigureBeans -&gt; BeanDependencyManager(为 GlobalCacheConfig 添加 CacheAutoInit 依赖) -&gt; GlobalCacheConfig * 由此会完成初始化配置操作，缓存实例构造器 CacheBuilder 也会被注入容器 * * Created on 2016/11/17. * * @author &lt;a href=&quot;mailto:areyouok@gmail.com&quot;&gt;huangli&lt;/a&gt; */@Configuration@ConditionalOnClass(GlobalCacheConfig.class)@ConditionalOnMissingBean(GlobalCacheConfig.class)@EnableConfigurationProperties(JetCacheProperties.class)@Import(&#123;RedisAutoConfiguration.class, CaffeineAutoConfiguration.class, MockRemoteCacheAutoConfiguration.class, LinkedHashMapAutoConfiguration.class, RedisLettuceAutoConfiguration.class, RedisSpringDataAutoConfiguration.class&#125;)public class JetCacheAutoConfiguration &#123; public static final String GLOBAL_CACHE_CONFIG_NAME = &quot;globalCacheConfig&quot;; private SpringConfigProvider _springConfigProvider = new SpringConfigProvider(); private AutoConfigureBeans _autoConfigureBeans = new AutoConfigureBeans(); private GlobalCacheConfig _globalCacheConfig; @Bean @ConditionalOnMissingBean public SpringConfigProvider springConfigProvider() &#123; return _springConfigProvider; &#125; @Bean public AutoConfigureBeans autoConfigureBeans() &#123; return _autoConfigureBeans; &#125; @Bean public static BeanDependencyManager beanDependencyManager()&#123; return new BeanDependencyManager(); &#125; @Bean(name = GLOBAL_CACHE_CONFIG_NAME) public GlobalCacheConfig globalCacheConfig(SpringConfigProvider configProvider, AutoConfigureBeans autoConfigureBeans, JetCacheProperties props) &#123; if (_globalCacheConfig != null) &#123; return _globalCacheConfig; &#125; _globalCacheConfig = new GlobalCacheConfig(); _globalCacheConfig.setHiddenPackages(props.getHiddenPackages()); _globalCacheConfig.setStatIntervalMinutes(props.getStatIntervalMinutes()); _globalCacheConfig.setAreaInCacheName(props.isAreaInCacheName()); _globalCacheConfig.setPenetrationProtect(props.isPenetrationProtect()); _globalCacheConfig.setEnableMethodCache(props.isEnableMethodCache()); _globalCacheConfig.setLocalCacheBuilders(autoConfigureBeans.getLocalCacheBuilders()); _globalCacheConfig.setRemoteCacheBuilders(autoConfigureBeans.getRemoteCacheBuilders()); return _globalCacheConfig; &#125;&#125; 可以看到通过@Import注解，初始化构造器的那些类会被加入到Spring容器，加上@Condotional注解，只有我们配置过的缓存类型的构造器才会被加入，然后保存至AutoConfigureBeans对象中 注意到这里我们注入的是SpringConfigProvider对象，加上@ConditionalOnMissingBean注解，无法再次注册该对象至Spring容器，相比ConfigProvider对象，它的区别是设置了EncoderParser为DefaultSpringEncoderParser，设置了KeyConvertorParser为DefaultSpringKeyConvertorParser，目的是支持两个解析器能够解析自定义bean 在BeanDependencyManager中可以看到它是一个BeanFactoryPostProcessor，用于BeanFactory容器初始后执行操作，目的是往JetCacheAutoConfiguration的BeanDefinition的依赖中添加几个AbstractCacheAutoInit类型的beanName，保证几个CacheBuilder构造器已经初始化 globalCacheConfig方法中设置全局的相关配置并添加已经初始化的CacheBuilder构造器，然后返回GlobalCacheConfig让Spring容器管理，这样一来就完成了JetCache的解析配置并初始化的功能 CacheBuilder构造器构造器的作用就是根据配置构建一个对应类型的缓存实例 CacheBuilder的子类结构如下： 根据类名就可以知道其作用 CacheBuilder接口只定义了一个buildCache()方法，用于构建缓存实例，交由不同的实现类 AbstractCacheBuilder抽象类实现了buildCache()方法，主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public abstract class AbstractCacheBuilder&lt;T extends AbstractCacheBuilder&lt;T&gt;&gt; implements CacheBuilder, Cloneable &#123; /** * 该缓存实例的配置 */ protected CacheConfig config; /** * 创建缓存实例函数 */ private Function&lt;CacheConfig, Cache&gt; buildFunc; public abstract CacheConfig getConfig(); protected T self() &#123; return (T) this; &#125; public T buildFunc(Function&lt;CacheConfig, Cache&gt; buildFunc) &#123; this.buildFunc = buildFunc; return self(); &#125; protected void beforeBuild() &#123; &#125; @Deprecated public final &lt;K, V&gt; Cache&lt;K, V&gt; build() &#123; return buildCache(); &#125; @Override public final &lt;K, V&gt; Cache&lt;K, V&gt; buildCache() &#123; if (buildFunc == null) &#123; throw new CacheConfigException(&quot;no buildFunc&quot;); &#125; beforeBuild(); // 克隆一份配置信息，因为这里获取到的是全局配置信息，以防后续被修改 CacheConfig c = getConfig().clone(); // 通过构建函数创建一个缓存实例 Cache&lt;K, V&gt; cache = buildFunc.apply(c); /* * 目前发现 c.getLoader() 都是 null，后续都会把 cache 封装成 CacheHandlerRefreshCache * TODO 疑问？？？？ */ if (c.getLoader() != null) &#123; if (c.getRefreshPolicy() == null) &#123; cache = new LoadingCache&lt;&gt;(cache); &#125; else &#123; cache = new RefreshCache&lt;&gt;(cache); &#125; &#125; return cache; &#125; @Override public Object clone() &#123; AbstractCacheBuilder copy = null; try &#123; copy = (AbstractCacheBuilder) super.clone(); copy.config = getConfig().clone(); return copy; &#125; catch (CloneNotSupportedException e) &#123; throw new CacheException(e); &#125; &#125;&#125; 实现了java.lang.Cloneable的clone方法，支持克隆该对象，因为每个缓存实例的配置不一定相同，这个构造器中保存的是全局的一些配置，所以需要克隆一个构造器出来为每个缓存实例设置其自己的配置而不影响这个最初始的构造器 定义CacheConfig对象存放缓存配置，构建缓存实例需要根据这些配置 定义的buildFunc函数用于构建缓存实例，我们在初始化构造器中可以看到，不同的构造器设置的该函数都是new一个缓存实例并传入配置信息，例如： 123// 设置构建 CaffeineCache 缓存实例的函数buildFunc((c) -&gt; new CaffeineCache((EmbeddedCacheConfig) c));// 进入CaffeineCache的构造器你就可以看到会根据配置完成缓存实例的初始化 不同类型的构造器区别在于CacheConfig类型不同，因为远程和本地的配置是有所区别的，还有就是设置的buildFunc函数不同，因为需要构建不同的缓存实例，和上面的例子差不多，都是new一个缓存实例并传入配置信息，这里就不一一讲述了 AOP主要查看jetcache-anno子模块，提供AOP功能 启用JetCacheJetCache可以通过@EnableMethodCache和@EnableCreateCacheAnnotation注解完成AOP的初始化工作，我们在Spring Boot工程中的启动类上面添加这两个注解即可启用JetCache缓存。 @EnableMethodCache1234567891011121314@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(&#123;CommonConfiguration.class, ConfigSelector.class&#125;)public @interface EnableMethodCache &#123; boolean proxyTargetClass() default false; AdviceMode mode() default AdviceMode.PROXY; int order() default Ordered.LOWEST_PRECEDENCE; String[] basePackages();&#125; 注解的相关配置在上面的’如何使用’中已经讲过了，这里我们关注@Import注解中的CommonConfiguration和ConfigSelector两个类，将会被Spring容器管理 com.alicp.jetcache.anno.config.CommonConfiguration上面有@Configuration注解，所以会被作为一个Spring Bean，里面定义了一个Bean为ConfigMap，所以这个Bean也会被Spring容器管理，com.alicp.jetcache.anno.support.ConfigMap中保存方法与缓存注解配置信息的映射关系 com.alicp.jetcache.anno.config.ConfigSelector继承了AdviceModeImportSelector，通过@Import注解他的selectImports方法会被调用，根据不同的AdviceMode导入不同的配置类，可以看到会返回一个JetCacheProxyConfiguration类名称，那么它也会被注入 com.alicp.jetcache.anno.config.JetCacheProxyConfiguration是配置AOP的配置类，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Configurationpublic class JetCacheProxyConfiguration implements ImportAware, ApplicationContextAware &#123; protected AnnotationAttributes enableMethodCache; private ApplicationContext applicationContext; @Override public void setImportMetadata(AnnotationMetadata importMetadata) &#123; // 获取 @EnableMethodCache 注解信息 this.enableMethodCache = AnnotationAttributes.fromMap( importMetadata.getAnnotationAttributes(EnableMethodCache.class.getName(), false)); if (this.enableMethodCache == null) &#123; throw new IllegalArgumentException( &quot;@EnableMethodCache is not present on importing class &quot; + importMetadata.getClassName()); &#125; &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; @Bean(name = CacheAdvisor.CACHE_ADVISOR_BEAN_NAME) @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public CacheAdvisor jetcacheAdvisor(JetCacheInterceptor jetCacheInterceptor) &#123; CacheAdvisor advisor = new CacheAdvisor(); // bean的名称：jetcache2.internalCacheAdvisor advisor.setAdviceBeanName(CacheAdvisor.CACHE_ADVISOR_BEAN_NAME); // 设置缓存拦截器为 JetCacheInterceptor advisor.setAdvice(jetCacheInterceptor); // 设置需要扫描的包 advisor.setBasePackages(this.enableMethodCache.getStringArray(&quot;basePackages&quot;)); // 设置优先级，默认 Integer 的最大值，最低优先级 advisor.setOrder(this.enableMethodCache.&lt;Integer&gt;getNumber(&quot;order&quot;)); return advisor; &#125; /** * 注入一个 JetCacheInterceptor 拦截器，设置为框架内部的角色 * * @return JetCacheInterceptor */ @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public JetCacheInterceptor jetCacheInterceptor() &#123; return new JetCacheInterceptor(); &#125;&#125; 因为JetCacheProxyConfiguration是通过@Import注解注入的并且实现了ImportAware接口，当被注入Bean的时候会先调用其setImportMetadata方法（这里好像必须添加@Configuration注解，不然无法被Spring识别出来）获取到@EnableMethodCache注解的元信息 其中定义了两个Bean： com.alicp.jetcache.anno.aop.JetCacheInterceptor：实现了aop中的MethodInterceptor方法拦截器，可用于aop拦截方法后执行相关处理 com.alicp.jetcache.anno.aop.CacheAdvisor： 继承了org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor，将会作为一个AOP切面 设置了通知advice为JetCacheInterceptor，也就是说被拦截的方法都会进入JetCacheInterceptor，JetCacheInterceptor就作为JetCache的入口了 根据注解设置了需要扫描的包路径以及优先级，默认是最低优先级 CacheAdvisor实现了org.springframework.aopPointcutAdvisor接口的getPointcut()方法，设置这个切面的切入点为com.alicp.jetcache.anno.aop.CachePointcut 从CachePointcut作为切入点 实现了org.springframework.aop.ClassFilter接口，用于判断哪些类需要被拦截 实现了org.springframework.aop.MethodMatcher接口，用于判断哪些类中的哪些方法会被拦截 在判断方法是否需要进入JetCache的JetCacheInterceptor过程中，会解析方法上面的JetCache相关缓存注解，将配置信息封装com.alicp.jetcache.anno.methodCacheInvokeConfig对象中，并把它保存至com.alicp.jetcache.anno.support.ConfigMap对象中 总结：@EnableMethodCache注解主要就是生成一个AOP切面用于拦截带有缓存注解的方法 @EnableCreateCacheAnnotation123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(&#123;CommonConfiguration.class, CreateCacheAnnotationBeanPostProcessor.class&#125;)public @interface EnableCreateCacheAnnotation &#123;&#125; 相比@EnableMethodCache注解，没有相关属性，同样会导入CommonConfiguration类 不同的是将导入com.alicp.jetcache.anno.field.CreateCacheAnnotationBeanPostProcessor类，它继承了org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor 作为一个BeanPostProcessor，用于在Spring初始化bean的时候做一些操作 从代码中可以看到他的作用是：如果这个bean内部存在添加了带有@CreateCache注解的字段（没有添加static），会将这个字段作为需要注入的对象，解析成 com.alicp.jetcache.anno.field.LazyInitCache缓存实例 LazyInitCache的主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100class LazyInitCache implements ProxyCache &#123; /** * 是否初始化，用于懒加载 */ private boolean inited; /** * 缓存实例 */ private Cache cache; /** * 所处上下文 */ private ConfigurableListableBeanFactory beanFactory; /** * CreateCache 注解元信息 */ private CreateCache ann; /** * 字段 */ private Field field; /** * 刷新策略 */ private RefreshPolicy refreshPolicy; /** * 保护策略 */ private PenetrationProtectConfig protectConfig; public LazyInitCache(ConfigurableListableBeanFactory beanFactory, CreateCache ann, Field field) &#123; this.beanFactory = beanFactory; this.ann = ann; this.field = field; CacheRefresh cr = field.getAnnotation(CacheRefresh.class); if (cr != null) &#123; refreshPolicy = CacheConfigUtil.parseRefreshPolicy(cr); &#125; CachePenetrationProtect penetrateProtect = field.getAnnotation(CachePenetrationProtect.class); if (penetrateProtect != null) &#123; protectConfig = CacheConfigUtil.parsePenetrationProtectConfig(penetrateProtect); &#125; &#125; private void checkInit() &#123; if (!inited) &#123; synchronized (this) &#123; if (!inited) &#123; init(); inited = true; &#125; &#125; &#125; &#125; /** * 获取缓存实例，不存在则新建 * * @return 缓存实例 */ @Override public Cache getTargetCache() &#123; checkInit(); return cache; &#125; private void init() &#123; if (inited) &#123; throw new IllegalStateException(); &#125; // 从 spring 的容器中获取全局缓存配置 GlobalCacheConfig 对象 GlobalCacheConfig globalCacheConfig = beanFactory.getBean(GlobalCacheConfig.class); ConfigProvider configProvider = beanFactory.getBean(ConfigProvider.class); // 将注解信息封装到 CachedAnnoConfig 对象中 CachedAnnoConfig cac = new CachedAnnoConfig(); cac.setArea(ann.area()); cac.setName(ann.name()); cac.setTimeUnit(ann.timeUnit()); cac.setExpire(ann.expire()); cac.setLocalExpire(ann.localExpire()); cac.setCacheType(ann.cacheType()); cac.setLocalLimit(ann.localLimit()); cac.setSerialPolicy(ann.serialPolicy()); cac.setKeyConvertor(ann.keyConvertor()); cac.setRefreshPolicy(refreshPolicy); cac.setPenetrationProtectConfig(protectConfig); String cacheName = cac.getName(); if (CacheConsts.isUndefined(cacheName)) &#123; String[] hiddenPackages = globalCacheConfig.getHiddenPackages(); CacheNameGenerator g = configProvider.createCacheNameGenerator(hiddenPackages); cacheName = g.generateCacheName(field); &#125; // 从缓存实例管理器中获取或者创建对应的缓存实例 cache = configProvider.getCacheContext().__createOrGetCache(cac, ann.area(), cacheName); &#125;&#125; 可以看到通过@CreateCache创建的缓存实例也可以添加@CacheRefresh和@CachePenetrationProtect注解 在AbstractCache抽象类的computeIfAbsentImpl方法中我们有讲到，如果缓存实例是ProxyCache类型，则会先调用其getTargetCache()方法获取缓存实例对象，所以LazyInitCache在第一次访问的时候才进行初始化，并根据缓存注解配置信息创建（存在则直接获取）一个缓存实例 总结：@EnableCreateCacheAnnotation注解主要是支持@CreateCache能够创建缓存实例 通过@EnableMethodCache和@EnableCreateCacheAnnotation两个注解，加上前面的解析配置过程，已经完成的JetCache的解析与初始化过程，那么接下来我们来看看JetCache如何处理被拦截的方法。 拦截器从com.alicp.jetcache.anno.aop.CachePointcut切入点判断方法是否需要拦截的逻辑： 方法所在的类对象是否匹配，除去以”java”、”org.springframework”开头和包含”$$EnhancerBySpringCGLIB$$”、”$$FastClassBySpringCGLIB$$”的类，该类是否在我们通过@EnableMethodCache注解配置的basePackages中 从ConfigMap获取方法对应的CacheInvokeConfig对象，也就是获取缓存配置信息 如果是一个空对象，那么不需要被拦截，因为前面已经判断了所在的类是否需要被拦截，而这个类中并不是所有的方法都会添加缓存注解，所以这一类的方法会设置一个空对象（定义在CacheInvokeConfig内部的一个静态对象添加了final修饰），保存在ConfigMap中 如果不为null，则需被拦截 通过CacheConfigUtil解析这个方法的缓存注解，如果有@Cached注解或者@CacheInvalidate注解或者@CacheUpdate注解，先解析注解生成CacheInvokeConfig对象保存至ConfigMap中，然后该方法会被拦截，否在保存一个空对象不会被拦截 ConfigProvidercom.alicp.jetcache.anno.support.ConfigProvide是一个配置提供者对象，包含了JetCache的全局配置、缓存实例管理器、缓存value转换器、缓存key转换器、上下文和监控指标相关信息，主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121public class ConfigProvider extends AbstractLifecycle &#123; /** * 缓存的全局配置 */ @Resource protected GlobalCacheConfig globalCacheConfig; /** * 缓存实例管理器 */ protected SimpleCacheManager cacheManager; /** * 根据不同类型生成缓存数据转换函数的转换器 */ protected EncoderParser encoderParser; /** * 根据不同类型生成缓存 Key 转换函数的转换器 */ protected KeyConvertorParser keyConvertorParser; /** * 缓存监控指标管理器 */ protected CacheMonitorManager cacheMonitorManager; /** * 打印缓存各项指标的函数 */ private Consumer&lt;StatInfo&gt; metricsCallback = new StatInfoLogger(false); /** * 缓存更新事件（REMOVE OR PUT）消息接收者，无实现类 * 我们可以自己实现 CacheMessagePublisher 用于统计一些缓存的命中信息 */ private CacheMessagePublisher cacheMessagePublisher; /** * 默认的缓存监控指标管理器 */ private CacheMonitorManager defaultCacheMonitorManager = new DefaultCacheMonitorManager(); /** * 缓存上下文 */ private CacheContext cacheContext; public ConfigProvider() &#123; cacheManager = SimpleCacheManager.defaultManager; encoderParser = new DefaultEncoderParser(); keyConvertorParser = new DefaultKeyConvertorParser(); cacheMonitorManager = defaultCacheMonitorManager; &#125; @Override public void doInit() &#123; // 启动缓存指标监控器，周期性打印各项指标 initDefaultCacheMonitorInstaller(); // 初始化缓存上下文 cacheContext = newContext(); &#125; protected void initDefaultCacheMonitorInstaller() &#123; if (cacheMonitorManager == defaultCacheMonitorManager) &#123; DefaultCacheMonitorManager installer = (DefaultCacheMonitorManager) cacheMonitorManager; installer.setGlobalCacheConfig(globalCacheConfig); installer.setMetricsCallback(metricsCallback); if (cacheMessagePublisher != null) &#123; installer.setCacheMessagePublisher(cacheMessagePublisher); &#125; // 启动缓存指标监控器 installer.init(); &#125; &#125; @Override public void doShutdown() &#123; shutdownDefaultCacheMonitorInstaller(); cacheManager.rebuild(); &#125; protected void shutdownDefaultCacheMonitorInstaller() &#123; if (cacheMonitorManager == defaultCacheMonitorManager) &#123; ((DefaultCacheMonitorManager) cacheMonitorManager).shutdown(); &#125; &#125; /** * 根据编码类型通过缓存value转换器生成编码函数 * * @param valueEncoder 编码类型 * @return 编码函数 */ public Function&lt;Object, byte[]&gt; parseValueEncoder(String valueEncoder) &#123; return encoderParser.parseEncoder(valueEncoder); &#125; /** * 根据解码类型通过缓存value转换器生成解码函数 * * @param valueDecoder 解码类型 * @return 解码函数 */ public Function&lt;byte[], Object&gt; parseValueDecoder(String valueDecoder) &#123; return encoderParser.parseDecoder(valueDecoder); &#125; /** * 根据转换类型通过缓存key转换器生成转换函数 * * @param convertor 转换类型 * @return 转换函数 */ public Function&lt;Object, Object&gt; parseKeyConvertor(String convertor) &#123; return keyConvertorParser.parseKeyConvertor(convertor); &#125; public CacheNameGenerator createCacheNameGenerator(String[] hiddenPackages) &#123; return new DefaultCacheNameGenerator(hiddenPackages); &#125; protected CacheContext newContext() &#123; return new CacheContext(this, globalCacheConfig); &#125;&#125; 继承了com.alicp.jetcache.anno.support.AbstractLifecycle，查看其代码可以看到有两个方法，分别为init()初始化方法和shutdown()销毁方法，因为分别添加了@PostConstruct注解和@PreDestroy注解，所以在Spring初始化时会调用init()，在Spring容器销毁时会调用shutdown()方法，内部分别调用doInit()和doShutdown()，这两个方法交由子类实现 在doInit()方法中先启动缓存指标监控器，用于周期性打印各项缓存指标，然后初始化CacheContext缓存上下文，SpringConfigProvider返回的是SpringConfigContext 在doShutdown()方法中关闭缓存指标监控器，清除缓存实例 CacheContextcom.alicp.jetcache.anno.support.CacheContext缓存上下文主要为每一个被拦截的请求创建缓存上下文，构建对应的缓存实例，主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225public class CacheContext &#123; private static Logger logger = LoggerFactory.getLogger(CacheContext.class); private static ThreadLocal&lt;CacheThreadLocal&gt; cacheThreadLocal = new ThreadLocal&lt;CacheThreadLocal&gt;() &#123; @Override protected CacheThreadLocal initialValue() &#123; return new CacheThreadLocal(); &#125; &#125;; /** * JetCache 缓存的管理器（包含很多信息） */ private ConfigProvider configProvider; /** * 缓存的全局配置 */ private GlobalCacheConfig globalCacheConfig; /** * 缓存实例管理器 */ protected SimpleCacheManager cacheManager; public CacheContext(ConfigProvider configProvider, GlobalCacheConfig globalCacheConfig) &#123; this.globalCacheConfig = globalCacheConfig; this.configProvider = configProvider; cacheManager = configProvider.getCacheManager(); &#125; public CacheInvokeContext createCacheInvokeContext(ConfigMap configMap) &#123; // 创建一个本次调用的上下文 CacheInvokeContext c = newCacheInvokeContext(); // 添加一个函数，后续用于获取缓存实例 // 根据注解配置信息获取缓存实例对象，不存在则创建并设置到缓存注解配置类中 c.setCacheFunction((invokeContext, cacheAnnoConfig) -&gt; &#123; Cache cache = cacheAnnoConfig.getCache(); if (cache == null) &#123; if (cacheAnnoConfig instanceof CachedAnnoConfig) &#123; // 缓存注解 // 根据配置创建一个缓存实例对象，通过 CacheBuilder cache = createCacheByCachedConfig((CachedAnnoConfig) cacheAnnoConfig, invokeContext); &#125; else if ((cacheAnnoConfig instanceof CacheInvalidateAnnoConfig) || (cacheAnnoConfig instanceof CacheUpdateAnnoConfig)) &#123; // 更新/使失效缓存注解 CacheInvokeConfig cacheDefineConfig = configMap.getByCacheName(cacheAnnoConfig.getArea(), cacheAnnoConfig.getName()); if (cacheDefineConfig == null) &#123; String message = &quot;can&#x27;t find @Cached definition with area=&quot; + cacheAnnoConfig.getArea() + &quot; name=&quot; + cacheAnnoConfig.getName() + &quot;, specified in &quot; + cacheAnnoConfig.getDefineMethod(); CacheConfigException e = new CacheConfigException(message); logger.error(&quot;Cache operation aborted because can&#x27;t find @Cached definition&quot;, e); return null; &#125; cache = createCacheByCachedConfig(cacheDefineConfig.getCachedAnnoConfig(), invokeContext); &#125; cacheAnnoConfig.setCache(cache); &#125; return cache; &#125;); return c; &#125; private Cache createCacheByCachedConfig(CachedAnnoConfig ac, CacheInvokeContext invokeContext) &#123; // 缓存区域 String area = ac.getArea(); // 缓存实例名称 String cacheName = ac.getName(); if (CacheConsts.isUndefined(cacheName)) &#123; // 没有定义缓存实例名称 // 生成缓存实例名称：类名+方法名+(参数类型) cacheName = configProvider.createCacheNameGenerator(invokeContext.getHiddenPackages()) .generateCacheName(invokeContext.getMethod(), invokeContext.getTargetObject()); &#125; // 创建缓存实例对象 Cache cache = __createOrGetCache(ac, area, cacheName); return cache; &#125; @Deprecated public &lt;K, V&gt; Cache&lt;K, V&gt; getCache(String cacheName) &#123; return getCache(CacheConsts.DEFAULT_AREA, cacheName); &#125; @Deprecated public &lt;K, V&gt; Cache&lt;K, V&gt; getCache(String area, String cacheName) &#123; Cache cache = cacheManager.getCacheWithoutCreate(area, cacheName); return cache; &#125; public Cache __createOrGetCache(CachedAnnoConfig cachedAnnoConfig, String area, String cacheName) &#123; // 缓存名称拼接 String fullCacheName = area + &quot;_&quot; + cacheName; // 从缓存实例管理器中根据缓存区域和缓存实例名称获取缓存实例 Cache cache = cacheManager.getCacheWithoutCreate(area, cacheName); if (cache == null) &#123; synchronized (this) &#123; // 加锁 // 再次确认 cache = cacheManager.getCacheWithoutCreate(area, cacheName); if (cache == null) &#123; /* * 缓存区域的名称是否作为缓存 key 名称前缀，默认为 true ，我一般设置为 false */ if (globalCacheConfig.isAreaInCacheName()) &#123; // for compatible reason, if we use default configuration, the prefix should same to that version &lt;=2.4.3 cache = buildCache(cachedAnnoConfig, area, fullCacheName); &#125; else &#123; // 构建一个缓存实例 cache = buildCache(cachedAnnoConfig, area, cacheName); &#125; cacheManager.putCache(area, cacheName, cache); &#125; &#125; &#125; return cache; &#125; protected Cache buildCache(CachedAnnoConfig cachedAnnoConfig, String area, String cacheName) &#123; Cache cache; if (cachedAnnoConfig.getCacheType() == CacheType.LOCAL) &#123; // 本地缓存 cache = buildLocal(cachedAnnoConfig, area); &#125; else if (cachedAnnoConfig.getCacheType() == CacheType.REMOTE) &#123; // 远程缓存 cache = buildRemote(cachedAnnoConfig, area, cacheName); &#125; else &#123; // 两级缓存 // 构建本地缓存实例 Cache local = buildLocal(cachedAnnoConfig, area); // 构建远程缓存实例 Cache remote = buildRemote(cachedAnnoConfig, area, cacheName); // 两级缓存时是否单独设置了本地缓存失效时间 localExpire boolean useExpireOfSubCache = cachedAnnoConfig.getLocalExpire() &gt; 0; // 创建一个两级缓存CacheBuilder cache = MultiLevelCacheBuilder.createMultiLevelCacheBuilder() .expireAfterWrite(remote.config().getExpireAfterWriteInMillis(), TimeUnit.MILLISECONDS) .addCache(local, remote) .useExpireOfSubCache(useExpireOfSubCache) .cacheNullValue(cachedAnnoConfig.isCacheNullValue()) .buildCache(); &#125; // 设置缓存刷新策略 cache.config().setRefreshPolicy(cachedAnnoConfig.getRefreshPolicy()); // 将 cache 封装成 CacheHandlerRefreshCache，也就是 RefreshCache 类型 // 后续添加刷新任务时会判断是否为 RefreshCache 类型，然后决定是否执行 addOrUpdateRefreshTask 方法，添加刷新任务，没有刷新策略不会添加 cache = new CacheHandler.CacheHandlerRefreshCache(cache); // 设置缓存未命中时，JVM是否只允许一个线程执行方法，其他线程等待，全局配置默认为false cache.config().setCachePenetrationProtect(globalCacheConfig.isPenetrationProtect()); PenetrationProtectConfig protectConfig = cachedAnnoConfig.getPenetrationProtectConfig(); if (protectConfig != null) &#123; // 方法的@CachePenetrationProtect注解 cache.config().setCachePenetrationProtect(protectConfig.isPenetrationProtect()); cache.config().setPenetrationProtectTimeout(protectConfig.getPenetrationProtectTimeout()); &#125; if (configProvider.getCacheMonitorManager() != null) &#123; // 添加监控统计配置 configProvider.getCacheMonitorManager().addMonitors(area, cacheName, cache); &#125; return cache; &#125; protected Cache buildRemote(CachedAnnoConfig cachedAnnoConfig, String area, String cacheName) &#123; // 获取缓存区域对应的 CacheBuilder 构造器 ExternalCacheBuilder cacheBuilder = (ExternalCacheBuilder) globalCacheConfig.getRemoteCacheBuilders().get(area); if (cacheBuilder == null) &#123; throw new CacheConfigException(&quot;no remote cache builder: &quot; + area); &#125; // 克隆一个 CacheBuilder 构造器，因为不同缓存实例有不同的配置 cacheBuilder = (ExternalCacheBuilder) cacheBuilder.clone(); if (cachedAnnoConfig.getExpire() &gt; 0 ) &#123; // 设置失效时间 cacheBuilder.expireAfterWrite(cachedAnnoConfig.getExpire(), cachedAnnoConfig.getTimeUnit()); &#125; // 设置缓存 key 的前缀 if (cacheBuilder.getConfig().getKeyPrefix() != null) &#123; // 配置文件中配置了 prefix，则设置为 prefix+cacheName cacheBuilder.setKeyPrefix(cacheBuilder.getConfig().getKeyPrefix() + cacheName); &#125; else &#123; // 设置为 cacheName cacheBuilder.setKeyPrefix(cacheName); &#125; if (!CacheConsts.isUndefined(cachedAnnoConfig.getKeyConvertor())) &#123; // 如果注解中设置了Key的转换方式则替换，否则还是使用全局的 // 设置 key 的转换器，只支持 FASTJSON cacheBuilder.setKeyConvertor(configProvider.parseKeyConvertor(cachedAnnoConfig.getKeyConvertor())); &#125; if (!CacheConsts.isUndefined(cachedAnnoConfig.getSerialPolicy())) &#123; // 缓存数据保存至远程需要进行编码和解码，所以这里设置其编码和解码方式，KRYO 和 JAVA 可选择 cacheBuilder.setValueEncoder(configProvider.parseValueEncoder(cachedAnnoConfig.getSerialPolicy())); cacheBuilder.setValueDecoder(configProvider.parseValueDecoder(cachedAnnoConfig.getSerialPolicy())); &#125; // 设置是否缓存 null 值 cacheBuilder.setCacheNullValue(cachedAnnoConfig.isCacheNullValue()); return cacheBuilder.buildCache(); &#125; protected Cache buildLocal(CachedAnnoConfig cachedAnnoConfig, String area) &#123; // 获取缓存区域对应的 CacheBuilder 构造器 EmbeddedCacheBuilder cacheBuilder = (EmbeddedCacheBuilder) globalCacheConfig.getLocalCacheBuilders().get(area); if (cacheBuilder == null) &#123; throw new CacheConfigException(&quot;no local cache builder: &quot; + area); &#125; // 克隆一个 CacheBuilder 构造器，因为不同缓存实例有不同的配置 cacheBuilder = (EmbeddedCacheBuilder) cacheBuilder.clone(); if (cachedAnnoConfig.getLocalLimit() != CacheConsts.UNDEFINED_INT) &#123; // 本地缓存数量限制 cacheBuilder.setLimit(cachedAnnoConfig.getLocalLimit()); &#125; if (cachedAnnoConfig.getCacheType() == CacheType.BOTH &amp;&amp; cachedAnnoConfig.getLocalExpire() &gt; 0) &#123; // 设置本地缓存失效时间，前提是多级缓存，一般和远程缓存保持一致不设置 cacheBuilder.expireAfterWrite(cachedAnnoConfig.getLocalExpire(), cachedAnnoConfig.getTimeUnit()); &#125; else if (cachedAnnoConfig.getExpire() &gt; 0) &#123; // 设置失效时间 cacheBuilder.expireAfterWrite(cachedAnnoConfig.getExpire(), cachedAnnoConfig.getTimeUnit()); &#125; if (!CacheConsts.isUndefined(cachedAnnoConfig.getKeyConvertor())) &#123; cacheBuilder.setKeyConvertor(configProvider.parseKeyConvertor(cachedAnnoConfig.getKeyConvertor())); &#125; // 设置是否缓存 null 值 cacheBuilder.setCacheNullValue(cachedAnnoConfig.isCacheNullValue()); // 构建一个缓存实例 return cacheBuilder.buildCache(); &#125; protected CacheInvokeContext newCacheInvokeContext() &#123; return new CacheInvokeContext(); &#125;&#125; createCacheInvokeContext方法返回一个本次调用的上下文CacheInvokeContext，为这个上下文设置缓存函数，用于获取或者构建缓存实例，这个函数在CacheHandler中会被调用，我们来看看这个函数的处理逻辑：有两个入参，分别为本次调用的上下文和缓存注解的配置信息 首先从缓存注解的配置信息中获取缓存实例，如果不为null则直接返回，否则调用createCacheByCachedConfig方法，根据配置通过CacheBuilder构造器创建一个缓存实例对象 createCacheByCachedConfig方法： 如果没有定义缓存实例名称（@Cached注解中的name配置），则生成类名+方法名+(参数类型)作为缓存实例名称 然后调用__createOrGetCache方法 __createOrGetCache方法： 通过缓存实例管理器SimpleCacheManager根据缓存区域area和缓存实例名称cacheName获取缓存实例对象，如果不为null则直接返回，判断缓存实例对象是否为null为进行两次确认，第二次会给当前CacheContext加锁进行判断，避免线程不安全 缓存实例对象还是为null的话，先判断缓存区域area是否添加至缓存实例名称中，是的话”area_cacheName”为缓存实例名称，然后调用buildCache方法创建一个缓存实例对象 buildCache方法：根据缓存实例类型构建不同的缓存实例对象，处理逻辑如下： CacheType为LOCAL则调用buildLocal方法： 1234567891011121314151.1. 从GlobalCacheConfig全局配置的localCacheBuilders（保存本地缓存CacheBuilder构造器的集合）中的获取本地缓存该缓存区域的构造器，在之前讲到的&#x27;JetCacheAutoConfiguration自动配置&#x27;中有说到过，会将初始化好的构造器从AutoConfigureBeans中添加至GlobalCacheConfig中1.2. 克隆一个 CacheBuilder 构造器，因为不同缓存实例有不同的配置1.3. 将缓存注解的配置信息设置到构造器中，有以下配置： - 如果配置了localLimit，则设置本地缓存最大数量limit的值 - 如果CacheType为BOTH并且配置了localExpire（大于0），则设置有效时间expireAfterWrite的值为localExpire，否则如果配置的expire大于0，则设置其值为expire - 如果配置了keyConvertor，则根据该值生成一个转换函数，没有配置的话在初始化构造器的时候根据全局配置可能已经生成了一个转换函数（我一般在全局配置中设置） - 设置是否缓存null值1.4. 通过调用构造器的buildCache()方法构建一个缓存实例对象，该方法在之前讲到的&#x27;CacheBuilder构造器&#x27;中有分析过 CacheType为REMOTE则调用buildRemote方法： 12345678910111213141516171.1. 从GlobalCacheConfig全局配置的remoteCacheBuilders（保存远程缓存CacheBuilder构造器的集合）中的获取远程缓存该缓存区域的构造器1.2. 克隆一个 CacheBuilder 构造器，因为不同缓存实例有不同的配置1.3. 将缓存注解的配置信息设置到构造器中，有以下配置： - 如果配置了expire，则设置远程缓存有效时间expireAfterWrite的值 - 如果全局设置远程缓存的缓存key的前缀keyPrefix，则设置缓存key的前缀为&quot;keyPrefix+cacheName&quot;，否则我为&quot;cacheName&quot; - 如果配置了keyConvertor，则根据该值生成一个转换函数，没有配置的话在初始化构造器的时候根据全局配置可能已经生成了一个转换函数（我一般在全局配置中设置） - 如果设置了serialPolicy，则根据该值生成编码和解码函数，没有配置的话在初始化构造器的时候根据全局配置可能已经生成了编码函数和解码函数（我一般在全局配置中设置） - 设置是否缓存null值1.4. 通过调用构造器的buildCache()方法构建一个缓存实例对象 CacheType为BOTH则调用buildLocal方法构建本地缓存实例，调用buildRemote方法构建远程缓存实例： 123451.1. 创建一个MultiLevelCacheBuilder构造器1.2. 设置有效时间为远程缓存的有效时间、添加local和remote缓存实例、设置是否单独配置了本地缓存的失效时间（是否有配置localExpire）、设置是否缓存null值1.3. 通过调用构造器的buildCache()方法构建一个缓存实例对象 设置刷新策略RefreshPolicy，没有的话为null 将缓存实例对象封装成CacheHandlerRefreshCache对象，用于后续的添加刷新任务，在之前的’AbstractCache抽象类’有讲到 设置是否开启缓存未命中时加载方法的保护模式，全局默认为false 将缓存实例添加至监控管理器中 JetCacheInterceptor被拦截后的处理在com.alicp.jetcache.anno.aop.JetCacheInterceptor中，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class JetCacheInterceptor implements MethodInterceptor, ApplicationContextAware &#123; private static final Logger logger = LoggerFactory.getLogger(JetCacheInterceptor.class); /** * 缓存实例注解信息 */ @Autowired private ConfigMap cacheConfigMap; /** * Spring 上下文 */ private ApplicationContext applicationContext; /** * 缓存的全局配置 */ private GlobalCacheConfig globalCacheConfig; /** * JetCache 缓存的管理器（包含很多信息） */ ConfigProvider configProvider; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; @Override public Object invoke(final MethodInvocation invocation) throws Throwable &#123; if (configProvider == null) &#123; /** * 这里会获取到 SpringConfigProvider 可查看 &#123;@link com.alicp.jetcache.autoconfigure.JetCacheAutoConfiguration&#125; */ configProvider = applicationContext.getBean(ConfigProvider.class); &#125; if (configProvider != null &amp;&amp; globalCacheConfig == null) &#123; globalCacheConfig = configProvider.getGlobalCacheConfig(); &#125; if (globalCacheConfig == null || !globalCacheConfig.isEnableMethodCache()) &#123; return invocation.proceed(); &#125; // 获取被拦截的方法 Method method = invocation.getMethod(); // 获取被拦截的对象 Object obj = invocation.getThis(); CacheInvokeConfig cac = null; if (obj != null) &#123; // 获取改方法的Key(方法所在类名+方法名+(参数类型)+方法返回类型+_被拦截的类名) String key = CachePointcut.getKey(method, obj.getClass()); // 获取该方法的缓存注解信息，在 Pointcut 中已经对注解进行解析并放入 ConfigMap 中 cac = cacheConfigMap.getByMethodInfo(key); &#125; if(logger.isTraceEnabled())&#123; logger.trace(&quot;JetCacheInterceptor invoke. foundJetCacheConfig=&#123;&#125;, method=&#123;&#125;.&#123;&#125;(), targetClass=&#123;&#125;&quot;, cac != null, method.getDeclaringClass().getName(), method.getName(), invocation.getThis() == null ? null : invocation.getThis().getClass().getName()); &#125; // 无缓存相关注解配置信息表明无须缓存，直接执行该方法 if (cac == null || cac == CacheInvokeConfig.getNoCacheInvokeConfigInstance()) &#123; return invocation.proceed(); &#125; // 为本次调用创建一个上下文对象，包含对应的缓存实例 CacheInvokeContext context = configProvider.getCacheContext().createCacheInvokeContext(cacheConfigMap); context.setTargetObject(invocation.getThis()); context.setInvoker(invocation::proceed); context.setMethod(method); context.setArgs(invocation.getArguments()); context.setCacheInvokeConfig(cac); context.setHiddenPackages(globalCacheConfig.getHiddenPackages()); // 继续往下执行 return CacheHandler.invoke(context); &#125; public void setCacheConfigMap(ConfigMap cacheConfigMap) &#123; this.cacheConfigMap = cacheConfigMap; &#125;&#125; 从ConfigMap中获取被拦截的方法对象的缓存配置信息，如果没有则直接执行该方法，否则继续往下执行 根据CacheContext对象（SpringCacheContext，因为在之前讲到的’JetCacheAutoConfiguration自动配置’中有说到注入的是SpringConfigProvider对象，在其初始化方法中调用newContext()方法生成SpringCacheContext）调用其createCacheInvokeContext方法为本次调用创建一个上下文CacheInvokeContext，并设置获取缓存实例函数，具体实现逻辑查看上面讲到的CacheContext 设置本次调用上下文的targetObject为被拦截对象，invoker为被拦截对象的调用器，method为被拦截方法，args为方法入参，cacheInvokeConfig为缓存配置信息，hiddenPackages为缓存实例名称需要截断的包名 通过CacheHandler的invoke方法继续往下执行 CacheHandlercom.alicp.jetcache.anno.method.CacheHandler用于JetCache处理被拦截的方法，部分代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115public class CacheHandler implements InvocationHandler &#123; public static Object invoke(CacheInvokeContext context) throws Throwable &#123; if (context.getCacheInvokeConfig().isEnableCacheContext()) &#123; try &#123; CacheContextSupport._enable(); return doInvoke(context); &#125; finally &#123; CacheContextSupport._disable(); &#125; &#125; else &#123; return doInvoke(context); &#125; &#125; private static Object doInvoke(CacheInvokeContext context) throws Throwable &#123; // 获取缓存实例配置 CacheInvokeConfig cic = context.getCacheInvokeConfig(); // 获取注解配置信息 CachedAnnoConfig cachedConfig = cic.getCachedAnnoConfig(); if (cachedConfig != null &amp;&amp; (cachedConfig.isEnabled() || CacheContextSupport._isEnabled())) &#123; // 经过缓存中获取结果 return invokeWithCached(context); &#125; else if (cic.getInvalidateAnnoConfigs() != null || cic.getUpdateAnnoConfig() != null) &#123; // 根据结果删除或者更新缓存 return invokeWithInvalidateOrUpdate(context); &#125; else &#123; // 执行该方法 return invokeOrigin(context); &#125; &#125; private static Object invokeWithCached(CacheInvokeContext context) throws Throwable &#123; // 获取本地调用的上下文 CacheInvokeConfig cic = context.getCacheInvokeConfig(); // 获取注解配置信息 CachedAnnoConfig cac = cic.getCachedAnnoConfig(); // 获取缓存实例对象（不存在则会创建并设置到 cac 中） // 可在 JetCacheInterceptor 创建本次调用的上下文时，调用 createCacheInvokeContext(cacheConfigMap) 方法中查看详情 Cache cache = context.getCacheFunction().apply(context, cac); if (cache == null) &#123; logger.error(&quot;no cache with name: &quot; + context.getMethod()); // 无缓存实例对象，执行原有方法 return invokeOrigin(context); &#125; // 生成缓存 Key 对象（注解中没有配置的话就是入参，没有入参则为 &quot;_$JETCACHE_NULL_KEY$_&quot; ） Object key = ExpressionUtil.evalKey(context, cic.getCachedAnnoConfig()); if (key == null) &#123; // 生成缓存 Key 失败则执行原方法，并记录 CacheLoadEvent 事件 return loadAndCount(context, cache, key); &#125; /* * 根据配置的 condition 来决定是否走缓存 * 缓存注解中没有配置 condition 表示所有请求都走缓存 * 配置了 condition 表示满足条件的才走缓存 */ if (!ExpressionUtil.evalCondition(context, cic.getCachedAnnoConfig())) &#123; // 不满足 condition 则直接执行原方法，并记录 CacheLoadEvent 事件 return loadAndCount(context, cache, key); &#125; try &#123; // 创建一个执行原有方法的函数 CacheLoader loader = new CacheLoader() &#123; @Override public Object load(Object k) throws Throwable &#123; Object result = invokeOrigin(context); context.setResult(result); return result; &#125; @Override public boolean vetoCacheUpdate() &#123; // 本次执行原方法后是否需要更新缓存 return !ExpressionUtil.evalPostCondition(context, cic.getCachedAnnoConfig()); &#125; &#125;; // 获取结果 Object result = cache.computeIfAbsent(key, loader); return result; &#125; catch (CacheInvokeException e) &#123; throw e.getCause(); &#125; &#125; private static Object loadAndCount(CacheInvokeContext context, Cache cache, Object key) throws Throwable &#123; long t = System.currentTimeMillis(); Object v = null; boolean success = false; try &#123; // 调用原有方法 v = invokeOrigin(context); success = true; &#125; finally &#123; t = System.currentTimeMillis() - t; // 发送 CacheLoadEvent 事件 CacheLoadEvent event = new CacheLoadEvent(cache, t, key, v, success); while (cache instanceof ProxyCache) &#123; cache = ((ProxyCache) cache).getTargetCache(); &#125; if (cache instanceof AbstractCache) &#123; ((AbstractCache) cache).notify(event); &#125; &#125; return v; &#125; private static Object invokeOrigin(CacheInvokeContext context) throws Throwable &#123; // 执行被拦截的方法 return context.getInvoker().invoke(); &#125;&#125; 直接查看invokeWithCached方法： 获取缓存注解信息 根据本地调用的上下文CacheInvokeContext获取缓存实例对象（调用其cacheFunction函数），在CacheContext中有讲到 如果缓存实例不存在则直接调用invokeOrigin方法，执行被拦截的对象的调用器 根据本次调用的上下文CacheInvokeContext生成缓存key，根据配置的缓存key的SpEL表达式生成，如果没有配置则返回入参对象，如果没有对象则返回”_ $JETCACHE_NULL_KEY$_” 根据配置condition表达式判断是否需要走缓存 创建一个CacheLoader对象，用于执行被拦截的对象的调用器，也就是加载原有方法 调用缓存实例的computeIfAbsent(key, loader)方法获取结果，这个方法的处理过程可查看’缓存API’这一小节 至此结束！！！😄😄😄 文章转自：https://www.cnblogs.com/lifullmoon/p/13854158.html","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://jlynet.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"java","slug":"java","permalink":"https://jlynet.github.io/tags/java/"}]},{"title":"各种开源协议介绍","slug":"各种开源协议介绍","date":"2021-09-29T10:34:05.000Z","updated":"2021-09-29T10:40:52.000Z","comments":true,"path":"2021/09/29/各种开源协议介绍/","link":"","permalink":"https://jlynet.github.io/2021/09/29/%E5%90%84%E7%A7%8D%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"世界上的开源许可证（Open Source License）大概有上百种，今天我们来介绍下几种我们常见的开源协议。大致有GPL、BSD、MIT、Mozilla、Apache和LGPL等。 Apache LicenseApache License（Apache许可证），是Apache软件基金会发布的一个自由软件许可证。 Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和最终原作者的著作权，同样允许源代码修改和再发布。但是也需要遵循以下条件： 需要给代码的用户一份Apache Licence。 如果修改了代码，需要再被修改的文件中说明。 在衍生的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。 如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以再Notice中增加自己的许可，但是不可以表现为对Apache Licence构成更改。 Apache Licence也是对商业应用友好的许可。使用者也可以再需要的时候修改代码来满足并作为开源或商业产品发布/销售。 使用这个协议的好处是: 永久权利 一旦被授权，永久拥有。 全球范围的权利 在一个国家获得授权，适用于所有国家。假如你在美国，许可是从印度授权的，也没有问题。 授权免费 无版税， 前期、后期均无任何费用。 授权无排他性 任何人都可以获得授权 授权不可撤消 一旦获得授权，没有任何人可以取消。比如，你基于该产品代码开发了衍生产品，你不用担心会在某一天被禁止使用该代码 BSDBSD是”Berkeley Software Distribution”的缩写，意思是”伯克利软件发行版”。 BSD开源协议：是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。 当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件： 1． 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。 2． 如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。 3． 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。 BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。 GPLGPL （GNU General Public License） ：GNU通用公共许可协议。 Linux 采用了 GPL。 GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。 LGPLLGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。 但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。 GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。 MITMIT是和BSD一样宽范的许可协议,源自麻省理工学院（Massachusetts Institute of Technology, MIT），又称X11协议。作者只想保留版权,而无任何其他了限制。MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。 MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。 MPL (Mozilla Public License 1.1)MPL协议允许免费重发布、免费修改，但要求修改后的代码版权归软件的发起者 。这种授权维护了商业软件的利益，它要求基于这种软件的修改无偿贡献版权给该软件。这样，围绕该软件的所有代码的版权都集中在发起开发人的手中。但MPL是允许修改，无偿使用得。MPL软件对链接没有要求。 EPL (Eclipse Public License 1.0)EPL允许Recipients任意使用、复制、分发、传播、展示、修改以及改后闭源的二次商业发布。 使用EPL协议，需要遵守以下规则： 当一个Contributors将源码的整体或部分再次开源发布的时候,必须继续遵循EPL开源协议来发布,而不能改用其他协议发布.除非你得到了原”源码”Owner 的授权； EPL协议下,你可以将源码不做任何修改来商业发布.但如果你要发布修改后的源码,或者当你再发布的是Object Code的时候,你必须声明它的Source Code是可以获取的,而且要告知获取方法； 当你需要将EPL下的源码作为一部分跟其他私有的源码混和着成为一个Project发布的时候,你可以将整个Project/Product以私人的协议发布,但要声明哪一部分代码是EPL下的,而且声明那部分代码继续遵循EPL； 4.独立的模块(Separate Module),不需要开源。 Creative Commons 知识共享协议Creative Commons (CC) 许可协议并不能说是真正的开源协议，它们大多是被使用于设计类的工程上。 CC 协议种类繁多，每一种都授权特定的权利。 一个 CC 许可协议具有四个基本部分，这几个部分可以单独起作用，也可以组合起来。下面是这几部分的简介： 1、署名 作品上必须附有作品的归属。如此之后，作品可以被修改，分发，复制和其它用途。 2、相同方式共享 作品可以被修改、分发或其它操作，但所有的衍生品都要置于CC许可协议下。 3、非商业用途 作品可以被修改、分发等等，但不能用于商业目的。但语言上对什么是”商业”的说明十分含糊不清 (没有提供精确的定义)，所以你可以在你的工程里对其进行说明。例如，有些人简单的解释”非商业”为不能出售这个作品。而另外一些人认为你甚至不能在有广告的网站上使用它们。 还有些人认为”商业”仅仅指你用它获取利益。 4、禁止衍生作品 CC 许可协议的这些条款可以自由组合使用。大多数的比较严格的CC协议会声明 “署名权，非商业用途，禁止衍生”条款，这意味着你可以自由的分享这个作品，但你不能改变它和对其收费，而且必须声明作品的归属。这个许可协议非常的有用，它可以让你的作品传播出去，但又可以对作品的使用保留部分或完全的控制。最少限制的CC协议类型当属 “署名”协议，这意味着只要人们能维护你的名誉，他们对你的作品怎么使用都行。 CC 许可协议更多的是在设计类工程中使用，而不是开发类，但没有人或妨碍你将之使用与后者。只是你必须要清楚各部分条款能覆盖到的和不能覆盖到的权利。 图解分析 文章拷贝来源：https://www.runoob.com/w3cnote/open-source-license.html","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"},{"name":"技术笔记","slug":"默认分类/技术笔记","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://jlynet.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"随笔","slug":"随笔","permalink":"https://jlynet.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"hexo","slug":"hexo","permalink":"https://jlynet.github.io/tags/hexo/"}]},{"title":"PHP和Java中的SHA256","slug":"PHP和Java中的SHA256","date":"2021-08-16T14:44:29.000Z","updated":"2021-08-16T14:47:18.000Z","comments":true,"path":"2021/08/16/PHP和Java中的SHA256/","link":"","permalink":"https://jlynet.github.io/2021/08/16/PHP%E5%92%8CJava%E4%B8%AD%E7%9A%84SHA256/","excerpt":"","text":"我正在将一些Java代码移植到PHP代码中.在Java中,我有一个哈希SHA256代码,如下所示： 1234567891011public static String hashSHA256(String input) throws NoSuchAlgorithmException &#123; MessageDigest mDigest = MessageDigest.getInstance(&quot;SHA-256&quot;);byte[] shaByteArr = mDigest.digest(input.getBytes(Charset.forName(&quot;UTF-8&quot;))); StringBuilder hexStrBuilder = new StringBuilder(); for (int i = 0; i &lt; shaByteArr.length; i++) &#123; hexStrBuilder.append(Integer.toHexString(0xFF &amp; shaByteArr[i])); &#125; return hexStrBuilder.toString();&#125; 在PHP中,我哈希如下： 1$hash = hash(&quot;sha256&quot;, utf8_encode($input)); 我用input =“test”运行示例代码.但是,我得到了2个不同的哈希字符串： 12Java: 9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2bb822cd15d6c15b0f0a8PHP: 9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08 有人可以向我解释为什么以及如何让它们相互匹配？请注意,我无法修改Java实现代码,只能修改PHP. 万分感激！ 解决方法:PHP版本是正确的;测试的SHA-256校验和是9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08.Java版本返回相同的校验和,其中两个0被剥离.这是因为您将字节转换为十六进制的方式.而不是使用0xFF&amp; ing使用它们,使用String.format(),如this answer： 1hexStrBuilder.append(String.format(&quot;%02x&quot;, shaByteArr[i])); 修改方法： public static String hashSHA256(String input) throws NoSuchAlgorithmException &#123; MessageDigest mDigest = MessageDigest.getInstance(&quot;SHA-256&quot;); byte[] shaByteArr = mDigest.digest(input.getBytes(Charset.forName(&quot;UTF-8&quot;))); StringBuilder hexStrBuilder = new StringBuilder(); for (int i = 0; i &lt; shaByteArr.length; i++) &#123; //hexStrBuilder.append(Integer.toHexString(0xFF &amp; shaByteArr[i])); hexStrBuilder.append(String.format(&quot;%02x&quot;, shaByteArr[i])); &#125; return hexStrBuilder.toString(); &#125; 我意识到你说你不能修改Java代码,但它是不正确的！ 来源： https://codeday.me/bug/20190725/1530972.html","categories":[{"name":"其他","slug":"其他","permalink":"https://jlynet.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://jlynet.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"java","slug":"java","permalink":"https://jlynet.github.io/tags/java/"},{"name":"php","slug":"php","permalink":"https://jlynet.github.io/tags/php/"}]},{"title":"Arthas classloader命令","slug":"Java诊断工具Arthas高级命令教程/Arthasclassloader命令","date":"2021-08-07T01:51:45.000Z","updated":"2021-09-29T02:51:44.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthasclassloader命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasclassloader%E5%91%BD%E4%BB%A4/","excerpt":"","text":"启动demo 启动arthas-boot classloader命令 参数说明 使用参考 列出所有ClassLoader 列出ClassLoader里加载的所有类 查看类的classloader层次 查看ClassLoader树 查看URLClassLoader实际的urls 加载指定ClassLoader里的资源文件 尝试加载指定的类 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个普通的Spring Boot应用为例，演示classloader命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动demo下载demo-arthas-spring-boot.jar，再用java -jar命令启动： 1wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar demo-arthas-spring-boot是一个很简单的spring boot应用，源代码：查看 启动之后，可以访问61000端口： 点击查看 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help classloader命令 查看classloader的继承树，urls，类加载信息 classloader 命令将 JVM 中所有的classloader的信息统计出来，并可以展示继承树，urls等。 可以让指定的classloader去getResources，打印出所有查找到的resources的url。对于ResourceNotFoundException比较有用。 参数说明 参数名称 参数说明 [l] 按类加载实例进行统计 [t] 打印所有ClassLoader的继承树 [a] 列出所有ClassLoader加载的类，请谨慎使用 [c:] ClassLoader的hashcode [classLoaderClass:] 指定执行表达式的 ClassLoader 的 class name [c: r:] 用ClassLoader去查找resource [c: load:] 用ClassLoader去加载指定的类 使用参考先访问一个jsp网页，触发jsp的加载： hello 列出所有ClassLoader1classloader -l 1234567891011121314151617181920$ classloader -l name loadedCount hash parent BootstrapClassLoader 2724 null null com.taobao.arthas.agent.ArthasClassloader@411ce1ab 2009 411ce1ab sun.misc.Launcher$ExtClassLoader@7494e528 com.taobao.arthas.agent.ArthasClassloader@22ae1234 1253 22ae1234 sun.misc.Launcher$ExtClassLoader@7494e528 org.apache.jasper.servlet.JasperLoader@65361d9a 1 65361d9a TomcatEmbeddedWebappClassLoader context: ROOT delegate: true ----------&gt; Parent Classloader: org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3 TomcatEmbeddedWebappClassLoader 0 8546cd5 org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3 context: ROOT delegate: true ----------&gt; Parent Classloader: org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3 org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3 5416 1be6f5c3 sun.misc.Launcher$AppClassLoader@3d4eac69 sun.misc.Launcher$AppClassLoader@3d4eac69 45 3d4eac69 sun.misc.Launcher$ExtClassLoader@7494e528 sun.misc.Launcher$ExtClassLoader@7494e528 4 7494e528 null TomcatEmbeddedWebappClassLoader 加载的class数量是0，所以在spring boot embedded tomcat里，它只是一个空壳，所有的类加载都是LaunchedURLClassLoader完成的 注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。 如果你使用-c，你需要手动输入hashcode：-c &lt;hashcode&gt; 1$ classloader -c 65361d9a 对于只有唯一实例的ClassLoader可以通过--classLoaderClass指定class name，使用起来更加方便： 1$ classloader --classLoaderClass org.apache.jasper.servlet.JasperLoader --classLoaderClass 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而-c &lt;hashcode&gt;是动态变化的。 列出ClassLoader里加载的所有类列出上面的org.apache.jasper.servlet.JasperLoader加载的类： 1classloader -a --classLoaderClass org.apache.jasper.servlet.JasperLoader 123$ classloader -a --classLoaderClass org.apache.jasper.servlet.JasperLoader hash:1698045338, org.apache.jasper.servlet.JasperLoader@65361d9a org.apache.jsp.jsp.hello_jsp 查看类的classloader层次1sc -d org.apache.jsp.jsp.hello_jsp 查看ClassLoader树1classloader -t 12345678910111213$ classloader -t+-BootstrapClassLoader+-sun.misc.Launcher$ExtClassLoader@28cbbddd +-com.taobao.arthas.agent.ArthasClassloader@8c25e55 +-sun.misc.Launcher$AppClassLoader@55f96302 +-org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3 +-TomcatEmbeddedWebappClassLoader context: ROOT delegate: true ----------&gt; Parent Classloader: org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3 +-org.apache.jasper.servlet.JasperLoader@21ae0fe2 查看URLClassLoader实际的urls比如上面查看到的spring LaunchedURLClassLoader的 hashcode是1be6f5c3，可以通过-c参数来指定classloader，或者直接使用--classLoaderClass，从而查看URLClassLoader实际的urls： 1classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader 12345$ classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoaderjar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/classes!/jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/lib/spring-boot-starter-aop-1.5.13.RELEASE.jar!/... 加载指定ClassLoader里的资源文件查找指定的资源文件： classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml 1classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml 12$ classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/classes!/logback-spring.xml 也可以尝试查找类的class文件： 1classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r java/lang/String.class 12$ classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r java/lang/String.class jar:file:/Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/Home/jre/lib/rt.jar!/java/lang/String.class 尝试加载指定的类比如用上面的spring LaunchedURLClassLoader 尝试加载 ch.qos.logback.classic.spi.StackTraceElementProxy ： 首先使用sc ch.qos.logback.classic.spi.StackTraceElementProxy查看，可发现未加载： 1sc ch.qos.logback.classic.spi.StackTraceElementProxy 1Affect(row-cnt:0) cost in 18 ms. 因而使用spring LaunchedURLClassLoader 尝试加载： 1classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader --load ch.qos.logback.classic.spi.StackTraceElementProxy 123456789101112131415161718192021222324$ classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader --load ch.qos.logback.classic.spi.StackTraceElementProxyload class success. class-info ch.qos.logback.classic.spi.StackTraceElementProxy code-source file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/lib/logback-classic-1. 1.11.jar!/ name ch.qos.logback.classic.spi.StackTraceElementProxy isInterface false isAnnotation false isEnum false isAnonymousClass false isArray false isLocalClass false isMemberClass false isPrimitive false isSynthetic false simple-name StackTraceElementProxy modifier public annotation interfaces java.io.Serializable super-class +-java.lang.Object class-loader +-org.springframework.boot.loader.LaunchedURLClassLoader@5674cd4d +-sun.misc.Launcher$AppClassLoader@70dea4e +-sun.misc.Launcher$ExtClassLoader@56a96482 classLoaderHash 5674cd4d 再次使用sc ch.qos.logback.classic.spi.StackTraceElementProxy查看，发现已经加载： 1sc ch.qos.logback.classic.spi.StackTraceElementProxy 12ch.qos.logback.classic.spi.StackTraceElementProxyAffect(row-cnt:1) cost in 19 ms. 更多信息在“classloader”中，我们演示了了Arthas的classloader命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas dump命令","slug":"Java诊断工具Arthas高级命令教程/Arthasdump命令","date":"2021-08-07T01:51:44.000Z","updated":"2021-09-29T02:51:42.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthasdump命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasdump%E5%91%BD%E4%BB%A4/","excerpt":"","text":"启动arthas demo 启动arthas-boot dump命令 参数说明 使用参考 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示dump命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help dump命令 dump 已加载类的 bytecode 到特定目录 参数说明 参数名称 参数说明 class-pattern 类名表达式匹配 [c:] 类所属 ClassLoader 的 hashcode [d:] 设置类文件的目标目录 [classLoaderClass:] 指定执行表达式的 ClassLoader 的 class name [E] 开启正则表达式匹配，默认为通配符匹配 使用参考1dump java.lang.String 12345$ dump java.lang.String HASHCODE CLASSLOADER LOCATION null /Users/admin/logs/arthas/classdump/java/lang/String.classAffect(row-cnt:1) cost in 119 ms.dump demo.* 123456$ dump demo.* HASHCODE CLASSLOADER LOCATION 3d4eac69 +-sun.misc.Launcher$AppClassLoader@3d4eac69 /Users/admin/logs/arthas/classdump/sun.misc.Launcher$AppClassLoader-3d4eac69/demo/MathGame.class +-sun.misc.Launcher$ExtClassLoader@66350f69Affect(row-cnt:1) cost in 39 ms.dump -d /tmp/output java.lang.String 1234$ dump -d /tmp/output java.lang.String HASHCODE CLASSLOADER LOCATION null /tmp/output/java/lang/String.classAffect(row-cnt:1) cost in 138 ms. 指定classLoader 注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。 如果你使用-c，你需要手动输入hashcode：-c &lt;hashcode&gt; 1$ dump -c 3d4eac69 demo.* 对于只有唯一实例的ClassLoader可以通过--classLoaderClass指定class name，使用起来更加方便： 1dump --classLoaderClass sun.misc.Launcher$AppClassLoader demo.* 12345$ dump --classLoaderClass sun.misc.Launcher$AppClassLoader demo.* HASHCODE CLASSLOADER LOCATION 3d4eac69 +-sun.misc.Launcher$AppClassLoader@3d4eac69 /Users/admin/logs/arthas/classdump/sun.misc.Launcher$AppClassLoader-3d4eac69/demo/MathGame.class +-sun.misc.Launcher$ExtClassLoader@66350f69Affect(row-cnt:1) cost in 39 ms. 注: 这里classLoaderClass 在 java 8 是 sun.misc.Launcher$AppClassLoader，而java 11的classloader是jdk.internal.loader.ClassLoaders$AppClassLoader，katacoda目前环境是java8。 --classLoaderClass 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而-c &lt;hashcode&gt;是动态变化的。 更多信息在“dump”中，我们演示了了Arthas的dump命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas jad命令","slug":"Java诊断工具Arthas高级命令教程/Arthasjad命令","date":"2021-08-07T01:51:44.000Z","updated":"2021-09-29T02:51:50.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthasjad命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasjad%E5%91%BD%E4%BB%A4/","excerpt":"","text":"启动arthas demo 启动arthas-boot jad命令 参数说明 使用参考 编译java.lang.String 反编译时只显示源代码 反编译指定的函数 反编译时指定ClassLoader 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示jad命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help jad命令 反编译指定已加载类的源码 jad 命令将 JVM 中实际运行的 class 的 byte code 反编译成 java 代码，便于你理解业务逻辑； 在 Arthas Console 上，反编译出来的源码是带语法高亮的，阅读更方便 当然，反编译出来的 java 代码可能会存在语法错误，但不影响你进行阅读理解 参数说明 参数名称 参数说明 class-pattern 类名表达式匹配 [c:] 类所属 ClassLoader 的 hashcode [classLoaderClass:] 指定执行表达式的 ClassLoader 的 class name [E] 开启正则表达式匹配，默认为通配符匹配 使用参考编译java.lang.String1jad java.lang.String 123456789101112131415161718192021222324252627$ jad java.lang.StringClassLoader:Location:/** Decompiled with CFR 0_132.*/package java.lang;import java.io.ObjectStreamField;...public final class Stringimplements Serializable,Comparable&lt;String&gt;,CharSequence &#123; private final char[] value; private int hash; private static final long serialVersionUID = -6849794470754667710L; private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0]; public static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER = new CaseInsensitiveComparator(); public String(byte[] arrby, int n, int n2) &#123; String.checkBounds(arrby, n, n2); this.value = StringCoding.decode(arrby, n, n2); &#125;... 反编译时只显示源代码默认情况下，反编译结果里会带有ClassLoader信息，通过--source-only选项，可以只打印源代码。方便和mc/redefine命令结合使用。 1jad --source-only java.lang.String 123456789101112131415161718192021$ jad --source-only java.lang.String... @Override public int compare(String string, String string2) &#123; int n = string.length(); int n2 = string2.length(); int n3 = Math.min(n, n2); for (int i = 0; i &lt; n3; ++i) &#123; char c; char c2 = string.charAt(i); if (c2 == (c = string2.charAt(i)) || (c2 = Character.toUpperCase(c2)) == (c = Character.toUpperCase(c)) || (c2 = Character.toLowerCase(c2)) == (c = Character.toLowerCase(c))) continue; return c2 - c; &#125; return n - n2; &#125; private Object readResolve() &#123; return String.CASE_INSENSITIVE_ORDER; &#125; &#125;&#125; 反编译指定的函数1jad java.lang.String toString 1234567891011$ jad java.lang.String toStringClassLoader:Location:@Overridepublic String toString() &#123; return this;&#125;Affect(row-cnt:2) cost in 407 ms. 反编译时指定ClassLoader 当有多个 ClassLoader 都加载了这个类时，jad 命令会输出对应 ClassLoader 实例的 hashcode，然后你只需要重新执行 jad 命令，并使用参数 -c &lt;hashcode&gt; 就可以反编译指定 ClassLoader 加载的那个类了； 例如： 123456789101112$ jad org.apache.log4j.LoggerFound more than one class for: org.apache.log4j.Logger, Please use jad -c hashcode org.apache.log4j.LoggerHASHCODE CLASSLOADER69dcaba4 +-monitor&#x27;s ModuleClassLoader6e51ad67 +-java.net.URLClassLoader@6e51ad67 +-sun.misc.Launcher$AppClassLoader@6951a712 +-sun.misc.Launcher$ExtClassLoader@6fafc4c22bdd9114 +-pandora-qos-service&#x27;s ModuleClassLoader4c0df5f8 +-pandora-framework&#x27;s ModuleClassLoaderAffect(row-cnt:0) cost in 38 ms. 123456789101112131415161718192021222324$ jad org.apache.log4j.Logger -c 69dcaba4ClassLoader:+-monitor&#x27;s ModuleClassLoaderLocation:/Users/admin/app/log4j-1.2.14.jarpackage org.apache.log4j;import org.apache.log4j.spi.*;public class Logger extends Category&#123; private static final String FQCN; protected Logger(String name) &#123; super(name); &#125;...Affect(row-cnt:1) cost in 190 ms. 对于只有唯一实例的ClassLoader还可以通过--classLoaderClass指定class name，使用起来更加方便： --classLoaderClass 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而-c &lt;hashcode&gt;是动态变化的。 更多信息在“heapdump”中，我们演示了了Arthas的heapdump命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas mc-redefine命令","slug":"Java诊断工具Arthas高级命令教程/Arthasmc-redefine命令","date":"2021-08-07T01:51:43.000Z","updated":"2021-09-29T02:52:08.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthasmc-redefine命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasmc-redefine%E5%91%BD%E4%BB%A4/","excerpt":"","text":"启动demo 启动arthas-boot mc命令 redefine命令 常见问题 参数说明 redefine的限制 热更新代码 jad反编译UserController sc查找加载UserController的ClassLoader mc redefine 热修改代码结果 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个普通的Spring Boot应用为例，演示mc-redefine命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动demo下载demo-arthas-spring-boot.jar，再用java -jar命令启动： 1wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar demo-arthas-spring-boot是一个很简单的spring boot应用，源代码：查看 启动之后，可以访问61000端口： 点击查看 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help mc命令 Memory Compiler/内存编译器，编译.java文件生成.class。 可以通过-c/--classLoaderClass参数指定classloader，-d参数指定输出目录 编译生成.class文件之后，可以结合redefine命令实现热更新代码。 redefine命令 加载外部的.class文件，redefine jvm已加载的类。 参考：Instrumentation#redefineClasses 常见问题 redefine的class不能修改、添加、删除类的field和method，包括方法参数、方法名称及返回值 如果mc失败，可以在本地开发环境编译好class文件，上传到目标系统，使用redefine热加载class 目前redefine 和watch/trace/jad/tt等命令冲突，以后重新实现redefine功能会解决此问题 注意， redefine后的原来的类不能恢复，redefine有可能失败（比如增加了新的field），参考jdk本身的文档。 reset命令对redefine的类无效。如果想重置，需要redefine原始的字节码。 redefine命令和jad/watch/trace/monitor/tt等命令会冲突。执行完redefine之后，如果再执行上面提到的命令，则会把redefine的字节码重置。 原因是jdk本身redefine和Retransform是不同的机制，同时使用两种机制来更新字节码，只有最后修改的会生效。 参数说明 参数名称 参数说明 [c:] ClassLoader的hashcode [classLoaderClass:] 指定执行表达式的 ClassLoader 的 class name [p:] 外部的.class文件的完整路径，支持多个 redefine的限制 不允许新增加field/method 正在跑的函数，没有退出不能生效。 热更新代码下面介绍通过jad/mc/redefine 命令实现动态更新代码的功能。 目前，访问 http://localhost:61000/user/0 ，会返回500异常： 1curl http://localhost:61000/user/0 1&#123;&quot;timestamp&quot;:1550223186170,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;exception&quot;:&quot;java.lang.IllegalArgumentException&quot;,&quot;message&quot;:&quot;id &lt; 1&quot;,&quot;path&quot;:&quot;/user/0&quot;&#125; 下面通过热更新代码，修改这个逻辑。 jad反编译UserController1jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java jad反编译的结果保存在 /tmp/UserController.java文件里了。 再打开一个Terminal 3，然后用vim来编辑/tmp/UserController.java： 1vim /tmp/UserController.java 比如当 user id 小于1时，也正常返回，不抛出异常： 123456789@GetMapping(value=&#123;&quot;/user/&#123;id&#125;&quot;&#125;)public User findUserById(@PathVariable Integer id) &#123; logger.info(&quot;id: &#123;&#125;&quot;, (Object)id); if (id != null &amp;&amp; id &lt; 1) &#123; return new User(id, &quot;name&quot; + id); // throw new IllegalArgumentException(&quot;id &lt; 1&quot;); &#125; return new User(id.intValue(), &quot;name&quot; + id);&#125; sc查找加载UserController的ClassLoader1sc -d *UserController | grep classLoaderHash 12$ sc -d *UserController | grep classLoaderHash classLoaderHash 1be6f5c3 可以发现是 spring boot LaunchedURLClassLoader@1be6f5c3 加载的。 注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。 如果你使用-c，你需要手动输入hashcode：-c &lt;hashcode&gt; 对于只有唯一实例的ClassLoader可以通过--classLoaderClass指定class name，使用起来更加方便. --classLoaderClass 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而-c &lt;hashcode&gt;是动态变化的。 mc保存好/tmp/UserController.java之后，使用mc(Memory Compiler)命令来编译，并且通过--classLoaderClass参数指定ClassLoader： 1mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmp 1234$ mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmpMemory compiler output:/tmp/com/example/demo/arthas/user/UserController.classAffect(row-cnt:1) cost in 346 ms 也可以通过mc -c &lt;classLoaderHash&gt; /tmp/UserController.java -d /tmp，使用-c参数指定ClassLoaderHash: 1$ mc -c 1be6f5c3 /tmp/UserController.java -d /tmp redefine再使用redefine命令重新加载新编译好的UserController.class： 1redefine /tmp/com/example/demo/arthas/user/UserController.class 12$ redefine /tmp/com/example/demo/arthas/user/UserController.classredefine success, size: 1 热修改代码结果redefine成功之后，再次访问 user/0 ，结果是： 1234&#123; &quot;id&quot;: 0, &quot;name&quot;: &quot;name0&quot;&#125; 更多信息在“mc-redefine”中，我们演示了了Arthas的mc-redefine命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas sc命令","slug":"Java诊断工具Arthas高级命令教程/Arthassc命令","date":"2021-08-07T01:51:42.000Z","updated":"2021-09-29T02:52:28.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthassc命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthassc%E5%91%BD%E4%BB%A4/","excerpt":"","text":"启动arthas demo 启动arthas-boot sc命令 参数说明 参数说明 使用参考 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示sc命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help sc命令 查看JVM已加载的类信息 “Search-Class” 的简写，这个命令能搜索出所有已经加载到 JVM 中的 Class 信息，这个命令支持的参数有 [d]、[E]、[f] 和 [x:]。 参数说明参数说明 参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 方法名表达式匹配 [d] 输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的ClassLoader等详细信息。 如果一个类被多个ClassLoader所加载，则会出现多次 [E] 开启正则表达式匹配，默认为通配符匹配 [f] 输出当前类的成员变量信息（需要配合参数-d一起使用） [x:] 指定输出静态变量时属性的遍历深度，默认为 0，即直接使用 toString 输出 [c:] 指定class的 ClassLoader 的 hashcode [classLoaderClass:] 指定执行表达式的 ClassLoader 的 class name [n:] 具有详细信息的匹配类的最大数量（默认为100） class-pattern支持全限定名，如com.taobao.test.AAA，也支持com/taobao/test/AAA这样的格式，这样，我们从异常堆栈里面把类名拷贝过来的时候，不需要在手动把/替换为.啦。 sc 默认开启了子类匹配功能，也就是说所有当前类的子类也会被搜索出来，想要精确的匹配，请打开options disable-sub-class true开关 使用参考 模糊搜索 sc demo.* 1sc demo.* 123$ sc demo.*demo.MathGameAffect(row-cnt:1) cost in 55 ms. 打印类的详细信息 sc -d demo.MathGame 1sc -d demo.MathGame 1234567891011121314151617181920212223$ sc -d demo.MathGameclass-info demo.MathGamecode-source /private/tmp/arthas-demo.jarname demo.MathGameisInterface falseisAnnotation falseisEnum falseisAnonymousClass falseisArray falseisLocalClass falseisMemberClass falseisPrimitive falseisSynthetic falsesimple-name MathGamemodifier publicannotationinterfacessuper-class +-java.lang.Objectclass-loader +-sun.misc.Launcher$AppClassLoader@3d4eac69 +-sun.misc.Launcher$ExtClassLoader@66350f69classLoaderHash 3d4eac69Affect(row-cnt:1) cost in 875 ms. 指定classLoader 注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。 如果你使用-c，你需要手动输入hashcode：-c &lt;hashcode&gt; 1$ sc -c 3d4eac69 -d demo* 对于只有唯一实例的ClassLoader可以通过--classLoaderClass指定class name，使用起来更加方便： 1sc --classLoaderClass sun.misc.Launcher$AppClassLoader -d demo* 注: 这里classLoaderClass 在 java 8 是 sun.misc.Launcher$AppClassLoader，而java 11的classloader是jdk.internal.loader.ClassLoaders$AppClassLoader，katacoda目前环境是java8。 --classLoaderClass 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而-c &lt;hashcode&gt;是动态变化的。 打印出类的Field信息 sc -d -f demo.MathGame 1sc -d -f demo.MathGame 12345678910111213141516171819202122232425262728293031$ sc -d -f demo.MathGameclass-info demo.MathGamecode-source /private/tmp/arthas-demo.jarname demo.MathGameisInterface falseisAnnotation falseisEnum falseisAnonymousClass falseisArray falseisLocalClass falseisMemberClass falseisPrimitive falseisSynthetic falsesimple-name MathGamemodifier publicannotationinterfacessuper-class +-java.lang.Objectclass-loader +-sun.misc.Launcher$AppClassLoader@3d4eac69 +-sun.misc.Launcher$ExtClassLoader@66350f69classLoaderHash 3d4eac69fields modifierprivate,static type java.util.Random name random value java.util.Random@522b4 08a modifierprivate type int name illegalArgumentCountAffect(row-cnt:1) cost in 19 ms. 更多信息在“sc”中，我们演示了了Arthas的sc命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas sm命令","slug":"Java诊断工具Arthas高级命令教程/Arthassm命令","date":"2021-08-07T01:51:41.000Z","updated":"2021-09-29T02:52:32.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthassm命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthassm%E5%91%BD%E4%BB%A4/","excerpt":"","text":"启动arthas demo 启动arthas-boot sm命令 参数说明 使用参考 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示sm命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help sm命令 查看已加载类的方法信息 “Search-Method” 的简写，这个命令能搜索出所有已经加载了 Class 信息的方法信息。 sm 命令只能看到由当前类所声明 (declaring) 的方法，父类则无法看到。 参数说明 参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 方法名表达式匹配 [d] 展示每个方法的详细信息 [E] 开启正则表达式匹配，默认为通配符匹配 [c:] 指定class的 ClassLoader 的 hashcode [classLoaderClass:] 指定执行表达式的 ClassLoader 的 class name [n:] 具有详细信息的匹配类的最大数量（默认为100） 使用参考 查找java.lang.String类的具体方法 1sm java.lang.String 12345678910111213141516171819202122232425262728293031323334353637383940414243444546$ sm java.lang.Stringjava.lang.String-&gt;&lt;init&gt;java.lang.String-&gt;equalsjava.lang.String-&gt;toStringjava.lang.String-&gt;hashCodejava.lang.String-&gt;compareTojava.lang.String-&gt;indexOfjava.lang.String-&gt;valueOfjava.lang.String-&gt;checkBoundsjava.lang.String-&gt;lengthjava.lang.String-&gt;isEmptyjava.lang.String-&gt;charAtjava.lang.String-&gt;codePointAtjava.lang.String-&gt;codePointBeforejava.lang.String-&gt;codePointCountjava.lang.String-&gt;offsetByCodePointsjava.lang.String-&gt;getCharsjava.lang.String-&gt;getBytesjava.lang.String-&gt;contentEqualsjava.lang.String-&gt;nonSyncContentEqualsjava.lang.String-&gt;equalsIgnoreCasejava.lang.String-&gt;compareToIgnoreCasejava.lang.String-&gt;regionMatchesjava.lang.String-&gt;startsWithjava.lang.String-&gt;endsWithjava.lang.String-&gt;indexOfSupplementaryjava.lang.String-&gt;lastIndexOfjava.lang.String-&gt;lastIndexOfSupplementaryjava.lang.String-&gt;substringjava.lang.String-&gt;subSequencejava.lang.String-&gt;concatjava.lang.String-&gt;replacejava.lang.String-&gt;matchesjava.lang.String-&gt;containsjava.lang.String-&gt;replaceFirstjava.lang.String-&gt;replaceAlljava.lang.String-&gt;splitjava.lang.String-&gt;joinjava.lang.String-&gt;toLowerCasejava.lang.String-&gt;toUpperCasejava.lang.String-&gt;trimjava.lang.String-&gt;toCharArrayjava.lang.String-&gt;formatjava.lang.String-&gt;copyValueOfjava.lang.String-&gt;internAffect(row-cnt:44) cost in 1342 ms. 指定ClassLoader 查找ClassLoaderHash： 1sc -d demo.MathGame | grep classLoaderHash 12$ sc -d demo.MathGame | grep classLoaderHash classLoaderHash 70dea4e 指定classLoader 注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。 如果你使用-c，你需要手动输入hashcode：-c &lt;hashcode&gt; 1$ sm -c 70dea4e demo.MathGame 对于只有唯一实例的ClassLoader可以通过--classLoaderClass指定class name，使用起来更加方便： 1sm --classLoaderClass sun.misc.Launcher$AppClassLoader demo.MathGame 1234567$ sm --classLoaderClass sun.misc.Launcher$AppClassLoader demo.MathGamedemo.MathGame &lt;init&gt;()Vdemo.MathGame primeFactors(I)Ljava/util/List;demo.MathGame main([Ljava/lang/String;)Vdemo.MathGame run()Vdemo.MathGame print(ILjava/util/List;)VAffect(row-cnt:5) cost in 2 ms. 注: 这里classLoaderClass 在 java 8 是 sun.misc.Launcher$AppClassLoader，而java 11的classloader是jdk.internal.loader.ClassLoaders$AppClassLoader，katacoda目前环境是java8。 --classLoaderClass 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而-c &lt;hashcode&gt;是动态变化的。 查找java.lang.String#toString函数并打印详细信息 1sm -d java.lang.String toString 12345678910$ sm -d java.lang.String toString declaring-class java.lang.String method-name toString modifier public annotation parameters return java.lang.String exceptionsAffect(row-cnt:1) cost in 3 ms. 更多信息在“sm”中，我们演示了了Arthas的sm命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas mc-retransform命令","slug":"Java诊断工具Arthas高级命令教程/Arthasmc-retransform命令","date":"2021-08-07T01:51:40.000Z","updated":"2021-09-29T02:52:10.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthasmc-retransform命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasmc-retransform%E5%91%BD%E4%BB%A4/","excerpt":"","text":"启动demo 启动arthas-boot mc命令 retransform命令 参数说明 retransform的限制 热更新代码 jad反编译UserController sc查找加载UserController的ClassLoader mc retransform 热修改代码结果 retransform命令更多说明 查看 retransform entry 删除指定 retransform entry 删除所有 retransform entry 显式触发 retransform 消除 retransform 的影响 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个普通的Spring Boot应用为例，演示mc-retransform命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动demo下载demo-arthas-spring-boot.jar，再用java -jar命令启动： 1wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar demo-arthas-spring-boot是一个很简单的spring boot应用，源代码：查看 启动之后，可以访问61000端口： 点击查看 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help mc命令 Memory Compiler/内存编译器，编译.java文件生成.class。 可以通过-c/--classLoaderClass参数指定classloader，-d参数指定输出目录 编译生成.class文件之后，可以结合retransform命令实现热更新代码。 retransform命令 加载外部的.class文件，retransform jvm已加载的类。 参考：Instrumentation#retransformClasses 参数说明 参数名称 参数说明 [c:] ClassLoader的hashcode [classLoaderClass:] 指定执行表达式的 ClassLoader 的 class name [p:] 外部的.class文件的完整路径，支持多个 retransform的限制 不允许新增加field/method 正在跑的函数，没有退出不能生效。 热更新代码下面介绍通过jad/mc/retransform 命令实现动态更新代码的功能。 目前，访问 http://localhost:61000/user/0 ，会返回500异常： 1curl http://localhost:61000/user/0 1&#123;&quot;timestamp&quot;:1550223186170,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;exception&quot;:&quot;java.lang.IllegalArgumentException&quot;,&quot;message&quot;:&quot;id &lt; 1&quot;,&quot;path&quot;:&quot;/user/0&quot;&#125; 下面通过热更新代码，修改这个逻辑。 jad反编译UserController1jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java jad反编译的结果保存在 /tmp/UserController.java文件里了。 再打开一个Terminal 3，然后用vim来编辑/tmp/UserController.java： 1vim /tmp/UserController.java 比如当 user id 小于1时，也正常返回，不抛出异常： 123456789@GetMapping(value=&#123;&quot;/user/&#123;id&#125;&quot;&#125;)public User findUserById(@PathVariable Integer id) &#123; logger.info(&quot;id: &#123;&#125;&quot;, (Object)id); if (id != null &amp;&amp; id &lt; 1) &#123; return new User(id, &quot;name&quot; + id); // throw new IllegalArgumentException(&quot;id &lt; 1&quot;); &#125; return new User(id.intValue(), &quot;name&quot; + id);&#125; sc查找加载UserController的ClassLoader1sc -d *UserController | grep classLoaderHash 12$ sc -d *UserController | grep classLoaderHash classLoaderHash 1be6f5c3 可以发现是 spring boot LaunchedURLClassLoader@1be6f5c3 加载的。 注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。 如果你使用-c，你需要手动输入hashcode：-c &lt;hashcode&gt; 对于只有唯一实例的ClassLoader可以通过--classLoaderClass指定class name，使用起来更加方便. --classLoaderClass 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而-c &lt;hashcode&gt;是动态变化的。 mc保存好/tmp/UserController.java之后，使用mc(Memory Compiler)命令来编译，并且通过--classLoaderClass参数指定ClassLoader： 1mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmp 1234$ mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmpMemory compiler output:/tmp/com/example/demo/arthas/user/UserController.classAffect(row-cnt:1) cost in 346 ms 也可以通过mc -c &lt;classLoaderHash&gt; /tmp/UserController.java -d /tmp，使用-c参数指定ClassLoaderHash: 1$ mc -c 1be6f5c3 /tmp/UserController.java -d /tmp retransform再使用retransform命令重新加载新编译好的UserController.class： 1retransform /tmp/com/example/demo/arthas/user/UserController.class 12$ retransform /tmp/com/example/demo/arthas/user/UserController.classretransform success, size: 1 热修改代码结果retransform成功之后，再次访问 user/0 ，结果是： 1234&#123; &quot;id&quot;: 0, &quot;name&quot;: &quot;name0&quot;&#125; retransform命令更多说明 加载外部的.class文件，retransform jvm已加载的类。 参考：Instrumentation#retransformClasses 查看 retransform entry1retransform -l 12345$ retransform -lId ClassName TransformCount LoaderHash LoaderClassName1 com.example.dem 1 null null o.arthas.user.U serController TransformCount 统计在 ClassFileTransformer#transform 函数里尝试返回 entry对应的 .class文件的次数，但并不表明transform一定成功。 删除指定 retransform entry1retransform -d 1 需要指定 id： 1retransform -d 1 删除所有 retransform entry1retransform --deleteAll 1retransform --deleteAll 显式触发 retransform1retransform --classPattern com.example.demo.arthas.user.UserController 123$ retransform --classPattern com.example.demo.arthas.user.UserControllerretransform success, size: 1, classes:com.example.demo.arthas.user.UserController 注意：对于同一个类，当存在多个 retransform entry时，如果显式触发 retransform ，则最后添加的entry生效(id最大的)。 消除 retransform 的影响如果对某个类执行 retransform 之后，想消除影响，则需要： 删除这个类对应的 retransform entry 重新触发 retransform 如果不清除掉所有的 retransform entry，并重新触发 retransform ，则arthas stop时，retransform过的类仍然生效。 在上面删掉 retransform entry，再显式触发 retransform之后，可以用 jad命令来确认之前retransform的结果已经被消除了。 再次访问 user/0 ，会抛出异常。 更多信息在“mc-retransform”中，我们演示了了Arthas的mc-retransform命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas monitor命令","slug":"Java诊断工具Arthas高级命令教程/Arthasmonitor命令","date":"2021-08-07T01:51:39.000Z","updated":"2021-09-29T02:52:14.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthasmonitor命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasmonitor%E5%91%BD%E4%BB%A4/","excerpt":"","text":"启动arthas demo 启动arthas-boot monitor命令 监控的维度说明 参数说明 使用参考 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示monitor命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help monitor命令 方法执行监控 对匹配 class-pattern／method-pattern的类、方法的调用进行监控。 monitor 命令是一个非实时返回命令. 实时返回命令是输入之后立即返回，而非实时返回的命令，则是不断的等待目标 Java 进程返回信息，直到用户输入 Ctrl+C 为止。 服务端是以任务的形式在后台跑任务，植入的代码随着任务的中止而不会被执行，所以任务关闭后，不会对原有性能产生太大影响，而且原则上，任何Arthas命令不会引起原有业务逻辑的改变。 监控的维度说明 监控项 说明 timestamp 时间戳 class Java类 method 方法（构造方法、普通方法） total 调用次数 success 成功次数 fail 失败次数 rt 平均RT fail-rate 失败率 参数说明方法拥有一个命名参数 [c:]，意思是统计周期（cycle of output），拥有一个整型的参数值 参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 方法名表达式匹配 [E] 开启正则表达式匹配，默认为通配符匹配 [c:] 统计周期，默认值为120秒 使用参考1monitor -c 5 demo.MathGame primeFactors 按q或者Ctrl+c退出 1q 1234567891011121314151617181920212223242526$ monitor -c 5 demo.MathGame primeFactorsPress Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:1) cost in 94 ms. timestamp class method total success fail avg-rt(ms) fail-rate----------------------------------------------------------------------------------------------- 2018-12-03 19:06:38 demo.MathGame primeFactors 5 1 4 1.15 80.00% timestamp class method total success fail avg-rt(ms) fail-rate----------------------------------------------------------------------------------------------- 2018-12-03 19:06:43 demo.MathGame primeFactors 5 3 2 42.29 40.00% timestamp class method total success fail avg-rt(ms) fail-rate----------------------------------------------------------------------------------------------- 2018-12-03 19:06:48 demo.MathGame primeFactors 5 3 2 67.92 40.00% timestamp class method total success fail avg-rt(ms) fail-rate----------------------------------------------------------------------------------------------- 2018-12-03 19:06:53 demo.MathGame primeFactors 5 2 3 0.25 60.00% timestamp class method total success fail avg-rt(ms) fail-rate----------------------------------------------------------------------------------------------- 2018-12-03 19:06:58 demo.MathGame primeFactors 1 1 0 0.45 0.00% timestamp class method total success fail avg-rt(ms) fail-rate----------------------------------------------------------------------------------------------- 2018-12-03 19:07:03 demo.MathGame primeFactors 2 2 0 3182.72 0.00% 更多信息在“monitor”中，我们演示了了Arthas的monitor命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas profiler命令","slug":"Java诊断工具Arthas高级命令教程/Arthasprofiler命令","date":"2021-08-07T01:51:39.000Z","updated":"2021-09-29T02:52:24.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthasprofiler命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasprofiler%E5%91%BD%E4%BB%A4/","excerpt":"","text":"启动arthas demo 启动arthas-boot profiler命令 参数说明 查看所有支持的action 查看版本 启动profiler 获取已采集的sample的数量 查看profiler状态 停止profiler 生成svg格式结果 生成html格式结果 通过浏览器查看arthas-output下面的profiler结果 profiler支持的events 恢复采样 使用execute来执行复杂的命令 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示profiler命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help profiler命令 使用async-profiler生成火焰图 profiler 命令支持生成应用热点的火焰图。本质上是通过不断的采样，然后把收集到的采样结果生成火焰图。 1profiler` 命令基本运行结构是 `profiler action [actionArg] 参数说明 参数名称 参数说明 action 要执行的操作 actionArg 属性名模式 [i:] 采样间隔（单位：ns）（默认值：10’000’000，即10 ms） [f:] 将输出转储到指定路径 [d:] 运行评测指定秒 [e:] 要跟踪哪个事件（cpu, alloc, lock, cache-misses等），默认是cpu 查看所有支持的action1profiler actions 12$ profiler actionsSupported Actions: [resume, dumpCollapsed, getSamples, start, list, execute, version, stop, load, dumpFlat, actions, dumpTraces, status] 查看版本1profiler version 123$ profiler versionAsync-profiler 1.6 built on Sep 9 2019Copyright 2019 Andrei Pangin 启动profiler1profiler start -e itimer 12$ profiler start -e itimerStarted [itimer] profiling 默认情况下，生成的是cpu的火焰图，即event为cpu。可以用--event参数来指定。 因为katacoda环境不支持perf_events，所以这里使用-e itimer参数指定event为itimer 获取已采集的sample的数量1profiler getSamples 12$ profiler getSamples23 查看profiler状态1profiler status 12$ profiler status[itimer] profiling is running for 4 seconds 可以查看当前profiler在采样哪种event和采样时间。 停止profiler生成svg格式结果1profiler stop 123$ profiler stopprofiler output file: /tmp/demo/arthas-output/20191125-135546.svgOK 默认情况下，生成的结果保存到应用的工作目录下的arthas-output目录。可以通过 --file参数来指定输出结果路径。比如： 1profiler stop --file /tmp/output.svg 123$ profiler stop --file /tmp/output.svgprofiler output file: /tmp/output.svgOK 生成html格式结果默认情况下，结果文件是svg格式，如果想生成html格式，可以用--format参数指定： 1profiler stop --format html 123$ profiler stop --format htmlprofiler output file: /tmp/test/arthas-output/20191125-143329.htmlOK 或者在--file参数里用文件名指名格式。比如--file /tmp/result.html 。 1profiler stop --file /tmp/result.html 通过浏览器查看arthas-output下面的profiler结果默认情况下，arthas使用8563http端口，则可以打开： 目录下面的profiler结果： 点击可以查看具体的结果： 如果是chrome浏览器，可能需要多次刷新。 profiler支持的events1profiler list 在不同的平台，不同的OS下面，支持的events各有不同。比如在macos下面： 1234567$ profiler listBasic events: cpu alloc lock wall itimer 在linux下面 12345678910111213141516171819202122$ profiler listBasic events: cpu alloc lock wall itimerPerf events: page-faults context-switches cycles instructions cache-references cache-misses branches branch-misses bus-cycles L1-dcache-load-misses LLC-load-misses dTLB-load-misses mem:breakpoint trace:tracepoint 如果遇到OS本身的权限/配置问题，然后缺少部分event，可以参考async-profiler本身文档：async-profiler 可以用--event参数指定要采样的事件，比如对alloc事件进入采样： 1profiler start --event alloc 1$ profiler start --event alloc 恢复采样1profiler resume 12$ profiler resumeStarted [cpu] profiling start和resume的区别是：start是新开始采样，resume会保留上次stop时的数据。 通过执行profiler getSamples可以查看samples的数量来验证。 使用execute来执行复杂的命令比如开始采样： 1profiler execute &#x27;start,framebuf=5000000&#x27; 1profiler execute &#x27;start,framebuf=5000000&#x27; 停止采样，并保存到指定文件里： 1profiler execute &#x27;stop,file=/tmp/result.svg&#x27; 1profiler execute &#x27;stop,file=/tmp/result.svg&#x27; 具体的格式参考： arguments.cpp 更多信息在“profiler”中，我们演示了了Arthas的profiler命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas stack命令","slug":"Java诊断工具Arthas高级命令教程/Arthasstack命令","date":"2021-08-07T01:51:38.000Z","updated":"2021-09-29T02:52:36.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthasstack命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasstack%E5%91%BD%E4%BB%A4/","excerpt":"","text":"启动arthas demo 启动arthas-boot stack命令 参数说明 使用例子 stack 据条件表达式来过滤 据执行时间来过滤 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示stack命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help stack命令 输出当前方法被调用的调用路径 很多时候我们都知道一个方法被执行，但这个方法被执行的路径非常多，或者你根本就不知道这个方法是从那里被执行了，此时你需要的是 stack 命令。 参数说明 参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 方法名表达式匹配 condition-express 条件表达式 [E] 开启正则表达式匹配，默认为通配符匹配 [n:] 执行次数限制 这里重点要说明的是观察表达式，观察表达式的构成主要由 ognl 表达式组成，所以你可以这样写&quot;&#123;params,returnObj&#125;&quot;，只要是一个合法的 ognl 表达式，都能被正常支持。 观察的维度也比较多，主要体现在参数 advice 的数据结构上。Advice 参数最主要是封装了通知节点的所有信息。 特殊用法请参考：https://github.com/alibaba/arthas/issues/71 OGNL表达式官网：https://commons.apache.org/proper/commons-ognl/language-guide.html 使用例子stack1stack demo.MathGame primeFactors 按q或者Ctrl+c退出 1q 123456$ stack demo.MathGame primeFactorsPress Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:1) cost in 36 ms.ts=2018-12-04 01:32:19;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69 @demo.MathGame.run() at demo.MathGame.main(MathGame.java:16) 据条件表达式来过滤1stack demo.MathGame primeFactors &#x27;params[0]&lt;0&#x27; -n 2 按q或者Ctrl+c退出 1q 123456789101112$ stack demo.MathGame primeFactors &#x27;params[0]&lt;0&#x27; -n 2Press Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:1) cost in 30 ms.ts=2018-12-04 01:34:27;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69 @demo.MathGame.run() at demo.MathGame.main(MathGame.java:16)ts=2018-12-04 01:34:30;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69 @demo.MathGame.run() at demo.MathGame.main(MathGame.java:16)Command execution times exceed limit: 2, so command will exit. You can set it with -n option. 据执行时间来过滤1stack demo.MathGame primeFactors &#x27;#cost&gt;5&#x27; 按q或者Ctrl+c退出 1q 123456$ stack demo.MathGame primeFactors &#x27;#cost&gt;5&#x27;Press Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:1) cost in 35 ms.ts=2018-12-04 01:35:58;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69 @demo.MathGame.run() at demo.MathGame.main(MathGame.java:16) 更多信息在“stack”中，我们演示了了Arthas的stack命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas trace命令","slug":"Java诊断工具Arthas高级命令教程/Arthastrace命令","date":"2021-08-07T01:51:37.000Z","updated":"2021-09-29T02:52:56.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthastrace命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthastrace%E5%91%BD%E4%BB%A4/","excerpt":"","text":"启动arthas demo 启动arthas-boot trace命令 参数说明 注意事项 使用参考 trace函数 trace次数限制 包含jdk的函数 据调用耗时过滤 trace多个类或者多个函数 动态trace 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示trace命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help trace命令 方法内部调用路径，并输出方法路径上的每个节点上耗时 trace 命令能主动搜索 class-pattern／method-pattern 对应的方法调用路径，渲染和统计整个调用链路上的所有性能开销和追踪调用链路。 参数说明 参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 方法名表达式匹配 condition-express 条件表达式 [E] 开启正则表达式匹配，默认为通配符匹配 [n:] 命令执行次数 #cost 方法执行耗时 这里重点要说明的是观察表达式，观察表达式的构成主要由 \bognl 表达式组成，所以你可以这样写&quot;&#123;params,returnObj&#125;&quot;，只要是一个合法的 ognl 表达式，都能被正常支持。 观察的维度也比较多，主要体现在参数 advice 的数据结构上。Advice 参数最主要是封装了通知节点的所有信息。 请参考表达式核心变量中关于该节点的描述。 特殊用法请参考：https://github.com/alibaba/arthas/issues/71 OGNL表达式官网：https://commons.apache.org/proper/commons-ognl/language-guide.html 很多时候我们只想看到某个方法的rt大于某个时间之后的trace结果，现在Arthas可以按照方法执行的耗时来进行过滤了，例如trace *StringUtils isBlank &#39;#cost&gt;100&#39;表示当执行时间超过100ms的时候，才会输出trace的结果。 watch/stack/trace这个三个命令都支持#cost 注意事项trace 能方便的帮助你定位和发现因 RT 高而导致的性能问题缺陷，但其每次只能跟踪一级方法的调用链路。 参考：Trace命令的实现原理 3.3.0 版本后，可以使用动态Trace功能，不断增加新的匹配类，参考下面的示例。 使用参考trace函数1trace demo.MathGame run 按q或者Ctrl+c退出 1q 12345678$ trace demo.MathGame runPress Q or Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:1) cost in 28 ms.`---ts=2019-12-04 00:45:08;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69; `---[0.617465ms] demo.MathGame:run() `---[0.078946ms] demo.MathGame:primeFactors() #24 [throws Exception]`---ts=2019-12-04 00:45:09;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69; `---[1.276874ms] demo.MathGame:run() `---[0.03752ms] demo.MathGame:primeFactors() #24 [throws Exception] trace次数限制如果方法调用的次数很多，那么可以用-n参数指定捕捉结果的次数。比如下面的例子里，捕捉到一次调用就退出命令。 1trace demo.MathGame run -n 1 按q或者Ctrl+c退出 1q 12345678$ trace demo.MathGame run -n 1Press Q or Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:1) cost in 20 ms.`---ts=2019-12-04 00:45:53;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69; `---[0.549379ms] demo.MathGame:run() +---[0.059839ms] demo.MathGame:primeFactors() #24 `---[0.232887ms] demo.MathGame:print() #25Command execution times exceed limit: 1, so command will exit. You can set it with -n option. 包含jdk的函数 --skipJDKMethod &lt;value&gt; skip jdk method trace, default value true. 1trace --skipJDKMethod false demo.MathGame run 按q或者Ctrl+c退出 1q 默认情况下，trace不会包含jdk里的函数调用，如果希望trace jdk里的函数，需要显式设置--skipJDKMethod false。 123456789101112131415161718192021222324$ trace --skipJDKMethod false demo.MathGame runPress Q or Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:1) cost in 60 ms.`---ts=2019-12-04 00:44:41;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69; `---[1.357742ms] demo.MathGame:run() +---[0.028624ms] java.util.Random:nextInt() #23 +---[0.045534ms] demo.MathGame:primeFactors() #24 [throws Exception] +---[0.005372ms] java.lang.StringBuilder:&lt;init&gt;() #28 +---[0.012257ms] java.lang.Integer:valueOf() #28 +---[0.234537ms] java.lang.String:format() #28 +---[min=0.004539ms,max=0.005778ms,total=0.010317ms,count=2] java.lang.StringBuilder:append() #28 +---[0.013777ms] java.lang.Exception:getMessage() #28 +---[0.004935ms] java.lang.StringBuilder:toString() #28 `---[0.06941ms] java.io.PrintStream:println() #28`---ts=2019-12-04 00:44:42;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69; `---[3.030432ms] demo.MathGame:run() +---[0.010473ms] java.util.Random:nextInt() #23 +---[0.023715ms] demo.MathGame:primeFactors() #24 [throws Exception] +---[0.005198ms] java.lang.StringBuilder:&lt;init&gt;() #28 +---[0.006405ms] java.lang.Integer:valueOf() #28 +---[0.178583ms] java.lang.String:format() #28 +---[min=0.011636ms,max=0.838077ms,total=0.849713ms,count=2] java.lang.StringBuilder:append() #28 +---[0.008747ms] java.lang.Exception:getMessage() #28 +---[0.019768ms] java.lang.StringBuilder:toString() #28 `---[0.076457ms] java.io.PrintStream:println() #28 据调用耗时过滤1trace demo.MathGame run &#x27;#cost &gt; 10&#x27; 按q或者Ctrl+c退出 1q 1234567$ trace demo.MathGame run &#x27;#cost &gt; 10&#x27;Press Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:1) cost in 41 ms.`---ts=2018-12-04 01:12:02;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69; `---[12.033735ms] demo.MathGame:run() +---[0.006783ms] java.util.Random:nextInt() +---[11.852594ms] demo.MathGame:primeFactors() `---[0.05447ms] demo.MathGame:print() 只会展示耗时大于10ms的调用路径，有助于在排查问题的时候，只关注异常情况 是不是很眼熟，没错，在 JProfiler 等收费软件中你曾经见识类似的功能，这里你将可以通过命令就能打印出指定调用路径。 友情提醒下，trace 在执行的过程中本身是会有一定的性能开销，在统计的报告中并未像 JProfiler 一样预先减去其自身的统计开销。所以这统计出来有些许的不准，渲染路径上调用的类、方法越多，性能偏差越大。但还是能让你看清一些事情的。 [12.033735ms] 的含义，12.033735 的含义是：当前节点在当前步骤的耗时，单位为毫秒 [0,0,0ms,11]xxx:yyy() [throws Exception]，对该方法中相同的方法调用进行了合并，0,0,0ms,11 表示方法调用耗时，min,max,total,count；throws Exception 表明该方法调用中存在异常返回 这里存在一个统计不准确的问题，就是所有方法耗时加起来可能会小于该监测方法的总耗时，这个是由于 Arthas 本身的逻辑会有一定的耗时 trace多个类或者多个函数trace命令只会trace匹配到的函数里的子调用，并不会向下trace多层。因为trace是代价比较贵的，多层trace可能会导致最终要trace的类和函数非常多。 可以用正则表匹配路径上的多个类和函数，一定程度上达到多层trace的效果。 1trace -E com.test.ClassA|org.test.ClassB method1|method2|method3 动态trace3.3.0 版本后支持。 打开终端1，trace run函数，可以看到打印出 listenerId: 1： 1trace demo.MathGame run 按q或者Ctrl+c退出 1q 123456789[arthas@59161]$ trace demo.MathGame runPress Q or Ctrl+C to abort.Affect(class count: 1 , method count: 1) cost in 112 ms, listenerId: 1`---ts=2020-07-09 16:48:11;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69; `---[1.389634ms] demo.MathGame:run() `---[0.123934ms] demo.MathGame:primeFactors() #24 [throws Exception]`---ts=2020-07-09 16:48:12;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69; `---[3.716391ms] demo.MathGame:run() +---[3.182813ms] demo.MathGame:primeFactors() #24 `---[0.167786ms] demo.MathGame:print() #25 现在想要深入子函数primeFactors，可以打开一个新终端2，使用telnet localhost 3658连接上arthas，再trace primeFactors时，指定listenerId。 1trace demo.MathGame primeFactors --listenerId 1 按q或者Ctrl+c退出 1q 123[arthas@59161]$ trace demo.MathGame primeFactors --listenerId 1Press Q or Ctrl+C to abort.Affect(class count: 1 , method count: 1) cost in 34 ms, listenerId: 1 这时终端2打印的结果，说明已经增强了一个函数：Affect(class count: 1 , method count: 1)，但不再打印更多的结果。 再查看终端1，可以发现trace的结果增加了一层，打印了primeFactors函数里的内容： 123456789`---ts=2020-07-09 16:49:29;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69; `---[0.492551ms] demo.MathGame:run() `---[0.113929ms] demo.MathGame:primeFactors() #24 [throws Exception] `---[0.061462ms] demo.MathGame:primeFactors() `---[0.001018ms] throw:java.lang.IllegalArgumentException() #46`---ts=2020-07-09 16:49:30;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69; `---[0.409446ms] demo.MathGame:run() +---[0.232606ms] demo.MathGame:primeFactors() #24 | `---[0.1294ms] demo.MathGame:primeFactors() `---[0.084025ms] demo.MathGame:print() #25 通过指定listenerId的方式动态trace，可以不断深入。另外 watch/tt/monitor等命令也支持类似的功能。 更多信息在“trace”中，我们演示了了Arthas的trace命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas tt命令","slug":"Java诊断工具Arthas高级命令教程/Arthastt命令","date":"2021-08-07T01:51:36.000Z","updated":"2021-09-29T02:53:02.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthastt命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthastt%E5%91%BD%E4%BB%A4/","excerpt":"","text":"启动arthas demo 启动arthas-boot tt命令 使用参考 记录调用 检索调用记录 查看调用信息 重做一次调用 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示tt命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help tt命令 方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测 watch 虽然很方便和灵活，但需要提前想清楚观察表达式的拼写，这对排查问题而言要求太高，因为很多时候我们并不清楚问题出自于何方，只能靠蛛丝马迹进行猜测。 这个时候如果能记录下当时方法调用的所有入参和返回值、抛出的异常会对整个问题的思考与判断非常有帮助。 于是乎，TimeTunnel 命令就诞生了。 使用参考记录调用对于一个最基本的使用来说，就是记录下当前方法的每次调用环境现场。 1tt -t demo.MathGame primeFactors 按q或者Ctrl+c退出 1q 12345678910$ tt -t demo.MathGame primeFactorsPress Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:1) cost in 66 ms. INDEX TIMESTAMP COST(ms) IS-RET IS-EXP OBJECT CLASS METHOD------------------------------------------------------------------------------------------------------------------------------------- 1000 2018-12-04 11:15:38 1.096236 false true 0x4b67cf4d MathGame primeFactors 1001 2018-12-04 11:15:39 0.191848 false true 0x4b67cf4d MathGame primeFactors 1002 2018-12-04 11:15:40 0.069523 false true 0x4b67cf4d MathGame primeFactors 1003 2018-12-04 11:15:41 0.186073 false true 0x4b67cf4d MathGame primeFactors 1004 2018-12-04 11:15:42 17.76437 true false 0x4b67cf4d MathGame primeFactors 命令参数解析 -t tt 命令有很多个主参数，-t 就是其中之一。这个参数的表明希望记录下类 *Test 的 print 方法的每次执行情况。 -n 3 当你执行一个调用量不高的方法时可能你还能有足够的时间用 CTRL+C 中断 tt 命令记录的过程，但如果遇到调用量非常大的方法，瞬间就能将你的 JVM 内存撑爆。 此时你可以通过 -n 参数指定你需要记录的次数，当达到记录次数时 Arthas 会主动中断tt命令的记录过程，避免人工操作无法停止的情况。 表格字段说明 表格字段 字段解释 INDEX 时间片段记录编号，每一个编号代表着一次调用，后续tt还有很多命令都是基于此编号指定记录操作，非常重要。 TIMESTAMP 方法执行的本机时间，记录了这个时间片段所发生的本机时间 COST(ms) 方法执行的耗时 IS-RET 方法是否以正常返回的形式结束 IS-EXP 方法是否以抛异常的形式结束 OBJECT 执行对象的hashCode()，注意，曾经有人误认为是对象在JVM中的内存地址，但很遗憾他不是。但他能帮助你简单的标记当前执行方法的类实体 CLASS 执行的类名 METHOD 执行的方法名 条件表达式 不知道大家是否有在使用过程中遇到以下困惑 Arthas 似乎很难区分出重载的方法 我只需要观察特定参数，但是 tt 却全部都给我记录了下来 条件表达式也是用 \bOGNL 来编写，核心的判断对象依然是 Advice 对象。除了 tt 命令之外，watch、trace、stack 命令也都支持条件表达式。 解决方法重载 tt -t *Test print params.length==1 通过制定参数个数的形式解决不同的方法签名，如果参数个数一样，你还可以这样写 tt -t *Test print &#39;params[1] instanceof Integer&#39; 解决指定参数 tt -t *Test print params[0].mobile==&quot;13989838402&quot; 构成条件表达式的 Advice 对象 前边看到了很多条件表达式中，都使用了 params[0]，有关这个变量的介绍，请参考表达式核心变量 检索调用记录当你用 tt 记录了一大片的时间片段之后，你希望能从中筛选出自己需要的时间片段，这个时候你就需要对现有记录进行检索。 假设我们有这些记录 1tt -l 1234567891011$ tt -l INDEX TIMESTAMP COST(ms) IS-RET IS-EXP OBJECT CLASS METHOD------------------------------------------------------------------------------------------------------------------------------------- 1000 2018-12-04 11:15:38 1.096236 false true 0x4b67cf4d MathGame primeFactors 1001 2018-12-04 11:15:39 0.191848 false true 0x4b67cf4d MathGame primeFactors 1002 2018-12-04 11:15:40 0.069523 false true 0x4b67cf4d MathGame primeFactors 1003 2018-12-04 11:15:41 0.186073 false true 0x4b67cf4d MathGame primeFactors 1004 2018-12-04 11:15:42 17.76437 true false 0x4b67cf4d MathGame primeFactors 9 1005 2018-12-04 11:15:43 0.4776 false true 0x4b67cf4d MathGame primeFactorsAffect(row-cnt:6) cost in 4 ms. 我需要筛选出 primeFactors 方法的调用信息 1tt -s &#x27;method.name==&quot;primeFactors&quot;&#x27; 1234567891011$ tt -s &#x27;method.name==&quot;primeFactors&quot;&#x27; INDEX TIMESTAMP COST(ms) IS-RET IS-EXP OBJECT CLASS METHOD------------------------------------------------------------------------------------------------------------------------------------- 1000 2018-12-04 11:15:38 1.096236 false true 0x4b67cf4d MathGame primeFactors 1001 2018-12-04 11:15:39 0.191848 false true 0x4b67cf4d MathGame primeFactors 1002 2018-12-04 11:15:40 0.069523 false true 0x4b67cf4d MathGame primeFactors 1003 2018-12-04 11:15:41 0.186073 false true 0x4b67cf4d MathGame primeFactors 1004 2018-12-04 11:15:42 17.76437 true false 0x4b67cf4d MathGame primeFactors 9 1005 2018-12-04 11:15:43 0.4776 false true 0x4b67cf4d MathGame primeFactorsAffect(row-cnt:6) cost in 607 ms. 你需要一个 -s 参数。同样的，搜索表达式的核心对象依旧是 Advice 对象。 查看调用信息对于具体一个时间片的信息而言，你可以通过 -i 参数后边跟着对应的 INDEX 编号查看到他的详细信息。 1tt -i 1003 12345678910111213141516$ tt -i 1003 INDEX 1003 GMT-CREATE 2018-12-04 11:15:41 COST(ms) 0.186073 OBJECT 0x4b67cf4d CLASS demo.MathGame METHOD primeFactors IS-RETURN false IS-EXCEPTION true PARAMETERS[0] @Integer[-564322413] THROW-EXCEPTION java.lang.IllegalArgumentException: number is: -564322413, need &gt;= 2 at demo.MathGame.primeFactors(MathGame.java:46) at demo.MathGame.run(MathGame.java:24) at demo.MathGame.main(MathGame.java:16)Affect(row-cnt:1) cost in 11 ms. 重做一次调用当你稍稍做了一些调整之后，你可能需要前端系统重新触发一次你的调用，此时得求爷爷告奶奶的需要前端配合联调的同学再次发起一次调用。而有些场景下，这个调用不是这么好触发的。 tt 命令由于保存了当时调用的所有现场信息，所以我们可以自己主动对一个 INDEX 编号的时间片自主发起一次调用，从而解放你的沟通成本。此时你需要 -p 参数。通过 --replay-times 指定 调用次数，通过 --replay-interval 指定多次调用间隔(单位ms, 默认1000ms) 1tt -i 1004 -p 123456789101112131415161718$ tt -i 1004 -p RE-INDEX 1004 GMT-REPLAY 2018-12-04 11:26:00 OBJECT 0x4b67cf4d CLASS demo.MathGame METHOD primeFactors PARAMETERS[0] @Integer[946738738] IS-RETURN true IS-EXCEPTION false COST(ms) 0.186073 RETURN-OBJ @ArrayList[ @Integer[2], @Integer[11], @Integer[17], @Integer[2531387], ]Time fragment[1004] successfully replayed.Affect(row-cnt:1) cost in 14 ms. 你会发现结果虽然一样，但调用的路径发生了变化，有原来的程序发起变成了 Arthas 自己的内部线程发起的调用了。 需要强调的点 ThreadLocal 信息丢失 很多框架偷偷的将一些环境变量信息塞到了发起调用线程的 ThreadLocal 中，由于调用线程发生了变化，这些 ThreadLocal 线程信息无法通过 Arthas 保存，所以这些信息将会丢失。 一些常见的 CASE 比如：鹰眼的 TraceId 等。 引用的对象 需要强调的是，tt 命令是将当前环境的对象引用保存起来，但仅仅也只能保存一个引用而已。如果方法内部对入参进行了变更，或者返回的对象经过了后续的处理，那么在 tt 查看的时候将无法看到当时最准确的值。这也是为什么 watch 命令存在的意义。 更多信息在“tt”中，我们演示了了Arthas的tt命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas watch命令","slug":"Java诊断工具Arthas高级命令教程/Arthaswatch命令","date":"2021-08-07T01:51:36.000Z","updated":"2021-09-29T02:53:08.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthaswatch命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthaswatch%E5%91%BD%E4%BB%A4/","excerpt":"","text":"启动arthas demo 启动arthas-boot watch命令 参数说明 使用参考 观察方法出参和返回值 观察方法入参 同时观察方法调用前和方法返回后 调整-x的值，观察具体的方法参数值 条件表达式的例子 观察异常信息的例子 按照耗时进行过滤 观察当前对象中的属性 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示watch命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help watch命令 方法执行数据观测 让你能方便的观察到指定方法的调用情况。能观察到的范围为：返回值、抛出异常、入参，通过编写 OGNL 表达式进行对应变量的查看。 参数说明watch 的参数比较多，主要是因为它能在 4 个不同的场景观察对象 参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 方法名表达式匹配 express 观察表达式 condition-express 条件表达式 [b] 在方法调用之前观察 [e] 在方法异常之后观察 [s] 在方法返回之后观察 [f] 在方法结束之后(正常返回和异常返回)观察 [E] 开启正则表达式匹配，默认为通配符匹配 [x:] 指定输出结果的属性遍历深度，默认为 1 这里重点要说明的是观察表达式，观察表达式的构成主要由 \bognl 表达式组成，所以你可以这样写&quot;&#123;params,returnObj&#125;&quot;，只要是一个合法的 ognl 表达式，都能被正常支持。 观察的维度也比较多，主要体现在参数 advice 的数据结构上。Advice 参数最主要是封装了通知节点的所有信息。请参考表达式核心变量中关于该节点的描述。 特殊用法请参考：https://github.com/alibaba/arthas/issues/71 OGNL表达式官网：https://commons.apache.org/proper/commons-ognl/language-guide.html 特别说明： watch 命令定义了4个观察事件点，即 -b 方法调用前，-e 方法异常后，-s 方法返回后，-f 方法结束后 4个观察事件点 -b、-e、-s 默认关闭，-f 默认打开，当指定观察点被打开后，在相应事件点会对观察表达式进行求值并输出 这里要注意方法入参和方法出参的区别，有可能在中间被修改导致前后不一致，除了 -b 事件点 params 代表方法入参外，其余事件都代表方法出参 当使用 -b 时，由于观察事件点是在方法调用前，此时返回值或异常均不存在 使用参考观察方法出参和返回值1watch demo.MathGame primeFactors &quot;&#123;params,returnObj&#125;&quot; -x 2 按q或者Ctrl+c退出 1q 1234567891011121314$ watch demo.MathGame primeFactors &quot;&#123;params,returnObj&#125;&quot; -x 2Press Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:1) cost in 44 ms.ts=2018-12-03 19:16:51; [cost=1.280502ms] result=@ArrayList[ @Object[][ @Integer[535629513], ], @ArrayList[ @Integer[3], @Integer[19], @Integer[191], @Integer[49199], ],] 观察方法入参1watch demo.MathGame primeFactors &quot;&#123;params,returnObj&#125;&quot; -x 2 -b 按q或者Ctrl+c退出 1q 123456789$ watch demo.MathGame primeFactors &quot;&#123;params,returnObj&#125;&quot; -x 2 -bPress Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:1) cost in 50 ms.ts=2018-12-03 19:23:23; [cost=0.0353ms] result=@ArrayList[ @Object[][ @Integer[-1077465243], ], null,] 对比前一个例子，返回值为空（事件点为方法执行前，因此获取不到返回值） 同时观察方法调用前和方法返回后1watch demo.MathGame primeFactors &quot;&#123;params,target,returnObj&#125;&quot; -x 2 -b -s -n 2 按q或者Ctrl+c退出 1q 1234567891011121314151617181920212223242526272829303132$ watch demo.MathGame primeFactors &quot;&#123;params,target,returnObj&#125;&quot; -x 2 -b -s -n 2Press Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:1) cost in 46 ms.ts=2018-12-03 19:29:54; [cost=0.01696ms] result=@ArrayList[ @Object[][ @Integer[1544665400], ], @MathGame[ random=@Random[java.util.Random@522b408a], illegalArgumentCount=@Integer[13038], ], null,]ts=2018-12-03 19:29:54; [cost=4.277392ms] result=@ArrayList[ @Object[][ @Integer[1544665400], ], @MathGame[ random=@Random[java.util.Random@522b408a], illegalArgumentCount=@Integer[13038], ], @ArrayList[ @Integer[2], @Integer[2], @Integer[2], @Integer[5], @Integer[5], @Integer[73], @Integer[241], @Integer[439], ],] 参数里-n 2，表示只执行两次 这里输出结果中，第一次输出的是方法调用前的观察表达式的结果，第二次输出的是方法返回后的表达式的结果 结果的输出顺序和事件发生的先后顺序一致，和命令中 -s -b 的顺序无关 调整-x的值，观察具体的方法参数值1watch demo.MathGame primeFactors &quot;&#123;params,target&#125;&quot; -x 3 按q或者Ctrl+c退出 1q 12345678910111213141516171819202122232425262728$ watch demo.MathGame primeFactors &quot;&#123;params,target&#125;&quot; -x 3Press Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:1) cost in 58 ms.ts=2018-12-03 19:34:19; [cost=0.587833ms] result=@ArrayList[ @Object[][ @Integer[47816758], ], @MathGame[ random=@Random[ serialVersionUID=@Long[3905348978240129619], seed=@AtomicLong[3133719055989], multiplier=@Long[25214903917], addend=@Long[11], mask=@Long[281474976710655], DOUBLE_UNIT=@Double[1.1102230246251565E-16], BadBound=@String[bound must be positive], BadRange=@String[bound must be greater than origin], BadSize=@String[size must be non-negative], seedUniquifier=@AtomicLong[-3282039941672302964], nextNextGaussian=@Double[0.0], haveNextNextGaussian=@Boolean[false], serialPersistentFields=@ObjectStreamField[][isEmpty=false;size=3], unsafe=@Unsafe[sun.misc.Unsafe@2eaa1027], seedOffset=@Long[24], ], illegalArgumentCount=@Integer[13159], ],] -x表示遍历深度，可以调整来打印具体的参数和结果内容，默认值是1。 条件表达式的例子1watch demo.MathGame primeFactors &quot;&#123;params[0],target&#125;&quot; &quot;params[0]&lt;0&quot; 按q或者Ctrl+c退出 1q 1234567$ watch demo.MathGame primeFactors &quot;&#123;params[0],target&#125;&quot; &quot;params[0]&lt;0&quot;Press Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:1) cost in 68 ms.ts=2018-12-03 19:36:04; [cost=0.530255ms] result=@ArrayList[ @Integer[-18178089], @MathGame[demo.MathGame@41cf53f9],] 只有满足条件的调用，才会有响应。 watch-express 单个值可以不加’{}’，多个值需要加’{a,b,c}’。 condition-express 不能加’{}’，可以使用逗号分隔子表达式，取表达式最后一个值来判断。 如果watch的方法存在同名的其它重载方法，可以通过下面的办法进行过滤： 根据参数类型进行过滤 watch demo.MathGame primeFactors &#39;&#123;params, params[0].class.name&#125;&#39; &#39;params[0].class.name == &quot;java.lang.Integer&quot;&#39; 1watch demo.MathGame primeFactors &#x27;&#123;params, params[0].class.name&#125;&#x27; &#x27;params[0].class.name == &quot;java.lang.Integer&quot;&#x27; 按q或者Ctrl+c退出 1q 根据参数个数进行过滤 watch demo.MathGame primeFactors &#39;&#123;params, params.length&#125;&#39; &#39;params.length==1&#39; 1watch demo.MathGame primeFactors &#x27;&#123;params, params.length&#125;&#x27; &#x27;params.length==1&#x27; 按q或者Ctrl+c退出 1q 观察异常信息的例子1watch demo.MathGame primeFactors &quot;&#123;params[0],throwExp&#125;&quot; -e -x 2 按q或者Ctrl+c退出 1q 1234567891011$ watch demo.MathGame primeFactors &quot;&#123;params[0],throwExp&#125;&quot; -e -x 2Press Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:1) cost in 62 ms.ts=2018-12-03 19:38:00; [cost=1.414993ms] result=@ArrayList[ @Integer[-1120397038], java.lang.IllegalArgumentException: number is: -1120397038, need &gt;= 2 at demo.MathGame.primeFactors(MathGame.java:46) at demo.MathGame.run(MathGame.java:24) at demo.MathGame.main(MathGame.java:16),] -e表示抛出异常时才触发 express中，表示异常信息的变量是throwExp 根据异常类型或者message进行过滤： 1watch demo.MathGame primeFactors &#x27;&#123;params, throwExp&#125;&#x27; &#x27;#msg=throwExp.toString(), #msg.contains(&quot;IllegalArgumentException&quot;)&#x27; -e -x 2 按q或者Ctrl+c退出 1q 按照耗时进行过滤1watch demo.MathGame primeFactors &#x27;&#123;params, returnObj&#125;&#x27; &#x27;#cost&gt;200&#x27; -x 2 按q或者Ctrl+c退出 1q 123456789101112$ watch demo.MathGame primeFactors &#x27;&#123;params, returnObj&#125;&#x27; &#x27;#cost&gt;200&#x27; -x 2Press Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:1) cost in 66 ms.ts=2018-12-03 19:40:28; [cost=2112.168897ms] result=@ArrayList[ @Object[][ @Integer[2141897465], ], @ArrayList[ @Integer[5], @Integer[428379493], ],] #cost&gt;200(单位是ms)表示只有当耗时大于200ms时才会输出，过滤掉执行时间小于200ms的调用 观察当前对象中的属性1watch demo.MathGame primeFactors &#x27;target&#x27; 按q或者Ctrl+c退出 1q 如果想查看方法运行前后，当前对象中的属性，可以使用target关键字，代表当前对象 1234567$ watch demo.MathGame primeFactors &#x27;target&#x27;Press Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:1) cost in 52 ms.ts=2018-12-03 19:41:52; [cost=0.477882ms] result=@MathGame[ random=@Random[java.util.Random@522b408a], illegalArgumentCount=@Integer[13355],] 然后使用target.field_name访问当前对象的某个属性 1watch demo.MathGame primeFactors &#x27;target.illegalArgumentCount&#x27; 按q或者Ctrl+c退出 1q 12345$ watch demo.MathGame primeFactors &#x27;target.illegalArgumentCount&#x27;Press Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:1) cost in 67 ms.ts=2018-12-03 20:04:34; [cost=131.303498ms] result=@Integer[8]ts=2018-12-03 20:04:35; [cost=0.961441ms] result=@Integer[8] 更多信息在“watch”中，我们演示了了Arthas的watch命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas getstatic命令","slug":"Java诊断工具Arthas高级命令教程/Arthasgetstatic命令","date":"2021-08-07T01:51:35.000Z","updated":"2021-09-29T02:51:42.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthasgetstatic命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasgetstatic%E5%91%BD%E4%BB%A4/","excerpt":"","text":"启动arthas demo 启动arthas-boot getstatic命令 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示getstatic命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help getstatic命令 推荐直接使用ognl命令，更加灵活。 通过getstatic命令可以方便的查看类的静态属性。使用方法为getstatic class_name field_name 1getstatic demo.MathGame random 12345678910111213141516171819$ getstatic demo.MathGame randomfield: random@Random[ serialVersionUID=@Long[3905348978240129619], seed=@AtomicLong[120955813885284], multiplier=@Long[25214903917], addend=@Long[11], mask=@Long[281474976710655], DOUBLE_UNIT=@Double[1.1102230246251565E-16], BadBound=@String[bound must be positive], BadRange=@String[bound must be greater than origin], BadSize=@String[size must be non-negative], seedUniquifier=@AtomicLong[-3282039941672302964], nextNextGaussian=@Double[0.0], haveNextNextGaussian=@Boolean[false], serialPersistentFields=@ObjectStreamField[][isEmpty=false;size=3], unsafe=@Unsafe[sun.misc.Unsafe@2eaa1027], seedOffset=@Long[24],] 指定classLoader 注意hashcode是变化的，需要先查看当前的ClassLoader信息，使用sc -d &lt;ClassName&gt;提取对应ClassLoader的hashcode。 如果你使用-c，你需要手动输入hashcode：-c &lt;hashcode&gt; 1$ getstatic -c 3d4eac69 demo.MathGame random 对于只有唯一实例的ClassLoader可以通过--classLoaderClass指定class name，使用起来更加方便： 1getstatic --classLoaderClass sun.misc.Launcher$AppClassLoader demo.MathGame random 注: 这里classLoaderClass 在 java 8 是 sun.misc.Launcher$AppClassLoader，而java 11的classloader是jdk.internal.loader.ClassLoaders$AppClassLoader，katacoda目前环境是java8。 --classLoaderClass 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而-c &lt;hashcode&gt;是动态变化的。 如果该静态属性是一个复杂对象，还可以支持在该属性上通过ognl表示进行遍历，过滤，访问对象的内部属性等操作。 OGNL特殊用法请参考：https://github.com/alibaba/arthas/issues/71 OGNL表达式官方指南：https://commons.apache.org/proper/commons-ognl/language-guide.html 更多信息在“getstatic”中，我们演示了了Arthas的getstatic命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas dashboard命令","slug":"Java诊断工具Arthas高级命令教程/Arthasdashboard命令","date":"2021-08-07T01:51:34.000Z","updated":"2021-09-29T02:51:42.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthasdashboard命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasdashboard%E5%91%BD%E4%BB%A4/","excerpt":"","text":"启动arthas-demo 启动arthas-boot dashboard 命令 数据说明 JVM内部线程 dashboard 数据说明 截图展示 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示dashboard命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动arthas-demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help dashboard 命令dashboard 命令可以查看当前系统的实时数据面板。 1dashboard 当运行在Ali-tomcat时，会显示当前tomcat的实时信息，如HTTP请求的qps, rt, 错误数, 线程池信息等等。 1234567891011121314151617181920212223242526272829303132$ dashboardID NAME GROUP PRIORITY STATE %CPU DELTA_TIME TIME INTERRUPTE DAEMON-1 C2 CompilerThread0 - -1 - 1.55 0.077 0:8.684 false true53 Timer-for-arthas-dashboard-07b system 5 RUNNABLE 0.08 0.004 0:0.004 false true22 scheduling-1 main 5 TIMED_WAI 0.06 0.003 0:0.287 false false-1 C1 CompilerThread0 - -1 - 0.06 0.003 0:2.171 false true-1 VM Periodic Task Thread - -1 - 0.03 0.001 0:0.092 false true49 arthas-NettyHttpTelnetBootstra system 5 RUNNABLE 0.02 0.001 0:0.156 false true16 Catalina-utility-1 main 1 TIMED_WAI 0.0 0.000 0:0.029 false false-1 G1 Young RemSet Sampling - -1 - 0.0 0.000 0:0.019 false true17 Catalina-utility-2 main 1 WAITING 0.0 0.000 0:0.025 false false34 http-nio-8080-ClientPoller main 5 RUNNABLE 0.0 0.000 0:0.016 false true23 http-nio-8080-BlockPoller main 5 RUNNABLE 0.0 0.000 0:0.011 false true-1 VM Thread - -1 - 0.0 0.000 0:0.032 false true-1 Service Thread - -1 - 0.0 0.000 0:0.006 false true-1 GC Thread#5 - -1 - 0.0 0.000 0:0.043 false trueMemory used total max usage GCheap 36M 70M 4096M 0.90% gc.g1_young_generation.count 12g1_eden_space 6M 18M -1 33.33% 86g1_old_gen 30M 50M 4096M 0.74% gc.g1_old_generation.count 0g1_survivor_space 491K 2048K -1 24.01% gc.g1_old_generation.time(ms) 0nonheap 66M 69M -1 96.56%codeheap_&#x27;non-nmethods&#x27; 1M 2M 5M 22.39%metaspace 46M 47M -1 98.01%Runtimeos.name Mac OS Xos.version 10.15.4java.version 15java.home /Library/Java/JavaVirtualMachines/jdk-15.jdk/Contents/Homesystemload.average 10.68processors 8uptime 272s 输入 q 或者 Ctrl+C 可以退出dashboard命令。 1q 数据说明 ID: Java级别的线程ID，注意这个ID不能跟jstack中的nativeID一一对应。 NAME: 线程名 GROUP: 线程组名 PRIORITY: 线程优先级, 1~10之间的数字，越大表示优先级越高 STATE: 线程的状态 CPU%: 线程的cpu使用率。比如采样间隔1000ms，某个线程的增量cpu时间为100ms，则cpu使用率=100/1000=10% DELTA_TIME: 上次采样之后线程运行增量CPU时间，数据格式为秒 TIME: 线程运行总CPU时间，数据格式为分:秒 INTERRUPTED: 线程当前的中断位状态 DAEMON: 是否是daemon线程 JVM内部线程Java 8之后支持获取JVM内部线程CPU时间，这些线程只有名称和CPU时间，没有ID及状态等信息（显示ID为-1）。 通过内部线程可以观测到JVM活动，如GC、JIT编译等占用CPU情况，方便了解JVM整体运行状况。 当JVM 堆(heap)/元数据(metaspace)空间不足或OOM时，可以看到GC线程的CPU占用率明显高于其他的线程。 当执行trace/watch/tt/redefine等命令后，可以看到JIT线程活动变得更频繁。因为JVM热更新class字节码时清除了此class相关的JIT编译结果，需要重新编译。 JVM内部线程包括下面几种： JIT编译线程: 如 C1 CompilerThread0, C2 CompilerThread0 GC线程: 如GC Thread0, G1 Young RemSet Sampling 其它内部线程: 如VM Periodic Task Thread, VM Thread, Service Thread dashboard 数据说明 ID: Java级别的线程ID，注意这个ID不能跟jstack中的nativeID一一对应 NAME: 线程名 GROUP: 线程组名 PRIORITY: 线程优先级, 1~10之间的数字，越大表示优先级越高 STATE: 线程的状态 CPU%: 线程消耗的cpu占比，采样100ms，将所有线程在这100ms内的cpu使用量求和，再算出每个线程的cpu使用占比。 TIME: 线程运行总时间，数据格式为分：秒 INTERRUPTED: 线程当前的中断位状态 DAEMON: 是否是daemon线程 截图展示 更多信息通过本教程基本掌握了Arthas dashboard的用法。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas heapdump命令","slug":"Java诊断工具Arthas高级命令教程/Arthasheapdump命令","date":"2021-08-07T01:51:33.000Z","updated":"2021-09-29T02:51:36.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthasheapdump命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasheapdump%E5%91%BD%E4%BB%A4/","excerpt":"","text":"启动arthas demo 启动arthas-boot heapdump命令 使用参考 dump到指定文件 只dump live对象 dump到临时文件 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示heapdump命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help heapdump命令 dump java heap, 类似jmap命令的heap dump功能。 使用参考 dump到指定文件1heapdump /tmp/dump.hprof 123[arthas@58205]$ heapdump /tmp/dump.hprofDumping heap to /tmp/dump.hprof...Heap dump file created 只dump live对象1heapdump --live /tmp/dump.hprof 123[arthas@58205]$ heapdump --live /tmp/dump.hprofDumping heap to /tmp/dump.hprof...Heap dump file created dump到临时文件1heapdump 123[arthas@58205]$ heapdumpDumping heap to /var/folders/my/wy7c9w9j5732xbkcyt1mb4g40000gp/T/heapdump2019-09-03-16-385121018449645518991.hprof...Heap dump file created 更多信息在“heapdump”中，我们演示了了Arthas的heapdump命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas jvm命令","slug":"Java诊断工具Arthas高级命令教程/Arthasjvm命令","date":"2021-08-07T01:51:33.000Z","updated":"2021-09-29T02:51:54.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthasjvm命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasjvm%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Arthas demo 启动arthas-boot jvm命令 查找Java应用的classpath jvm使用参考 jvm使用参考 THREAD相关 文件描述符相关 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示jvm命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ Arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help jvm命令jvm 命令可以查看当前JVM信息。 1jvm 查找Java应用的classpath1jvm | grep PATH 1234[arthas@41064]$ jvm | grep PATH CLASS-PATH packaging/target/arthas-bin/arthas-demo.jar BOOT-CLASS-PATH /Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/resources.jar:/Librar LIBRARY-PATH /Users/gongdewei/Library/Java/Extensions:/Library/Java/Extensions:/Network/Library/Java/Extens jvm使用参考12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697$ jvmRUNTIME-------------------------------------------------------------------------------------------------------------- MACHINE-NAME 37@ff267334bb65 JVM-START-TIME 2020-07-23 07:50:36 MANAGEMENT-SPEC-VERSION 1.2 SPEC-NAME Java Virtual Machine Specification SPEC-VENDOR Oracle Corporation SPEC-VERSION 1.8 VM-NAME Java HotSpot(TM) 64-Bit Server VM VM-VENDOR Oracle Corporation VM-VERSION 25.201-b09 INPUT-ARGUMENTS [] CLASS-PATH demo-arthas-spring-boot.jar BOOT-CLASS-PATH /usr/lib/jvm/java-8-oracle/jre/lib/resources.jar:/usr/lib/jvm/java-8-oracle/j re/lib/rt.jar:/usr/lib/jvm/java-8-oracle/jre/lib/sunrsasign.jar:/usr/lib/jvm/ java-8-oracle/jre/lib/jsse.jar:/usr/lib/jvm/java-8-oracle/jre/lib/jce.jar:/us r/lib/jvm/java-8-oracle/jre/lib/charsets.jar:/usr/lib/jvm/java-8-oracle/jre/l ib/jfr.jar:/usr/lib/jvm/java-8-oracle/jre/classes LIBRARY-PATH /usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib-------------------------------------------------------------------------------------------------------------- CLASS-LOADING-------------------------------------------------------------------------------------------------------------- LOADED-CLASS-COUNT 7529 TOTAL-LOADED-CLASS-COUNT 7529 UNLOADED-CLASS-COUNT 0 IS-VERBOSE false-------------------------------------------------------------------------------------------------------------- COMPILATION-------------------------------------------------------------------------------------------------------------- NAME HotSpot 64-Bit Tiered Compilers TOTAL-COMPILE-TIME 14921(ms)-------------------------------------------------------------------------------------------------------------- GARBAGE-COLLECTORS-------------------------------------------------------------------------------------------------------------- PS Scavenge name : PS Scavenge [count/time (ms)] collectionCount : 7 collectionTime : 68 PS MarkSweep name : PS MarkSweep [count/time (ms)] collectionCount : 1 collectionTime : 47 -------------------------------------------------------------------------------------------------------------- MEMORY-MANAGERS-------------------------------------------------------------------------------------------------------------- CodeCacheManager Code Cache Metaspace Manager Metaspace Compressed Class Space Copy Eden Space Survivor Space MarkSweepCompact Eden Space Survivor Space Tenured Gen-------------------------------------------------------------------------------------------------------------- MEMORY-------------------------------------------------------------------------------------------------------------- HEAP-MEMORY-USAGE init : 268435456(256.0 MiB) [memory in bytes] used : 18039504(17.2 MiB) committed : 181403648(173.0 MiB) max : 3817865216(3.6 GiB) NO-HEAP-MEMORY-USAGE init : 2555904(2.4 MiB) [memory in bytes] used : 33926216(32.4 MiB) committed : 35176448(33.5 MiB) max : -1(-1 B) -------------------------------------------------------------------------------------------------------------- OPERATING-SYSTEM-------------------------------------------------------------------------------------------------------------- OS Linux ARCH amd64 PROCESSORS-COUNT 3 LOAD-AVERAGE 29.53 VERSION 4.15.0-52-generic-------------------------------------------------------------------------------------------------------------- THREAD-------------------------------------------------------------------------------------------------------------- COUNT 30 DAEMON-COUNT 24 PEAK-COUNT 31 STARTED-COUNT 36 DEADLOCK-COUNT 0-------------------------------------------------------------------------------------------------------------- FILE-DESCRIPTOR-------------------------------------------------------------------------------------------------------------- MAX-FILE-DESCRIPTOR-COUNT 1048576 OPEN-FILE-DESCRIPTOR-COUNT 100Affect(row-cnt:0) cost in 88 ms. jvm使用参考THREAD相关 COUNT: JVM当前活跃的线程数 DAEMON-COUNT: JVM当前活跃的守护线程数 PEAK-COUNT: 从JVM启动开始曾经活着的最大线程数 STARTED-COUNT: 从JVM启动开始总共启动过的线程次数 DEADLOCK-COUNT: JVM当前死锁的线程数 文件描述符相关 MAX-FILE-DESCRIPTOR-COUNT：JVM进程最大可以打开的文件描述符数 OPEN-FILE-DESCRIPTOR-COUNT：JVM当前打开的文件描述符数 更多信息在“jvm”中，我们演示了了Arthas的jvm命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas mbean命令","slug":"Java诊断工具Arthas高级命令教程/Arthasmbean命令","date":"2021-08-07T01:51:32.000Z","updated":"2021-09-29T02:52:02.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthasmbean命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasmbean%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Arthas demo 启动arthas-boot mbean命令 参数说明 使用参考 列出所有 Mbean 的名称 查看 Mbean 的元信息 查看mbean属性信息 mbean的name支持通配符匹配 多属性名称的匹配 通配符匹配特定的属性字段 使用-E命令切换为正则匹配 使用-i命令实时监控 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示mbean命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ Arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help mbean命令查看 Mbean 的信息 这个命令可以便捷的查看或监控 Mbean 的属性信息。 参数说明 参数名称 参数说明 name-pattern 名称表达式匹配 attribute-pattern 属性名表达式匹配 [m] 查看元信息 [i:] 刷新属性值的时间间隔 (ms) [n:] 刷新属性值的次数 [E] 开启正则表达式匹配，默认为通配符匹配。仅对属性名有效 使用参考列出所有 Mbean 的名称1mbean 查看 Mbean 的元信息1mbean -m java.lang:type=Threading 查看mbean属性信息1mbean java.lang:type=Threading mbean的name支持通配符匹配1mbean java.lang:type=Th* 注意：ObjectName 的匹配规则与正常的通配符存在差异，详细参见：javax.management.ObjectName 多属性名称的匹配查看内存池： 1mbean java.lang:name=*,type=MemoryPool 通配符匹配特定的属性字段1mbean java.lang:type=Threading *Count 使用-E命令切换为正则匹配1mbean -E java.lang:type=Threading PeakThreadCount|ThreadCount|DaemonThreadCount 查看内存池： 1mbean -E java.lang:name=*,type=MemoryPool Name|Usage|Type | grep &quot; HEAP&quot; -A3 -B1 使用-i命令实时监控1mbean -i 1000 java.lang:type=Threading *Count 更多信息在“mbean”中，我们演示了了Arthas的mbean命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas logger命令","slug":"Java诊断工具Arthas高级命令教程/Arthaslogger命令","date":"2021-08-07T01:51:31.000Z","updated":"2021-09-29T02:51:58.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthaslogger命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthaslogger%E5%91%BD%E4%BB%A4/","excerpt":"","text":"启动demo 启动arthas-boot logger命令 使用参考 查看所有logger信息 查看指定名字的logger信息 查看指定classloader的logger信息 更新logger level 指定classloader更新 logger level 查看没有appender的logger的信息 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个普通的Spring Boot应用为例，演示logger命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动demo下载demo-arthas-spring-boot.jar，再用java -jar命令启动： 1wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar demo-arthas-spring-boot是一个很简单的spring boot应用，源代码：查看 启动之后，可以访问61000端口： 点击查看 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help logger命令查看logger信息，更新logger level 使用参考查看所有logger信息1logger 12345678910111213141516[arthas@2062]$ logger name ROOT class ch.qos.logback.classic.Logger classLoader org.springframework.boot.loader.LaunchedURLClassLoader@5674cd4d classLoaderHash 5674cd4d level INFO effectiveLevel INFO additivity true codeSource jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/lib/logback-classi c-1.1.11.jar!/ appenders name CONSOLE class ch.qos.logback.core.ConsoleAppender classLoader org.springframework.boot.loader.LaunchedURLClassLoader@5674cd4d classLoaderHash 5674cd4d target System.out... 查看指定名字的logger信息1logger -n org.springframework.web 12345678910[arthas@2062]$ logger -n org.springframework.web name org.springframework.web class ch.qos.logback.classic.Logger classLoader org.springframework.boot.loader.LaunchedURLClassLoader@5674cd4d classLoaderHash 5674cd4d level null effectiveLevel INFO additivity true codeSource jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/lib/logback-classi c-1.1.11.jar!/ 请记下你的classLoaderHash，后面需要使用它。在这里，它是 5674cd4d。 注意：请使用你的classLoaderHash值覆盖 &lt;classLoaderHash&gt; ，然后手动执行下面所述命令： 查看指定classloader的logger信息注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。 如果你使用-c，你需要手动输入hashcode：-c &lt;hashcode&gt; 1$ logger -c 5674cd4d 对于只有唯一实例的ClassLoader可以通过--classLoaderClass指定class name，使用起来更加方便： 1logger --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader 12345678910111213141516[arthas@2062]$ logger --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoadername ROOT class ch.qos.logback.classic.Logger classLoader org.springframework.boot.loader.LaunchedURLClassLoader@5674cd4d classLoaderHash 5674cd4d level INFO effectiveLevel INFO additivity true codeSource jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/lib/logback-classi c-1.1.11.jar!/ appenders name CONSOLE class ch.qos.logback.core.ConsoleAppender classLoader org.springframework.boot.loader.LaunchedURLClassLoader@5674cd4d classLoaderHash 5674cd4d target System.out... --classLoaderClass 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而-c &lt;hashcode&gt;是动态变化的。 更新logger level1logger --name ROOT --level debug 12[arthas@2062]$ logger --name ROOT --level debugupdate logger level success. 注意：在教程中执行会提示错误，需要指定classloader 指定classloader更新 logger level默认情况下，logger命令会在SystemClassloader下执行，如果应用是传统的war应用，或者spring boot fat jar启动的应用，那么需要指定classloader。 可以先用 sc -d yourClassName 来查看具体的 classloader hashcode，然后在更新level时指定classloader： 1logger --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader --name ROOT --level debug 1[arthas@2062]$ logger --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader --name ROOT --level debug 查看没有appender的logger的信息默认情况下，logger命令只打印有appender的logger的信息。如果想查看没有appender的logger的信息，可以加上参数--include-no-appender。 注意，通常输出结果会很长。 1logger --include-no-appender 123456789101112131415[arthas@2062]$ logger --include-no-appender name org.thymeleaf class ch.qos.logback.classic.Logger classLoader org.springframework.boot.loader.LaunchedURLClassLoader@5674cd4d classLoaderHash 5674cd4d level null effectiveLevel INFO additivity false codeSource jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/lib/logback-classi c-1.1.11.jar!/ appenders name DEBUG_LEVEL_REMAPPER class org.springframework.boot.logging.logback.LevelRemappingAppender classLoader org.springframework.boot.loader.LaunchedURLClassLoader@5674cd4d classLoaderHash 5674cd4d... 更多信息在“logger”中，我们演示了了Arthas的logger命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas ognl","slug":"Java诊断工具Arthas高级命令教程/Arthasognl命令","date":"2021-08-07T01:51:30.000Z","updated":"2021-09-29T02:52:18.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthasognl命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasognl%E5%91%BD%E4%BB%A4/","excerpt":"","text":"启动demo 启动arthas-boot，help命令 Ognl详解 调用static函数 查找UserController的ClassLoader 获取静态类的静态字段 执行多行表达式，赋值给临时变量，返回一个List 更多 案例: 动态更新应用Logger Level 查找UserController的ClassLoader 用ognl获取logger 单独设置UserController的logger level 修改logback的全局logger level 案例: 排查logger冲突问题 确认应用使用的logger系统 获取logback实际加载的配置文件 使用classloader命令查找可能存在的logger配置文件 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个普通的Spring Boot应用为例，演示ognl命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动demo下载demo-arthas-spring-boot.jar，再用java -jar命令启动： 1wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar demo-arthas-spring-boot是一个很简单的spring boot应用，源代码：查看 启动之后，可以访问61000端口： 点击查看 启动arthas-boot，help命令在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help Ognl详解在Arthas里，有一个单独的ognl命令，可以动态执行代码。 查看用法：ognl --help 1ognl --help 调用static函数1ognl &#x27;@java.lang.System@out.println(&quot;hello ognl&quot;)&#x27; 可以检查Terminal 1里的进程输出，可以发现打印出了hello ognl。 查找UserController的ClassLoader1sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash 12$ sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash classLoaderHash 1be6f5c3 注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。 如果你使用-c，你需要手动输入hashcode：-c &lt;hashcode&gt; 1$ ognl -c 1be6f5c3 @com.example.demo.arthas.user.UserController@logger 对于只有唯一实例的ClassLoader可以通过--classLoaderClass指定class name，使用起来更加方便： 123456$ ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader @org.springframework.boot.SpringApplication@logger@Slf4jLocationAwareLog[ FQCN=@String[org.apache.commons.logging.LogAdapter$Slf4jLocationAwareLog], name=@String[org.springframework.boot.SpringApplication], logger=@Logger[Logger[org.springframework.boot.SpringApplication]],] --classLoaderClass 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而-c &lt;hashcode&gt;是动态变化的。 获取静态类的静态字段获取UserController类里的logger字段： 1ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader @com.example.demo.arthas.user.UserController@logger 还可以通过-x参数控制返回值的展开层数。比如： 1ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -x 2 @com.example.demo.arthas.user.UserController@logger 执行多行表达式，赋值给临时变量，返回一个List1ognl &#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27; 12345$ ognl &#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27;@ArrayList[ @String[/Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre], @String[Java(TM) SE Runtime Environment],] 更多在Arthas里ognl表达式是很重要的功能，在很多命令里都可以使用ognl表达式。 一些更复杂的用法，可以参考： OGNL特殊用法请参考：https://github.com/alibaba/arthas/issues/71 OGNL表达式官方指南：https://commons.apache.org/proper/commons-ognl/language-guide.html 案例: 动态更新应用Logger Level在这个案例里，动态修改应用的Logger Level。 查找UserController的ClassLoader1sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash 12$ sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash classLoaderHash 1be6f5c3 用ognl获取logger1ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger&#x27; 12345678910111213$ ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger&#x27;@Logger[ serialVersionUID=@Long[5454405123156820674], FQCN=@String[ch.qos.logback.classic.Logger], name=@String[com.example.demo.arthas.user.UserController], level=null, effectiveLevelInt=@Integer[20000], parent=@Logger[Logger[com.example.demo.arthas.user]], childrenList=null, aai=null, additive=@Boolean[true], loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],] 可以知道UserController@logger实际使用的是logback。可以看到level=null，则说明实际最终的level是从root logger里来的。 单独设置UserController的logger level1ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger.setLevel(@ch.qos.logback.classic.Level@DEBUG)&#x27; 再次获取UserController@logger，可以发现已经是DEBUG了： 1ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger&#x27; 12345678910111213$ ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger&#x27;@Logger[ serialVersionUID=@Long[5454405123156820674], FQCN=@String[ch.qos.logback.classic.Logger], name=@String[com.example.demo.arthas.user.UserController], level=@Level[DEBUG], effectiveLevelInt=@Integer[10000], parent=@Logger[Logger[com.example.demo.arthas.user]], childrenList=null, aai=null, additive=@Boolean[true], loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],] 修改logback的全局logger level通过获取root logger，可以修改全局的logger level： 1ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@org.slf4j.LoggerFactory@getLogger(&quot;root&quot;).setLevel(@ch.qos.logback.classic.Level@DEBUG)&#x27; 案例: 排查logger冲突问题在这个案例里，展示排查logger冲突的方法。 确认应用使用的logger系统以UserController为例，它使用的是slf4j api，但实际使用到的logger系统是logback。 1ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger&#x27; 12345678910111213$ ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger&#x27;@Logger[ serialVersionUID=@Long[5454405123156820674], FQCN=@String[ch.qos.logback.classic.Logger], name=@String[com.example.demo.arthas.user.UserController], level=null, effectiveLevelInt=@Integer[20000], parent=@Logger[Logger[com.example.demo.arthas.user]], childrenList=null, aai=null, additive=@Boolean[true], loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],] 获取logback实际加载的配置文件1ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;#map1=@org.slf4j.LoggerFactory@getLogger(&quot;root&quot;).loggerContext.objectMap, #map1.get(&quot;CONFIGURATION_WATCH_LIST&quot;)&#x27; 使用classloader命令查找可能存在的logger配置文件1classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml 1234$ classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml jar:file:/Users/hengyunabc/code/java/spring-boot-inside/demo-arthas-spring-boot/target/demo-arthas-spring-boot-0.0.1-SNAPSHOT.jar!/BOOT-INF/classes!/logback-spring.xmlAffect(row-cnt:1) cost in 13 ms. 可以知道加载的配置的具体来源。 可以尝试加载容易冲突的文件： 1classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback.xml 1classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r log4j.properties 更多信息在“ognl”中，我们演示了了Arthas的ognl命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas perfcounter命令","slug":"Java诊断工具Arthas高级命令教程/Arthasperfcounter命令","date":"2021-08-07T01:51:30.000Z","updated":"2021-09-29T02:52:22.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthasperfcounter命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasperfcounter%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Arthas demo 启动arthas-boot perfcounter命令 使用参考 备注: 对于jdk9以上的应用 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示perfcounter命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ Arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help perfcounter命令查看当前JVM的 Perf Counter信息 1perfcounter -h 12345678910111213141516USAGE: perfcounter [-d] [-h]SUMMARY: Display the perf counter information.Examples: perfcounter perfcounter -dWIKI: https://arthas.aliyun.com/doc/perfcounterOPTIONS:-d, --details print all perf counter details-h, --help this help 使用参考1perfcounter 123456789$ perfcounter java.ci.totalTime 2325637411 java.cls.loadedClasses 3403 java.cls.sharedLoadedClasses 0 java.cls.sharedUnloadedClasses 0 java.cls.unloadedClasses 0 java.property.java.version 11.0.4 java.property.java.vm.info mixed mode java.property.java.vm.name OpenJDK 64-Bit Server VM 可以用-d参数打印更多信息： 1perfcounter -d 12345678$ perfcounter -d Name Variability Units Value--------------------------------------------------------------------------------- java.ci.totalTime Monotonic Ticks 3242526906 java.cls.loadedClasses Monotonic Events 3404 java.cls.sharedLoadedClasses Monotonic Events 0 java.cls.sharedUnloadedClasses Monotonic Events 0 java.cls.unloadedClasses Monotonic Events 0 备注: 对于jdk9以上的应用如果没有打印出信息，应用在启动时，加下面的参数： 1--add-opens java.base/jdk.internal.perf=ALL-UNNAMED --add-exports java.base/jdk.internal.perf=ALL-UNNAMED 更多信息在“perfcounter”中，我们演示了了Arthas的perfcounter命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas sysprop命令","slug":"Java诊断工具Arthas高级命令教程/Arthassysprop命令","date":"2021-08-07T01:51:29.000Z","updated":"2021-09-29T02:52:50.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthassysprop命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthassysprop%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Arthas demo 启动arthas-boot sysprop命令 使用参考 查看所有属性 查看单个属性 修改单个属性 自动补全 历史命令的补全 管道 通过grep来过滤 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示sysprop命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ Arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help sysprop命令sysprop 命令可以查看当前JVM的系统属性(System Property) 1sysprop 使用参考12sysprop -hsysprop -h 123456789101112131415161718USAGE: sysprop [-h] [property-name] [property-value] SUMMARY: Display, and change all the system properties. EXAMPLES: sysprop sysprop file.encoding sysprop production.mode true WIKI: https://arthas.aliyun.com/doc/sysprop OPTIONS: -h, --help this help &lt;property-name&gt; property name &lt;property-value&gt; property value 查看所有属性12syspropsysprop 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970$ sysprop KEY VALUE------------------------------------------------------------------------------------------------------------------------------------- java.runtime.name Java(TM) SE Runtime Environment sun.boot.library.path /Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Contents/Home/jre/lib java.vm.version 25.51-b03 user.country.format CN gopherProxySet false java.vm.vendor Oracle Corporation java.vendor.url http://java.oracle.com/ path.separator : java.vm.name Java HotSpot(TM) 64-Bit Server VM file.encoding.pkg sun.io user.country US sun.java.launcher SUN_STANDARD sun.os.patch.level unknown java.vm.specification.name Java Virtual Machine Specification user.dir /private/var/tmp java.runtime.version 1.8.0_51-b16 java.awt.graphicsenv sun.awt.CGraphicsEnvironment java.endorsed.dirs /Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Contents/Home/jre/lib/endors ed os.arch x86_64 java.io.tmpdir /var/folders/2c/tbxwzs4s4sbcvh7frbcc7n000000gn/T/ line.separator java.vm.specification.vendor Oracle Corporation os.name Mac OS X sun.jnu.encoding UTF-8 java.library.path /Users/wangtao/Library/Java/Extensions:/Library/Java/Extensions:/Network/Libra ry/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java:. sun.nio.ch.bugLevel java.specification.name Java Platform API Specification java.class.version 52.0 sun.management.compiler HotSpot 64-Bit Tiered Compilers os.version 10.12.6 user.home /Users/wangtao user.timezone Asia/Shanghai java.awt.printerjob sun.lwawt.macosx.CPrinterJob file.encoding UTF-8 java.specification.version 1.8 user.name wangtao java.class.path . java.vm.specification.version 1.8 sun.arch.data.model 64 java.home /Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Contents/Home/jre sun.java.command Test java.specification.vendor Oracle Corporation user.language en awt.toolkit sun.lwawt.macosx.LWCToolkit java.vm.info mixed mode java.version 1.8.0_51 java.ext.dirs /Users/wangtao/Library/Java/Extensions:/Library/Java/JavaVirtualMachines/jdk1. 8.0_51.jdk/Contents/Home/jre/lib/ext:/Library/Java/Extensions:/Network/Library /Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java sun.boot.class.path /Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Contents/Home/jre/lib/resour ces.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Contents/Home/jre/li b/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Contents/Home/jre/l ib/sunrsasign.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Contents/H ome/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Content s/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Conte nts/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_51.jd k/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_51. jdk/Contents/Home/jre/classes java.vendor Oracle Corporation file.separator / java.vendor.url.bug http://bugreport.sun.com/bugreport/ sun.cpu.endian little sun.io.unicode.encoding UnicodeBig sun.cpu.isalist 查看单个属性12sysprop java.versionsysprop java.version 12$ sysprop java.versionjava.version=1.8.0_51 修改单个属性12sysprop user.countrysysprop user.country 12sysprop user.country CNsysprop user.country CN 12345$ sysprop user.countryuser.country=US$ sysprop user.country CNSuccessfully changed the system property.user.country=CN 自动补全Arthas支持丰富的自动补全功能，在使用有疑惑时，可以输入Tab来获取更多信息。 比如输入 sysprop java. 之后，再输入Tab，会补全出对应的key： 1234$ sysprop java.java.runtime.name java.protocol.handler.pkgs java.vm.versionjava.vm.vendor java.vendor.url java.vm.name... 历史命令的补全支持通过TAB键自动补全 如果想再执行之前的命令，可以在输入一半时，按Up/↑ 或者 Ddown/↓，来匹配到之前的命令。 比如之前执行过sysprop java.version，那么在输入sysprop ja之后，可以输入Up/↑，就会自动补全为sysprop java.version。 如果想查看所有的历史命令，也可以通过 history 命令查看到。 1history 管道Arthas支持在pipeline之后，执行一些简单的命令，比如： 12sysprop | grep javasysprop | grep java 12sysprop | wc -lsysprop | wc -l 通过grep来过滤12sysprop | grep usersysprop | grep user 更多信息在“sysprop”中，我们演示了了Arthas的sysprop命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas sysenv命令","slug":"Java诊断工具Arthas高级命令教程/Arthassysenv命令","date":"2021-08-07T01:51:28.000Z","updated":"2021-09-29T02:52:46.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthassysenv命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthassysenv%E5%91%BD%E4%BB%A4/","excerpt":"","text":"启动arthas demo 启动arthas-boot sysenv命令 使用参考 查看所有环境变量 查看单个环境变量 自动补全 历史命令的补全 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示sysenv命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help sysenv命令sysenv 命令可以查看当前JVM的环境属性(System Property)，与sysprop类似 1sysenv 使用参考12sysenv -hsysenv -h 12345678910111213141516USAGE: sysenv [-h] [env-name]SUMMARY: Display the system env.EXAMPLES: sysenv sysenv USERWIKI: https://arthas.aliyun.com/doc/sysenvOPTIONS:-h, --help this help&lt;env-name&gt; env name 查看所有环境变量12sysenvsysenv 123456789101112131415161718192021222324252627282930313233$ sysenv KEY VALUE---------------------------------------------------------------------------------------------------------------------------- PATH /Users/admin/.sdkman/candidates/visualvm/current/bin:/Users/admin/.sdkman/candidates/ja va/current/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Wireshark.app/Contents/ MacOS SDKMAN_VERSION 5.7.3+337 JAVA_HOME /Users/admin/.sdkman/candidates/java/current JAVA_MAIN_CLASS_65244 demo.MathGame TERM xterm-256color LANG zh_CN.UTF-8 AUTOJUMP_SOURCED 1 COLORTERM truecolor LOGNAME admin XPC_SERVICE_NAME 0 PWD /Users/admin/code/ali/arthas/demo TERM_PROGRAM_VERSION 3.2.5 _ /Users/admin/.sdkman/candidates/java/current/bin/java SHELL /bin/bash TERM_PROGRAM iTerm.app SDKMAN_PLATFORM Darwin USER admin ITERM_PROFILE Default TMPDIR /var/folders/0r/k561bkk917gg972stqclbz9h0000gn/T/ XPC_FLAGS 0x0 TERM_SESSION_ID w0t4p0:60BC264D-9649-42AC-A7E4-AF85B69F93F8 __CF_USER_TEXT_ENCODING 0x1F5:0x19:0x34 Apple_PubSub_Socket_Ren /private/tmp/com.apple.launchd.DwmmjSQsll/Render der COLORFGBG 7;0 HOME /Users/admin SHLVL 1 AUTOJUMP_ERROR_PATH /Users/admin/Library/autojump/errors.log 查看单个环境变量12sysenv USERsysenv USER 12$ sysenv USERUSER=admin 自动补全Arthas支持丰富的自动补全功能，在使用有疑惑时，可以输入Tab来获取更多信息。 比如输入 sysenv US 之后，再输入Tab，会补全出对应的key： 123$ sysenv USUSER... 历史命令的补全支持通过TAB键自动补全 如果想再执行之前的命令，可以在输入一半时，按Up/↑ 或者 Ddown/↓，来匹配到之前的命令。 比如之前执行过sysenv USER，那么在输入sysenv US之后，可以输入Up/↑，就会自动补全为sysenv USER。 如果想查看所有的历史命令，也可以通过 history 命令查看到。 1history 更多信息在“sysenv”中，我们演示了了Arthas的sysenv命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas thread命令","slug":"Java诊断工具Arthas高级命令教程/Arthasthread命令","date":"2021-08-07T01:51:27.000Z","updated":"2021-09-29T02:52:54.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthasthread命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasthread%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Arthas demo 启动arthas-boot Thread命令 参数说明 cpu占比是如何统计出来的？ cpu使用率是如何统计出来的？ Thread用法 支持一键展示当前最忙的前N个线程并打印堆栈： 当没有参数时，显示第一页线程信息 thread –all, 显示所有匹配的线程 thread id， 显示指定线程的运行堆栈 thread -b, 找出当前阻塞其他线程的线程 thread -i, 指定采样时间间隔 thread –state ，查看指定状态的线程 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示thread命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ Arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help Thread命令查看当前线程信息，查看线程的堆栈 参数说明 参数名称 参数说明 id 线程id [n:] 指定最忙的前N个线程并打印堆栈 [b] 找出当前阻塞其他线程的线程 [i ] 指定cpu占比统计的采样间隔，单位为毫秒 [–all] 显示所有匹配的线程 cpu占比是如何统计出来的？cpu使用率是如何统计出来的？这里的cpu使用率与linux 命令top -H -p &lt;pid&gt; 的线程%CPU类似，一段采样间隔时间内，当前JVM里各个线程的增量cpu时间与采样间隔时间的比例。 工作原理说明： 首先第一次采样，获取所有线程的CPU时间(调用的是java.lang.management.ThreadMXBean#getThreadCpuTime()及sun.management.HotspotThreadMBean.getInternalThreadCpuTimes()接口) 然后睡眠等待一个间隔时间（默认为200ms，可以通过-i指定间隔时间） 再次第二次采样，获取所有线程的CPU时间，对比两次采样数据，计算出每个线程的增量CPU时间 线程CPU使用率 = 线程增量CPU时间 / 采样间隔时间 * 100% 注意： 这个统计也会产生一定的开销（JDK这个接口本身开销比较大），因此会看到as的线程占用一定的百分比，为了降低统计自身的开销带来的影响，可以把采样间隔拉长一些，比如5000毫秒。 另外一种查看Java进程的线程cpu使用率方法：可以使用show-busy-java-threads这个脚本 Thread用法 支持一键展示当前最忙的前N个线程并打印堆栈：1thread -n 3 12345678910111213141516171819$ thread -n 3&quot;C1 CompilerThread0&quot; [Internal] cpuUsage=1.63% deltaTime=3ms time=1170ms&quot;arthas-command-execute&quot; Id=23 cpuUsage=0.11% deltaTime=0ms time=401ms RUNNABLE at java.management@11.0.7/sun.management.ThreadImpl.dumpThreads0(Native Method) at java.management@11.0.7/sun.management.ThreadImpl.getThreadInfo(ThreadImpl.java:466) at com.taobao.arthas.core.command.monitor200.ThreadCommand.processTopBusyThreads(ThreadCommand.java:199) at com.taobao.arthas.core.command.monitor200.ThreadCommand.process(ThreadCommand.java:122) at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl.process(AnnotatedCommandImpl.java:82) at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl.access$100(AnnotatedCommandImpl.java:18) at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl$ProcessHandler.handle(AnnotatedCommandImpl.java:111) at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl$ProcessHandler.handle(AnnotatedCommandImpl.java:108) at com.taobao.arthas.core.shell.system.impl.ProcessImpl$CommandProcessTask.run(ProcessImpl.java:385) at java.base@11.0.7/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515) at java.base@11.0.7/java.util.concurrent.FutureTask.run(FutureTask.java:264) at java.base@11.0.7/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304) at java.base@11.0.7/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) at java.base@11.0.7/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) at java.base@11.0.7/java.lang.Thread.run(Thread.java:834)&quot;VM Periodic Task Thread&quot; [Internal] cpuUsage=0.07% deltaTime=0ms time=584ms 没有线程ID，包含[Internal]表示为JVM内部线程，参考dashboard命令的介绍。 cpuUsage为采样间隔时间内线程的CPU使用率，与dashboard命令的数据一致。 deltaTime为采样间隔时间内线程的增量CPU时间，小于1ms时被取整显示为0ms。 time 线程运行总CPU时间。 注意：线程栈为第二采样结束时获取，不能表明采样间隔时间内该线程都是在处理相同的任务。建议间隔时间不要太长，可能间隔时间越大越不准确。 可以根据具体情况尝试指定不同的间隔时间，观察输出结果。 当没有参数时，显示第一页线程信息默认按照CPU增量时间降序排列，只显示第一页数据，避免滚屏。 1thread 12345678910111213141516171819$ threadThreads Total: 33, NEW: 0, RUNNABLE: 9, BLOCKED: 0, WAITING: 3, TIMED_WAITING: 4, TERMINATED: 0, Internal threads: 17ID NAME GROUP PRIORITY STATE %CPU DELTA_TIME TIME INTERRUPT DAEMON-1 C2 CompilerThread0 - -1 - 5.06 0.010 0:0.973 false true-1 C1 CompilerThread0 - -1 - 0.95 0.001 0:0.603 false true23 arthas-command-execute system 5 RUNNABLE 0.17 0.000 0:0.226 false true-1 VM Periodic Task Thread - -1 - 0.05 0.000 0:0.094 false true-1 Sweeper thread - -1 - 0.04 0.000 0:0.011 false true-1 G1 Young RemSet Sampling - -1 - 0.02 0.000 0:0.025 false true12 Attach Listener system 9 RUNNABLE 0.0 0.000 0:0.022 false true11 Common-Cleaner InnocuousThrea 8 TIMED_WAI 0.0 0.000 0:0.000 false true3 Finalizer system 8 WAITING 0.0 0.000 0:0.000 false true2 Reference Handler system 10 RUNNABLE 0.0 0.000 0:0.000 false true4 Signal Dispatcher system 9 RUNNABLE 0.0 0.000 0:0.000 false true15 arthas-NettyHttpTelnetBootstra system 5 RUNNABLE 0.0 0.000 0:0.029 false true22 arthas-NettyHttpTelnetBootstra system 5 RUNNABLE 0.0 0.000 0:0.196 false true24 arthas-NettyHttpTelnetBootstra system 5 RUNNABLE 0.0 0.000 0:0.038 false true16 arthas-NettyWebsocketTtyBootst system 5 RUNNABLE 0.0 0.000 0:0.001 false true17 arthas-NettyWebsocketTtyBootst system 5 RUNNABLE 0.0 0.000 0:0.001 false true thread –all, 显示所有匹配的线程显示所有匹配线程信息，有时需要获取全部JVM的线程数据进行分析。 1thread --all thread id， 显示指定线程的运行堆栈查看线程ID 16的栈： 1thread 16 123456789$ thread 1&quot;main&quot; Id=1 WAITING on java.util.concurrent.CountDownLatch$Sync@29fafb28 at sun.misc.Unsafe.park(Native Method) - waiting on java.util.concurrent.CountDownLatch$Sync@29fafb28 at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836) at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:997) at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304) at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231) thread -b, 找出当前阻塞其他线程的线程有时候我们发现应用卡住了， 通常是由于某个线程拿住了某个锁， 并且其他线程都在等待这把锁造成的。 为了排查这类问题， arthas提供了thread -b， 一键找出那个罪魁祸首。 1thread -b 123456789101112131415161718192021222324252627282930313233343536$ thread -b&quot;http-bio-8080-exec-4&quot; Id=27 TIMED_WAITING at java.lang.Thread.sleep(Native Method) at test.arthas.TestThreadBlocking.doGet(TestThreadBlocking.java:22) - locked java.lang.Object@725be470 &lt;---- but blocks 4 other threads! at javax.servlet.http.HttpServlet.service(HttpServlet.java:624) at javax.servlet.http.HttpServlet.service(HttpServlet.java:731) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:303) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) at test.filter.TestDurexFilter.doFilter(TestDurexFilter.java:46) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:220) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:122) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:505) at com.taobao.tomcat.valves.ContextLoadFilterValve$FilterChainAdapter.doFilter(ContextLoadFilterValve.java:191) at com.taobao.eagleeye.EagleEyeFilter.doFilter(EagleEyeFilter.java:81) at com.taobao.tomcat.valves.ContextLoadFilterValve.invoke(ContextLoadFilterValve.java:150) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:170) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:103) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:116) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:429) at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1085) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:625) at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:318) - locked org.apache.tomcat.util.net.SocketWrapper@7127ee12 at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:745) Number of locked synchronizers = 1 - java.util.concurrent.ThreadPoolExecutor$Worker@31a6493e 注意， 目前只支持找出synchronized关键字阻塞住的线程， 如果是java.util.concurrent.Lock， 目前还不支持。 thread -i, 指定采样时间间隔 thread -i 1000 : 统计最近1000ms内的线程CPU时间。 1thread -i 1000 thread -n 3 -i 1000 : 列出1000ms内最忙的3个线程栈 1thread -n 3 -i 1000 123456789101112131415161718$ thread -n 3 -i 1000&quot;as-command-execute-daemon&quot; Id=4759 cpuUsage=23% RUNNABLE at sun.management.ThreadImpl.dumpThreads0(Native Method) at sun.management.ThreadImpl.getThreadInfo(ThreadImpl.java:440) at com.taobao.arthas.core.command.monitor200.ThreadCommand.processTopBusyThreads(ThreadCommand.java:133) at com.taobao.arthas.core.command.monitor200.ThreadCommand.process(ThreadCommand.java:79) at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl.process(AnnotatedCommandImpl.java:96) at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl.access$100(AnnotatedCommandImpl.java:27) at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl$ProcessHandler.handle(AnnotatedCommandImpl.java:125) at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl$ProcessHandler.handle(AnnotatedCommandImpl.java:122) at com.taobao.arthas.core.shell.system.impl.ProcessImpl$CommandProcessTask.run(ProcessImpl.java:332) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:756) Number of locked synchronizers = 1 - java.util.concurrent.ThreadPoolExecutor$Worker@546aeec1... thread –state ，查看指定状态的线程1thread --state WAITING 123456[arthas@28114]$ thread --state WAITINGThreads Total: 16, NEW: 0, RUNNABLE: 9, BLOCKED: 0, WAITING: 3, TIMED_WAITING: 4, TERMINATED: 0ID NAME GROUP PRIORITY STATE %CPU DELTA_TIME TIME INTERRUPTE DAEMON3 Finalizer system 8 WAITING 0.0 0.000 0:0.000 false true20 arthas-UserStat system 9 WAITING 0.0 0.000 0:0.001 false true14 arthas-timer system 9 WAITING 0.0 0.000 0:0.000 false true 更多信息在“thread”中，我们演示了了Arthas的thread命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas vmoption命令","slug":"Java诊断工具Arthas高级命令教程/Arthasvmoption命令","date":"2021-08-07T01:51:26.000Z","updated":"2021-09-29T02:53:04.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas高级命令教程/Arthasvmoption命令/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasvmoption%E5%91%BD%E4%BB%A4/","excerpt":"","text":"启动arthas demo 启动arthas-boot vmoption命令 使用参考 查看所有的option： 查看指定的option 更新指定的option 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示vmoption命令。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 为了和使用vmoption后的效果作对比，此时使用Ctrl+c，程序很自然地退出。 Ctrl+C 再次启动arthas-demo： 1java -jar arthas-demo.jar 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help vmoption命令查看，更新VM诊断相关的参数 1vmoption -h 12345678910111213141516171819[arthas@48]$ vmoption -h USAGE: vmoption [-h] [name] [value] SUMMARY: Display, and update the vm diagnostic options. Examples: vmoption vmoption PrintGCDetails vmoption PrintGCDetails true WIKI: https://arthas.aliyun.com/doc/vmoption OPTIONS: -h, --help this help &lt;name&gt; VMOption name &lt;value&gt; VMOption value 使用参考查看所有的option：1vmoption 12345678910111213141516171819202122232425[arthas@56963]$ vmoption KEY VALUE ORIGIN WRITEABLE--------------------------------------------------------------------------------------------- HeapDumpBeforeFullGC false DEFAULT true HeapDumpAfterFullGC false DEFAULT true HeapDumpOnOutOfMemory false DEFAULT true Error HeapDumpPath DEFAULT true CMSAbortablePrecleanW 100 DEFAULT true aitMillis CMSWaitDuration 2000 DEFAULT true CMSTriggerInterval -1 DEFAULT true PrintGC false DEFAULT true PrintGCDetails true MANAGEMENT true PrintGCDateStamps false DEFAULT true PrintGCTimeStamps false DEFAULT true PrintGCID false DEFAULT true PrintClassHistogramBe false DEFAULT true foreFullGC PrintClassHistogramAf false DEFAULT true terFullGC PrintClassHistogram false DEFAULT true MinHeapFreeRatio 0 DEFAULT true MaxHeapFreeRatio 100 DEFAULT true PrintConcurrentLocks false DEFAULT true 查看指定的option1vmoption PrintGCDetails 1234[arthas@56963]$ vmoption PrintGCDetails KEY VALUE ORIGIN WRITEABLE--------------------------------------------------------------------------------------------- PrintGCDetails false MANAGEMENT true 更新指定的option1vmoption PrintGCDetails true 123[arthas@56963]$ vmoption PrintGCDetails trueSuccessfully updated the vm option.PrintGCDetails=true 此时，切换到arthas demo 运行所在的Terminal，使用Ctrl+c退出，发现比之前多打印了GC垃圾回收信息： 123456789Heap def new generation total 10432K, used 5682K [0x00000000f4800000, 0x00000000f5350000, 0x00000000f8550000) eden space 9280K, 61% used [0x00000000f4800000, 0x00000000f4d8cad0, 0x00000000f5110000) from space 1152K, 0% used [0x00000000f5110000, 0x00000000f5110000, 0x00000000f5230000) to space 1152K, 0% used [0x00000000f5230000, 0x00000000f5230000, 0x00000000f5350000) tenured generation total 22992K, used 13795K [0x00000000f8550000, 0x00000000f9bc4000, 0x0000000100000000) the space 22992K, 59% used [0x00000000f8550000, 0x00000000f92c8cc8, 0x00000000f92c8e00, 0x00000000f9bc4000) Metaspace used 14926K, capacity 15128K, committed 15360K, reserved 1062912K class space used 1895K, capacity 1954K, committed 2048K, reserved 1048576K 更多信息在“vmoption”中，我们演示了了Arthas的vmoption命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas 动态更新应用Logger Level 案例","slug":"Java诊断工具Arthas最佳实践/Arthas动态更新应用LoggerLevel案例","date":"2021-08-07T00:35:41.000Z","updated":"2021-09-29T02:54:12.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas最佳实践/Arthas动态更新应用LoggerLevel案例/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E5%BA%94%E7%94%A8LoggerLevel%E6%A1%88%E4%BE%8B/","excerpt":"","text":"Start demo Start arthas-boot 动态更新应用Logger Level 查找UserController的ClassLoader 用ognl获取logger 单独设置UserController的logger level 修改logback的全局logger level 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个普通的Spring Boot应用为例，演示动态更新应用Logger Level。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ Start demo下载demo-arthas-spring-boot.jar，再用java -jar命令启动： 1wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar demo-arthas-spring-boot是一个很简单的spring boot应用，源代码：查看 启动之后，可以访问61000端口： 点击查看 Start arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help 动态更新应用Logger Level在这个案例里，动态修改应用的Logger Level。 查找UserController的ClassLoader1sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash  12$ sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash classLoaderHash 1be6f5c3 注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。 如果你使用-c，你需要手动输入hashcode：-c &lt;hashcode&gt; 1$ ognl -c 1be6f5c3 @com.example.demo.arthas.user.UserController@logger 对于只有唯一实例的ClassLoader可以通过--classLoaderClass指定class name，使用起来更加方便： 123456$ ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader @org.springframework.boot.SpringApplication@logger@Slf4jLocationAwareLog[ FQCN=@String[org.apache.commons.logging.LogAdapter$Slf4jLocationAwareLog], name=@String[org.springframework.boot.SpringApplication], logger=@Logger[Logger[org.springframework.boot.SpringApplication]],] --classLoaderClass 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而-c &lt;hashcode&gt;是动态变化的。 用ognl获取logger1ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger&#x27; 12345678910111213$ ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger&#x27;@Logger[ serialVersionUID=@Long[5454405123156820674], FQCN=@String[ch.qos.logback.classic.Logger], name=@String[com.example.demo.arthas.user.UserController], level=null, effectiveLevelInt=@Integer[20000], parent=@Logger[Logger[com.example.demo.arthas.user]], childrenList=null, aai=null, additive=@Boolean[true], loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],] 可以知道UserController@logger实际使用的是logback。可以看到level=null，则说明实际最终的level是从root logger里来的。 单独设置UserController的logger level1ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger.setLevel(@ch.qos.logback.classic.Level@DEBUG)&#x27; 再次获取UserController@logger，可以发现已经是DEBUG了： 1ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger&#x27; 12345678910111213$ ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger&#x27;@Logger[ serialVersionUID=@Long[5454405123156820674], FQCN=@String[ch.qos.logback.classic.Logger], name=@String[com.example.demo.arthas.user.UserController], level=@Level[DEBUG], effectiveLevelInt=@Integer[10000], parent=@Logger[Logger[com.example.demo.arthas.user]], childrenList=null, aai=null, additive=@Boolean[true], loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],] 修改logback的全局logger level通过获取root logger，可以修改全局的logger level： 1ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@org.slf4j.LoggerFactory@getLogger(&quot;root&quot;).setLevel(@ch.qos.logback.classic.Level@DEBUG)&#x27; 更多信息通过本教程基本掌握了Arthas动态更新应用Logger Level。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 最佳实践","slug":"Java-诊断工具-Arthas-最佳实践","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}]},{"title":"Arthas Web Console 案例","slug":"Java诊断工具Arthas最佳实践/ArthasWebConsole案例","date":"2021-08-07T00:35:40.000Z","updated":"2021-09-29T02:54:12.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas最佳实践/ArthasWebConsole案例/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/ArthasWebConsole%E6%A1%88%E4%BE%8B/","excerpt":"","text":"启动arthas demo 启动arthas-boot Web Console 本地体验 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示Web Console。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar --target-ip 0.0.0.0 arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help Web ConsoleArthas支持通过Web Socket来连接。 本地体验当在本地启动时，可以访问 http://127.0.0.1:8563/ ，通过浏览器来使用Arthas。 推荐通过“快速入门”来体验： https://arthas.aliyun.com/doc/quick-start.html 更多信息通过本教程基本掌握了Arthas Web Console。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 最佳实践","slug":"Java-诊断工具-Arthas-最佳实践","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}]},{"title":"Arthas 排查函数调用异常 案例","slug":"Java诊断工具Arthas最佳实践/Arthas排查函数调用异常案例","date":"2021-08-07T00:35:39.000Z","updated":"2021-09-29T02:54:08.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas最佳实践/Arthas排查函数调用异常案例/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%BC%82%E5%B8%B8%E6%A1%88%E4%BE%8B/","excerpt":"","text":"Start demo Start arthas-boot 排查函数调用异常 现象 查看UserController的 参数/异常 返回值表达式 条件表达式 当异常时捕获 按照耗时进行过滤 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个普通的Spring Boot应用为例，演示排查函数调用异常。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ Start demo下载demo-arthas-spring-boot.jar，再用java -jar命令启动： 1wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar demo-arthas-spring-boot是一个很简单的spring boot应用，源代码：查看 启动之后，可以访问61000端口： 点击查看 Start arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help 排查函数调用异常现象目前，访问 http://localhost:61000/user/0 ，会返回500异常： 1curl http://localhost:61000/user/0 1&#123;&quot;timestamp&quot;:1550223186170,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;exception&quot;:&quot;java.lang.IllegalArgumentException&quot;,&quot;message&quot;:&quot;id &lt; 1&quot;,&quot;path&quot;:&quot;/user/0&quot;&#125; 但请求的具体参数，异常栈是什么呢？ 查看UserController的 参数/异常在Arthas里执行： 1watch com.example.demo.arthas.user.UserController * &#x27;&#123;params, throwExp&#125;&#x27; 第一个参数是类名，支持通配 第二个参数是函数名，支持通配 访问 curl http://localhost:61000/user/0 ,watch命令会打印调用的参数和异常 1curl http://localhost:61000/user/0 1234567$ watch com.example.demo.arthas.user.UserController * &#x27;&#123;params, throwExp&#125;&#x27;Press Q or Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:2) cost in 53 ms.ts=2019-02-15 01:35:25; [cost=0.996655ms] result=@ArrayList[ @Object[][isEmpty=false;size=1], @IllegalArgumentException[java.lang.IllegalArgumentException: id &lt; 1],] 可以看到实际抛出的异常是IllegalArgumentException。 可以输入 q 或者 Ctrl+C 退出watch命令。 1q 如果想把获取到的结果展开，可以用-x参数： 1watch com.example.demo.arthas.user.UserController * &#x27;&#123;params, throwExp&#125;&#x27; -x 2 123456789101112131415$ watch com.example.demo.arthas.user.UserController * &#x27;&#123;params, throwExp&#125;&#x27; -x 2Press Q or Ctrl+C to abort.Affect(class count: 1 , method count: 2) cost in 190 ms, listenerId: 1ts=2020-08-13 05:22:45; [cost=4.805432ms] result=@ArrayList[ @Object[][ @Integer[0], ], java.lang.IllegalArgumentException: id &lt; 1 at com.example.demo.arthas.user.UserController.findUserById(UserController.java:19) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ...,] 返回值表达式在上面的例子里，第三个参数是返回值表达式，它实际上是一个ognl表达式，它支持一些内置对象： loader clazz method target params returnObj throwExp isBefore isThrow isReturn 你可以利用这些内置对象来组成不同的表达式。比如返回一个数组： 1watch com.example.demo.arthas.user.UserController * &#x27;&#123;params[0], target, returnObj&#125;&#x27; 更多参考： https://arthas.aliyun.com/doc/advice-class.html 条件表达式watch命令支持在第4个参数里写条件表达式，比如： 1watch com.example.demo.arthas.user.UserController * returnObj &#x27;params[0] &gt; 100&#x27; 当访问 user/1 时，watch命令没有输出 当访问 user/101 时，watch会打印出结果。 1234567$ watch com.example.demo.arthas.user.UserController * returnObj &#x27;params[0] &gt; 100&#x27;Press Q or Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:2) cost in 47 ms.ts=2019-02-13 19:42:12; [cost=0.821443ms] result=@User[ id=@Integer[101], name=@String[name101],] 当异常时捕获watch命令支持-e选项，表示只捕获抛出异常时的请求： 1watch com.example.demo.arthas.user.UserController * &quot;&#123;params[0],throwExp&#125;&quot; -e 按照耗时进行过滤watch命令支持按请求耗时进行过滤，比如： 1watch com.example.demo.arthas.user.UserController * &#x27;&#123;params, returnObj&#125;&#x27; &#x27;#cost&gt;200&#x27; 更多信息通过本教程基本掌握了Arthas排查函数调用异常。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 最佳实践","slug":"Java-诊断工具-Arthas-最佳实践","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}]},{"title":"Arthas 执行结果存日志 案例","slug":"Java诊断工具Arthas最佳实践/Arthas执行结果存日志案例","date":"2021-08-07T00:35:38.000Z","updated":"2021-09-29T02:54:10.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas最佳实践/Arthas执行结果存日志案例/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%AD%98%E6%97%A5%E5%BF%97%E6%A1%88%E4%BE%8B/","excerpt":"","text":"Arthas demo Start arthas-boot 执行结果存日志 使用新版本Arthas的异步后台任务将结果存日志文件 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示Arthas执行结果存日志。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ Arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 Start arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help 执行结果存日志将命令的结果完整保存在日志文件中，便于后续进行分析 默认情况下，该功能是关闭的，如果需要开启，请执行以下命令： 1options save-result true 12345$ options save-result true NAME BEFORE-VALUE AFTER-VALUE---------------------------------------- save-result false trueAffect(row-cnt:1) cost in 3 ms. 看到上面的输出，即表示成功开启该功能； 日志文件路径 结果会异步保存在：&#123;user.home&#125;/logs/arthas-cache/result.log，请定期进行清理，以免占据磁盘空间 使用新版本Arthas的异步后台任务将结果存日志文件123$ trace Test t &gt;&gt; &amp;job id : 2cache location : /Users/admin/logs/arthas-cache/28198/2 此时命令会在后台异步执行，并将结果异步保存在文件（~/logs/arthas-cache/$&#123;PID&#125;/$&#123;JobId&#125;）中; 此时任务的执行不受session断开的影响；任务默认超时时间是1天，可以通过全局 options 命令修改默认超时时间； 此命令的结果将异步输出到文件中；此时不管 save-result 是否为true，都不会再往~/logs/arthas-cache/result.log 中异步写结果 更多信息通过本教程基本掌握了Arthas执行结果存日志。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 最佳实践","slug":"Java-诊断工具-Arthas-最佳实践","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}]},{"title":"Arthas 查找Top N线程 案例","slug":"Java诊断工具Arthas最佳实践/Arthas查找TopN线程案例","date":"2021-08-07T00:35:38.000Z","updated":"2021-09-29T02:54:08.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas最佳实践/Arthas查找TopN线程案例/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%9F%A5%E6%89%BETopN%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/","excerpt":"","text":"Arthas demo Start arthas-boot 查找Top N线程 查看所有线程信息 查看具体线程的栈 查看CPU使用率top n线程的栈 查找线程是否有阻塞 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示查找Top N线程。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ Arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 Start arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help 查找Top N线程查看所有线程信息1thread 查看具体线程的栈查看线程ID 16的栈： 1thread 16 查看CPU使用率top n线程的栈参数n用来指定最忙的前N个线程并打印堆栈 1thread -n 3 参数i用来指定cpu占比统计的采样间隔，单位为毫秒 查看5秒内的CPU使用率top n线程栈 1thread -n 3 -i 5000 查找线程是否有阻塞参数b用来指定找出当前阻塞其他线程的线程 1thread -b 更多信息通过本教程基本掌握了Arthas查找Top N线程。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 最佳实践","slug":"Java-诊断工具-Arthas-最佳实践","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}]},{"title":"Arthas 排查logger冲突问题 案例","slug":"Java诊断工具Arthas最佳实践/Arthas排查logger冲突问题案例","date":"2021-08-07T00:35:37.000Z","updated":"2021-09-29T02:54:08.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas最佳实践/Arthas排查logger冲突问题案例/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5logger%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%E6%A1%88%E4%BE%8B/","excerpt":"","text":"Start demo Start arthas-boot 排查logger冲突问题 查找UserController的ClassLoader 确认应用使用的logger系统 获取logback实际加载的配置文件 使用classloader命令查找可能存在的logger配置文件 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个普通的Spring Boot应用为例，演示排查logger冲突问题。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ Start demo下载demo-arthas-spring-boot.jar，再用java -jar命令启动： 1wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar demo-arthas-spring-boot是一个很简单的spring boot应用，源代码：查看 启动之后，可以访问61000端口： 点击查看 Start arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help 排查logger冲突问题在这个案例里，展示排查logger冲突的方法。 查找UserController的ClassLoader1sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash 12$ sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash classLoaderHash 1be6f5c3 注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。 如果你使用-c，你需要手动输入hashcode：-c &lt;hashcode&gt; 1$ ognl -c 1be6f5c3 @com.example.demo.arthas.user.UserController@logger 对于只有唯一实例的ClassLoader可以通过--classLoaderClass指定class name，使用起来更加方便： 123456$ ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader @org.springframework.boot.SpringApplication@logger@Slf4jLocationAwareLog[ FQCN=@String[org.apache.commons.logging.LogAdapter$Slf4jLocationAwareLog], name=@String[org.springframework.boot.SpringApplication], logger=@Logger[Logger[org.springframework.boot.SpringApplication]],] --classLoaderClass 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而-c &lt;hashcode&gt;是动态变化的。 确认应用使用的logger系统以UserController为例，它使用的是slf4j api，但实际使用到的logger系统是logback。 1ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger&#x27; 12345678910111213$ ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger&#x27;@Logger[ serialVersionUID=@Long[5454405123156820674], FQCN=@String[ch.qos.logback.classic.Logger], name=@String[com.example.demo.arthas.user.UserController], level=null, effectiveLevelInt=@Integer[20000], parent=@Logger[Logger[com.example.demo.arthas.user]], childrenList=null, aai=null, additive=@Boolean[true], loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],] 获取logback实际加载的配置文件1ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;#map1=@org.slf4j.LoggerFactory@getLogger(&quot;root&quot;).loggerContext.objectMap, #map1.get(&quot;CONFIGURATION_WATCH_LIST&quot;)&#x27; 使用classloader命令查找可能存在的logger配置文件1classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml 1234$ classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml jar:file:/Users/hengyunabc/code/java/spring-boot-inside/demo-arthas-spring-boot/target/demo-arthas-spring-boot-0.0.1-SNAPSHOT.jar!/BOOT-INF/classes!/logback-spring.xmlAffect(row-cnt:1) cost in 13 ms. 可以知道加载的配置的具体来源。 可以尝试加载容易冲突的文件： 1classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback.xml 1classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r log4j.properties 更多信息通过本教程基本掌握了Arthas排查logger冲突问题。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 最佳实践","slug":"Java-诊断工具-Arthas-最佳实践","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}]},{"title":"Arthas 热更新代码 案例","slug":"Java诊断工具Arthas最佳实践/Arthas热更新代码案例","date":"2021-08-07T00:35:36.000Z","updated":"2021-09-29T02:54:06.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas最佳实践/Arthas热更新代码案例/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E7%83%AD%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B/","excerpt":"","text":"Start demo Start arthas-boot 热更新代码 jad反编译UserController sc查找加载UserController的ClassLoader mc redefine 热修改代码结果 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个普通的Spring Boot应用为例，演示热更新代码。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ Start demo下载demo-arthas-spring-boot.jar，再用java -jar命令启动： 1wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar demo-arthas-spring-boot是一个很简单的spring boot应用，源代码：查看 启动之后，可以访问61000端口： 点击查看 Start arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help 热更新代码下面介绍通过jad/mc/redefine 命令实现动态更新代码的功能。 目前，访问 http://localhost:61000/user/0 ，会返回500异常： 1curl http://localhost:61000/user/0 1&#123;&quot;timestamp&quot;:1550223186170,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;exception&quot;:&quot;java.lang.IllegalArgumentException&quot;,&quot;message&quot;:&quot;id &lt; 1&quot;,&quot;path&quot;:&quot;/user/0&quot;&#125; 下面通过热更新代码，修改这个逻辑。 jad反编译UserController1jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java jad反编译的结果保存在 /tmp/UserController.java文件里了。 再打开一个Terminal 3，然后用vim来编辑/tmp/UserController.java： 1vim /tmp/UserController.java 比如当 user id 小于1时，也正常返回，不抛出异常： 123456789@GetMapping(value=&#123;&quot;/user/&#123;id&#125;&quot;&#125;)public User findUserById(@PathVariable Integer id) &#123; logger.info(&quot;id: &#123;&#125;&quot;, (Object)id); if (id != null &amp;&amp; id &lt; 1) &#123; return new User(id, &quot;name&quot; + id); // throw new IllegalArgumentException(&quot;id &lt; 1&quot;); &#125; return new User(id.intValue(), &quot;name&quot; + id);&#125; sc查找加载UserController的ClassLoader1sc -d *UserController | grep classLoaderHash 12$ sc -d *UserController | grep classLoaderHash classLoaderHash 1be6f5c3 可以发现是 spring boot LaunchedURLClassLoader@1be6f5c3 加载的。 注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。 如果你使用-c，你需要手动输入hashcode：-c &lt;hashcode&gt; 对于只有唯一实例的ClassLoader可以通过--classLoaderClass指定class name，使用起来更加方便. --classLoaderClass 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而-c &lt;hashcode&gt;是动态变化的。 mc保存好/tmp/UserController.java之后，使用mc(Memory Compiler)命令来编译，并且通过--classLoaderClass参数指定ClassLoader： 1mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmp 1234$ mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmpMemory compiler output:/tmp/com/example/demo/arthas/user/UserController.classAffect(row-cnt:1) cost in 346 ms 也可以通过mc -c &lt;classLoaderHash&gt; /tmp/UserController.java -d /tmp，使用-c参数指定ClassLoaderHash: 1$ mc -c 1be6f5c3 /tmp/UserController.java -d /tmp redefine再使用redefine命令重新加载新编译好的UserController.class： 1redefine /tmp/com/example/demo/arthas/user/UserController.class 12$ redefine /tmp/com/example/demo/arthas/user/UserController.classredefine success, size: 1 热修改代码结果redefine成功之后，再次访问 user/0 ，结果是： 1234&#123; &quot;id&quot;: 0, &quot;name&quot;: &quot;name0&quot;&#125; 更多信息通过本教程基本掌握了Arthas热更新代码。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 最佳实践","slug":"Java-诊断工具-Arthas-最佳实践","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}]},{"title":"Arthas Http API案例","slug":"Java诊断工具Arthas最佳实践/ArthasHttpAPI案例","date":"2021-08-07T00:35:35.000Z","updated":"2021-09-29T02:54:12.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas最佳实践/ArthasHttpAPI案例/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/ArthasHttpAPI%E6%A1%88%E4%BE%8B/","excerpt":"","text":"启动arthas demo 启动arthas-boot Http API 此教程暂时无法在Handson环境下运行,同学们可以在本地尝试 概览 访问地址 请求数据格式 请求Action 响应状态 一次性命令 会话交互* [创建会话](#创建会话) * [加入会话](#加入会话) * [拉取命令结果](#拉取命令结果) * [异步执行命令](#异步执行命令) * [中断命令执行](#中断命令执行) * [关闭会话](#关闭会话) Web UI watch命令输出map对象 { “foo” : “foo value”, “bar” : “bar value” } Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示http-api案例。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc 启动arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help Http API此教程暂时无法在Handson环境下运行,同学们可以在本地尝试概览Http API 提供类似RESTful的交互接口，请求和响应均为JSON格式的数据。相对于Telnet/WebConsole的输出非结构化文本数据，Http API可以提供结构化的数据，支持更复杂的交互功能，比如特定应用场景的一系列诊断操作。 访问地址Http API接口地址为：http://ip:port/api，必须使用POST方式提交请求参数。如POST http://127.0.0.1:8563/api 。 注意：telnet服务的3658端口与Chrome浏览器有兼容性问题，建议使用http端口8563来访问http接口。 请求数据格式12345678&#123; &quot;action&quot;: &quot;exec&quot;, &quot;requestId&quot;: &quot;req112&quot;, &quot;sessionId&quot;: &quot;94766d3c-8b39-42d3-8596-98aee3ccbefb&quot;, &quot;consumerId&quot;: &quot;955dbd1325334a84972b0f3ac19de4f7_2&quot;, &quot;command&quot;: &quot;version&quot;, &quot;execTimeout&quot;: &quot;10000&quot;&#125; 请求数据格式说明： action : 请求的动作/行为，可选值请参考”请求Action”小节。 requestId : 可选请求ID，由客户端生成。 sessionId : Arthas会话ID，一次性命令不需要设置会话ID。 consumerId : Arthas消费者ID，用于多人共享会话。 command : Arthas command line 。 execTimeout : 命令同步执行的超时时间(ms)，默认为30000。 注意: 不同的action使用到参数不同，根据具体的action来设置参数。 请求Action目前支持的请求Action如下： exec : 同步执行命令，命令正常结束或者超时后中断命令执行后返回命令的执行结果。 async_exec : 异步执行命令，立即返回命令的调度结果，命令执行结果通过pull_results获取。 interrupt_job : 中断会话当前的命令，类似Telnet Ctrl + c的功能。 pull_results : 获取异步执行的命令的结果，以http 长轮询（long-polling）方式重复执行 init_session : 创建会话 join_session : 加入会话，用于支持多人共享同一个Arthas会话 close_session : 关闭会话 响应状态响应中的state属性表示请求处理状态，取值如下： SCHEDULED：异步执行命令时表示已经创建job并已提交到命令执行队列，命令可能还没开始执行或者执行中； SUCCEEDED：请求处理成功（完成状态）； FAILED：请求处理失败（完成状态），通常附带message说明原因； REFUSED：请求被拒绝（完成状态），通常附带message说明原因； 一次性命令与执行批处理命令类似，一次性命令以同步方式执行。不需要创建会话，不需要设置sessionId选项。 1234&#123; &quot;action&quot;: &quot;exec&quot;, &quot;command&quot;: &quot;&lt;Arthas command line&gt;&quot;&#125; 比如获取Arthas版本号： curl -Ss -XPOST http://localhost:8563/api -d &#39;;&#123; &quot;action&quot;:&quot;exec&quot;, &quot;command&quot;:&quot;version&quot; &#125; 1&#x27; | json_pp 响应内容如下： 12345678910111213141516171819202122&#123; &quot;state&quot; : &quot;SUCCEEDED&quot;, &quot;sessionId&quot; : &quot;ee3bc004-4586-43de-bac0-b69d6db7a869&quot;, &quot;body&quot; : &#123; &quot;results&quot; : [ &#123; &quot;type&quot; : &quot;version&quot;, &quot;version&quot; : &quot;3.3.7&quot;, &quot;jobId&quot; : 5 &#125;, &#123; &quot;jobId&quot; : 5, &quot;statusCode&quot; : 0, &quot;type&quot; : &quot;status&quot; &#125; ], &quot;timeExpired&quot; : false, &quot;command&quot; : &quot;version&quot;, &quot;jobStatus&quot; : &quot;TERMINATED&quot;, &quot;jobId&quot; : 5 &#125;&#125; 响应数据解析： state: 请求处理状态，参考“接口响应状态”说明 sessionId: Arthas会话ID，一次性命令自动创建及销毁临时会话 body.jobId: 命令的任务ID，同一任务输出的所有Result都是相同的jobId body.jobStatus: 任务状态，同步执行正常结束为TERMINATED body.timeExpired: 任务执行是否超时 body/results: 命令执行的结果列表 命令结果格式说明 12345678910[&#123; &quot;type&quot; : &quot;version&quot;, &quot;version&quot; : &quot;3.3.7&quot;, &quot;jobId&quot; : 5&#125;,&#123; &quot;jobId&quot; : 5, &quot;statusCode&quot; : 0, &quot;type&quot; : &quot;status&quot;&#125;] type : 命令结果类型，除了status等特殊的几个外，其它的保持与Arthas命令名称一致。请参考”特殊命令结果”小节。 jobId : 处理命令的任务ID。 其它字段为每个不同命令的数据。 注意：也可以使用一次性命令的方式执行watch/trace等连续输出的命令，但不能中断命令执行，可能出现长时间没有结束的问题。请参考”watch命令输出map对象”小节的示例。 请尽量按照以下方式处理： 设置合理的execTimeout，到达超时时间后强制中断命令执行，避免长时间挂起。 通过-n参数指定较少的执行次数。 保证命令匹配的方法可以成功命中和condition-express编写正确，如果watch/trace没有命中就算指定-n 1也会挂起等待到执行超时。 会话交互由用户创建及管理Arthas会话，适用于复杂的交互过程。访问流程如下： 创建会话 加入会话(可选） 拉取命令结果 执行一系列命令 中断命令执行 关闭会话 创建会话创建会话, 保存输出到bash环境变量 session*data=$(curl -Ss -XPOST http://localhost:8563/api -d &#39;;&#123; &quot;action&quot;:&quot;init*session&quot; &#125; &#39;) 1echo $session_data | json_pp 注： json_pp 工具将输出内容格式化为pretty json。 响应结果： 12345&#123; &quot;sessionId&quot; : &quot;b09f1353-202c-407b-af24-701b744f971e&quot;, &quot;consumerId&quot; : &quot;5ae4e5fbab8b4e529ac404f260d4e2d1_1&quot;, &quot;state&quot; : &quot;SUCCEEDED&quot;&#125; 提取会话ID和消费者ID。 当前会话ID为： 1session_id=$(echo $session_data | sed &#x27;s/.*&quot;sessionId&quot;:&quot;\\([^&quot;]*\\)&quot;.*/\\1/g&#x27;);echo $session_id b09f1353-202c-407b-af24-701b744f971e; 请记下这里的会话ID，在Terminal 4中需要手动输入。 当前消费者ID为： 1consumer_id=$(echo $session_data | sed &#x27;s/.*&quot;consumerId&quot;:&quot;\\([^&quot;]*\\)&quot;.*/\\1/g&#x27;);echo $consumer_id 5ae4e5fbab8b4e529ac404f260d4e2d1_1。 加入会话指定要加入的会话ID，服务端将分配一个新的消费者ID。多个消费者可以接收到同一个会话的命令结果。本接口用于支持多人共享同一个会话或刷新页面后重新拉取会话历史记录。 加入会话，保存输出到bash环境变量 session*data=$(curl -Ss -XPOST http://localhost:8563/api -d &#39;;&#123; &quot;action&quot;:&quot;join*session&quot;, &quot;sessionId&quot; : &quot;&#39;&quot;$session_id&quot;&#39;&quot; &#125; &#39;) 1echo $session_data | json_pp 响应结果： 12345&#123; &quot;consumerId&quot; : &quot;8f7f6ad7bc2d4cb5aa57a530927a95cc_2&quot;, &quot;sessionId&quot; : &quot;b09f1353-202c-407b-af24-701b744f971e&quot;, &quot;state&quot; : &quot;SUCCEEDED&quot;&#125; 提取消费者ID。 新的消费者ID为 1consumer_id=$(echo $session_data | sed &#x27;s/.*&quot;consumerId&quot;:&quot;\\([^&quot;]*\\)&quot;.*/\\1/g&#x27;);echo $consumer_id 8f7f6ad7bc2d4cb5aa57a530927a95cc_2 。 请记下这里的消费者ID，在Terminal 4中需要手动输入。 拉取命令结果拉取命令结果消息的action为pull_results。请使用Http long-polling方式，定时循环拉取结果消息。 消费者的超时时间为5分钟，超时后需要调用join_session分配新的消费者。每个消费者单独分配一个缓存队列，按顺序拉取命令结果，不会影响到其它消费者。 请求参数需要指定会话ID及消费者ID: curl -Ss -XPOST http://localhost:8563/api -d &#39;;&#123; &quot;action&quot;:&quot;pull*results&quot;, &quot;sessionId&quot; : &quot;&#39;&quot;$session*id&quot;&#39;&quot;, &quot;consumerId&quot; : &quot;&#39;&quot;$consumer_id&quot;&#39;&quot; &#125; 1&#x27; | json_pp 用Bash脚本定时拉取结果消息: 请在Terminal 4中输入Terminal 3中的会话ID，这里的例子如下： 12b09f1353-202c-407b-af24-701b744f971eecho -n &quot;Enter your sessionId in T3:&quot;;read session_id 同样，接着输入Terminal 3中的消费者ID，这里的例子如下： 128f7f6ad7bc2d4cb5aa57a530927a95cc_2echo -n &quot;Enter your consumerId in T3:&quot;;read consumer_id while true; do curl -Ss -XPOST http://localhost:8563/api -d &#39;;&#123; &quot;action&quot;:&quot;pull*results&quot;, &quot;sessionId&quot; : &quot;&#39;&quot;$session*id&quot;&#39;&quot;, &quot;consumerId&quot; : &quot;&#39;&quot;$consumer_id&quot;&#39;&quot; &#125; 1&#x27; | json_pp; sleep 2; done 响应内容如下： 123456789101112131415161718192021222324252627282930313233&#123; &quot;body&quot; : &#123; &quot;results&quot; : [ &#123; &quot;inputStatus&quot; : &quot;DISABLED&quot;, &quot;jobId&quot; : 0, &quot;type&quot; : &quot;input_status&quot; &#125;, &#123; &quot;type&quot; : &quot;message&quot;, &quot;jobId&quot; : 0, &quot;message&quot; : &quot;Welcome to arthas!&quot; &#125;, &#123; &quot;tutorials&quot; : &quot;https://arthas.aliyun.com/doc/arthas-tutorials.html&quot;, &quot;time&quot; : &quot;2020-08-06 15:56:43&quot;, &quot;type&quot; : &quot;welcome&quot;, &quot;jobId&quot; : 0, &quot;pid&quot; : &quot;7909&quot;, &quot;wiki&quot; : &quot;https://arthas.aliyun.com/doc&quot;, &quot;version&quot; : &quot;3.3.7&quot; &#125;, &#123; &quot;inputStatus&quot; : &quot;ALLOW_INPUT&quot;, &quot;type&quot; : &quot;input_status&quot;, &quot;jobId&quot; : 0 &#125; ] &#125;, &quot;sessionId&quot; : &quot;b09f1353-202c-407b-af24-701b744f971e&quot;, &quot;consumerId&quot; : &quot;8f7f6ad7bc2d4cb5aa57a530927a95cc_2&quot;, &quot;state&quot; : &quot;SUCCEEDED&quot;&#125; 异步执行命令curl -Ss -XPOST http://localhost:8563/api -d &#39;&#39;&#39;;&#123; &quot;action&quot;:&quot;async*exec&quot;, &quot;command&quot;:&quot;watch demo.MathGame primeFactors \\&quot;&#123;params, returnObj, throwExp&#125;\\&quot; &quot;, &quot;sessionId&quot; : &quot;&#39;&quot;$session*id&quot;&#39;&quot; &#125; 1&#x27;&#x27;&#x27; | json_pp async_exec 的结果： 123456789&#123; &quot;sessionId&quot; : &quot;2b085b5d-883b-4914-ab35-b2c5c1d5aa2a&quot;, &quot;state&quot; : &quot;SCHEDULED&quot;, &quot;body&quot; : &#123; &quot;jobStatus&quot; : &quot;READY&quot;, &quot;jobId&quot; : 3, &quot;command&quot; : &quot;watch demo.MathGame primeFactors \\&quot;&#123;params, returnObj, throwExp&#125;\\&quot; &quot; &#125;&#125; state : SCHEDULED 状态表示已经解析命令生成任务，但未开始执行。 body.jobId : 异步执行命令的任务ID，可以根据此任务ID来过滤在pull_results输出的命令结果。 body.jobStatus : 任务状态READY表示未开始执行。 切换到上面自动拉取结果消息脚本的shell（Terminal 4），查看输出： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&#123; &quot;body&quot; : &#123; &quot;results&quot; : [ &#123; &quot;type&quot; : &quot;command&quot;, &quot;jobId&quot; : 3, &quot;state&quot; : &quot;SCHEDULED&quot;, &quot;command&quot; : &quot;watch demo.MathGame primeFactors \\&quot;&#123;params, returnObj, throwExp&#125;\\&quot; &quot; &#125;, &#123; &quot;inputStatus&quot; : &quot;ALLOW_INTERRUPT&quot;, &quot;jobId&quot; : 0, &quot;type&quot; : &quot;input_status&quot; &#125;, &#123; &quot;success&quot; : true, &quot;jobId&quot; : 3, &quot;effect&quot; : &#123; &quot;listenerId&quot; : 3, &quot;cost&quot; : 24, &quot;classCount&quot; : 1, &quot;methodCount&quot; : 1 &#125;, &quot;type&quot; : &quot;enhancer&quot; &#125;, &#123; &quot;sizeLimit&quot; : 10485760, &quot;expand&quot; : 1, &quot;jobId&quot; : 3, &quot;type&quot; : &quot;watch&quot;, &quot;cost&quot; : 0.071499, &quot;ts&quot; : 1596703453237, &quot;value&quot; : [ [ -170365 ], null, &#123; &quot;stackTrace&quot; : [ &#123; &quot;className&quot; : &quot;demo.MathGame&quot;, &quot;classLoaderName&quot; : &quot;app&quot;, &quot;methodName&quot; : &quot;primeFactors&quot;, &quot;nativeMethod&quot; : false, &quot;lineNumber&quot; : 46, &quot;fileName&quot; : &quot;MathGame.java&quot; &#125;, ... ], &quot;localizedMessage&quot; : &quot;number is: -170365, need &gt;= 2&quot;, &quot;@type&quot; : &quot;java.lang.IllegalArgumentException&quot;, &quot;message&quot; : &quot;number is: -170365, need &gt;= 2&quot; &#125; ] &#125;, &#123; &quot;type&quot; : &quot;watch&quot;, &quot;cost&quot; : 0.033375, &quot;jobId&quot; : 3, &quot;ts&quot; : 1596703454241, &quot;value&quot; : [ [ 1 ], [ 2, 2, 2, 2, 13, 491 ], null ], &quot;sizeLimit&quot; : 10485760, &quot;expand&quot; : 1 &#125; ] &#125;, &quot;consumerId&quot; : &quot;8ecb9cb7c7804d5d92e258b23d5245cc_1&quot;, &quot;sessionId&quot; : &quot;2b085b5d-883b-4914-ab35-b2c5c1d5aa2a&quot;, &quot;state&quot; : &quot;SUCCEEDED&quot;&#125; watch命令结果的value为watch-experss的值，上面命令中为&#123;params, returnObj, throwExp&#125;，所以watch结果的value为一个长度为3的数组，每个元素分别对应相应顺序的表达式。 请参考”watch命令输出map对象”小节。 中断命令执行中断会话正在运行的前台Job（前台任务）： curl -Ss -XPOST http://localhost:8563/api -d &#39;&#39;&#39;;&#123; &quot;action&quot;:&quot;interrupt*job&quot;, &quot;sessionId&quot; : &quot;&#39;&quot;$session*id&quot;&#39;&quot; &#125; 1&#x27;&#x27;&#x27; | json_pp 1234567&#123; &quot;state&quot; : &quot;SUCCEEDED&quot;, &quot;body&quot; : &#123; &quot;jobStatus&quot; : &quot;TERMINATED&quot;, &quot;jobId&quot; : 3 &#125;&#125; 关闭会话指定会话ID，关闭会话。 curl -Ss -XPOST http://localhost:8563/api -d &#39;&#39;&#39;;&#123; &quot;action&quot;:&quot;close*session&quot;, &quot;sessionId&quot; : &quot;&#39;&quot;$session*id&quot;&#39;&quot; &#125; 1&#x27;&#x27;&#x27; | json_pp 123&#123; &quot;state&quot; : &quot;SUCCEEDED&quot;&#125; Web UI 一个基于Http API接口实现的Web UI，访问地址为： 。 已实现功能： 创建会话 复制并打开url加入会话，多人共享会话 周期性拉取会话命令结果消息 刷新页面或者加入会话拉取会话历史命令消息 输入命令/中断命令状态控制 待开发功能： 改进将命令结果消息可读性 命令输入支持自动完成及命令模板 提供命令帮助 支持个人选项设置 watch命令输出map对象watch的结果值由计算watch-express ognl表达式产生，可以通过改变ognl表达式来生成想要的值，请参考OGNL文档。 Maps can also be created using a special syntax. { “foo” : “foo value”, “bar” : “bar value” } 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 最佳实践","slug":"Java-诊断工具-Arthas-最佳实践","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}]},{"title":"Arthas 排查HTTP请求返回404 案例","slug":"Java诊断工具Arthas最佳实践/Arthas排查HTTP请求返回404案例","date":"2021-08-07T00:35:35.000Z","updated":"2021-09-29T02:54:10.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas最佳实践/Arthas排查HTTP请求返回404案例/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5HTTP%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E404%E6%A1%88%E4%BE%8B/","excerpt":"","text":"Start demo Start arthas-boot 排查HTTP请求返回404 跟踪所有的Servlet函数 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个普通的Spring Boot应用为例，演示排查HTTP请求返回404。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ Start demo下载demo-arthas-spring-boot.jar，再用java -jar命令启动： 1wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar demo-arthas-spring-boot是一个很简单的spring boot应用，源代码：查看 启动之后，可以访问61000端口： 点击查看 Start arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help 排查HTTP请求返回404在这个案例里，展示排查HTTP 404问题的技巧。 访问： a.txt 结果是： 1Something went wrong: 404 Not Found 那么到底是哪个Servlet处理了这个请求，返回了404？ 跟踪所有的Servlet函数开始trace： 1trace javax.servlet.Servlet * &gt; /tmp/servlet.txt 访问： a.txt 在Terminal 3里，查看/tmp/servlet.txt的内容： 1less /tmp/servlet.txt /tmp/servlet.txt里的内容会比较多，需要耐心找到调用树里最长的地方。 可以发现请求最终是被freemarker处理的： 123456`---[13.974188ms] org.springframework.web.servlet.ViewResolver:resolveViewName(); +---[0.045561ms] javax.servlet.GenericServlet:&lt;init&gt;() +---[min=0.045545ms,max=0.074342ms,total=0.119887ms,count=2] org.springframework.web.servlet.view.freemarker.FreeMarkerView$GenericServletAdapter:&lt;init&gt;() +---[0.170895ms] javax.servlet.GenericServlet:init() | `---[0.068578ms] javax.servlet.GenericServlet:init() | `---[0.021793ms] javax.servlet.GenericServlet:init() `---[0.164035ms] javax.servlet.GenericServlet:getServletContext() 更多信息通过本教程基本掌握了Arthas排查HTTP请求返回404。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 最佳实践","slug":"Java-诊断工具-Arthas-最佳实践","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}]},{"title":"Arthas 排查HTTP请求返回401 案例","slug":"Java诊断工具Arthas最佳实践/Arthas排查HTTP请求返回401案例","date":"2021-08-07T00:35:34.000Z","updated":"2021-09-29T02:54:10.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas最佳实践/Arthas排查HTTP请求返回401案例/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5HTTP%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E401%E6%A1%88%E4%BE%8B/","excerpt":"","text":"Start demo Start arthas-boot 排查HTTP请求返回401 跟踪所有的Filter函数 通过stack获取调用栈 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个普通的Spring Boot应用为例，演示排查HTTP请求返回401。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ Start demo下载demo-arthas-spring-boot.jar，再用java -jar命令启动： 1wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar demo-arthas-spring-boot是一个很简单的spring boot应用，源代码：查看 启动之后，可以访问61000端口： 点击查看 Start arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help 排查HTTP请求返回401在这个案例里，展示排查HTTP 401问题的技巧。 访问： admin 结果是： 1Something went wrong: 401 Unauthorized 我们知道401通常是被权限管理的Filter拦截了，那么到底是哪个Filter处理了这个请求，返回了401？ 跟踪所有的Filter函数开始trace： 1trace javax.servlet.Filter * 访问： admin 可以在调用树的最深层，找到AdminFilterConfig$AdminFilter返回了401： 123+---[3.806273ms] javax.servlet.FilterChain:doFilter()| `---[3.447472ms] com.example.demo.arthas.AdminFilterConfig$AdminFilter:doFilter()| `---[0.17259ms] javax.servlet.http.HttpServletResponse:sendError() 通过stack获取调用栈上面是通过trace命令来获取信息，从结果里，我们可以知道通过stack跟踪HttpServletResponse:sendError()，同样可以知道是哪个Filter返回了401 执行： 1stack javax.servlet.http.HttpServletResponse sendError &#x27;params[0]==401&#x27; 访问： admin 12345678910$ stack javax.servlet.http.HttpServletResponse sendError &#x27;params[0]==401&#x27;Press Q or Ctrl+C to abort.Affect(class-cnt:2 , method-cnt:4) cost in 87 ms.ts=2019-02-15 16:44:06;thread_name=http-nio-8080-exec-6;id=16;is_daemon=true;priority=5;TCCL=org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedWebappClassLoader@8546cd5 @org.apache.catalina.connector.ResponseFacade.sendError() at com.example.demo.arthas.AdminFilterConfig$AdminFilter.doFilter(AdminFilterConfig.java:38) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 更多信息通过本教程基本掌握了Arthas排查HTTP请求返回401。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 最佳实践","slug":"Java-诊断工具-Arthas-最佳实践","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}]},{"title":"Arthas 获取Spring Context 案例","slug":"Java诊断工具Arthas最佳实践/Arthas获取Spring上下文案例","date":"2021-08-07T00:35:33.000Z","updated":"2021-09-29T02:54:06.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas最佳实践/Arthas获取Spring上下文案例/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E8%8E%B7%E5%8F%96Spring%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A1%88%E4%BE%8B/","excerpt":"","text":"Start demo Start arthas-boot 获取Spring Context 使用tt命令获取到spring context 使用tt命令从调用记录里获取到spring context 获取spring bean，并调用函数 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个普通的Spring Boot应用为例，演示获取Spring Context 案例。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ Start demo下载demo-arthas-spring-boot.jar，再用java -jar命令启动： 1wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar demo-arthas-spring-boot是一个很简单的spring boot应用，源代码：查看 启动之后，可以访问61000端口： 点击查看 Start arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help 获取Spring Context在这个案例里，展示获取spring context，再获取bean，然后调用函数。 使用tt命令获取到spring contexttt即 TimeTunnel，它可以记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测。 https://arthas.aliyun.com/doc/tt.html 1tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter invokeHandlerMethod 访问：user/1 可以看到tt命令捕获到了一个请求： 1234567$ tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdaptePress Q or Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:1) cost in 252 ms. INDE TIMESTAMP COST( IS-R IS- OBJECT CLASS METHOD X ms) ET EXP----------------------------------------------------------------------------------------- 1000 2019-02-15 4.583 true fal 0xc93cf1a RequestMappingHand invokeHandlerMethod 15:38:32 923 se lerAdapter 使用tt命令从调用记录里获取到spring context输入 q 或者 Ctrl + C 退出上面的 tt -t命令。 1q 1tt -i 1000 -w &#x27;target.getApplicationContext()&#x27; 1$ tt -i 1000 -w &#x27;target.getApplicationContext()&#x27;@AnnotationConfigEmbeddedWebApplicationContext[ reader=@AnnotatedBeanDefinitionReader[org.springframework.context.annotation.AnnotatedBeanDefinitionReader@2e457641], scanner=@ClassPathBeanDefinitionScanner[org.springframework.context.annotation.ClassPathBeanDefinitionScanner@6eb38026], annotatedClasses=null, basePackages=null,]Affect(row-cnt:1) cost in 439 ms. 获取spring bean，并调用函数1tt -i 1000 -w &#x27;target.getApplicationContext().getBean(&quot;helloWorldService&quot;).getHelloMessage()&#x27; 结果是： 1$ tt -i 1000 -w &#x27;target.getApplicationContext().getBean(&quot;helloWorldService&quot;).getHelloMessage()&#x27;@String[Hello World]Affect(row-cnt:1) cost in 52 ms. 更多信息通过本教程基本掌握了Arthas获取Spring Context。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 最佳实践","slug":"Java-诊断工具-Arthas-最佳实践","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}]},{"title":"Arthas arthas-boot支持的参数 案例","slug":"Java诊断工具Arthas最佳实践/学习Arthasarthas-boot支持的参数案例","date":"2021-08-07T00:35:32.000Z","updated":"2021-09-29T02:54:06.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas最佳实践/学习Arthasarthas-boot支持的参数案例/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%AD%A6%E4%B9%A0Arthasarthas-boot%E6%94%AF%E6%8C%81%E7%9A%84%E5%8F%82%E6%95%B0%E6%A1%88%E4%BE%8B/","excerpt":"","text":"Arthas demo arthas-boot支持的参数 参数详解 指定目标pid 允许外部访问 列出所有的版本 打印运行的详情 指定需要执行的命令目标pid 指定需要执行的批处理文件目标pid 通过类名或者jar文件名指定目标进程 指定会话超时秒数 仅附加目标进程，不连接 指定镜像仓库，强制使用http 指定arthas客户端命令行宽高 指定arthas主目录 以Java Agent的方式启动 使用as.sh 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示arthas-boot支持的参数。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ Arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar  arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 arthas-boot支持的参数在新的Terminal 2里，下载arthas-boot.jar： 1wget https://arthas.aliyun.com/arthas-boot.jar arthas-boot.jar 支持很多参数，可以执行 java -jar arthas-boot.jar -h 来查看。 1java -jar arthas-boot.jar -h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556$ java -jar arthas-boot.jar -h[INFO] arthas-boot version: 3.3.6Usage: arthas-boot [-h] [--target-ip &lt;value&gt;] [--telnet-port &lt;value&gt;] [--http-port &lt;value&gt;] [--session-timeout &lt;value&gt;] [--arthas-home &lt;value&gt;] [--use-version &lt;value&gt;] [--repo-mirror &lt;value&gt;] [--versions] [--use-http] [--attach-only] [-c &lt;value&gt;] [-f &lt;value&gt;] [--height &lt;value&gt;] [--width &lt;value&gt;] [-v] [--tunnel-server &lt;value&gt;] [--agent-id &lt;value&gt;] [--stat-url &lt;value&gt;] [--select &lt;value&gt;] [pid]Bootstrap ArthasEXAMPLES: java -jar arthas-boot.jar &lt;pid&gt; java -jar arthas-boot.jar --target-ip 0.0.0.0 java -jar arthas-boot.jar --telnet-port 9999 --http-port -1 java -jar arthas-boot.jar --tunnel-server &#x27;ws://192.168.10.11:7777/ws&#x27; java -jar arthas-boot.jar --tunnel-server &#x27;ws://192.168.10.11:7777/ws&#x27;--agent-id bvDOe8XbTM2pQWjF4cfw java -jar arthas-boot.jar --stat-url &#x27;http://192.168.10.11:8080/api/stat&#x27; java -jar arthas-boot.jar -c &#x27;sysprop; thread&#x27; &lt;pid&gt; java -jar arthas-boot.jar -f batch.as &lt;pid&gt; java -jar arthas-boot.jar --use-version 3.3.6 java -jar arthas-boot.jar --versions java -jar arthas-boot.jar --select arthas-demo java -jar arthas-boot.jar --session-timeout 3600 java -jar arthas-boot.jar --attach-only java -jar arthas-boot.jar --repo-mirror aliyun --use-httpWIKI: https://arthas.aliyun.com/docOptions and Arguments: -h,--help Print usage --target-ip &lt;value&gt; The target jvm listen ip, default 127.0.0.1 --telnet-port &lt;value&gt; The target jvm listen telnet port, default 3658 --http-port &lt;value&gt; The target jvm listen http port, default 8563 --session-timeout &lt;value&gt; The session timeout seconds, default 1800 (30min) --arthas-home &lt;value&gt; The arthas home --use-version &lt;value&gt; Use special version arthas --repo-mirror &lt;value&gt; Use special maven repository mirror, value is center/aliyun or http repo url. --versions List local and remote arthas versions --use-http Enforce use http to download, default use https --attach-only Attach target process only, do not connect -c,--command &lt;value&gt; Command to execute, multiple commands separated by ; -f,--batch-file &lt;value&gt; The batch file to execute --height &lt;value&gt; arthas-client terminal height --width &lt;value&gt; arthas-client terminal width -v,--verbose Verbose, print debug info. --tunnel-server &lt;value&gt; The tunnel server url --agent-id &lt;value&gt; The agent id register to tunnel server --stat-url &lt;value&gt; The report stat url --select &lt;value&gt; select target process by classname or JARfilename &lt;pid&gt; Target pid 参数详解指定目标pid可以使用jps命令查看pid。 1jps 直接在参数中添加pid，可指定目标pid。 1java -jar arthas-boot.jar 1 允许外部访问默认情况下， arthas server侦听的是 127.0.0.1 这个IP，如果希望远程可以访问，可以使用--target-ip的参数。 1java -jar arthas-boot.jar --target-ip 0.0.0.0 列出所有的版本1java -jar arthas-boot.jar --versions 使用指定版本： 1java -jar arthas-boot.jar --use-version 3.1.0 打印运行的详情使用-v或者-verbose。 1java -jar arthas-boot.jar -v 指定需要执行的命令目标pid可以使用--command或者-c参数指定，并同时指定pid，多个命令之间用;分隔。 1java -jar arthas-boot.jar -c &#x27;sysprop; thread&#x27; 1 指定需要执行的批处理文件目标pid可以使用--command或者-c参数指定，并同时指定pid。 1java -jar arthas-boot.jar -f batch.as 1 通过类名或者jar文件名指定目标进程通过--select参数类名或者jar文件名指定目标进程 1java -jar arthas-boot.jar --select arthas-demo 指定会话超时秒数使用--session-timeout参数指定，默认为1800(30分钟) 1java -jar arthas-boot.jar --session-timeout 3600 仅附加目标进程，不连接1java -jar arthas-boot.jar --attach-only 指定镜像仓库，强制使用http--repo-mirror使用特定maven仓库镜像，参数可以为center/aliyun或http仓库地址。 --use-http强制使用http下载，默认使用https。 1java -jar arthas-boot.jar --repo-mirror aliyun --use-http 指定arthas客户端命令行宽高1java -jar arthas-boot.jar --height 25 --width 80 指定arthas主目录1java -jar arthas-boot.jar --arthas-home . 以Java Agent的方式启动通常Arthas是以动态attach的方式来诊断应用，但从3.2.0版本起，Arthas支持直接以 java agent的方式启动。 比如下载全量的arthas zip包，解压之后以 -javaagent 的参数指定arthas-agent.jar来启动： 1java -javaagent:/tmp/test/arthas-agent.jar -jar arthas-demo.jar 默认的配置项在解压目录里的arthas.properties文件里。 参考： https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html 使用as.shArthas 支持在 Linux/Unix/Mac 等平台上一键安装： 1curl -L https://arthas.aliyun.com/install.sh | sh 上述命令会下载启动脚本文件 as.sh 到当前目录，你可以放在任何地方或将其加入到 $PATH 中。 直接在shell下面执行./as.sh，就会进入交互界面。 也可以执行./as.sh -h来获取更多参数信息, 具体用法与java -jar arthas-boot.jar类似。 更多信息通过本教程基本掌握了Arthas boot支持的参数。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 最佳实践","slug":"Java-诊断工具-Arthas-最佳实践","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}]},{"title":"Arthas 理解Spring Boot应用的ClassLoader结构 案例","slug":"Java诊断工具Arthas最佳实践/学习Arthasclassloader案例","date":"2021-08-07T00:35:32.000Z","updated":"2021-09-29T02:54:14.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas最佳实践/学习Arthasclassloader案例/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%AD%A6%E4%B9%A0Arthasclassloader%E6%A1%88%E4%BE%8B/","excerpt":"","text":"Start demo Start arthas-boot 理解Spring Boot应用的ClassLoader结构 列出所有ClassLoader 列出ClassLoader里加载的所有类 查看类的classloader层次 查看ClassLoader树 查看URLClassLoader实际的urls 加载指定ClassLoader里的资源文件 尝试加载指定的类 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个普通的Spring Boot应用为例，演示Arthas Spring Boot应用的ClassLoader结构。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ Start demo下载demo-arthas-spring-boot.jar，再用java -jar命令启动： 1wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar demo-arthas-spring-boot是一个很简单的spring boot应用，源代码：查看 启动之后，可以访问61000端口： 点击查看 Start arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help 理解Spring Boot应用的ClassLoader结构下面介绍classloader命令的功能。 先访问一个jsp网页，触发jsp的加载： hello 列出所有ClassLoader1classloader -l 1234567891011121314151617181920$ classloader -l name loadedCount hash parent BootstrapClassLoader 2724 null null com.taobao.arthas.agent.ArthasClassloader@411ce1ab 2009 411ce1ab sun.misc.Launcher$ExtClassLoader@7494e528 com.taobao.arthas.agent.ArthasClassloader@22ae1234 1253 22ae1234 sun.misc.Launcher$ExtClassLoader@7494e528 org.apache.jasper.servlet.JasperLoader@65361d9a 1 65361d9a TomcatEmbeddedWebappClassLoader context: ROOT delegate: true ----------&gt; Parent Classloader: org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3 TomcatEmbeddedWebappClassLoader 0 8546cd5 org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3 context: ROOT delegate: true ----------&gt; Parent Classloader: org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3 org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3 5416 1be6f5c3 sun.misc.Launcher$AppClassLoader@3d4eac69 sun.misc.Launcher$AppClassLoader@3d4eac69 45 3d4eac69 sun.misc.Launcher$ExtClassLoader@7494e528 sun.misc.Launcher$ExtClassLoader@7494e528 4 7494e528 null TomcatEmbeddedWebappClassLoader 加载的class数量是0，所以在spring boot embedded tomcat里，它只是一个空壳，所有的类加载都是LaunchedURLClassLoader完成的 请记下你的classLoaderHash，后面需要使用它。在这里，它是 65361d9a。 注意：请使用你的classLoaderHash值覆盖 &lt;classLoaderHash&gt; ，然后手动执行下面所有所述命令： 列出ClassLoader里加载的所有类列出上面的org.apache.jasper.servlet.JasperLoader加载的类： 1234classloader -a -c &lt;classLoaderHash&gt;$ classloader -a -c 65361d9a hash:1698045338, org.apache.jasper.servlet.JasperLoader@65361d9a org.apache.jsp.jsp.hello_jsp 查看类的classloader层次1sc -d org.apache.jsp.jsp.hello_jsp 查看ClassLoader树1classloader -t 1$ classloader -t+-BootstrapClassLoader+-sun.misc.Launcher$ExtClassLoader@28cbbddd +-com.taobao.arthas.agent.ArthasClassloader@8c25e55 +-sun.misc.Launcher$AppClassLoader@55f96302 +-org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3 +-TomcatEmbeddedWebappClassLoader context: ROOT delegate: true ----------&gt; Parent Classloader: org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3 +-org.apache.jasper.servlet.JasperLoader@21ae0fe2 查看URLClassLoader实际的urls比如上面查看到的spring LaunchedURLClassLoader的 hashcode是1be6f5c3，可以通过-c参数来指定classloader，从而查看URLClassLoader实际的urls： 1classloader -c &lt;classLoaderHash&gt;$ classloader -c 1be6f5c3jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/classes!/jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/lib/spring-boot-starter-aop-1.5.13.RELEASE.jar!/... 加载指定ClassLoader里的资源文件查找指定的资源文件： classloader -c &lt;classLoaderHash&gt; -r logback-spring.xml 1$ classloader -c 1be6f5c3 -r logback-spring.xml jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/classes!/logback-spring.xml 也可以尝试查找类的class文件： 1classloader -c &lt;classLoaderHash&gt; -r java/lang/String.class$ classloader -c 1b6d3586 -r java/lang/String.class jar:file:/Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/Home/jre/lib/rt.jar!/java/lang/String.class 尝试加载指定的类比如用上面的spring LaunchedURLClassLoader 尝试加载 ch.qos.logback.classic.spi.StackTraceElementProxy ： 首先使用sc ch.qos.logback.classic.spi.StackTraceElementProxy查看，可发现未加载： 1sc ch.qos.logback.classic.spi.StackTraceElementProxy  1Affect(row-cnt:0) cost in 18 ms. 因而使用spring LaunchedURLClassLoader 尝试加载： 1classloader -c &lt;classLoaderHash&gt; --load ch.qos.logback.classic.spi.StackTraceElementProxy$ classloader -c 1be6f5c3 --load ch.qos.logback.classic.spi.StackTraceElementProxyload class success. class-info ch.qos.logback.classic.spi.StackTraceElementProxy code-source file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/lib/logback-classic-1. 1.11.jar!/ name ch.qos.logback.classic.spi.StackTraceElementProxy isInterface false isAnnotation false isEnum false isAnonymousClass false isArray false isLocalClass false isMemberClass false isPrimitive false isSynthetic false simple-name StackTraceElementProxy modifier public annotation interfaces java.io.Serializable super-class +-java.lang.Object class-loader +-org.springframework.boot.loader.LaunchedURLClassLoader@5674cd4d +-sun.misc.Launcher$AppClassLoader@70dea4e +-sun.misc.Launcher$ExtClassLoader@56a96482 classLoaderHash 5674cd4d 再次使用sc ch.qos.logback.classic.spi.StackTraceElementProxy查看，发现已经加载： 1sc ch.qos.logback.classic.spi.StackTraceElementProxy 1ch.qos.logback.classic.spi.StackTraceElementProxyAffect(row-cnt:1) cost in 19 ms. 更多信息通过本教程基本掌握了Arthas Spring Boot应用的ClassLoader结构。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 最佳实践","slug":"Java-诊断工具-Arthas-最佳实践","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}]},{"title":"Arthas 后台异步任务 案例","slug":"Java诊断工具Arthas最佳实践/Arthas后台异步任务案例","date":"2021-08-07T00:35:31.000Z","updated":"2021-09-29T02:54:10.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas最佳实践/Arthas后台异步任务案例/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E5%90%8E%E5%8F%B0%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%A1%88%E4%BE%8B/","excerpt":"","text":"Arthas demo Start arthas-boot 后台异步任务 使用&amp;在后台执行任务 通过jobs查看任务 任务暂停和取消 fg、bg命令，将命令转到前台、后台继续执行 任务输出重定向 停止命令 其他 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决： 这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到JVM的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 本教程会以一个简单的应用为例，演示后台异步任务。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ Arthas demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 Start arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help 后台异步任务arthas中的后台异步任务，使用了仿linux系统任务相关的命令。linux任务相关介绍。 使用&amp;在后台执行任务比如希望执行后台执行trace命令，那么调用下面命令 1trace demo.MathGame primeFactors &amp; 这时命令在后台执行，可以在console中继续执行其他命令。 通过jobs查看任务如果希望查看当前有哪些arthas任务在执行，可以执行jobs命令，执行结果如下 1jobs 1234567$ jobs[1]* Running trace demo.MathGame primeFactors &amp; execution count : 49 start time : Wed Jul 22 05:47:52 GMT 2020 timeout date : Thu Jul 23 05:47:52 GMT 2020 session : aa75753d-74f1-4929-a829-7ff965345183 (current) 可以看到目前有一个后台任务在执行。 job id是10, * 表示此job是当前session创建 状态是Stopped execution count是执行次数，从启动开始已经执行了19次 timeout date是超时的时间，到这个时间，任务将会自动超时退出 任务暂停和取消当任务正在前台执行，比如直接调用命令trace Test t或者调用后台执行命令trace Test t &amp;后又通过fg命令将任务转到前台。这时console中无法继续执行命令，但是可以接收并处理以下事件： ctrl + z：将任务暂停。通过jbos查看任务状态将会变为Stopped，通过bg &lt;job-id&gt;或者fg &lt;job-id&gt;可让任务重新开始执行 ctrl + c：停止任务 ctrl + d：按照linux语义应当是退出终端，目前arthas中是空实现，不处理 fg、bg命令，将命令转到前台、后台继续执行 任务在后台执行或者暂停状态（ctrl + z暂停任务）时，执行fg &lt;job-id&gt;将可以把对应的任务转到前台继续执行。在前台执行时，无法在console中执行其他命令 当任务处于暂停状态时（ctrl + z暂停任务），执行bg &lt;job-id&gt;将可以把对应的任务在后台继续执行 非当前session创建的job，只能由当前session fg到前台执行 任务输出重定向可通过&gt;或者&gt;&gt;将任务输出结果输出到指定的文件中，可以和&amp;一起使用，实现arthas命令的后台异步任务。比如： 1trace demo.MathGame primeFactors &gt;&gt; test.out &amp; 这时trace命令会在后台执行，并且把结果输出到~/logs/arthas-cache/test.out。可继续执行其他命令。并可查看文件中的命令执行结果。 1cat test.out 当连接到远程的arthas server时，可能无法查看远程机器的文件，arthas同时支持了自动重定向到本地缓存路径。使用方法如下： 1trace demo.MathGame primeFactors &gt;&gt; &amp; 123$ trace Test t &gt;&gt; &amp;job id : 2cache location : /Users/gehui/logs/arthas-cache/28198/2 可以看到并没有指定重定向文件位置，arthas自动重定向到缓存中了，执行命令后会输出job id和cache location。cache location就是重定向文件的路径，在系统logs目录下，路径包括pid和job id，避免和其他任务冲突。命令输出结果到/Users/gehui/logs/arthas-cache/28198/2中，job id为2。 停止命令异步执行的命令，如果希望停止，可执行kill 其他 最多同时支持8个命令使用重定向将结果写日志 请勿同时开启过多的后台异步命令，以免对目标JVM性能造成影响 如果不想停止arthas，继续执行后台任务，可以执行 quit 退出arthas控制台（stop 会停止arthas 服务） 更多信息通过本教程基本掌握了Arthas后台异步任务。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 最佳实践","slug":"Java-诊断工具-Arthas-最佳实践","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}]},{"title":"Arthas 进阶","slug":"Java诊断工具Arthas入门教程/Arthas-进阶","date":"2021-08-07T00:01:59.000Z","updated":"2021-09-29T02:54:26.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas入门教程/Arthas-进阶/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/Arthas-%E8%BF%9B%E9%98%B6/","excerpt":"","text":"启动demo 启动arthas-boot 查看JVM信息 sysprop sysenv jvm dashboard Tips help 自动补全 readline的快捷键支持 历史命令的补全 pipeline sc/sm 查看已加载的类 sc sm Jad Ognl 调用static函数 查找UserController的ClassLoader 获取静态类的静态字段 执行多行表达式，赋值给临时变量，返回一个List 更多 案例: 排查函数调用异常 现象 查看UserController的 参数/异常 返回值表达式 条件表达式 当异常时捕获 按照耗时进行过滤 案例: 热更新代码 jad反编译UserController sc查找加载UserController的ClassLoader mc redefine 热修改代码结果 案例: 动态更新应用Logger Level 查找UserController的ClassLoader 用ognl获取logger 单独设置UserController的logger level 修改logback的全局logger level 案例: 排查logger冲突问题 确认应用使用的logger系统 获取logback实际加载的配置文件 使用classloader命令查找可能存在的logger配置文件 案例: 获取Spring Context 使用tt命令获取到spring context 使用tt命令从调用记录里获取到spring context 获取spring bean，并调用函数 案例: 排查HTTP请求返回401 跟踪所有的Filter函数 通过stack获取调用栈 案例: 排查HTTP请求返回404 跟踪所有的Servlet函数 案例: 理解Spring Boot应用的ClassLoader结构 列出所有ClassLoader 列出ClassLoader里加载的所有类 反编译jsp的代码 查看ClassLoader树 列出ClassLoader的urls 加载指定ClassLoader里的资源文件 尝试加载指定的类 案例：查找Top N线程 查看所有线程信息 查看具体线程的栈 查看CPU使用率top n线程的栈 查找线程是否有阻塞 Web Console 本地体验 Exit/Stop reset 退出Arthas 彻底退出Arthas arthas-boot支持的参数 允许外部访问 列出所有的版本 只侦听Telnet端口，不侦听HTTP端口 打印运行的详情 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。 本教程会以一个普通的Spring Boot应用为例，演示Arthas命令的详细用法。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动demo下载demo-arthas-spring-boot.jar，再用java -jar命令启动： 1wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar demo-arthas-spring-boot是一个很简单的spring boot应用，源代码：查看 启动之后，可以访问61000端口： 点击查看 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar --target-ip 0.0.0.0 arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help 查看JVM信息下面介绍Arthas里查看JVM信息的命令。 syspropsysprop 可以打印所有的System Properties信息。 1sysprop 也可以指定单个key： sysprop java.version 1sysprop java.version 也可以通过grep来过滤： sysprop | grep user 1sysprop | grep user 可以设置新的value： sysprop testKey testValue 1sysprop testKey testValue sysenvsysenv 命令可以获取到环境变量。和sysprop命令类似。 1sysenv jvmjvm 命令会打印出JVM的各种详细信息。 1jvm dashboarddashboard 命令可以查看当前系统的实时数据面板。 1dashboard 输入 q 或者 Ctrl+C 可以退出dashboard命令。 1q Tips为了更好使用Arthas，下面先介绍Arthas里的一些使用技巧。 helpArthas里每一个命令都有详细的帮助信息。可以用-h来查看。帮助信息里有EXAMPLES和WIKI链接。 比如： 1sysprop -h 自动补全Arthas支持丰富的自动补全功能，在使用有疑惑时，可以输入Tab来获取更多信息。 比如输入 sysprop java. 之后，再输入Tab，会补全出对应的key： 1234$ sysprop java.java.runtime.name java.protocol.handler.pkgs java.vm.versionjava.vm.vendor java.vendor.url java.vm.name... readline的快捷键支持Arthas支持常见的命令行快捷键，比如Ctrl + A跳转行首，Ctrl + E跳转行尾。 更多的快捷键可以用 keymap 命令查看。 1keymap 历史命令的补全如果想再执行之前的命令，可以在输入一半时，按Up/↑ 或者 Ddown/↓，来匹配到之前的命令。 比如之前执行过sysprop java.version，那么在输入sysprop ja之后，可以输入Up/↑，就会自动补全为sysprop java.version。 如果想查看所有的历史命令，也可以通过 history 命令查看到。 1history pipelineArthas支持在pipeline之后，执行一些简单的命令，比如： 12sysprop | grep javasysprop | grep java 12sysprop | wc -lsysprop | wc -l sc/sm 查看已加载的类下面介绍Arthas里查找已加载类的命令。 scsc 命令可以查找到所有JVM已经加载到的类。 如果搜索的是接口，还会搜索所有的实现类。比如查看所有的Filter实现类： 1sc javax.servlet.Filter 通过-d参数，可以打印出类加载的具体信息，很方便查找类加载问题。 1sc -d javax.servlet.Filter sc支持通配，比如搜索所有的StringUtils： 1sc *StringUtils smsm命令则是查找类的具体函数。比如： 1sm java.math.RoundingMode 通过-d参数可以打印函数的具体属性： 1sm -d java.math.RoundingMode 也可以查找特定的函数，比如查找构造函数： 1sm java.math.RoundingMode &lt;init&gt; Jad可以通过 jad 命令来反编译代码： 1jad com.example.demo.arthas.user.UserController 通过--source-only参数可以只打印出在反编译的源代码： 1jad --source-only com.example.demo.arthas.user.UserController Ognl在Arthas里，有一个单独的ognl命令，可以动态执行代码。 调用static函数1ognl &#x27;@java.lang.System@out.println(&quot;hello ognl&quot;)&#x27; 可以检查Terminal 1里的进程输出，可以发现打印出了hello ognl。 查找UserController的ClassLoader1sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash 12$ sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash classLoaderHash 1be6f5c3 注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。 如果你使用-c，你需要手动输入hashcode：-c &lt;hashcode&gt; 1$ ognl -c 1be6f5c3 @com.example.demo.arthas.user.UserController@logger 对于只有唯一实例的ClassLoader可以通过--classLoaderClass指定class name，使用起来更加方便： 123456$ ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader @org.springframework.boot.SpringApplication@logger@Slf4jLocationAwareLog[ FQCN=@String[org.apache.commons.logging.LogAdapter$Slf4jLocationAwareLog], name=@String[org.springframework.boot.SpringApplication], logger=@Logger[Logger[org.springframework.boot.SpringApplication]],] --classLoaderClass 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而-c &lt;hashcode&gt;是动态变化的。 获取静态类的静态字段获取UserController类里的logger字段： 1ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader @com.example.demo.arthas.user.UserController@logger 还可以通过-x参数控制返回值的展开层数。比如： 1ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -x 2 @com.example.demo.arthas.user.UserController@logger 执行多行表达式，赋值给临时变量，返回一个List1ognl &#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27; 12345$ ognl &#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27;@ArrayList[ @String[/Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre], @String[Java(TM) SE Runtime Environment],] 更多在Arthas里ognl表达式是很重要的功能，在很多命令里都可以使用ognl表达式。 一些更复杂的用法，可以参考： OGNL特殊用法请参考：https://github.com/alibaba/arthas/issues/71 OGNL表达式官方指南：https://commons.apache.org/proper/commons-ognl/language-guide.html 案例: 排查函数调用异常现象目前，访问 http://localhost:61000/user/0 ，会返回500异常： 1curl http://localhost:61000/user/0 1&#123;&quot;timestamp&quot;:1550223186170,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;exception&quot;:&quot;java.lang.IllegalArgumentException&quot;,&quot;message&quot;:&quot;id &lt; 1&quot;,&quot;path&quot;:&quot;/user/0&quot;&#125; 但请求的具体参数，异常栈是什么呢？ 查看UserController的 参数/异常在Arthas里执行： 1watch com.example.demo.arthas.user.UserController * &#x27;&#123;params, throwExp&#125;&#x27; 第一个参数是类名，支持通配 第二个参数是函数名，支持通配 访问 curl http://localhost:61000/user/0 ,watch命令会打印调用的参数和异常 1curl http://localhost:61000/user/0 1234567$ watch com.example.demo.arthas.user.UserController * &#x27;&#123;params, throwExp&#125;&#x27;Press Q or Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:2) cost in 53 ms.ts=2019-02-15 01:35:25; [cost=0.996655ms] result=@ArrayList[ @Object[][isEmpty=false;size=1], @IllegalArgumentException[java.lang.IllegalArgumentException: id &lt; 1],] 可以看到实际抛出的异常是IllegalArgumentException。 可以输入 q 或者 Ctrl+C 退出watch命令。 1q 如果想把获取到的结果展开，可以用-x参数： 1watch com.example.demo.arthas.user.UserController * &#x27;&#123;params, throwExp&#125;&#x27; -x 2 返回值表达式在上面的例子里，第三个参数是返回值表达式，它实际上是一个ognl表达式，它支持一些内置对象： loader clazz method target params returnObj throwExp isBefore isThrow isReturn 你可以利用这些内置对象来组成不同的表达式。比如返回一个数组： 1watch com.example.demo.arthas.user.UserController * &#x27;&#123;params[0], target, returnObj&#125;&#x27; 更多参考： https://arthas.aliyun.com/doc/advice-class.html 条件表达式watch命令支持在第4个参数里写条件表达式，比如： 1watch com.example.demo.arthas.user.UserController * returnObj &#x27;params[0] &gt; 100&#x27; 当访问 user/1 时，watch命令没有输出 当访问 user/101 时，watch会打印出结果。 1234567$ watch com.example.demo.arthas.user.UserController * returnObj &#x27;params[0] &gt; 100&#x27;Press Q or Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:2) cost in 47 ms.ts=2019-02-13 19:42:12; [cost=0.821443ms] result=@User[ id=@Integer[101], name=@String[name101],] 当异常时捕获watch命令支持-e选项，表示只捕获抛出异常时的请求： 1watch com.example.demo.arthas.user.UserController * &quot;&#123;params[0],throwExp&#125;&quot; -e 按照耗时进行过滤watch命令支持按请求耗时进行过滤，比如： 1watch com.example.demo.arthas.user.UserController * &#x27;&#123;params, returnObj&#125;&#x27; &#x27;#cost&gt;200&#x27; 案例: 热更新代码下面介绍通过jad/mc/redefine 命令实现动态更新代码的功能。 目前，访问 http://localhost:61000/user/0 ，会返回500异常： 1curl http://localhost:61000/user/0 1&#123;&quot;timestamp&quot;:1550223186170,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;exception&quot;:&quot;java.lang.IllegalArgumentException&quot;,&quot;message&quot;:&quot;id &lt; 1&quot;,&quot;path&quot;:&quot;/user/0&quot;&#125; 下面通过热更新代码，修改这个逻辑。 jad反编译UserController1jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java jad反编译的结果保存在 /tmp/UserController.java文件里了。 再打开一个Terminal 3，然后用vim来编辑/tmp/UserController.java： 1vim /tmp/UserController.java 比如当 user id 小于1时，也正常返回，不抛出异常： 123456789@GetMapping(value=&#123;&quot;/user/&#123;id&#125;&quot;&#125;)public User findUserById(@PathVariable Integer id) &#123; logger.info(&quot;id: &#123;&#125;&quot;, (Object)id); if (id != null &amp;&amp; id &lt; 1) &#123; return new User(id, &quot;name&quot; + id); // throw new IllegalArgumentException(&quot;id &lt; 1&quot;); &#125; return new User(id.intValue(), &quot;name&quot; + id);&#125; sc查找加载UserController的ClassLoader1sc -d *UserController | grep classLoaderHash 12$ sc -d *UserController | grep classLoaderHash classLoaderHash 1be6f5c3 可以发现是 spring boot LaunchedURLClassLoader@1be6f5c3 加载的。 请记下你的classLoaderHash，后面需要使用它。在这里，它是 1be6f5c3。 mc保存好/tmp/UserController.java之后，使用mc(Memory Compiler)命令来编译，并且通过-c或者--classLoaderClass参数指定ClassLoader： 1mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmp 1234$ mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmpMemory compiler output:/tmp/com/example/demo/arthas/user/UserController.classAffect(row-cnt:1) cost in 346 ms 也可以通过mc -c &lt;classLoaderHash&gt; /tmp/UserController.java -d /tmp，使用-c参数指定ClassLoaderHash: 1$ mc -c 1be6f5c3 /tmp/UserController.java -d /tmp redefine再使用redefine命令重新加载新编译好的UserController.class： 1redefine /tmp/com/example/demo/arthas/user/UserController.class 12$ redefine /tmp/com/example/demo/arthas/user/UserController.classredefine success, size: 1 热修改代码结果redefine成功之后，再次访问 user/0 ，结果是： 1234&#123; &quot;id&quot;: 0, &quot;name&quot;: &quot;name0&quot;&#125; 案例: 动态更新应用Logger Level在这个案例里，动态修改应用的Logger Level。 查找UserController的ClassLoader1sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash 12$ sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash classLoaderHash 1be6f5c3 用ognl获取logger1ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger&#x27; 12345678910111213$ ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger&#x27;@Logger[ serialVersionUID=@Long[5454405123156820674], FQCN=@String[ch.qos.logback.classic.Logger], name=@String[com.example.demo.arthas.user.UserController], level=null, effectiveLevelInt=@Integer[20000], parent=@Logger[Logger[com.example.demo.arthas.user]], childrenList=null, aai=null, additive=@Boolean[true], loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],] 可以知道UserController@logger实际使用的是logback。可以看到level=null，则说明实际最终的level是从root logger里来的。 单独设置UserController的logger level1ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger.setLevel(@ch.qos.logback.classic.Level@DEBUG)&#x27; 再次获取UserController@logger，可以发现已经是DEBUG了： 1ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger&#x27; 12345678910111213$ ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger&#x27;@Logger[ serialVersionUID=@Long[5454405123156820674], FQCN=@String[ch.qos.logback.classic.Logger], name=@String[com.example.demo.arthas.user.UserController], level=@Level[DEBUG], effectiveLevelInt=@Integer[10000], parent=@Logger[Logger[com.example.demo.arthas.user]], childrenList=null, aai=null, additive=@Boolean[true], loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],] 修改logback的全局logger level通过获取root logger，可以修改全局的logger level： 1ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@org.slf4j.LoggerFactory@getLogger(&quot;root&quot;).setLevel(@ch.qos.logback.classic.Level@DEBUG)&#x27; 案例: 排查logger冲突问题在这个案例里，展示排查logger冲突的方法。 确认应用使用的logger系统以UserController为例，它使用的是slf4j api，但实际使用到的logger系统是logback。 1ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger&#x27; 12345678910111213$ ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;@com.example.demo.arthas.user.UserController@logger&#x27;@Logger[ serialVersionUID=@Long[5454405123156820674], FQCN=@String[ch.qos.logback.classic.Logger], name=@String[com.example.demo.arthas.user.UserController], level=null, effectiveLevelInt=@Integer[20000], parent=@Logger[Logger[com.example.demo.arthas.user]], childrenList=null, aai=null, additive=@Boolean[true], loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],] 获取logback实际加载的配置文件1ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader &#x27;#map1=@org.slf4j.LoggerFactory@getLogger(&quot;root&quot;).loggerContext.objectMap, #map1.get(&quot;CONFIGURATION_WATCH_LIST&quot;)&#x27; 使用classloader命令查找可能存在的logger配置文件1classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml 1234$ classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml jar:file:/Users/hengyunabc/code/java/spring-boot-inside/demo-arthas-spring-boot/target/demo-arthas-spring-boot-0.0.1-SNAPSHOT.jar!/BOOT-INF/classes!/logback-spring.xmlAffect(row-cnt:1) cost in 13 ms. 可以知道加载的配置的具体来源。 可以尝试加载容易冲突的文件： 1classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback.xml 1classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r log4j.properties 案例: 获取Spring Context在这个案例里，展示获取spring context，再获取bean，然后调用函数。 使用tt命令获取到spring contexttt即 TimeTunnel，它可以记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测。 https://arthas.aliyun.com/doc/tt.html 1tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter invokeHandlerMethod 访问：user/1 可以看到tt命令捕获到了一个请求： 1234567$ tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdaptePress Q or Ctrl+C to abort.Affect(class-cnt:1 , method-cnt:1) cost in 252 ms. INDE TIMESTAMP COST( IS-R IS- OBJECT CLASS METHOD X ms) ET EXP----------------------------------------------------------------------------------------- 1000 2019-02-15 4.583 true fal 0xc93cf1a RequestMappingHand invokeHandlerMethod 15:38:32 923 se lerAdapter 使用tt命令从调用记录里获取到spring context输入 q 或者 Ctrl + C 退出上面的 tt -t命令。 1q 1tt -i 1000 -w &#x27;target.getApplicationContext()&#x27; 12345678$ tt -i 1000 -w &#x27;target.getApplicationContext()&#x27;@AnnotationConfigEmbeddedWebApplicationContext[ reader=@AnnotatedBeanDefinitionReader[org.springframework.context.annotation.AnnotatedBeanDefinitionReader@2e457641], scanner=@ClassPathBeanDefinitionScanner[org.springframework.context.annotation.ClassPathBeanDefinitionScanner@6eb38026], annotatedClasses=null, basePackages=null,]Affect(row-cnt:1) cost in 439 ms. 获取spring bean，并调用函数1tt -i 1000 -w &#x27;target.getApplicationContext().getBean(&quot;helloWorldService&quot;).getHelloMessage()&#x27; 结果是： 123$ tt -i 1000 -w &#x27;target.getApplicationContext().getBean(&quot;helloWorldService&quot;).getHelloMessage()&#x27;@String[Hello World]Affect(row-cnt:1) cost in 52 ms. 案例: 排查HTTP请求返回401在这个案例里，展示排查HTTP 401问题的技巧。 访问： admin 结果是： 1Something went wrong: 401 Unauthorized 我们知道401通常是被权限管理的Filter拦截了，那么到底是哪个Filter处理了这个请求，返回了401？ 跟踪所有的Filter函数开始trace： 1trace javax.servlet.Filter * 访问： admin 可以在调用树的最深层，找到AdminFilterConfig$AdminFilter返回了401： 123+---[3.806273ms] javax.servlet.FilterChain:doFilter()| `---[3.447472ms] com.example.demo.arthas.AdminFilterConfig$AdminFilter:doFilter()| `---[0.17259ms] javax.servlet.http.HttpServletResponse:sendError() 通过stack获取调用栈上面是通过trace命令来获取信息，从结果里，我们可以知道通过stack跟踪HttpServletResponse:sendError()，同样可以知道是哪个Filter返回了401 执行： 1stack javax.servlet.http.HttpServletResponse sendError &#x27;params[0]==401&#x27; 访问： admin 12345678910$ stack javax.servlet.http.HttpServletResponse sendError &#x27;params[0]==401&#x27;Press Q or Ctrl+C to abort.Affect(class-cnt:2 , method-cnt:4) cost in 87 ms.ts=2019-02-15 16:44:06;thread_name=http-nio-8080-exec-6;id=16;is_daemon=true;priority=5;TCCL=org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedWebappClassLoader@8546cd5 @org.apache.catalina.connector.ResponseFacade.sendError() at com.example.demo.arthas.AdminFilterConfig$AdminFilter.doFilter(AdminFilterConfig.java:38) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 案例: 排查HTTP请求返回404在这个案例里，展示排查HTTP 404问题的技巧。 访问： a.txt 结果是： 1Something went wrong: 404 Not Found 那么到底是哪个Servlet处理了这个请求，返回了404？ 跟踪所有的Servlet函数开始trace： 1trace javax.servlet.Servlet * &gt; /tmp/servlet.txt 访问： a.txt 在Terminal 3里，查看/tmp/servlet.txt的内容： 1less /tmp/servlet.txt /tmp/servlet.txt里的内容会比较多，需要耐心找到调用树里最长的地方。 可以发现请求最终是被freemarker处理的： 123456`---[13.974188ms] org.springframework.web.servlet.ViewResolver:resolveViewName(); +---[0.045561ms] javax.servlet.GenericServlet:&lt;init&gt;() +---[min=0.045545ms,max=0.074342ms,total=0.119887ms,count=2] org.springframework.web.servlet.view.freemarker.FreeMarkerView$GenericServletAdapter:&lt;init&gt;() +---[0.170895ms] javax.servlet.GenericServlet:init() | `---[0.068578ms] javax.servlet.GenericServlet:init() | `---[0.021793ms] javax.servlet.GenericServlet:init() `---[0.164035ms] javax.servlet.GenericServlet:getServletContext() 案例: 理解Spring Boot应用的ClassLoader结构下面介绍classloader命令的功能。 先访问一个jsp网页，触发jsp的加载： hello 列出所有ClassLoader1classloader -l 1234567891011121314151617181920$ classloader -l name loadedCount hash parent BootstrapClassLoader 2724 null null com.taobao.arthas.agent.ArthasClassloader@411ce1ab 2009 411ce1ab sun.misc.Launcher$ExtClassLoader@7494e528 com.taobao.arthas.agent.ArthasClassloader@22ae1234 1253 22ae1234 sun.misc.Launcher$ExtClassLoader@7494e528 org.apache.jasper.servlet.JasperLoader@65361d9a 1 65361d9a TomcatEmbeddedWebappClassLoader context: ROOT delegate: true ----------&gt; Parent Classloader: org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3 TomcatEmbeddedWebappClassLoader 0 8546cd5 org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3 context: ROOT delegate: true ----------&gt; Parent Classloader: org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3 org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3 5416 1be6f5c3 sun.misc.Launcher$AppClassLoader@3d4eac69 sun.misc.Launcher$AppClassLoader@3d4eac69 45 3d4eac69 sun.misc.Launcher$ExtClassLoader@7494e528 sun.misc.Launcher$ExtClassLoader@7494e528 4 7494e528 null TomcatEmbeddedWebappClassLoader 加载的class数量是0，所以在spring boot embedded tomcat里，它只是一个空壳，所有的类加载都是LaunchedURLClassLoader完成的 列出ClassLoader里加载的所有类列出上面的org.apache.jasper.servlet.JasperLoader加载的类： 1classloader -a --classLoaderClass apache.jasper.servlet.JasperLoader 123$ classloader -a --classLoaderClass apache.jasper.servlet.JasperLoader hash:1698045338, org.apache.jasper.servlet.JasperLoader@65361d9a org.apache.jsp.jsp.hello_jsp 注：同ognl, 也可用-c &lt;hashcode&gt;而不用--classLoaderClass指定 反编译jsp的代码1jad org.apache.jsp.jsp.hello_jsp 1234567$ jad org.apache.jsp.jsp.hello_jspClassLoader:+-org.apache.jasper.servlet.JasperLoader@65361d9a +-TomcatEmbeddedWebappClassLoader context: ROOT... 查看ClassLoader树1classloader -t 12345678910111213$ classloader -t+-BootstrapClassLoader+-sun.misc.Launcher$ExtClassLoader@28cbbddd +-com.taobao.arthas.agent.ArthasClassloader@8c25e55 +-sun.misc.Launcher$AppClassLoader@55f96302 +-org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3 +-TomcatEmbeddedWebappClassLoader context: ROOT delegate: true ----------&gt; Parent Classloader: org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3 +-org.apache.jasper.servlet.JasperLoader@21ae0fe2 注意：请使用你的classLoaderHash值覆盖 &lt;classLoaderHash&gt; ，然后手动执行下面相关命令： 列出ClassLoader的urls比如上面查看到的spring LaunchedURLClassLoader的 hashcode是1be6f5c3，可以通过-c或者--classLoaderClass参数来列出它的所有urls： 1classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader 12345$ classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoaderjar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/classes!/jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/lib/spring-boot-starter-aop-1.5.13.RELEASE.jar!/... 加载指定ClassLoader里的资源文件查找指定的资源文件： classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml 1classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml 12$ classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/classes!/logback-spring.xml 尝试加载指定的类比如用上面的spring LaunchedURLClassLoader 尝试加载 java.lang.String ： 1classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader --load java.lang.String 123456789101112131415161718192021$ classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader --load java.lang.Stringload class success. class-info java.lang.String code-source name java.lang.String isInterface false isAnnotation false isEnum false isAnonymousClass false isArray false isLocalClass false isMemberClass false isPrimitive false isSynthetic false simple-name String modifier final,public annotation interfaces java.io.Serializable,java.lang.Comparable,java.lang.CharSequence super-class +-java.lang.Object class-loader classLoaderHash null 案例：查找Top N线程查看所有线程信息1thread 查看具体线程的栈查看线程ID 16的栈： 1thread 16 查看CPU使用率top n线程的栈1thread -n 3 查看5秒内的CPU使用率top n线程栈 1thread -n 3 -i 5000 查找线程是否有阻塞1thread -b Web ConsoleArthas支持通过Web Socket来连接。 本地体验当在本地启动时，可以访问 http://127.0.0.1:8563/ ，通过浏览器来使用Arthas。 推荐通过“快速入门”来体验： https://arthas.aliyun.com/doc/quick-start.html Exit/StopresetArthas在 watch/trace 等命令时，实际上是修改了应用的字节码，插入增强的代码。显式执行 reset 命令，可以清除掉这些增强代码。 1reset 退出Arthas用 exit 或者 quit 命令可以退出Arthas。 1exit Ctrl+C 退出Arthas之后，还可以再次用 java -jar arthas-boot.jar 来连接。 1java -jar arthas-boot.jar Ctrl+C 彻底退出Arthasexit/quit命令只是退出当前session，arthas server还在目标进程中运行。 想完全退出Arthas，可以执行 stop 命令。 1stop Ctrl+C arthas-boot支持的参数arthas-boot.jar 支持很多参数，可以执行 java -jar arthas-boot.jar -h 来查看。 1java -jar arthas-boot.jar -h 允许外部访问默认情况下， arthas server侦听的是 127.0.0.1 这个IP，如果希望远程可以访问，可以使用--target-ip的参数。 1java -jar arthas-boot.jar --target-ip 列出所有的版本1java -jar arthas-boot.jar --versions 使用指定版本： 1java -jar arthas-boot.jar --use-version 3.1.0 只侦听Telnet端口，不侦听HTTP端口1java -jar arthas-boot.jar --telnet-port 9999 --http-port -1 打印运行的详情1java -jar arthas-boot.jar -v 更多信息在“进阶教程”，演示了Arthas的大部分高级用法，希望对大家排查问题有帮助。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。 Issues: https://github.com/alibaba/arthas/issues 文档： https://arthas.aliyun.com/doc 如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：查看 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=qDlgqpBT","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 入门教程","slug":"Java-诊断工具-Arthas-入门教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"}]},{"title":"Arthas 基础教程","slug":"Java诊断工具Arthas入门教程/Arthas-基础教程","date":"2021-08-07T00:01:39.000Z","updated":"2021-09-29T02:51:06.000Z","comments":true,"path":"2021/08/07/Java诊断工具Arthas入门教程/Arthas-基础教程/","link":"","permalink":"https://jlynet.github.io/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/Arthas-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/","excerpt":"","text":"启动arthas-demo 启动arthas-boot Dashboard Thread Sc Jad Watch Exit/Stop 退出Arthas 彻底退出Arthas 更多信息 Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。 Arthas 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 Github: https://github.com/alibaba/arthas 文档: https://arthas.aliyun.com/doc/ 启动arthas-demo下载arthas-demo.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar arthas-demo是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。 启动arthas-boot在新的Terminal 2里，下载arthas-boot.jar，再用java -jar命令启动： 1wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar arthas-boot是Arthas的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。 选择第一个进程，输入 1 ，再Enter/回车： 11 Attach成功之后，会打印Arthas LOGO。输入 help 可以获取到更多的帮助信息。 1help Dashboarddashboard 命令可以查看当前系统的实时数据面板。 1dashboard 输入 q 或者 Ctrl+C 可以退出dashboard命令。 1q Threadthread 1 命令会打印线程ID 1的栈。 1thread 1 Ctrl+C Arthas支持管道，可以用 thread 1 | grep &#39;main(&#39; 查找到main class。 1thread 1 | grep &#x27;main(&#x27; 可以看到main class是demo.MathGame： 12$ thread 1 | grep &#x27;main(&#x27; at demo.MathGame.main(MathGame.java:17) Sc可以通过 sc 命令来查找JVM里已加载的类： 1sc -d *MathGame Jad可以通过 jad 命令来反编译代码： 1jad demo.MathGame Watch通过watch命令可以查看函数的参数/返回值/异常信息。 1watch demo.MathGame primeFactors returnObj  输入 q 或者 Ctrl+C 退出watch命令。 1q Exit/Stop退出Arthas用 exit 或者 quit 命令可以退出Arthas。 1exit Ctrl+C 退出Arthas之后，还可以再次用 java -jar arthas-boot.jar 来连接。 1java -jar arthas-boot.jar Ctrl+C 彻底退出Arthasexit/quit命令只是退出当前session，arthas server还在目标进程中运行。 想完全退出Arthas，可以执行 stop 命令。 1stop Ctrl+C 更多信息通过本教程基本掌握了Arthas的用法。更多高级特性，可以在下面的进阶指南里继续了解。 Arthas进阶 Arthas Github Arthas 文档 文章拷贝来源：https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=qDlgqpBT","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"Java 诊断工具 Arthas 入门教程","slug":"Java-诊断工具-Arthas-入门教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"}]},{"title":"awk命令使用介绍","slug":"awk命令使用介绍","date":"2021-07-31T03:59:37.000Z","updated":"2021-07-31T10:10:04.000Z","comments":true,"path":"2021/07/31/awk命令使用介绍/","link":"","permalink":"https://jlynet.github.io/2021/07/31/awk%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"awk 是一门非常优秀的文本处理工具，甚至可以上升作为一门程序设计语言。它处理文本的速度是快得惊人的，现在很多基于shell 日志分析工具都可以用它完成。特点是设计简单，速度表现很好，本文将介绍awk内置变量。格式： awk [ -F re] [parameter…] [‘pattern {action}’ ] [-f progfile][in_file…] 一、内置变量 属 性 说 明 $0 当前记录行，代表一行记录 1~1 n 当前记录的第n个字段，字段间由FS分隔 FS 输入字段分隔符，默认是空格 NF 当前记录中的字段个数，就是有多少列，一般取最后一列字段 NR 已经读出的记录数，就是行号，从1开始 RS 输入的记录分隔符，默认为换行符 OFS 输出字段分隔符，默是空格 ORS 输出的记录分隔符，默认为换行符 ARGC 命令行参数个数 ARGV 命令行参数数组 FILENAME 当前输入文件的名字 IGNORECASE 如果为真，则进行忽略大小写的匹配 ARGIND 当前被处理文件的ARGV标志符 CONVFMT 数字转换格式 %.6g ENVIRON UNIX环境变量 ERRNO UNIX系统错误消息 FIELDWIDTHS 输入字段宽度的空白分隔字符串 FNR 当前记录数 OFMT 数字的输出格式 %.6g RSTART 被匹配函数匹配的字符串首 RLENGTH 被匹配函数匹配的字符串长度 SUBSEP \\034 Built-in variablesAwk’s built-in variables include the field variables: 1,1,2, 3, and so on (3,andsoon(0 represents the entire record). They hold the text or values in the individual text-fields in a record. Other variables include: NR: Keeps a current count of the number of input records. NF: Keeps a count of the number of fields in an input record. The last field in the input record can be designated by $NF. FS: Contains the “field separator” character used to divide fields on the input record. The default, “white space”, includes any space and tab characters. FS can be reassigned to another character to change the field separator. RS: Stores the current “record separator” character. Since, by default, an input line is the input record, the default record separator character is a “newline”. OFS: Stores the “output field separator”, which separates the fields when Awk prints them. The default is a “space” character. ORS: Stores the “output record separator”, which separates the output records when Awk prints them. The default is a “newline” character. OFMT: Stores the format for numeric output. The default format is “%.6g”. FILENAME: Contains the name of the current input-file. 二、 变量实例1） 常用操作awk ‘/^root/ {print $0}’ /etc/passwd结果： root:x:0:0:root:/root:/bin/bash # /^root/ 为正则过滤表达式，$0代表是逐行 2） FS 分隔符awk ‘BEGIN{FS=”:”} /^root/ {print 1,1,NF}’ /etc/passwd结果： root /bin/bash注： FS为字段分隔符，默认是空格。因为passwd里是”:”分隔，所以需要修改默认分隔符。NF是字段总数，0代表当前行记录，0代表当前行记录，1-n是当前行各个字段对应值，n是当前行各个字段对应值，NF代表最后一列。 3） 记录条数（NR，FNR）awk ‘BEGIN{FS=”:”}{print NR, 1,1,NF, “\\t”, $0}’ /etc/passwd结果：1 root /bin/bash root:x:0:0:root:/root:/bin/bash2 daemon /bin/sh daemon:x:1:1:daemon:/usr/sbin:/bin/sh3 bin /bin/sh bin:x:2:2:bin:/bin:/bin/sh4 sys /bin/sh sys:x:3:3:sys:/dev:/bin/sh5 sync /bin/sync sync:x:4:65534:sync:/bin:/bin/sync …….. awk ‘BEGIN{FS=”:”}/^s/{print NR, 1,1,NF, “\\t”, $0}’ /etc/passwd # 过滤以首字符”s“开头的所有行结果：4 sys /bin/sh sys:x:3:3:sys:/dev:/bin/sh5 sync /bin/sync sync:x:4:65534:sync:/bin:/bin/sync20 syslog /bin/false syslog:x:101:103::/home/syslog:/bin/false……..注： NR得到当前记录所在行 4） 字段分隔符（OFS）awk ‘BEGIN{FS=”:”; OFS=”##”} /^root/ {print FNR, 1,1,NF}’ /etc/passwd结果： 1##root##/bin/bash注： OFS设置默认字段分隔符， FNR当前记录行 5） 行记录分隔符（ORS）awk ‘BEGIN{FS=”:”; ORS=”##”}{print FNR, 1,1,NF}’ /etc/passwd结果： 1 root /bin/bash##2 daemon /bin/sh##3 bin /bin/sh##4 sys /bin/sh##5 sync /bin/sync##……awk ‘BEGIN{FS=”:”; ORS=”\\n”}{print FNR, 1,1,NF}’ /etc/passwd # “/n” 是linux 中换行符结果：1 root /bin/bash2 daemon /bin/sh3 bin /bin/sh4 sys /bin/sh5 sync /bin/sync…….注： ORS默认是换行符，这里修改为：”##”，所有行之间用”##”分隔了 6） 参数获取（ARGC ，ARGV）awk ‘BEGIN{FS=”:”; print “ARGC=”ARGC; for(k in ARGV) {print k”=”ARGV[k];}}’ /etc/passwd结果：ARGC=20=awk1=/etc/passwd注： ARGC得到所有输入参数个数，ARGV获得输入参数内容是一个数组 7） 获得传入的文件名（FILENAME） 1awk &#x27;BEGIN&#123;FS=&quot;:&quot;;&#125;/^r/ &#123;print FILENAME, &quot;\\t&quot;, $0&#125;&#x27; /etc/passwd 结果：/etc/passwd root:x:0:0:root:/root:/bin/bash/etc/passwd rtkit:x:110:117:RealtimeKit,,,:/proc:/bin/false注： FILENAME, 0-0−N,NF 不能使用在BEGIN中，BEGIN中不能获得任何与文件记录操作的变量 8） 获得linux环境变量（ENVIRON）awk ‘BEGIN{print ENVIRON[“PATH”];}’ /etc/passwd结果： /home/homer/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games注： ENVIRON是子典型数组，可以通过对应键值获得它的值，linux 环境变量还有HOME，*H**O**M**E*，PWD等，可以通过linux 命令 env 查看 9） 输出数据格式设置（OFMT）awk ‘BEGIN{OFMT=”%.3f”; print 1, 2.0, 3.1, 2/3, 123.11111111;}’ /etc/passwd结果： 1 2 3.100 0.667 123.111注： OFMT默认输出格式是：%.6g 保留六位小数，这里修改OFMT会修改默认数据输出格式，如保留三位小数 10） 按宽度指定分隔符（FIELDWIDTHS）echo 20130108122448 | awk ‘BEGIN{FIELDWIDTHS=”4 2 2 2 2 3”}{print 1”-“1”−”2”-“3,3,4”:”5”:”5”:”6}’结果： 2013-01-08 12:24:48注： FIELDWIDTHS其格式为空格分隔的一串数字，用以对记录进行域的分隔，FIELDWIDTHS=”4 2 2 2 2 2”就表示1宽度是4，1宽度是4，2是2，$3是2 …. 这个时候会忽略FS分隔符 11） RSTART，RLENGTH使用awk ‘BEGIN{start=match(“this is 1 teststr”, /[a-z]+$/); print start, RSTART, RLENGTH }’结果： 11 11 7awk ‘BEGIN{start=match(“this is a test”,/^[a-z ]+$/); print start, RSTART, RLENGTH }’结果： 0 0 -1awk ‘BEGIN{start=match(“this is a test”,/^[a-z ]+$/); print start, RSTART, RLENGTH }’结果： 1 1 14 # 增加了一个空格“ ”匹配注： RSTART 被匹配正则表达式首位置，RLENGTH 匹配字符长度，没有找到为-1 三、外部变量1） 基本用法awk 中两个特别的表达式，BEGIN和END这两者都可用于pattern中，提供BEGIN和END的作用是给程序赋予 初始状态 和 程序结束 之后执行一些扫尾的工作。a） 任何在BEGIN之后列出的操作（在{}内），将在awk开始扫描输入之前执行b） 任何在END之后列出的操作，将在扫描完全部的输入之后执行因此，通常使用BEGIN来显示变量和初始化变量，使用END来输出最终结果。示例： echo ‘awk test’ | awk ‘BEGIN{print “start….”} {print $0} END{print “end….”}’结果：start….awk testend….2） 获取外部变量格式如： awk ‘{action}’ 变量名=变量值 ，这样传入变量可以在action中获得值。示例：test=’awk test’echo | awk ‘{print test}’ test=”$test”结果： awk testecho | awk test=”$test” ‘{print test}’结果： awk: cmd. line:1: fatal: cannot open file ‘{print test}’ for reading (No such file or directory)注：变量名与值放到’{action}’后面，即 test=”$test” 在 print 后面 3） BEGIN程序块中变量格式如：awk –v 变量名=变量值 [–v 变量2=值2 …] ‘BEGIN{action}’示例：test=’awk test’echo | awk -v test=”$test” ‘BEGIN{print test}’结果： awk testecho | awk -v test=”$test” ‘{print test}’结果： awk test注：用-v 传入变量，可以在3中类型的action 中都可以获得到，但顺序在 action前面 4） 外部环境变量awk ‘BEGIN{for (i in ENVIRON) {print i”=”ENVIRON[i];}}’结果：HLVL=1PWD=/home/homerJAVA_HOME=/home/homer/eclipse/jdk1.7.0_05SHELL=/bin/bashPATH=/home/homer/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games……….注： ENVIRON是子典型数组，可以通过对应键值获得它的值，linux 环境变量还有HOME，HOM**E，PWD等，可以通过linux 命令 env 查看","categories":[{"name":"linux技术","slug":"linux技术","permalink":"https://jlynet.github.io/categories/linux%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://jlynet.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"shell","slug":"shell","permalink":"https://jlynet.github.io/tags/shell/"},{"name":"linux","slug":"linux","permalink":"https://jlynet.github.io/tags/linux/"}]},{"title":"Arthas安装使用","slug":"Arthas安装使用","date":"2021-07-30T10:12:31.000Z","updated":"2021-08-07T04:56:10.000Z","comments":true,"path":"2021/07/30/Arthas安装使用/","link":"","permalink":"https://jlynet.github.io/2021/07/30/Arthas%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","excerpt":"","text":"arthas-boot: 1234java -jar arthas-boot.jar -hjava -jar arthas-boot.jar #选择进程号java -jar arthas-boot.jar 18095 #指定进程号java -jar arthas-boot.jar $(ps -ef |grep $USER| grep &quot;PortalWebMain&quot;| grep 8001 | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;) arthas-client: 1234java -jar arthas-client.jar -hjava -jar arthas-client.jar 127.0.0.1 3658java -jar arthas-client.jar -c &#x27;dashboard -n 1&#x27;java -jar arthas-client.jar -f batch.as 127.0.0.1","categories":[{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://jlynet.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"java","slug":"java","permalink":"https://jlynet.github.io/tags/java/"}]},{"title":"JsonFormatTool 跨平台json 格式化工具","slug":"JsonFormatTool","date":"2021-07-28T12:30:03.000Z","updated":"2022-12-12T02:32:20.000Z","comments":true,"path":"2021/07/28/JsonFormatTool/","link":"","permalink":"https://jlynet.github.io/2021/07/28/JsonFormatTool/","excerpt":"","text":"基于Qt5 框架开发的 JsonFormatTool，一款跨平台的json格式化工具 依托强大跨平台和高效的qt5框架，简洁明了的UI界面布局，使用便捷的文本按操作功能 支持搜索高亮的json树展示结构 下载地址： window 系统macOS 系统macOS（universal）系统，支持原生M1linux 系统跨平台 WebAssembly（基于浏览器） 更新记录： 2019年11月29日 v1.0 初始版本创建2020年1月2日 v1.5 修复加载文件解析异常2021年7月6日 v1.5.1 增加右侧复制分支功能2022年6月25日 v1.5.2 增加去除json中的转义字符2022年8月07日 v1.5.2 增加M1原生支持2022年12月11日 v1.5.2 增加WebAssembly支持","categories":[{"name":"个人作品展示","slug":"个人作品展示","permalink":"https://jlynet.github.io/categories/%E4%B8%AA%E4%BA%BA%E4%BD%9C%E5%93%81%E5%B1%95%E7%A4%BA/"}],"tags":[]},{"title":"Lockbox跨平台密码记事本管理工具","slug":"Lockbox","date":"2021-07-28T12:30:03.000Z","updated":"2021-07-31T10:28:28.000Z","comments":true,"path":"2021/07/28/Lockbox/","link":"","permalink":"https://jlynet.github.io/2021/07/28/Lockbox/","excerpt":"","text":"基于Qt5框架开发的Lockbox，一款跨平台密码记事本管理工具","categories":[{"name":"个人作品展示","slug":"个人作品展示","permalink":"https://jlynet.github.io/categories/%E4%B8%AA%E4%BA%BA%E4%BD%9C%E5%93%81%E5%B1%95%E7%A4%BA/"}],"tags":[]},{"title":"swagger2word 跨平台json 格式化工具","slug":"swagger2word","date":"2021-07-28T12:30:03.000Z","updated":"2021-07-31T10:28:10.000Z","comments":true,"path":"2021/07/28/swagger2word/","link":"","permalink":"https://jlynet.github.io/2021/07/28/swagger2word/","excerpt":"","text":"基于java 框架开发的 swagger2word，一款跨平台的json格式化工具","categories":[{"name":"个人作品展示","slug":"个人作品展示","permalink":"https://jlynet.github.io/categories/%E4%B8%AA%E4%BA%BA%E4%BD%9C%E5%93%81%E5%B1%95%E7%A4%BA/"}],"tags":[]},{"title":"hexo命令说明","slug":"hexo命令说明","date":"2021-07-28T04:27:05.000Z","updated":"2024-06-05T02:18:17.350Z","comments":true,"path":"2021/07/28/hexo命令说明/","link":"","permalink":"https://jlynet.github.io/2021/07/28/hexo%E5%91%BD%E4%BB%A4%E8%AF%B4%E6%98%8E/","excerpt":"","text":"安装： 1sudo npm install -g hexo hexo-cli --registry=https://registry.npmmirror.com 创建并初始化 1234mkdir -p ~/myappWeb &amp;&amp; cd ~/myappWebhexo init # 初始化npm install # 安装组件npm install hexo-deployer-git --save #git 部署插件 配置SSH key 12$ cd ~/. ssh #检查本机已存在的ssh密钥ssh-keygen -t rsa -C \"GitHub 邮箱\" 进入部署目录设置git递交信息 123$ cd .deploy_git$ git config user.name \"liuxianan\"// 你的github⽤户名，⾮昵称$ git config user.email \" xxx@qq.com \"// \"// 填写你的github注册邮箱 测试是否成功 1$ ssh -T git@github.com # # 注意邮箱地址不⽤改 常见命令： 12345678$ hexo new \"postName\" #新建⽂章$ hexo new page \"pageName\" #新建⻚⾯$ hexo generate #⽣⽣成成静静态态⻚⾯⻚⾯⾄⾄public public⽬⽬录录$ hexo server #开启预览访问端⼝（默认端⼝4000，，'ctrl + c'关闭server）$ hexo deploy #部署到GitHub$ hexo help # 查看帮助$ hexo version #查看Hexo的版本$ hexo clean #清楚 缩写： 1234$ hexo n == hexo new$ hexo g == hexo generate$ hexo s == hexo server$ hexo d == hexo deploy 组合命令： 12hexo s -g #⽣成并本地预览hexo d -g #⽣成并上传 文字里面添加图片 在_config.yml配置文件中，修改为 post_asset_folder: true 网站切割域名路径前缀位置 post_asset_folder_position_length: 4 1npm install https://github.com/ai930/hexo-asset-image --save 此时再执行命令 hexo n article_name 创建新的文章，在 source/_posts 中会生成文章 post_name.md 和同名文件夹 post_name,我们将文章中所使用到的将图片资源均放在 post_name 中，这时就可以在文章中使用相对路径引用图片资源了![img_name](img_name.jpg) #文章中的图片资源路径格式 给文章添加目录安装 1npm install hexo-toc --save 使用方法跟显示文章摘要类似，在Markdown中需要显示文章目录的地方添加 ` yilia上一页下一页显示的问题 在博客根目录下的_config.yml` 中如下配置： 12toc: maxDepth: 3 maxDepth 表示目录深度为3，即最多生成三级目录。找到主题下的文章模版，我的是themes\\yilia\\layout\\_partial\\article.ejs。在其末尾增加代码： 12345678910111213141516171819&lt;% if (!index &amp;&amp; theme.toc){ %&gt;&lt;script&gt; var tocEx = function(el){ var toc = document.querySelector(el), content = toc.innerHTML; content = content.replace('&lt;!-- toc --&gt;', '&lt;div class=\"toc\"&gt;').replace('&lt;!-- tocstop --&gt;', '&lt;/div&gt;'); toc.innerHTML = content; }('.article-entry');&lt;/script&gt;&lt;% } %&gt;&lt;style&gt;.toc { float: right; margin-left: 40px; padding: 10px 20px; background: #f1f1f1; border-radius: 10px; box-shadow: 0 0 3px #bbb;}&lt;/style&gt; yilia上一页下一页显示的问题修改themes/yilia-plus/layout/_partial/archive.ejs 文件 12345678910111213141516171819.......&lt;% if (page.total &gt; 1){ %&gt; &lt;nav id=\"page-nav\"&gt; &lt;%- paginator({ prev_text: '上一页', next_text: '下一页' }) %&gt; &lt;/nav&gt; &lt;% } %&gt;.......&lt;% if (page.total &gt; 1){ %&gt; &lt;nav id=\"page-nav\"&gt; &lt;%- paginator({ prev_text: '上一页', next_text: '下一页' }) %&gt; &lt;/nav&gt; &lt;% } %&gt;....... 修改/Volumes/macData/Documents/jlynet_project/www.jlynet.cn/themes/yilia-plus/source-src/js/fix.js 1234567var $nav = document.querySelector('#page-nav') if ($nav &amp;&amp; !document.querySelector('#page-nav .extend.prev')) { $nav.innerHTML = '&lt;a class=\"extend prev disabled\" rel=\"prev\"&gt;&amp;laquo; Prev&lt;/a&gt;' + $nav.innerHTML } if ($nav &amp;&amp; !document.querySelector('#page-nav .extend.next')) { $nav.innerHTML = $nav.innerHTML + '&lt;a class=\"extend next disabled\" rel=\"next\"&gt;Next &amp;raquo;&lt;/a&gt;' } 修改成 1234567var $nav = document.querySelector('#page-nav') if ($nav &amp;&amp; !document.querySelector('#page-nav .extend.prev')) { $nav.innerHTML = '&lt;a class=\"extend prev disabled\" rel=\"prev\"&gt;&lt;/a&gt;' + $nav.innerHTML } if ($nav &amp;&amp; !document.querySelector('#page-nav .extend.next')) { $nav.innerHTML = $nav.innerHTML + '&lt;a class=\"extend next disabled\" rel=\"next\"&gt;&lt;/a&gt;' } Hexo 字数和阅读时间统计插件 项目地址 链接: hexo-symbols-count-time 安装配置 安装插件： 1npm install hexo-symbols-count-time --save 在站点配置文件_config.yml 中添加以下代码： 12345symbols_count_time: symbols: true time: true total_symbols: true total_time: true 然后由于此插件集成在 NexT 中，然后只需修改主题配置文件_config.yml： 123456symbols_count_time: separated_meta: true item_text_post: true item_text_total: false awl: 4 wpm: 275 最后一步，hexo三步走 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; hexo s","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"},{"name":"技术笔记","slug":"默认分类/技术笔记","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://jlynet.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"随笔","slug":"随笔","permalink":"https://jlynet.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"hexo","slug":"hexo","permalink":"https://jlynet.github.io/tags/hexo/"}]}],"categories":[{"name":"中间件","slug":"中间件","permalink":"https://jlynet.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"技术笔记","slug":"中间件/技术笔记","permalink":"https://jlynet.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"默认分类","slug":"默认分类","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"},{"name":"技术笔记","slug":"默认分类/技术笔记","permalink":"https://jlynet.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"java技术栈","slug":"java技术栈","permalink":"https://jlynet.github.io/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"其他","slug":"其他","permalink":"https://jlynet.github.io/categories/%E5%85%B6%E4%BB%96/"},{"name":"linux技术","slug":"linux技术","permalink":"https://jlynet.github.io/categories/linux%E6%8A%80%E6%9C%AF/"},{"name":"个人作品展示","slug":"个人作品展示","permalink":"https://jlynet.github.io/categories/%E4%B8%AA%E4%BA%BA%E4%BD%9C%E5%93%81%E5%B1%95%E7%A4%BA/"}],"tags":[{"name":"技术笔记","slug":"技术笔记","permalink":"https://jlynet.github.io/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://jlynet.github.io/tags/Tomcat/"},{"name":"中间件","slug":"中间件","permalink":"https://jlynet.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"linux","slug":"linux","permalink":"https://jlynet.github.io/tags/linux/"},{"name":"随笔","slug":"随笔","permalink":"https://jlynet.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"网络","slug":"网络","permalink":"https://jlynet.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"hexo","slug":"hexo","permalink":"https://jlynet.github.io/tags/hexo/"},{"name":"ssh","slug":"ssh","permalink":"https://jlynet.github.io/tags/ssh/"},{"name":"java","slug":"java","permalink":"https://jlynet.github.io/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"https://jlynet.github.io/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://jlynet.github.io/tags/SpringBoot/"},{"name":"shell","slug":"shell","permalink":"https://jlynet.github.io/tags/shell/"},{"name":"nginx","slug":"nginx","permalink":"https://jlynet.github.io/tags/nginx/"},{"name":"docker","slug":"docker","permalink":"https://jlynet.github.io/tags/docker/"},{"name":"php","slug":"php","permalink":"https://jlynet.github.io/tags/php/"},{"name":"Java 诊断工具 Arthas 高级命令教程","slug":"Java-诊断工具-Arthas-高级命令教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/"},{"name":"Java 诊断工具 Arthas 最佳实践","slug":"Java-诊断工具-Arthas-最佳实践","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"name":"Java 诊断工具 Arthas 入门教程","slug":"Java-诊断工具-Arthas-入门教程","permalink":"https://jlynet.github.io/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"}]}