<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>etCache 缓存框架的使用以及源码分析 | 爱上猫的小鱼儿</title><meta name="keywords" content="技术笔记,java"><meta name="author" content="jlynet"><meta name="copyright" content="jlynet"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="etCache 缓存框架的使用以及源码分析"><meta name="application-name" content="etCache 缓存框架的使用以及源码分析"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="etCache 缓存框架的使用以及源码分析"><meta property="og:url" content="https://jlynet.github.io/2021/10/01/etCache-%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html"><meta property="og:site_name" content="爱上猫的小鱼儿"><meta property="og:description" content="一、简介 为什么使用缓存？ 使用场景 使用规范   二、如何使用 引入maven依赖 添加配置 配置说明 注解说明 @EnableCreateCacheAnnotation @EnableMethodCache @Cached @CacheInvalidate @CacheUpdate @Ca"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://jlynet.github.io/img/64496e511b09c.jpg"><meta property="article:author" content="jlynet"><meta property="article:tag" content="[&quot;java&quot;,&quot;php&quot;,&quot;linux&quot;,&quot;win&quot;,&quot;jlynet&quot;,&quot;jlynet.cn&quot;,&quot;jlynet.com&quot;,&quot;爱上猫的小鱼儿&quot;]"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://jlynet.github.io/img/64496e511b09c.jpg"><meta name="description" content="一、简介 为什么使用缓存？ 使用场景 使用规范   二、如何使用 引入maven依赖 添加配置 配置说明 注解说明 @EnableCreateCacheAnnotation @EnableMethodCache @Cached @CacheInvalidate @CacheUpdate @Ca"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://jlynet.github.io/2021/10/01/etCache-%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: jlynet","link":"链接: ","source":"来源: 爱上猫的小鱼儿","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '爱上猫的小鱼儿',
  title: 'etCache 缓存框架的使用以及源码分析',
  postAI: '',
  pageFillDescription: '一、简介, 为什么使用缓存？, 使用场景, 使用规范, 二、如何使用, 引入maven依赖, 添加配置, 配置说明, 注解说明, @EnableCreateCacheAnnotation, @EnableMethodCache, @Cached, @CacheInvalidate, @CacheUpdate, @CacheRefresh, @CachePenetrationProtect, @CreateCache, 使用示例, 三、源码解析, 项目的各个子模块, 常用注解与变量, 缓存API, Cache接口, AbstractCache抽象类, AbstractEmbeddedCache本地缓存, LinkedHashMapCache, Cleaner清理器, CaffeineCache, AbstractExternalCache远程缓存, RedisCache, RedisLettuceCache, MultiLevelCache两级缓存, RefreshCache, 解析配置, 初始化构造器, AbstractCacheAutoInit, EmbeddedCacheAutoInit, LinkedHashMapAutoConfiguration, CaffeineAutoConfiguration, ExternalCacheAutoInit, RedisAutoInit, RedisLettuceAutoInit, JetCacheAutoConfiguration自动配置, CacheBuilder构造器, AOP, 启用JetCache, @EnableMethodCache, @EnableCreateCacheAnnotation, 拦截器, ConfigProvider, CacheContext, JetCacheInterceptor, CacheHandler一简介为什么使用缓存使用场景使用规范二如何使用引入依赖添加配置配置说明注解说明使用示例三源码解析项目的各个子模块常用注解与变量缓存接口抽象类本地缓存清理器远程缓存两级缓存解析配置初始化构造器自动配置构造器启用拦截器一简介是一个基于的缓存系统封装提供统一的和注解来简化缓存的使用提供了比更加强大的注解可以原生的支持两级缓存分布式自动刷新还提供了接口用于手工缓存操作当前有四个实现特性通过统一的访问系统通过注解实现声明式的方法缓存支持和两级缓存通过注解创建并配置实例针对所有实例和方法缓存的自动统计的生成策略和的序列化策略支持自定义配置分布式缓存自动刷新分布式锁异步使用的客户端时缓存类型本地使用做方式淘汰基于开发的提供了近乎最佳命中率的高性能的缓存库远程访问的客户端使用客户端官方首选的客户端使用访问官网未作介绍使用客户端一个高性能基于的驱动框架支持线程安全的同步异步操作底层集成了提供反应式编程参考高级客户端详解为什么使用缓存在高并发大流量等场景下降低系统延迟缓解数据库压力提高系统整体的性能让用户有更好的体验使用场景读多写少不追求强一致性请求入参不易变化使用规范选择了远程缓存请设置保证存放至的缓存规范化避免与其他系统出现冲突例如这样设计系统简称所属名字这样存储到的缓存为系统简称所属名字缓存选择了本地缓存请设置全局默认设置了本地缓存的数据存放于内存减轻内存的损耗如果使用了缓存的过多可能导致内存溢出请勿滥用缓存注解对于非必要添加缓存的方法我们尽量不使用缓存二如何使用说明以下使用方式是基于引入缓存框架的如果不是工程请参考官网使用引入依赖使用客户端添加以下依赖使用客户端添加以下依赖添加配置支持的类型支持的类型可自定义转换器函数支持的类型系统简称所属名字支持的类型可自定义编码器支持的类型可自定义解码器优先从节点中读取哨兵模式单节点模式设置为主从模式集群模式系统简称所属名字连接密码连接的超时时间读取数据的超时时间连接的数据库客户端名称是否使用哨兵模式配置说明的全局配置属性默认值说明用于统计缓存调用相关信息的统计间隔分钟表示不统计缓存实例名称会作为缓存的前缀以前的版本总是把加在中因此也出现在前缀中我们一般设置为当缓存访问未命中的情况下对并发进行的加载行为进行保护当前版本实现的是单内的保护即同一个中同一个只有一个线程去加载其它线程等待结果这是全局配置如果缓存实例没有指定则使用全局配置是否使用缓存无自动生成缓存实例名称时为了不让名称太长指定的包名前缀会被截掉多个包名使用逗号分隔我们一般会指定每个缓存实例的名称本地缓存的全局配置属性默认值说明无本地缓存类型支持每个缓存实例存储的缓存数量的全局配置仅本地缓存需要配置如果缓存实例没有指定则使用全局配置请结合实例的业务场景进行配置该参数无缓存转换器的全局配置支持的类型仅当使用且缓存类型为时可以指定为此时通过方法来识别方法缓存必须指定支持自定义转换器函数可设置为然后会从容器中获取该无穷大本地缓存超时时间的全局配置毫秒多长时间没访问就让缓存失效的全局配置毫秒仅支持本地缓存表示不使用这个功能远程缓存的全局配置属性默认值说明无连接的客户端类型支持无保存至远程缓存的前缀请规范使用无参考上述说明保存至远程缓存的编码函数支持支持自定义编码函数可设置为然后会从容器中获取该保存至远程缓存的解码函数支持支持自定义解码函数可设置为然后会从容器中获取该无穷大远程缓存超时时间的全局配置毫秒无节点信息上表中对应和的属性如果注解上没有指定默认值是关于缓存的超时时间等方法上指定了超时时间则以此时间为准等方法上未指定超时时间使用实例的默认超时时间实例的默认超时时间通过在和上的属性指定如果没有指定使用中定义的全局配置例如使用如果仍未指定则是无穷大注解说明如果需要使用缓存启动类添加两个注解开启可通过注解创建实例功能开启可通过注解创建实例功能初始化注解说明属性默认值说明无需要拦截的包名只有这些包名下的实例才会生效指定切面执行过程的顺序默认最低优先级的模式目前就提供默认值让你修改无为一个方法添加缓存创建对应的缓存实例注解可以添加在接口或者类的方法上面该类必须是注解说明属性默认值说明如果在配置中配置了多个缓存在这里指定使用哪个未定义指定缓存实例名称如果没有指定会根据类名方法名自动生成会被用于远程缓存的前缀另外在统计中一个简短有意义的名字会提高可读性是否激活缓存指定的单位未定义超时时间如果注解上没有定义会使用全局配置如果此时全局配置也没有定义则为无穷大未定义仅当为时适用为本地缓存指定一个不一样的超时时间通常应该小于如果没有设置且为那么本地缓存的超时时间和远程缓存保持一致缓存的类型支持如果定义为会使用和组合成两级缓存未定义如果为或这个参数指定本地缓存的最大元素数量以控制内存占用如果注解上没有定义会使用全局配置如果此时你没有定义全局配置则使用默认的全局配置请结合实际业务场景进行设置该值未定义指定远程缓存的序列化方式支持如果注解上没有定义会使用全局配置如果你没有定义全局配置则使用默认的全局配置未定义指定的转换方式用于将复杂的类型转换为缓存实现可以接受的类型支持表示不转换可以将复杂对象转换成如果注解上没有定义会使用全局配置未定义使用指定缓存如果没有指定会根据入参自动生成当方法返回值为的时候是否要缓存未定义使用指定条件如果表达式返回的时候才去缓存中查询未定义使用指定条件如果表达式返回的时候才更新缓存该评估在方法执行后进行因此可以访问到用于移除缓存配置说明配置默认值说明如果在配置中配置了多个缓存在这里指定使用哪个无指定缓存的唯一名称一般指向对应的定义的未定义使用指定如果没有指定会根据入参自动生成未定义使用指定条件如果表达式返回才执行删除可访问方法结果删除缓存实例中的元素如果根据指定的是一个集合是否从缓存实例中删除对应的每个缓存如果设置为但是不是集合则不会删除缓存用于更新缓存配置说明配置默认值说明如果在配置中配置了多个缓存在这里指定使用哪个无指定缓存的唯一名称一般指向对应的定义的未定义使用指定如果没有指定会根据入参自动生成无使用指定未定义使用指定条件如果表达式返回才执行更新可访问方法结果更新缓存实例中的元素如果根据指定和都是集合并且元素的个数相同则是否更新缓存实例中的对应的每个元素如果设置为但是不是集合或者不是集合或者它们的元素的个数不相同也不会更新缓存用于自定刷新缓存配置说明配置默认值说明无刷新间隔未定义指定该多长时间没有访问就停止刷新如果不指定会一直刷新秒类型为的缓存刷新时同时只会有一台服务器在刷新这台服务器会在远程缓存放置一个分布式锁此配置指定该锁的超时时间指定时间单位当缓存访问未命中的情况下对并发进行的加载行为进行保护当前版本实现的是单内的保护即同一个中同一个只有一个线程去加载其它线程等待结果配置说明配置默认值说明是否开启保护模式未定义其他线程的等待超时时间如果超时则自己执行方法直接返回结果指定时间单位在中使用该注解可创建一个实例配置说明配置默认值说明如果在配置中配置了多个缓存在这里指定使用哪个未定义指定缓存实例名称如果没有指定会根据类名方法名自动生成会被用于远程缓存的前缀另外在统计中一个简短有意义的名字会提高可读性指定的单位未定义超时时间如果注解上没有定义会使用全局配置如果此时全局配置也没有定义则为无穷大未定义仅当为时适用为本地缓存指定一个不一样的超时时间通常应该小于如果没有设置且为那么本地缓存的超时时间和远程缓存保持一致缓存的类型支持如果定义为会使用和组合成两级缓存未定义如果为或这个参数指定本地缓存的最大元素数量以控制内存占用如果注解上没有定义会使用全局配置如果此时你没有定义全局配置则使用默认的全局配置请结合实际业务场景进行设置该值未定义指定远程缓存的序列化方式支持如果注解上没有定义会使用全局配置如果你没有定义全局配置则使用默认的全局配置未定义指定的转换方式用于将复杂的类型转换为缓存实现可以接受的类型支持表示不转换可以将复杂对象转换成如果注解上没有定义会使用全局配置使用示例启动类接口实现类处理逻辑处理逻辑处理逻辑如上述所示方法会创建一个缓存实例通过注解可以看到缓存实例名称为缓存的有效时长为小时本地缓存的数量最多为缓存类型为优先从本地缓存获取通过注解可以看到会为该缓存实例设置一个刷新策略刷新间隔为小时个小时没访问后不再刷新需要刷新的缓存实例会为其每一个缓存数据创建一个周期性任务注解表示该缓存实例开启保护模式当缓存未命中同一个中同一个只有一个线程去加载数据其它线程等待结果方法可以更新缓存通过注解可以看到会更新缓存实例中缓存为的缓存为方法可以删除缓存通过注解可以看到会删除缓存实例中缓存为缓存数据字段会作为一个缓存实例对象通过注解可以看到会将该字段作为为缓存实例对象本地缓存的数量最多为缓存类型为注解表示该缓存实例开启保护模式我的业务场景是使用上述的方法创建缓存实例即可注意注解不能和或者同时使用可以多个同时使用另外通过注解创建缓存实例也可以这样初始化更加详细的使用方法请参考官方地址三源码解析参考本人仓库中的项目已做详细的注释简单概括利用功能在调用需要缓存的方法前通过解析注解获取缓存配置根据这些配置创建不同的实例对象进行缓存等操作分为两部分一部分是以及实现另一部分是注解支持项目的各个子模块定义注解和常量核心接口的实现提供各种缓存实例的操作不依赖于完成初始化解析配置文件中的相关配置以提供不同缓存实例的构造器基于提供和注解支持初始化以及注解等配置使用提供支持使用提供支持实现了异步访问缓存的的接口使用提供支持提供文件方式的基于提供文件方式的基于提供文件方式的基于提供相关测试常用注解与变量在模块中定义了需要用的缓存注解与常量在上述已经详细的讲述过其中注解定义为数组然后通过新增的注解在注解上面添加即可支持同一个地方可以使用多个注解缓存主要查看子模块提供各种缓存以支持不同的缓存类型接口的子关系结构如下图主要对象描述缓存接口定义基本方法抽象类缓存接口的继承者提供基本实现具体实现交由不同的子类基于设计的简易内存缓存基于工具设计的内存缓存实现使用客户端实现使用客户端两级缓存用于封装本地缓存和远程缓存基于装饰器模式提供自动刷新功能用于注解创建的缓存实例依赖于接口接口定义了缓存实例的操作方法部分有默认实现以及获取分布式锁非严格用于刷新远程缓存的实现因为继承了接口所以也提供了方法的默认实现空方法交由不同缓存实例的实现去实现该方法用于释放资源在方法中会调用每个缓存实例对象的方法进行资源释放主要代码如下多级缓存不支持此方法随机生成一个值过期时间创建一把会自动释放资源的锁实现其方法这把锁还没有过期则删除删除对应的值出现的结果成功失败不存在删除对应的值过程中出现了异常则重试释放成功锁已经被释放了该锁已失效往或者本地中存放值结尾的返回的结果成功已存在失败成功获取到锁尝试获取锁的过程中失败了也就是往中存放值出现异常这个时候可能值已经存储了但是由于其他原因导致返回的结果表示执行失败已存在表示该锁被其他人占有尝试获取锁获取到锁则执行下面的任务执行完锁的操作后会进行资源释放调用的方法定义的方法大都是关于缓存的获取删除和存放操作其中大写的方法返回自定义的完整的返回值可以清晰的知道执行结果例如返回的时候无法断定是对应的不存在还是访问缓存发生了异常小写的方法默认实现就是调用大写的方法方法最为核心交由子类去实现方法会非堵塞的尝试获取一把分布式锁非严格获取过程尝试往中设置已存在无法设置一个键值对为缓存为并设置这个键值对的过期时间为秒默认如果获取到锁后进行加载任务也就是重新加载方法并更新远程缓存该锁实现了接口使用方式在执行完加载任务后会自动释放资源也就是调用方法将获取锁过程中设置的键值对从中删除在中会调用该方法因为如果存在远程缓存需要刷新则需要采用分布式锁的方式抽象类抽象类实现了接口主要代码如下当缓存未命中时并发情况同一个是否只允许一个线程去加载其他线程等待结果可以设置超时则自己加载并直接返回如果是的话则由获取到对应的采用了的线程进行加载临时保存对应的对象获取内部的对象封装函数成一个对象主要在重新加载缓存后发出一个到该缓存实例需要刷新从缓存中获取数据如果是多级缓存先从本地缓存获取获取不到则从远程缓存获取如果缓存数据是从远程缓存获取到的数据则会更新至本地缓存并且如果本地缓存没有设置则使用远程缓存的到期时间作为自己的到期时间我一般不设置因为可能导致本地缓存的有效时间比远程缓存的有效时间更长如果设置了记得设置添加更新当前的刷新缓存任务存放于的中从缓存中获取数据缓存命中缓存未命中创建当缓存未命中去更新缓存的函数未在缓存注解中配置的生成方式则默认取入参作为缓存在进入当前方法时是否可以考虑为创建一个副本因为缓存未命中然后通过重新加载方法时如果方法内部对入参进行了修改那么生成的缓存也会被修改从而导致相同的进入该方法时一直与缓存中的不相同一直出现缓存未命中添加了注解一个只允许一个线程执行执行方法将新的结果异步缓存为什么加一个数组疑问加载该实例的方法将重新加载的数据更新至缓存标记已完成等待其他线程加载如果出现异常或者超时则自己加载返回数据但是不更新缓存重新加载数据锁栅栏持有的线程是否加载成功加载出来的数据实现了接口的大写方法内部调用自己定义的抽象方法以开头交由不同的子类实现操作缓存后发送相应的事件也就是调用自己定义的方法遍历每个对该事件进行后置操作用于统计信息方法实现了接口的核心方法从缓存实例中根据缓存获取缓存逻辑如下获取的因为我们通过注解创建的缓存实例将生成对象需要调用其方法才会完成缓存实例的初始化函数是对加载原有方法的封装这里再进行一层封装封装成类型目的是在加载原有方法后将发送事件从缓存实例中获取对应的缓存如果缓存实例对象是类型在方法中会将包装成则调用方法判断是否应该为它添加一个定时的刷新任务如果缓存未命中则执行函数如果开启了保护模式则调用自定义的方法大致逻辑根据缓存从自己的线程安全遍历中尝试获取不存在则创建加载锁获取到这把加载锁才可以执行函数如果已被其他线程占有则进行等待没有设置超时时间则一直等待通过计数器实现本地缓存抽象类继承抽象类定义了本地缓存的存放缓存数据的对象为接口和一个初始化该接口的抽象方法基于接口实现以开头的方法完成缓存实例各种操作的具体实现主要代码如下本地缓存的设置该缓存数据的最后一次访问时间抽象类实现了操作本地缓存的相关方法定义了缓存实例对象本地缓存的配置信息对象定义了缓存实例对象本地缓存基于内存操作缓存数据的对象它的初始化过程交由不同的内存缓存实例和基于完成缓存实例对象本地缓存基于内存操作缓存数据的对象的初始化工作主要代码如下将缓存实例添加至用于本地缓存类型为缓存实例存储缓存数据允许的最大缓存数量缓存实例锁当元素大于最大值时移除最老的元素最老的元素是否删除清理过期的元素占有当前缓存实例这把锁缓存的数据已经失效了则删除为什么不对进行判断取最小值疑问如果缓存不存在或者对应的已经失效则放入否则返回自定义继承并实现接口自定义字段存储元素个数的最大值并设置初始容量为自定义字段每个缓存实例的锁通过关键词保证线程安全所以性能相对来说不好覆盖的方法当元素大于最大值时移除最老的元素自定义方法遍历根据缓存被封装成的对象包含缓存数据失效时间戳和第一次访问的时间清理过期的元素该对象初始化时会被添加至清理器中会周期性每隔秒遍历缓存实例调用其方法清理器用于清理缓存类型为的缓存数据请查看相应注释代码如下执行任务定时清理每分钟缓存实例中过期的缓存数据存放弱引用对象以防内存溢出如果被弱引用的对象只被当前弱引用对象关联时时被弱引用的对象则会被回收取决于被弱引用的对象是否还与其他强引用对象关联个人理解当某个强引用对象没有被其他对象除了这里引用时我们应该让这个对象被回收但是由于这里使用的也是强引用这个对象被其他强引用对象关联了不可能被回收存在内存溢出的危险所以这里使用了弱引用对象如果被弱引用的对象没有被其他对象除了这里引用时这个对象会被回收举个例子如果我们往一个中存放一个键值对假设对应的键已经不再使用被回收了那我们无法再获取到对应的值也无法被回收占有一定的内存存在风险创建一个线程池个核心线程起一个循环任务一直清理过期的数据每隔秒创建一个弱引用对象并添加到清理对象中获取被弱引用的对象强引用表示被弱引用的对象被标记成了垃圾则移除基于完成缓存实例对象本地缓存基于内存操作缓存数据的对象的初始化工作主要代码如下缓存实例对象初始化本地缓存的容器对象设置缓存实例的最大缓存数量设置缓存实例的缓存数据的失效策略获取缓存的有效时间缓存数据有效时间如果本地缓存设置了多长时间没访问缓存则失效设置缓存的失效时间多长时间没访问缓存则失效缓存的有效时长取构建缓存实例通过构建一个缓存对象然后实现接口调用这个缓存对象的相关方法构建时设置每个元素的过期时间也就是根据每个元素的失效时间戳来设置底层如何实现的可以参考官方地址调用的方法我有遇到过内存溢出的问题所以请结合实际业务场景合理的设置缓存相关配置远程缓存抽象类继承抽象类定义了缓存实例对象远程缓存的配置信息对象提供了将缓存转换成字节数组的方法代码比较简单使用连接对远程的缓存数据进行操作代码没有很复杂可查看我的注释定义了配置对象包含连接池的相关信息实现了以开头的方法也就是通过操作缓存数据使用连接对远程的缓存数据进行操作代码没有很复杂可查看我的注释定义了配置对象包含客户端与建立的安全连接等信息因为底层是基于实现的所以无需配置线程池使用自定义管理器将与连接的相关信息封装成对象并管理与对应关系相比更加安全高效对不了解的可以参考我写的测试类两级缓存当你设置了缓存类型为两级缓存那么创建的实例对象会被封装成对象定义了字段类型为用于保存本地缓存实例和远程缓存实例本地缓存存放于远程缓存前面实现了方法遍历数组也就是先从本地缓存获取如果获取缓存不成功则从远程缓存获取成功获取到缓存后会调用方法从方法的逻辑可以看到将获取到的缓存数据更新至更底层的缓存中也就是说如果缓存数据是从远程获取到的那么进入这个方法后会将获取到的缓存数据更新到本地缓存中去这样下次请求可以直接从本地缓存获取避免与之间的网络消耗实现了方法遍历数组通过进行异步编程将所有的操作绑定在一条链上执行实现的了方法会先判断是否单独配置了本地缓存时间配置了则单独为本地缓存设置过期时间没有配置则到期时间和远程缓存的一样覆盖方法调用方法也就是只会调用最顶层远程缓存的这个方法主要代码如下本地缓存使用自己的失效时间设置了为本地缓存则使用自己的到期时间遍历多级缓存远程缓存排在后面这个遍历是从低层的缓存开始获取获取成功则将该值设置到更低层的缓存中情景本地没有获取到缓存远程获取到了缓存这里会将远程的缓存数据设置到本地中这样下次请求则直接从本次获取减少了远程获取的时间如果使用本地自己的缓存过期时间使用本地缓存自己的过期时间使用远程缓存的过期时间远程缓存数据还未失效则重新设置本地的缓存表示本地缓存使用自己过期时间将多个操作放在一条链上为缓存实例添加刷新任务前面在抽象类中讲到了在方法中会将包装成所以说每个缓存实例都会调用一下方法代码如下用于保存刷新任务获取缓存刷新策略没有则不进行刷新获取刷新时间间隔获取线程任务的获取对应的不存在则创建一个获取周期延迟线程池个核心线程创建的线程都是守护线程运行的任务多久延迟后开始执行后续执行的周期间隔多长时间单位通过其创建一个循环任务用于刷新缓存数据设置最后一次访问时间如果缓存实例配置了刷新策略并且刷新间隔大于则会从线程安全中尝试获取对应的刷新任务如果不存在则创建一个任务放入线程池周期性的执行代码如下如果是两级缓存则返回远程缓存唯一标志符也就是转换后的值缓存的执行方法的对象最后一次访问时间该的执行策略尝试中断当前任务从任务列表中删除重新加载数据异常封装成加载后会发起事件加载将重新加载的数据放入缓存远程加载数据缓存对象当前时间异常获取转换后的值创建分布式锁对应的分布式锁的存在时间刷新间隔对应的时间戳用于存放上次刷新时间获取上一次刷新时间是否需要重新加载当前时间与上一次刷新的时间间隔是否大于或等于刷新间隔无缓存将顶层的缓存数据更新至低层的缓存中例如将远程的缓存数据放入本地缓存因为如果是多级缓存创建刷新任务后我们只需更新远程的缓存然后从远程缓存获取缓存数据更新低层的缓存保证缓存一致重新加载保存一个至其中的信息为该的生成时间刷新缓存分布式缓存没有一个全局分配的功能这里尝试获取一把非严格的分布式锁获取锁的超时时间默认秒也就是获取到这把锁最多可以拥有秒只有获取对应的这把分布式锁才执行重新加载的操作没有获取到锁并且是多级缓存这个时候应该有其他实例在刷新缓存所以这里设置过一会直接获取远程的缓存数据更新到本地创建一个延迟任务刷新间隔后将最顶层的缓存数据更新至每一层获取多级缓存中顶层的缓存数据将缓存数据重新放入低层缓存刷新任务的具体执行取消执行最后一次访问到现在时间的间隔超过了设置的则取消当前任务执行获取缓存实例对象如果是多层则返回顶层也就是远程缓存远程缓存刷新本地缓存刷新刷新逻辑判断是否需要停止刷新了需要的话调用其的方法取消执行并从中删除获取缓存实例对象如果是多层则返回顶层也就是远程缓存实例对象如果是本地缓存则调用方法也就是执行函数加载原有方法将获取到的数据更新至缓存实例中如果是多级缓存则每级缓存都会更新如果是远程缓存对象则调用方法刷新后会往中存放一个键值对为为上一次刷新时间先从中获取上一次刷新时间的键值对根据上一次刷新的时间判断是否大于刷新间隔大于或者没有上一次刷新时间表示需要重新加载数据否则不需要重新加载数据如果不需要重新加载数据但是又是多级缓存则获取远程缓存数据更新至本地缓存保证两级缓存的一致性如果需要重新加载数据则调用方法尝试获取分布式锁执行刷新任务调用方法并往中重新设置上一次的刷新时间如果没有获取到分布式锁则创建一个延迟任务刷新间隔后将最顶层的缓存数据更新至每一层解析配置主要查看子模块解析中相关配置初始化不同缓存类型的构造器用于生产缓存实例也初始化以下对象缓存管理器注入了全局配置缓存实例管理器缓存上下文等大量信息存储构造器以及的相关信息全局配置类保存了一些全局信息初始化构造器通过注解将需要使用到的缓存类型对应的构造器初始化类注入到容器并执行初始化过程也就是创建构造器初始化构造器类的类型结构如下图所示主要对象描述抽象类实现的接口注入至容器时完成初始化抽象类继承解析本地缓存独有的配置初始化构造器初始化构造器抽象类继承解析远程缓存独有的配置初始化构造器初始化构造器抽象类主要实现了的接口在注入容器时会调用其方法完成本地缓存类型和远程缓存类型构造器的初始化主要代码如下初始化方法这里我们有两个指定前缀创建一个配置对象本地或者远程获取本地或者远程的配置项获取本地或者远程的这里我一般只有默认的获取本地或者远程存储类型例如缓存类型是否和当前的某一个匹配不同的会设置一个或者多个因为有很多继承者都会执行这个方法不同的继承者解析不同的配置例如只解析即可只解析即可获取本地或者远程的的子配置项根据配置信息构建本地或者远程缓存的构造器将构造器存放至设置公共的配置到构造器中构造器配置信息设置的转换函数设置超时时间兼容老版本多长时间没有访问就让缓存失效表示不使用该功能注意只支持本地缓存初始化构造器交由子类去实现配置信息配置前缀构造器在方法中可以看到会调用方法分别初始化本地缓存和远程缓存的构造器定义的方法首先会从当前环境中解析出的相关配置到对象中然后遍历缓存区域获取对应的缓存类型进行不同类型的缓存实例构造器初始化过程不同构造器的初始化方法交由子类实现获取到构造器后会将其放入对象中去另外也定义了方法解析本地缓存和远程缓存都有的配置至构造器中抽象类继承了主要是覆盖父类的解析本地缓存单有的配置代码如下设置本地缓存每个缓存实例的缓存数量个数限制默认继承了实现了方法先通过创建一个默认实现类然后解析相关配置至构造器中完成初始化代码如下创建一个构造器解析相关配置至的中配置了缓存类型为当前类才会被注入容器这里我们注意到注解这个注解的作用是满足条件这个才会被容器管理他的条件是继承了也就是说配置文件中配置了缓存类型为时这个类才会被容器管理才会完成构造器的初始化逻辑并不复杂可自行查看继承了实现了方法先通过创建一个默认实现类然后解析相关配置至构造器中完成初始化代码如下创建一个构造器解析相关配置至的中配置了缓存类型为当前类才会被注入容器同样使用了注解这个注解的作用是满足条件这个才会被容器管理他的条件是继承了也就是说配置文件中配置了缓存类型为时这个类才会被容器管理才会完成构造器的初始化抽象类继承了主要是覆盖父类的解析远程缓存单有的配置和代码如下设置远程缓存构造器的相关配置构造器配置信息设置远程缓存的前缀根据配置创建缓存数据的编码函数和解码函数继承了实现方法完成了通过连接的初始化操作主要代码如下配置了缓存类型为当前类才会被注入容器设置缓存类型是否只从的从节点读取数据获取从节点的配置信息依次创建每个从节点的连接池创建一个构造器解析相关配置至的中创建连接池配置信息连接池创建连接池配置对象创建一个连接池创建一个连接池是内部的静态类在内通过方法定义作为同样使用了注解满足条件这个才会被容器管理内部的也不会被管理也就是说配置文件中配置了缓存类型为时才会被容器管理才会完成构造器的初始化实现了方法先解析的相关配置通过创建连接池通过创建一个默认实现类解析相关配置至构造器中完成初始化将连接保存至中继承了实现方法完成了通过连接的初始化操作主要代码如下注入容器的条件配置了缓存类型为当前类才会被注入容器设置缓存类型初始化构造器配置信息配置前缀构造器数据节点偏好设置集群模式异步获取结果的超时时间默认只从节点中读取优先从节点中读取优先从节点中读取只从节点中读取使用最近一次连接的实例读取创建对应的只有一个集群模式只给一个域名怎么办疑问创建一个客户端设置失去连接时的行为拒绝命令默认为创建一个客户端创建一个安全连接并设置数据节点偏好多个集群模式创建一个客户端创建一个构造器解析相关配置至的中开始将客户端和安全连接保存至管理器中初始化连接初始化连接的相关信息保存至中并将相关信息保存至是内部的静态类在内通过方法定义作为同样使用了注解满足条件这个才会被容器管理内部的也不会被管理也就是说配置文件中配置了缓存类型为时才会被容器管理才会完成构造器的初始化实现了方法先解析的相关配置通过创建客户端和与的连接通过创建一个默认实现类解析相关配置至构造器中完成初始化获取管理器将通过创建客户端和与的连接保存将客户端与的连接同步命令异步命令和反应式命令相关保存至中自动配置上面的初始化构造器的类需要被容器管理就需被扫描到我们一般会设置扫描路径但是别人引入肯定是作为其他包不能够被扫描到的这些也就不会被管理这里我们查看模块下文件内容如下这应该是一种机制这样这个项目以外的包里面的就会被容器扫描到我们来看看他的代码该将会被容器注入依次注入下面几个为添加依赖由此会完成初始化配置操作缓存实例构造器也会被注入容器可以看到通过注解初始化构造器的那些类会被加入到容器加上注解只有我们配置过的缓存类型的构造器才会被加入然后保存至对象中注意到这里我们注入的是对象加上注解无法再次注册该对象至容器相比对象它的区别是设置了为设置了为目的是支持两个解析器能够解析自定义在中可以看到它是一个用于容器初始后执行操作目的是往的的依赖中添加几个类型的保证几个构造器已经初始化方法中设置全局的相关配置并添加已经初始化的构造器然后返回让容器管理这样一来就完成了的解析配置并初始化的功能构造器构造器的作用就是根据配置构建一个对应类型的缓存实例的子类结构如下根据类名就可以知道其作用接口只定义了一个方法用于构建缓存实例交由不同的实现类抽象类实现了方法主要代码如下该缓存实例的配置创建缓存实例函数克隆一份配置信息因为这里获取到的是全局配置信息以防后续被修改通过构建函数创建一个缓存实例目前发现都是后续都会把封装成疑问实现了的方法支持克隆该对象因为每个缓存实例的配置不一定相同这个构造器中保存的是全局的一些配置所以需要克隆一个构造器出来为每个缓存实例设置其自己的配置而不影响这个最初始的构造器定义对象存放缓存配置构建缓存实例需要根据这些配置定义的函数用于构建缓存实例我们在初始化构造器中可以看到不同的构造器设置的该函数都是一个缓存实例并传入配置信息例如设置构建缓存实例的函数进入的构造器你就可以看到会根据配置完成缓存实例的初始化不同类型的构造器区别在于类型不同因为远程和本地的配置是有所区别的还有就是设置的函数不同因为需要构建不同的缓存实例和上面的例子差不多都是一个缓存实例并传入配置信息这里就不一一讲述了主要查看子模块提供功能启用可以通过和注解完成的初始化工作我们在工程中的启动类上面添加这两个注解即可启用缓存注解的相关配置在上面的如何使用中已经讲过了这里我们关注注解中的和两个类将会被容器管理上面有注解所以会被作为一个里面定义了一个为所以这个也会被容器管理中保存方法与缓存注解配置信息的映射关系继承了通过注解他的方法会被调用根据不同的导入不同的配置类可以看到会返回一个类名称那么它也会被注入是配置的配置类代码如下获取注解信息的名称设置缓存拦截器为设置需要扫描的包设置优先级默认的最大值最低优先级注入一个拦截器设置为框架内部的角色因为是通过注解注入的并且实现了接口当被注入的时候会先调用其方法这里好像必须添加注解不然无法被识别出来获取到注解的元信息其中定义了两个实现了中的方法拦截器可用于拦截方法后执行相关处理继承了将会作为一个切面设置了通知为也就是说被拦截的方法都会进入就作为的入口了根据注解设置了需要扫描的包路径以及优先级默认是最低优先级实现了接口的方法设置这个切面的切入点为从作为切入点实现了接口用于判断哪些类需要被拦截实现了接口用于判断哪些类中的哪些方法会被拦截在判断方法是否需要进入的过程中会解析方法上面的相关缓存注解将配置信息封装对象中并把它保存至对象中总结注解主要就是生成一个切面用于拦截带有缓存注解的方法相比注解没有相关属性同样会导入类不同的是将导入类它继承了作为一个用于在初始化的时候做一些操作从代码中可以看到他的作用是如果这个内部存在添加了带有注解的字段没有添加会将这个字段作为需要注入的对象解析成缓存实例的主要代码如下是否初始化用于懒加载缓存实例所处上下文注解元信息字段刷新策略保护策略获取缓存实例不存在则新建缓存实例从的容器中获取全局缓存配置对象将注解信息封装到对象中从缓存实例管理器中获取或者创建对应的缓存实例可以看到通过创建的缓存实例也可以添加和注解在抽象类的方法中我们有讲到如果缓存实例是类型则会先调用其方法获取缓存实例对象所以在第一次访问的时候才进行初始化并根据缓存注解配置信息创建存在则直接获取一个缓存实例总结注解主要是支持能够创建缓存实例通过和两个注解加上前面的解析配置过程已经完成的的解析与初始化过程那么接下来我们来看看如何处理被拦截的方法拦截器从切入点判断方法是否需要拦截的逻辑方法所在的类对象是否匹配除去以开头和包含的类该类是否在我们通过注解配置的中从获取方法对应的对象也就是获取缓存配置信息如果是一个空对象那么不需要被拦截因为前面已经判断了所在的类是否需要被拦截而这个类中并不是所有的方法都会添加缓存注解所以这一类的方法会设置一个空对象定义在内部的一个静态对象添加了修饰保存在中如果不为则需被拦截通过解析这个方法的缓存注解如果有注解或者注解或者注解先解析注解生成对象保存至中然后该方法会被拦截否在保存一个空对象不会被拦截是一个配置提供者对象包含了的全局配置缓存实例管理器缓存转换器缓存转换器上下文和监控指标相关信息主要代码如下缓存的全局配置缓存实例管理器根据不同类型生成缓存数据转换函数的转换器根据不同类型生成缓存转换函数的转换器缓存监控指标管理器打印缓存各项指标的函数缓存更新事件消息接收者无实现类我们可以自己实现用于统计一些缓存的命中信息默认的缓存监控指标管理器缓存上下文启动缓存指标监控器周期性打印各项指标初始化缓存上下文启动缓存指标监控器根据编码类型通过缓存转换器生成编码函数编码类型编码函数根据解码类型通过缓存转换器生成解码函数解码类型解码函数根据转换类型通过缓存转换器生成转换函数转换类型转换函数继承了查看其代码可以看到有两个方法分别为初始化方法和销毁方法因为分别添加了注解和注解所以在初始化时会调用在容器销毁时会调用方法内部分别调用和这两个方法交由子类实现在方法中先启动缓存指标监控器用于周期性打印各项缓存指标然后初始化缓存上下文返回的是在方法中关闭缓存指标监控器清除缓存实例缓存上下文主要为每一个被拦截的请求创建缓存上下文构建对应的缓存实例主要代码如下缓存的管理器包含很多信息缓存的全局配置缓存实例管理器创建一个本次调用的上下文添加一个函数后续用于获取缓存实例根据注解配置信息获取缓存实例对象不存在则创建并设置到缓存注解配置类中缓存注解根据配置创建一个缓存实例对象通过更新使失效缓存注解缓存区域缓存实例名称没有定义缓存实例名称生成缓存实例名称类名方法名参数类型创建缓存实例对象缓存名称拼接从缓存实例管理器中根据缓存区域和缓存实例名称获取缓存实例加锁再次确认缓存区域的名称是否作为缓存名称前缀默认为我一般设置为构建一个缓存实例本地缓存远程缓存两级缓存构建本地缓存实例构建远程缓存实例两级缓存时是否单独设置了本地缓存失效时间创建一个两级缓存设置缓存刷新策略将封装成也就是类型后续添加刷新任务时会判断是否为类型然后决定是否执行方法添加刷新任务没有刷新策略不会添加设置缓存未命中时是否只允许一个线程执行方法其他线程等待全局配置默认为方法的注解添加监控统计配置获取缓存区域对应的构造器克隆一个构造器因为不同缓存实例有不同的配置设置失效时间设置缓存的前缀配置文件中配置了则设置为设置为如果注解中设置了的转换方式则替换否则还是使用全局的设置的转换器只支持缓存数据保存至远程需要进行编码和解码所以这里设置其编码和解码方式和可选择设置是否缓存值获取缓存区域对应的构造器克隆一个构造器因为不同缓存实例有不同的配置本地缓存数量限制设置本地缓存失效时间前提是多级缓存一般和远程缓存保持一致不设置设置失效时间设置是否缓存值构建一个缓存实例方法返回一个本次调用的上下文为这个上下文设置缓存函数用于获取或者构建缓存实例这个函数在中会被调用我们来看看这个函数的处理逻辑有两个入参分别为本次调用的上下文和缓存注解的配置信息首先从缓存注解的配置信息中获取缓存实例如果不为则直接返回否则调用方法根据配置通过构造器创建一个缓存实例对象方法如果没有定义缓存实例名称注解中的配置则生成类名方法名参数类型作为缓存实例名称然后调用方法方法通过缓存实例管理器根据缓存区域和缓存实例名称获取缓存实例对象如果不为则直接返回判断缓存实例对象是否为为进行两次确认第二次会给当前加锁进行判断避免线程不安全缓存实例对象还是为的话先判断缓存区域是否添加至缓存实例名称中是的话为缓存实例名称然后调用方法创建一个缓存实例对象方法根据缓存实例类型构建不同的缓存实例对象处理逻辑如下为则调用方法从全局配置的保存本地缓存构造器的集合中的获取本地缓存该缓存区域的构造器在之前讲到的自动配置中有说到过会将初始化好的构造器从中添加至中克隆一个构造器因为不同缓存实例有不同的配置将缓存注解的配置信息设置到构造器中有以下配置如果配置了则设置本地缓存最大数量的值如果为并且配置了大于则设置有效时间的值为否则如果配置的大于则设置其值为如果配置了则根据该值生成一个转换函数没有配置的话在初始化构造器的时候根据全局配置可能已经生成了一个转换函数我一般在全局配置中设置设置是否缓存值通过调用构造器的方法构建一个缓存实例对象该方法在之前讲到的构造器中有分析过为则调用方法从全局配置的保存远程缓存构造器的集合中的获取远程缓存该缓存区域的构造器克隆一个构造器因为不同缓存实例有不同的配置将缓存注解的配置信息设置到构造器中有以下配置如果配置了则设置远程缓存有效时间的值如果全局设置远程缓存的缓存的前缀则设置缓存的前缀为否则我为如果配置了则根据该值生成一个转换函数没有配置的话在初始化构造器的时候根据全局配置可能已经生成了一个转换函数我一般在全局配置中设置如果设置了则根据该值生成编码和解码函数没有配置的话在初始化构造器的时候根据全局配置可能已经生成了编码函数和解码函数我一般在全局配置中设置设置是否缓存值通过调用构造器的方法构建一个缓存实例对象为则调用方法构建本地缓存实例调用方法构建远程缓存实例创建一个构造器设置有效时间为远程缓存的有效时间添加和缓存实例设置是否单独配置了本地缓存的失效时间是否有配置设置是否缓存值通过调用构造器的方法构建一个缓存实例对象设置刷新策略没有的话为将缓存实例对象封装成对象用于后续的添加刷新任务在之前的抽象类有讲到设置是否开启缓存未命中时加载方法的保护模式全局默认为将缓存实例添加至监控管理器中被拦截后的处理在中代码如下缓存实例注解信息上下文缓存的全局配置缓存的管理器包含很多信息这里会获取到可查看获取被拦截的方法获取被拦截的对象获取改方法的方法所在类名方法名参数类型方法返回类型被拦截的类名获取该方法的缓存注解信息在中已经对注解进行解析并放入中无缓存相关注解配置信息表明无须缓存直接执行该方法为本次调用创建一个上下文对象包含对应的缓存实例继续往下执行从中获取被拦截的方法对象的缓存配置信息如果没有则直接执行该方法否则继续往下执行根据对象因为在之前讲到的自动配置中有说到注入的是对象在其初始化方法中调用方法生成调用其方法为本次调用创建一个上下文并设置获取缓存实例函数具体实现逻辑查看上面讲到的设置本次调用上下文的为被拦截对象为被拦截对象的调用器为被拦截方法为方法入参为缓存配置信息为缓存实例名称需要截断的包名通过的方法继续往下执行用于处理被拦截的方法部分代码如下获取缓存实例配置获取注解配置信息经过缓存中获取结果根据结果删除或者更新缓存执行该方法获取本地调用的上下文获取注解配置信息获取缓存实例对象不存在则会创建并设置到中可在创建本次调用的上下文时调用方法中查看详情无缓存实例对象执行原有方法生成缓存对象注解中没有配置的话就是入参没有入参则为生成缓存失败则执行原方法并记录事件根据配置的来决定是否走缓存缓存注解中没有配置表示所有请求都走缓存配置了表示满足条件的才走缓存不满足则直接执行原方法并记录事件创建一个执行原有方法的函数本次执行原方法后是否需要更新缓存获取结果调用原有方法发送事件执行被拦截的方法直接查看方法获取缓存注解信息根据本地调用的上下文获取缓存实例对象调用其函数在中有讲到如果缓存实例不存在则直接调用方法执行被拦截的对象的调用器根据本次调用的上下文生成缓存根据配置的缓存的表达式生成如果没有配置则返回入参对象如果没有对象则返回根据配置表达式判断是否需要走缓存创建一个对象用于执行被拦截的对象的调用器也就是加载原有方法调用缓存实例的方法获取结果这个方法的处理过程可查看缓存这一小节至此结束文章转自',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-01 10:54:00',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">爱上猫的小鱼儿</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/img/weixin.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/weixin.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/alipay.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" style="font-size: 1.05rem;">Java 诊断工具 Arthas 入门教程<sup>2</sup></a><a href="/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" style="font-size: 1.05rem;">Java 诊断工具 Arthas 最佳实践<sup>14</sup></a><a href="/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/" style="font-size: 1.05rem;">Java 诊断工具 Arthas 高级命令教程<sup>25</sup></a><a href="/tags/Spring/" style="font-size: 1.05rem;">Spring<sup>1</sup></a><a href="/tags/SpringBoot/" style="font-size: 1.05rem;">SpringBoot<sup>1</sup></a><a href="/tags/Tomcat/" style="font-size: 1.05rem;">Tomcat<sup>1</sup></a><a href="/tags/docker/" style="font-size: 1.05rem;">docker<sup>2</sup></a><a href="/tags/hexo/" style="font-size: 1.05rem;">hexo<sup>3</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>4</sup></a><a href="/tags/linux/" style="font-size: 1.05rem;">linux<sup>8</sup></a><a href="/tags/nginx/" style="font-size: 1.05rem;">nginx<sup>2</sup></a><a href="/tags/php/" style="font-size: 1.05rem;">php<sup>1</sup></a><a href="/tags/shell/" style="font-size: 1.05rem;">shell<sup>6</sup></a><a href="/tags/ssh/" style="font-size: 1.05rem;">ssh<sup>1</sup></a><a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 1.05rem;">中间件<sup>1</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" style="font-size: 1.05rem;">技术笔记<sup>17</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>2</sup></a><a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 1.05rem;">随笔<sup>12</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/08/"><span class="card-archive-list-date">八月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/06/"><span class="card-archive-list-date">六月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/11/"><span class="card-archive-list-date">十一月 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/10/"><span class="card-archive-list-date">十月 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/09/"><span class="card-archive-list-date">九月 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/" itemprop="url">java技术栈</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>技术笔记</span></a><a class="article-meta__tags" href="/tags/java/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>java</span></a></span></div></div><h1 class="post-title" itemprop="name headline">etCache 缓存框架的使用以及源码分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2021-10-01T02:41:48.000Z" title="发表于 2021-10-01 10:41:48">2021-10-01</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2021-10-01T02:54:00.000Z" title="更新于 2021-10-01 10:54:00">2021-10-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://jlynet.github.io/2021/10/01/etCache-%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><header><a class="post-meta-categories" href="/categories/java%E6%8A%80%E6%9C%AF%E6%A0%88/" itemprop="url">java技术栈</a><a href="/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" tabindex="-1" itemprop="url">技术笔记</a><a href="/tags/java/" tabindex="-1" itemprop="url">java</a><h1 id="CrawlerTitle" itemprop="name headline">etCache 缓存框架的使用以及源码分析</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">jlynet</span><time itemprop="dateCreated datePublished" datetime="2021-10-01T02:41:48.000Z" title="发表于 2021-10-01 10:41:48">2021-10-01</time><time itemprop="dateCreated datePublished" datetime="2021-10-01T02:54:00.000Z" title="更新于 2021-10-01 10:54:00">2021-10-01</time></header><!-- toc -->

<ul>
<li><a href="#%E4%B8%80-%E7%AE%80%E4%BB%8B">一、简介</a><ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98">为什么使用缓存？</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">使用场景</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83">使用规范</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">二、如何使用</a><ul>
<li><a href="#%E5%BC%95%E5%85%A5maven%E4%BE%9D%E8%B5%96">引入maven依赖</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE">添加配置</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E">配置说明</a></li>
<li><a href="#%E6%B3%A8%E8%A7%A3%E8%AF%B4%E6%98%8E">注解说明</a><ul>
<li><a href="#enablecreatecacheannotation">@EnableCreateCacheAnnotation</a></li>
<li><a href="#enablemethodcache">@EnableMethodCache</a></li>
<li><a href="#cached">@Cached</a></li>
<li><a href="#cacheinvalidate">@CacheInvalidate</a></li>
<li><a href="#cacheupdate">@CacheUpdate</a></li>
<li><a href="#cacherefresh">@CacheRefresh</a></li>
<li><a href="#cachepenetrationprotect">@CachePenetrationProtect</a></li>
<li><a href="#createcache">@CreateCache</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">使用示例</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">三、源码解析</a><ul>
<li><a href="#%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%90%84%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%9D%97">项目的各个子模块</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%98%E9%87%8F">常用注解与变量</a></li>
<li><a href="#%E7%BC%93%E5%AD%98api">缓存API</a><ul>
<li><a href="#cache%E6%8E%A5%E5%8F%A3">Cache接口</a></li>
<li><a href="#abstractcache%E6%8A%BD%E8%B1%A1%E7%B1%BB">AbstractCache抽象类</a></li>
<li><a href="#abstractembeddedcache%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98">AbstractEmbeddedCache本地缓存</a><ul>
<li><a href="#linkedhashmapcache">LinkedHashMapCache</a></li>
<li><a href="#cleaner%E6%B8%85%E7%90%86%E5%99%A8">Cleaner清理器</a></li>
<li><a href="#caffeinecache">CaffeineCache</a></li>
</ul>
</li>
<li><a href="#abstractexternalcache%E8%BF%9C%E7%A8%8B%E7%BC%93%E5%AD%98">AbstractExternalCache远程缓存</a><ul>
<li><a href="#rediscache">RedisCache</a></li>
<li><a href="#redislettucecache">RedisLettuceCache</a></li>
</ul>
</li>
<li><a href="#multilevelcache%E4%B8%A4%E7%BA%A7%E7%BC%93%E5%AD%98">MultiLevelCache两级缓存</a></li>
<li><a href="#refreshcache">RefreshCache</a></li>
</ul>
</li>
<li><a href="#%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE">解析配置</a><ul>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9E%84%E9%80%A0%E5%99%A8">初始化构造器</a><ul>
<li><a href="#abstractcacheautoinit">AbstractCacheAutoInit</a></li>
<li><a href="#embeddedcacheautoinit">EmbeddedCacheAutoInit</a><ul>
<li><a href="#linkedhashmapautoconfiguration">LinkedHashMapAutoConfiguration</a></li>
<li><a href="#caffeineautoconfiguration">CaffeineAutoConfiguration</a></li>
</ul>
</li>
<li><a href="#externalcacheautoinit">ExternalCacheAutoInit</a><ul>
<li><a href="#redisautoinit">RedisAutoInit</a></li>
<li><a href="#redislettuceautoinit">RedisLettuceAutoInit</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jetcacheautoconfiguration%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE">JetCacheAutoConfiguration自动配置</a></li>
<li><a href="#cachebuilder%E6%9E%84%E9%80%A0%E5%99%A8">CacheBuilder构造器</a></li>
</ul>
</li>
<li><a href="#aop">AOP</a><ul>
<li><a href="#%E5%90%AF%E7%94%A8jetcache">启用JetCache</a><ul>
<li><a href="#enablemethodcache-1">@EnableMethodCache</a></li>
<li><a href="#enablecreatecacheannotation-1">@EnableCreateCacheAnnotation</a></li>
</ul>
</li>
<li><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8">拦截器</a><ul>
<li><a href="#configprovider">ConfigProvider</a></li>
<li><a href="#cachecontext">CacheContext</a></li>
<li><a href="#jetcacheinterceptor">JetCacheInterceptor</a></li>
<li><a href="#cachehandler">CacheHandler</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="一-简介">一、简介</span></h2><p><a href="https://github.com/alibaba/jetcache"><code>JetCache</code></a>是一个基于Java的缓存系统封装，提供统一的API和注解来简化缓存的使用。 JetCache提供了比SpringCache更加强大的注解，可以原生的支持TTL、两级缓存、分布式自动刷新，还提供了<code>Cache</code>接口用于手工缓存操作。 当前有四个实现：<code>RedisCache</code>、<code>RedisLettuceCache</code>、<code>CaffeineCache</code>、<code>LinkedHashMapCache</code>。</p>
<p>特性：</p>
<ul>
<li>通过统一的API访问Cache系统</li>
<li>通过注解实现声明式的方法缓存，支持TTL和两级缓存</li>
<li>通过注解创建并配置<code>Cache</code>实例</li>
<li>针对所有<code>Cache</code>实例和方法缓存的自动统计</li>
<li>Key的生成策略和Value的序列化策略支持自定义配置</li>
<li>分布式缓存自动刷新，分布式锁</li>
<li>异步Cache API (使用Redis的Lettuce客户端时)</li>
</ul>
<p>缓存类型：</p>
<ul>
<li><p>本地</p>
<p><code>LinkedHashMap</code>：使用LinkedHashMap做LUR方式淘汰<br><a href="https://github.com/ben-manes/caffeine"><code>Caffeine</code></a>：基于Java8开发的提供了近乎最佳命中率的高性能的缓存库</p>
</li>
<li><p>远程（访问Redis的客户端）</p>
<p><code>Redis</code>：使用Jedis客户端，Redis官方首选的Java客户端<br><code>RedisSpringData</code>：使用SpringData访问Redis（官网未作介绍）<br><a href="https://github.com/lettuce-io/lettuce-core"><code>RedisLettuce</code></a>：使用Lettuce客户端，一个高性能基于Java的Redis驱动框架，支持线程安全的同步、异步操作，底层集成了<a href="https://projectreactor.io/">Project Reactor</a>，提供反应式编程，参考：<a href="https://www.cnblogs.com/throwable/p/11601538.html">Redis高级客户端Lettuce详解</a></p>
</li>
</ul>
<h3><span id="为什么使用缓存">为什么使用缓存？</span></h3><p>在高并发、大流量等场景下，降低系统延迟，缓解数据库压力，提高系统整体的性能，让用户有更好的体验。</p>
<h3><span id="使用场景">使用场景</span></h3><p>读多写少、不追求强一致性、请求入参不易变化</p>
<h3><span id="使用规范">使用规范</span></h3><p>选择了远程缓存请设置keyPrefix，保证存放至Redis的缓存key规范化，避免与其他系统出现冲突，例如这样设计：<code>系统简称:所属名字:</code>，这样存储到Redis的缓存key为：<code>系统简称:所属名字:缓存key</code></p>
<p>选择了本地缓存请设置limit，全局默认设置了100，本地缓存的数据存放于内存，减轻内存的损耗，如果使用了Caffeine，缓存的key过多可能导致内存溢出</p>
<p>请勿滥用缓存注解，对于非必要添加缓存的方法我们尽量不使用缓存</p>
<h2><span id="二-如何使用">二、如何使用</span></h2><p>说明：以下使用方式是基于SpringBoot引入<code>JetCache</code>缓存框架的，如果不是SpringBoot工程，请参考<a href="https://github.com/alibaba/jetcache"><code>JetCache</code></a>官网使用</p>
<h3><span id="引入maven依赖">引入maven依赖</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- 使用 jedis 客户端添加以下依赖 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alicp.jetcache&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jetcache-starter-redis&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- 使用 lettuce 客户端添加以下依赖 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alicp.jetcache&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jetcache-starter-redis-lettuce&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h3><span id="添加配置">添加配置</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">jetcache:</span><br><span class="line">  statIntervalMinutes: 60</span><br><span class="line">  areaInCacheName: false</span><br><span class="line">  penetrationProtect: false</span><br><span class="line">  enableMethodCache: true</span><br><span class="line">  hiddenPackages: com.xxx.xxx,com.xxx.xxx</span><br><span class="line">  local:</span><br><span class="line">    default:</span><br><span class="line">      type: caffeine # 支持的类型：linkedhashmap、caffeine</span><br><span class="line">      limit: 100</span><br><span class="line">      keyConvertor: fastjson # 支持的类型：fastjson，可自定义转换器函数</span><br><span class="line">      expireAfterWriteInMillis: 600000</span><br><span class="line">      expireAfterAccessInMillis: 300000 </span><br><span class="line">  remote:</span><br><span class="line">    default:</span><br><span class="line">      type: redis.lettuce # 支持的类型：redis、redis.lettuce</span><br><span class="line">      keyPrefix: &#x27;系统简称:所属名字:&#x27;</span><br><span class="line">      keyConvertor: fastjson</span><br><span class="line">      valueEncoder: java # 支持的类型：kryo、java，可自定义编码器</span><br><span class="line">      valueDecoder: java # 支持的类型：kryo、java，可自定义解码器</span><br><span class="line">      expireAfterWriteInMillis: 3600000</span><br><span class="line">      #readFrom: slavePreferred # 优先从Slave节点中读取</span><br><span class="line">      uri: redis-sentinel://host1:26379,host2:26379,host3:26379/?sentinelMasterId=mymaster # 哨兵模式</span><br><span class="line">      #uri: redis://127.0.0.1:6379/ # 单节点模式</span><br><span class="line">      #mode: masterslave # 设置为主从模式</span><br><span class="line">      #uri: # 集群模式</span><br><span class="line">      #- redis://127.0.0.1:7000</span><br><span class="line">      #- redis://127.0.0.1:7001</span><br><span class="line">      #- redis://127.0.0.1:7002</span><br><span class="line">    example:</span><br><span class="line">      keyPrefix: &#x27;系统简称:所属名字:&#x27;</span><br><span class="line">      type: redis</span><br><span class="line">      keyConvertor: fastjson</span><br><span class="line">      valueEncoder: java</span><br><span class="line">      valueDecoder: java</span><br><span class="line">      expireAfterWriteInMillis: 3600000</span><br><span class="line">      poolConfig:</span><br><span class="line">        minIdle: 10</span><br><span class="line">        maxIdle: 20</span><br><span class="line">        maxTotal: 50</span><br><span class="line">      #password: xxx # 连接密码</span><br><span class="line">      #timeout: 2000 # 连接的超时时间，读取数据的超时时间</span><br><span class="line">      #database: 0 # 连接的数据库</span><br><span class="line">      #clientName: null # 客户端名称</span><br><span class="line">      #ssl: 是否使用SSL</span><br><span class="line">      host: $&#123;redis.host&#125;</span><br><span class="line">      port: $&#123;redis.port&#125;</span><br><span class="line">      #sentinel: host1:26379,host2:26379,host3:26379 # 哨兵模式</span><br><span class="line">      #masterName: mymaster</span><br></pre></td></tr></table></figure>

<h3><span id="配置说明">配置说明</span></h3><p>jetcache的全局配置</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">jetcache.statIntervalMinutes</td>
<td align="left">0</td>
<td align="left">用于统计缓存调用相关信息的统计间隔（分钟），0表示不统计。</td>
</tr>
<tr>
<td align="left">jetcache.areaInCacheName</td>
<td align="left">true</td>
<td align="left">缓存实例名称cacheName会作为缓存key的前缀，2.4.3以前的版本总是把areaName加在cacheName中，因此areaName也出现在key前缀中。我们一般设置为false。</td>
</tr>
<tr>
<td align="left">jetcache.penetrationProtect</td>
<td align="left">false</td>
<td align="left">当缓存访问未命中的情况下，对并发进行的加载行为进行保护。 当前版本实现的是单JVM内的保护，即同一个JVM中同一个key只有一个线程去加载，其它线程等待结果。这是全局配置，如果缓存实例没有指定则使用全局配置。</td>
</tr>
<tr>
<td align="left">jetcache.enableMethodCache</td>
<td align="left">true</td>
<td align="left">是否使用jetcache缓存。</td>
</tr>
<tr>
<td align="left">jetcache.hiddenPackages</td>
<td align="left">无</td>
<td align="left">自动生成缓存实例名称时，为了不让名称太长，hiddenPackages指定的包名前缀会被截掉，多个包名使用逗号分隔。我们一般会指定每个缓存实例的名称。</td>
</tr>
</tbody></table>
<p>本地缓存的全局配置</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">jetcache.local.${area}.type</td>
<td align="left">无</td>
<td align="left">本地缓存类型，支持 linkedhashmap、caffeine。</td>
</tr>
<tr>
<td align="left">jetcache.local.${area}.limit</td>
<td align="left">100</td>
<td align="left">每个缓存实例存储的缓存数量的全局配置，仅本地缓存需要配置，如果缓存实例没有指定则使用全局配置，请结合实例的业务场景进行配置该参数。</td>
</tr>
<tr>
<td align="left">jetcache.local.${area}.keyConvertor</td>
<td align="left">无</td>
<td align="left">缓存key转换器的全局配置，支持的类型：<code>fastjson</code>。仅当使用@CreateCache且缓存类型为LOCAL时可以指定为<code>none</code>，此时通过equals方法来识别key。方法缓存必须指定keyConvertor。支持自定义转换器函数，可设置为：<code>bean:beanName</code>，然后会从spring容器中获取该bean。</td>
</tr>
<tr>
<td align="left">jetcache.local.${area}.expireAfterWriteInMillis</td>
<td align="left">无穷大</td>
<td align="left">本地缓存超时时间的全局配置（毫秒）。</td>
</tr>
<tr>
<td align="left">jetcache.local.${area}.expireAfterAccessInMillis</td>
<td align="left">0</td>
<td align="left">多长时间没访问就让缓存失效的全局配置（毫秒），仅支持本地缓存。0表示不使用这个功能。</td>
</tr>
</tbody></table>
<p>远程缓存的全局配置</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">jetcache.remote.${area}.type</td>
<td align="left">无</td>
<td align="left">连接Redis的客户端类型，支持 <code>redis</code>、<code>redis.lettuce</code>、<code>redis.springdata</code>。</td>
</tr>
<tr>
<td align="left">jetcache.remote.${area}.keyPrefix</td>
<td align="left">无</td>
<td align="left">保存至远程缓存key的前缀，请规范使用。</td>
</tr>
<tr>
<td align="left">jetcache.remote.${area}.keyConvertor</td>
<td align="left">无</td>
<td align="left">参考上述说明。</td>
</tr>
<tr>
<td align="left">jetcache.remote.${area}.valueEncoder</td>
<td align="left">java</td>
<td align="left">保存至远程缓存value的编码函数，支持：<code>java</code>、<code>kryo</code>。支持自定义编码函数，可设置为：<code>bean:beanName</code>，然后会从spring容器中获取该bean。</td>
</tr>
<tr>
<td align="left">jetcache.remote.${area}.valueDecoder</td>
<td align="left">java</td>
<td align="left">保存至远程缓存value的解码函数，支持：<code>java</code>、<code>kryo</code>。支持自定义解码函数，可设置为：<code>bean:beanName</code>，然后会从spring容器中获取该bean。</td>
</tr>
<tr>
<td align="left">jetcache.remote.${area}.expireAfterWriteInMillis</td>
<td align="left">无穷大</td>
<td align="left">远程缓存超时时间的全局配置（毫秒）。</td>
</tr>
<tr>
<td align="left">jetcache.remote.${area}.uri</td>
<td align="left">无</td>
<td align="left">redis节点信息。</td>
</tr>
</tbody></table>
<p>上表中${area}对应@Cached和@CreateCache的area属性，如果注解上没有指定area，默认值是”default”。</p>
<p>关于缓存的超时时间：</p>
<ol>
<li>put等方法上指定了超时时间，则以此时间为准；</li>
<li>put等方法上未指定超时时间，使用Cache实例的默认超时时间；</li>
<li>Cache实例的默认超时时间，通过在@CreateCache和@Cached上的expire属性指定，如果没有指定，使用yml中定义的全局配置，例如@Cached(cacheType=local)使用jetcache.local.default.expireAfterWriteInMillis，如果仍未指定则是无穷大。</li>
</ol>
<h3><span id="注解说明">注解说明</span></h3><p>如果需要使用<code>jetcache</code>缓存，启动类添加两个注解：<code>@EnableCreateCacheAnnotation</code>、<code>@EnableMethodCache</code></p>
<h4><span id="enablecreatecacheannotation">@EnableCreateCacheAnnotation</span></h4><p>开启可通过@CreateCache注解创建Cache实例功能。</p>
<h4><span id="enablemethodcache">@EnableMethodCache</span></h4><p>开启可通过@Cached注解创建Cache实例功能，初始化spring aop，注解说明：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">basePackages</td>
<td align="left">无</td>
<td align="left">jetcache需要拦截的包名，只有这些包名下的Cache实例才会生效</td>
</tr>
<tr>
<td align="left">order</td>
<td align="left">Ordered.LOWEST_PRECEDENCE</td>
<td align="left">指定AOP切面执行过程的顺序，默认最低优先级</td>
</tr>
<tr>
<td align="left">mode</td>
<td align="left">AdviceMode.PROXY</td>
<td align="left">Spring AOP的模式，目前就提供默认值让你修改</td>
</tr>
<tr>
<td align="left">proxyTargetClass</td>
<td align="left">false</td>
<td align="left">无</td>
</tr>
</tbody></table>
<h4><span id="cached">@Cached</span></h4><p>为一个方法添加缓存，创建对应的缓存实例，注解可以添加在接口或者类的方法上面，该类必须是spring bean，注解说明：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">area</td>
<td align="left">“default”</td>
<td align="left">如果在配置中配置了多个缓存area，在这里指定使用哪个area。</td>
</tr>
<tr>
<td align="left">name</td>
<td align="left">未定义</td>
<td align="left">指定缓存实例名称，如果没有指定，会根据类名+方法名自动生成。name会被用于远程缓存的key前缀。另外在统计中，一个简短有意义的名字会提高可读性。</td>
</tr>
<tr>
<td align="left">enabled</td>
<td align="left">true</td>
<td align="left">是否激活缓存。</td>
</tr>
<tr>
<td align="left">timeUnit</td>
<td align="left">TimeUnit.SECONDS</td>
<td align="left">指定expire的单位。</td>
</tr>
<tr>
<td align="left">expire</td>
<td align="left">未定义</td>
<td align="left">超时时间。如果注解上没有定义，会使用全局配置，如果此时全局配置也没有定义，则为无穷大。</td>
</tr>
<tr>
<td align="left">localExpire</td>
<td align="left">未定义</td>
<td align="left">仅当cacheType为BOTH时适用，为本地缓存指定一个不一样的超时时间，通常应该小于expire。如果没有设置localExpire且cacheType为BOTH，那么本地缓存的超时时间和远程缓存保持一致。</td>
</tr>
<tr>
<td align="left">cacheType</td>
<td align="left">CacheType.REMOTE</td>
<td align="left">缓存的类型，支持：<code>REMOTE</code>、<code>LOCAL</code>、<code>BOTH</code>，如果定义为BOTH，会使用LOCAL和REMOTE组合成两级缓存。</td>
</tr>
<tr>
<td align="left">localLimit</td>
<td align="left">未定义</td>
<td align="left">如果cacheType为LOCAL或BOTH，这个参数指定本地缓存的最大元素数量，以控制内存占用。如果注解上没有定义，会使用全局配置，如果此时你没有定义全局配置，则使用默认的全局配置100。请结合实际业务场景进行设置该值。</td>
</tr>
<tr>
<td align="left">serialPolicy</td>
<td align="left">未定义</td>
<td align="left">指定远程缓存VALUE的序列化方式，支持<code>SerialPolicy.JAVA</code>、<code>SerialPolicy.KRYO</code>。如果注解上没有定义，会使用全局配置，如果你没有定义全局配置，则使用默认的全局配置SerialPolicy.JAVA。</td>
</tr>
<tr>
<td align="left">keyConvertor</td>
<td align="left">未定义</td>
<td align="left">指定KEY的转换方式，用于将复杂的KEY类型转换为缓存实现可以接受的类型，支持：<code>KeyConvertor.FASTJSON</code>、<code>KeyConvertor.NONE</code>。NONE表示不转换，FASTJSON可以将复杂对象KEY转换成String。如果注解上没有定义，会使用全局配置。</td>
</tr>
<tr>
<td align="left">key</td>
<td align="left">未定义</td>
<td align="left">使用<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html">SpEL</a>指定缓存key，如果没有指定会根据入参自动生成。</td>
</tr>
<tr>
<td align="left">cacheNullValue</td>
<td align="left">false</td>
<td align="left">当方法返回值为null的时候是否要缓存。</td>
</tr>
<tr>
<td align="left">condition</td>
<td align="left">未定义</td>
<td align="left">使用<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html">SpEL</a>指定条件，如果表达式返回true的时候才去缓存中查询。</td>
</tr>
<tr>
<td align="left">postCondition</td>
<td align="left">未定义</td>
<td align="left">使用<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html">SpEL</a>指定条件，如果表达式返回true的时候才更新缓存，该评估在方法执行后进行，因此可以访问到#result。</td>
</tr>
</tbody></table>
<h4><span id="cacheinvalidate">@CacheInvalidate</span></h4><p>用于移除缓存，配置说明：</p>
<table>
<thead>
<tr>
<th align="left">配置</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">area</td>
<td align="left">“default”</td>
<td align="left">如果在配置中配置了多个缓存area，在这里指定使用哪个area。</td>
</tr>
<tr>
<td align="left">name</td>
<td align="left">无</td>
<td align="left">指定缓存的唯一名称，一般指向对应的@Cached定义的name。</td>
</tr>
<tr>
<td align="left">key</td>
<td align="left">未定义</td>
<td align="left">使用<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html">SpEL</a>指定key，如果没有指定会根据入参自动生成。</td>
</tr>
<tr>
<td align="left">condition</td>
<td align="left">未定义</td>
<td align="left">使用<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html">SpEL</a>指定条件，如果表达式返回true才执行删除，可访问方法结果#result。删除缓存实例中key的元素。</td>
</tr>
<tr>
<td align="left">multi</td>
<td align="left">false</td>
<td align="left">如果根据<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html">SpEL</a>指定的key是一个集合，是否从缓存实例中删除对应的每个缓存。如果设置为true，但是key不是集合，则不会删除缓存。</td>
</tr>
</tbody></table>
<h4><span id="cacheupdate">@CacheUpdate</span></h4><p>用于更新缓存，配置说明：</p>
<table>
<thead>
<tr>
<th align="left">配置</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">area</td>
<td align="left">“default”</td>
<td align="left">如果在配置中配置了多个缓存area，在这里指定使用哪个area。</td>
</tr>
<tr>
<td align="left">name</td>
<td align="left">无</td>
<td align="left">指定缓存的唯一名称，一般指向对应的@Cached定义的name。</td>
</tr>
<tr>
<td align="left">key</td>
<td align="left">未定义</td>
<td align="left">使用<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html">SpEL</a>指定key，如果没有指定会根据入参自动生成。</td>
</tr>
<tr>
<td align="left">value</td>
<td align="left">无</td>
<td align="left">使用<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html">SpEL</a>指定value。</td>
</tr>
<tr>
<td align="left">condition</td>
<td align="left">未定义</td>
<td align="left">使用<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html">SpEL</a>指定条件，如果表达式返回true才执行更新，可访问方法结果#result。更新缓存实例中key的元素。</td>
</tr>
<tr>
<td align="left">multi</td>
<td align="left">false</td>
<td align="left">如果根据<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html">SpEL</a>指定key和value都是集合并且元素的个数相同，则是否更新缓存实例中的对应的每个元素。如果设置为true，但是key不是集合或者value不是集合或者它们的元素的个数不相同，也不会更新缓存。</td>
</tr>
</tbody></table>
<h4><span id="cacherefresh">@CacheRefresh</span></h4><p>用于自定刷新缓存，配置说明：</p>
<table>
<thead>
<tr>
<th align="left">配置</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">refresh</td>
<td align="left">无</td>
<td align="left">刷新间隔</td>
</tr>
<tr>
<td align="left">stopRefreshAfterLastAccess</td>
<td align="left">未定义</td>
<td align="left">指定该key多长时间没有访问就停止刷新，如果不指定会一直刷新。</td>
</tr>
<tr>
<td align="left">refreshLockTimeout</td>
<td align="left">60秒</td>
<td align="left">类型为BOTH/REMOTE的缓存刷新时，同时只会有一台服务器在刷新，这台服务器会在远程缓存放置一个分布式锁，此配置指定该锁的超时时间。</td>
</tr>
<tr>
<td align="left">timeUnit</td>
<td align="left">TimeUnit.SECONDS</td>
<td align="left">指定refresh时间单位。</td>
</tr>
</tbody></table>
<h4><span id="cachepenetrationprotect">@CachePenetrationProtect</span></h4><p>当缓存访问未命中的情况下，对并发进行的加载行为进行保护。 当前版本实现的是单JVM内的保护，即同一个JVM中同一个key只有一个线程去加载，其它线程等待结果，配置说明：</p>
<table>
<thead>
<tr>
<th align="left">配置</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">value</td>
<td align="left">true</td>
<td align="left">是否开启保护模式。</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">未定义</td>
<td align="left">其他线程的等待超时时间，如果超时则自己执行方法直接返回结果。</td>
</tr>
<tr>
<td align="left">timeUnit</td>
<td align="left">TimeUnit.SECONDS</td>
<td align="left">指定timeout时间单位。</td>
</tr>
</tbody></table>
<h4><span id="createcache">@CreateCache</span></h4><p>在Spring Bean中使用该注解可创建一个Cache实例，配置说明：</p>
<table>
<thead>
<tr>
<th align="left">配置</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">area</td>
<td align="left">“default”</td>
<td align="left">如果在配置中配置了多个缓存area，在这里指定使用哪个area。</td>
</tr>
<tr>
<td align="left">name</td>
<td align="left">未定义</td>
<td align="left">指定缓存实例名称，如果没有指定，会根据类名+方法名自动生成。name会被用于远程缓存的key前缀。另外在统计中，一个简短有意义的名字会提高可读性。</td>
</tr>
<tr>
<td align="left">timeUnit</td>
<td align="left">TimeUnit.SECONDS</td>
<td align="left">指定expire的单位。</td>
</tr>
<tr>
<td align="left">expire</td>
<td align="left">未定义</td>
<td align="left">超时时间。如果注解上没有定义，会使用全局配置，如果此时全局配置也没有定义，则为无穷大。</td>
</tr>
<tr>
<td align="left">localExpire</td>
<td align="left">未定义</td>
<td align="left">仅当cacheType为BOTH时适用，为本地缓存指定一个不一样的超时时间，通常应该小于expire。如果没有设置localExpire且cacheType为BOTH，那么本地缓存的超时时间和远程缓存保持一致。</td>
</tr>
<tr>
<td align="left">cacheType</td>
<td align="left">CacheType.REMOTE</td>
<td align="left">缓存的类型，支持：<code>REMOTE</code>、<code>LOCAL</code>、<code>BOTH</code>，如果定义为BOTH，会使用LOCAL和REMOTE组合成两级缓存。</td>
</tr>
<tr>
<td align="left">localLimit</td>
<td align="left">未定义</td>
<td align="left">如果cacheType为LOCAL或BOTH，这个参数指定本地缓存的最大元素数量，以控制内存占用。如果注解上没有定义，会使用全局配置，如果此时你没有定义全局配置，则使用默认的全局配置100。请结合实际业务场景进行设置该值。</td>
</tr>
<tr>
<td align="left">serialPolicy</td>
<td align="left">未定义</td>
<td align="left">指定远程缓存VALUE的序列化方式，支持<code>SerialPolicy.JAVA</code>、<code>SerialPolicy.KRYO</code>。如果注解上没有定义，会使用全局配置，如果你没有定义全局配置，则使用默认的全局配置SerialPolicy.JAVA。</td>
</tr>
<tr>
<td align="left">keyConvertor</td>
<td align="left">未定义</td>
<td align="left">指定KEY的转换方式，用于将复杂的KEY类型转换为缓存实现可以接受的类型，支持：<code>KeyConvertor.FASTJSON</code>、<code>KeyConvertor.NONE</code>。NONE表示不转换，FASTJSON可以将复杂对象KEY转换成String。如果注解上没有定义，会使用全局配置。</td>
</tr>
</tbody></table>
<h3><span id="使用示例">使用示例</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 启动类</span><br><span class="line"> */</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableCreateCacheAnnotation</span><br><span class="line">@EnableMethodCache(basePackages = &quot;com.xxx.xxx&quot;)</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 接口</span><br><span class="line"> */</span><br><span class="line">public interface JetCacheExampleService &#123;</span><br><span class="line">    </span><br><span class="line">    User getValue(long userId);</span><br><span class="line">    </span><br><span class="line">    void updateValue(User  user);</span><br><span class="line">    </span><br><span class="line">    void deleteValue(User  user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 实现类</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class JetCacheExampleServiceImpl implements JetCacheExampleService &#123;</span><br><span class="line">    </span><br><span class="line">    @CreateCache(name = &quot;JetCacheExampleServiceImpl.exampleCache&quot; , localLimit = 50 ,cacheType = CacheType.LOCAL)</span><br><span class="line">    @CachePenetrationProtect</span><br><span class="line">    private Cache&lt;Long, User&gt; exampleCache;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    @Cached(name = &quot;JetCacheExampleService.getValue&quot;, expire = 3600 * 6, localLimit = 50, cacheType = CacheType.BOTH)</span><br><span class="line">    @CacheRefresh(refresh = 3600, stopRefreshAfterLastAccess = 3600 * 2)</span><br><span class="line">    @CachePenetrationProtect</span><br><span class="line">    public User getValue(long userId)&#123;</span><br><span class="line">        String result = new User();</span><br><span class="line">        // ... 处理逻辑</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    @CacheUpdate(name = &quot;JetCacheExampleService.getValue&quot;, key=&quot;#user.userId&quot;, value=&quot;#user&quot;)</span><br><span class="line">    public void updateValue(User user)&#123;</span><br><span class="line">        // 处理逻辑</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    @CacheInvalidate(name = &quot;JetCacheExampleService.getValue&quot;, key=&quot;#user.userId&quot;)</span><br><span class="line">    public void deleteValue(User user)&#123;</span><br><span class="line">        // 处理逻辑</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上述所示</p>
<p>getValue方法会创建一个缓存实例，通过<code>@Cached</code>注解可以看到缓存实例名称<code>cacheName</code>为’JetCacheExampleService.getValue’，缓存的有效时长为6小时，本地缓存的数量最多为50，缓存类型为<code>BOTH</code>（优先从本地缓存获取）；通过<code>@CacheRefresh</code>注解可以看到会为该缓存实例设置一个刷新策略，刷新间隔为1小时，2个小时没访问后不再刷新，需要刷新的缓存实例会为其每一个缓存数据创建一个<code>RefreshTask</code>周期性任务；<code>@CachePenetrationProtect</code>注解表示该缓存实例开启保护模式，当缓存未命中，同一个JVM中同一个key只有一个线程去加载数据，其它线程等待结果。</p>
<p>updateValue方法可以更新缓存，通过<code>@CacheUpdate</code>注解可以看到会更新缓存实例’JetCacheExampleService.getValue’中缓存key为#user.userId的缓存value为#user。</p>
<p>deleteValue方法可以删除缓存，通过<code>@CacheInvalidate</code>注解可以看到会删除缓存实例’JetCacheExampleService.getValue’中缓存key为#user.userId缓存数据。</p>
<p>exampleCache字段会作为一个缓存实例对象，通过<code>@CreateCache</code>注解可以看到，会将该字段作为<code>cacheName</code>为’JetCacheExampleService.getValue’缓存实例对象，本地缓存的数量最多为50，缓存类型为<code>LOCAL</code>，<code>@CachePenetrationProtect</code>注解表示该缓存实例开启保护模式。</p>
<p>我的业务场景是使用上述的getValue方法创建缓存实例即可。</p>
<p>注意：</p>
<ul>
<li><code>@Cached</code>注解不能和<code>@CacheUpdate</code>或者<code>@CacheInvalidate</code>同时使用</li>
<li><code>@CacheInvalidate</code>可以多个同时使用</li>
</ul>
<p>另外通过@CreateCache注解创建缓存实例也可以这样初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class JetCacheExampleServiceImpl implements JetCacheExampleService &#123;</span><br><span class="line">    </span><br><span class="line">	@CreateCache(name = &quot;JetCacheExampleServiceImpl.exampleCache&quot; , localLimit = 50 ,cacheType = CacheType.LOCAL)</span><br><span class="line">	private Cache&lt;Long, User&gt; exampleCache;</span><br><span class="line"></span><br><span class="line">	@PostConstruct</span><br><span class="line">	public exampleCacheInit()&#123;</span><br><span class="line">    	RefreshPolicy policy = RefreshPolicy.newPolicy(60, TimeUnit.MINUTES)</span><br><span class="line">                	.stopRefreshAfterLastAccess(120, TimeUnit.MINUTES);</span><br><span class="line">        exampleCache.config().setLoader(this::loadFromDatabase);</span><br><span class="line">        exampleCache.config().setRefreshPolicy(policy);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更加详细的使用方法请参考<a href="https://github.com/alibaba/jetcache"><code>JetCache</code></a>官方地址。</p>
<h2><span id="三-源码解析">三、源码解析</span></h2><p>参考本人Git仓库中的<a href="https://github.com/liu844869663/jetcache"><code>JetCache</code>项目</a>，已做详细的注释。</p>
<p>简单概括：利用Spring AOP功能，在调用需要缓存的方法前，通过解析注解获取缓存配置，根据这些配置创建不同的实例对象，进行缓存等操作。</p>
<p><code>JetCache</code>分为两部分，一部分是Cache API以及实现，另一部分是注解支持。</p>
<h3><span id="项目的各个子模块">项目的各个子模块</span></h3><ul>
<li>jetcache-anno-api：定义<code>JetCache</code>注解和常量。</li>
<li>jetcache-core：核心API，Cache接口的实现，提供各种缓存实例的操作，不依赖于Spring。</li>
<li>jetcache-autoconfigure：完成初始化，解析application.yml配置文件中的相关配置，以提供不同缓存实例的<code>CacheBuilder</code>构造器</li>
<li>jetcache-anno：基于Spring提供<code>@Cached</code>和<code>@CreateCache</code>注解支持，初始化Spring AOP以及<code>JetCache</code>注解等配置。</li>
<li>jetcache-redis：使用Jedis提供Redis支持。</li>
<li>jetcache-redis-lettuce：使用<a href="https://github.com/lettuce-io/lettuce-core">Lettuce</a>提供Redis支持，实现了<code>JetCache</code>异步访问缓存的的接口。</li>
<li>jetcache-redis-springdata：使用Spring Data提供Redis支持。</li>
<li>jetcache-starter-redis：提供pom文件，Spring Boot方式的Starter，基于Jedis。</li>
<li>jetcache-starter-redis-lettuce：提供pom文件，Spring Boot方式的Starter，基于Lettuce。</li>
<li>jetcache-starter-redis-springdata：提供pom文件，Spring Boot方式的Starter，基于Spring Data。</li>
<li>jetcache-test：提供相关测试。</li>
</ul>
<h3><span id="常用注解与变量">常用注解与变量</span></h3><p><a href="AnnoAPI.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2021/10/01/etCache-%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/AnnoAPI.png" alt="AnnoAPI"></a></p>
<p>在jetcache-anno-api模块中定义了需要用的缓存注解与常量，在上述已经详细的讲述过，其中<code>@CacheInvalidateContainer</code>注解定义value为<code>@CacheInvalidate</code>数组，然后通过jdk8新增的<code>@Repeatable</code>注解，在<code>@CacheInvalidate</code>注解上面添加<code>@Repeatable(CacheInvalidateContainer.class)</code>，即可支持同一个地方可以使用多个<code>@CacheInvalidate</code>注解。</p>
<h3><span id="缓存api">缓存API</span></h3><p>主要查看jetcache-core子模块，提供各种<code>Cache</code>缓存，以支持不同的缓存类型</p>
<p>Cache接口的子关系，结构如下图：</p>
<p><a href="Cache.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2021/10/01/etCache-%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Cache.png" alt="Cache"></a></p>
<p>主要对象描述：</p>
<ul>
<li>Cache：缓存接口，定义基本方法</li>
<li>AbstractCache：抽象类，缓存接口的继承者，提供基本实现，具体实现交由不同的子类</li>
<li>LinkedHashMapCache：基于LinkedHashMap设计的简易内存缓存</li>
<li>CaffeineCache：基于<a href="https://github.com/ben-manes/caffeine">Caffeine</a>工具设计的内存缓存</li>
<li>RedisCache：Redis实现，使用Jedis客户端</li>
<li>RedisLettuceCache：Redis实现，使用<a href="https://github.com/lettuce-io/lettuce-core">Lettuce</a>客户端</li>
<li>MultiLevelCache：两级缓存，用于封装EmbeddedCache（本地缓存）和ExternalCache（远程缓存）</li>
<li>RefreshCache：基于装饰器模式Decorator，提供自动刷新功能</li>
<li>LazyInitCache：用于@CreateCache注解创建的缓存实例，依赖于Spring</li>
</ul>
<h4><span id="cache接口">Cache接口</span></h4><p><code>com.alicp.jetcache.Cache</code>接口，定义了缓存实例的操作方法（部分有默认实现），以及获取分布式锁（非严格，用于刷新远程缓存）的实现，因为继承了<code>java.io.Closeable</code>接口，所以也提供了close方法的默认实现，空方法，交由不同缓存实例的实现去实现该方法用于释放资源，在<code>com.alicp.jetcache.anno.support.ConfigProvider.doShutdown()</code>方法中会调用每个缓存实例对象的close方法进行资源释放。主要代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">public interface Cache&lt;K, V&gt; extends Closeable &#123;</span><br><span class="line"></span><br><span class="line">    Logger logger = LoggerFactory.getLogger(Cache.class);</span><br><span class="line"></span><br><span class="line">    //-----------------------------JSR 107 style API------------------------------------------------</span><br><span class="line">    default V get(K key) throws CacheInvokeException &#123;</span><br><span class="line">        CacheGetResult&lt;V&gt; result = GET(key);</span><br><span class="line">        if (result.isSuccess()) &#123;</span><br><span class="line">            return result.getValue();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    default Map&lt;K, V&gt; getAll(Set&lt;? extends K&gt; keys) throws CacheInvokeException &#123;</span><br><span class="line">        MultiGetResult&lt;K, V&gt; cacheGetResults = GET_ALL(keys);</span><br><span class="line">        return cacheGetResults.unwrapValues();</span><br><span class="line">    &#125;</span><br><span class="line">    default void put(K key, V value) &#123;</span><br><span class="line">        PUT(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    default void putAll(Map&lt;? extends K, ? extends V&gt; map) &#123;</span><br><span class="line">        PUT_ALL(map);</span><br><span class="line">    &#125;</span><br><span class="line">    default boolean putIfAbsent(K key, V value) &#123; // 多级缓存MultiLevelCache不支持此方法</span><br><span class="line">        CacheResult result = PUT_IF_ABSENT(key, value, config().getExpireAfterWriteInMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">        return result.getResultCode() == CacheResultCode.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    default boolean remove(K key) &#123;</span><br><span class="line">        return REMOVE(key).isSuccess();</span><br><span class="line">    &#125;</span><br><span class="line">    default void removeAll(Set&lt;? extends K&gt; keys) &#123;</span><br><span class="line">        REMOVE_ALL(keys);</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;T&gt; T unwrap(Class&lt;T&gt; clazz);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    default void close() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //--------------------------JetCache API---------------------------------------------</span><br><span class="line">    CacheConfig&lt;K, V&gt; config();</span><br><span class="line"></span><br><span class="line">    default AutoReleaseLock tryLock(K key, long expire, TimeUnit timeUnit) &#123;</span><br><span class="line">        if (key == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        // 随机生成一个值</span><br><span class="line">        final String uuid = UUID.randomUUID().toString();</span><br><span class="line">        // 过期时间</span><br><span class="line">        final long expireTimestamp = System.currentTimeMillis() + timeUnit.toMillis(expire);</span><br><span class="line">        final CacheConfig config = config();</span><br><span class="line"></span><br><span class="line">        AutoReleaseLock lock = () -&gt; &#123; // 创建一把会自动释放资源的锁，实现其 close() 方法</span><br><span class="line">            int unlockCount = 0;</span><br><span class="line">            while (unlockCount++ &lt; config.getTryLockUnlockCount()) &#123;</span><br><span class="line">                if(System.currentTimeMillis() &lt; expireTimestamp) &#123; // 这把锁还没有过期，则删除</span><br><span class="line">                    // 删除对应的 Key 值</span><br><span class="line">                    // 出现的结果：成功，失败，Key 不存在</span><br><span class="line">                    CacheResult unlockResult = REMOVE(key);</span><br><span class="line">                    if (unlockResult.getResultCode() == CacheResultCode.FAIL</span><br><span class="line">                            || unlockResult.getResultCode() == CacheResultCode.PART_SUCCESS) &#123;</span><br><span class="line">                        // 删除对应的 Key 值过程中出现了异常，则重试</span><br><span class="line">                        logger.info(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] unlock failed. Key=&#123;&#125;, msg = &#123;&#125;&quot;,</span><br><span class="line">                                unlockCount, config.getTryLockUnlockCount(), uuid, key, unlockResult.getMessage());</span><br><span class="line">                        // retry</span><br><span class="line">                    &#125; else if (unlockResult.isSuccess()) &#123; // 释放成功</span><br><span class="line">                        logger.debug(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] successfully release the lock. Key=&#123;&#125;&quot;,</span><br><span class="line">                                unlockCount, config.getTryLockUnlockCount(), uuid, key);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125; else &#123; // 锁已经被释放了</span><br><span class="line">                        logger.warn(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] unexpected unlock result: Key=&#123;&#125;, result=&#123;&#125;&quot;,</span><br><span class="line">                                unlockCount, config.getTryLockUnlockCount(), uuid, key, unlockResult.getResultCode());</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123; // 该锁已失效</span><br><span class="line">                    logger.info(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] lock already expired: Key=&#123;&#125;&quot;,</span><br><span class="line">                            unlockCount, config.getTryLockUnlockCount(), uuid, key);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        int lockCount = 0;</span><br><span class="line">        Cache cache = this;</span><br><span class="line">        while (lockCount++ &lt; config.getTryLockLockCount()) &#123;</span><br><span class="line">            // 往 Redis（或者本地） 中存放 Key 值（_#RL#结尾的Key）</span><br><span class="line">            // 返回的结果：成功、已存在、失败</span><br><span class="line">            CacheResult lockResult = cache.PUT_IF_ABSENT(key, uuid, expire, timeUnit);</span><br><span class="line">            if (lockResult.isSuccess()) &#123; // 成功获取到锁</span><br><span class="line">                logger.debug(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] successfully get a lock. Key=&#123;&#125;&quot;,</span><br><span class="line">                        lockCount, config.getTryLockLockCount(), uuid, key);</span><br><span class="line">                return lock;</span><br><span class="line">            &#125; else if (lockResult.getResultCode() == CacheResultCode.FAIL || lockResult.getResultCode() == CacheResultCode.PART_SUCCESS) &#123;</span><br><span class="line">                logger.info(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] cache access failed during get lock, will inquiry &#123;&#125; times. Key=&#123;&#125;, msg=&#123;&#125;&quot;,</span><br><span class="line">                        lockCount, config.getTryLockLockCount(), uuid,</span><br><span class="line">                        config.getTryLockInquiryCount(), key, lockResult.getMessage());</span><br><span class="line">                // 尝试获取锁的过程中失败了，也就是往 Redis 中存放 Key 值出现异常</span><br><span class="line">                // 这个时候可能 Key 值已经存储了，但是由于其他原因导致返回的结果表示执行失败</span><br><span class="line">                int inquiryCount = 0;</span><br><span class="line">                while (inquiryCount++ &lt; config.getTryLockInquiryCount()) &#123;</span><br><span class="line">                    CacheGetResult inquiryResult = cache.GET(key);</span><br><span class="line">                    if (inquiryResult.isSuccess()) &#123;</span><br><span class="line">                        if (uuid.equals(inquiryResult.getValue())) &#123;</span><br><span class="line">                            logger.debug(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] successfully get a lock after inquiry. Key=&#123;&#125;&quot;,</span><br><span class="line">                                    inquiryCount, config.getTryLockInquiryCount(), uuid, key);</span><br><span class="line">                            return lock;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            logger.debug(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] not the owner of the lock, return null. Key=&#123;&#125;&quot;,</span><br><span class="line">                                    inquiryCount, config.getTryLockInquiryCount(), uuid, key);</span><br><span class="line">                            return null;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        logger.info(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] inquiry failed. Key=&#123;&#125;, msg=&#123;&#125;&quot;,</span><br><span class="line">                                inquiryCount, config.getTryLockInquiryCount(), uuid, key, inquiryResult.getMessage());</span><br><span class="line">                        // retry inquiry</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123; // 已存在表示该锁被其他人占有</span><br><span class="line">                // others holds the lock</span><br><span class="line">                logger.debug(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] others holds the lock, return null. Key=&#123;&#125;&quot;,</span><br><span class="line">                        lockCount, config.getTryLockLockCount(), uuid, key);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.debug(&quot;[tryLock] [&#123;&#125;] return null after &#123;&#125; attempts. Key=&#123;&#125;&quot;, uuid, config.getTryLockLockCount(), key);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default boolean tryLockAndRun(K key, long expire, TimeUnit timeUnit, Runnable action)&#123;</span><br><span class="line">        // Release the lock use Java 7 try-with-resources.</span><br><span class="line">        try (AutoReleaseLock lock = tryLock(key, expire, timeUnit)) &#123; // 尝试获取锁</span><br><span class="line">            if (lock != null) &#123; // 获取到锁则执行下面的任务</span><br><span class="line">                action.run();</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            // 执行完锁的操作后会进行资源释放，调用 AutoCloseable 的 close() 方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CacheGetResult&lt;V&gt; GET(K key);</span><br><span class="line"></span><br><span class="line">    MultiGetResult&lt;K, V&gt; GET_ALL(Set&lt;? extends K&gt; keys);</span><br><span class="line"></span><br><span class="line">    default V computeIfAbsent(K key, Function&lt;K, V&gt; loader) &#123;</span><br><span class="line">        return computeIfAbsent(key, loader, config().isCacheNullValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V computeIfAbsent(K key, Function&lt;K, V&gt; loader, boolean cacheNullWhenLoaderReturnNull);</span><br><span class="line"></span><br><span class="line">    V computeIfAbsent(K key, Function&lt;K, V&gt; loader, boolean cacheNullWhenLoaderReturnNull, long expireAfterWrite, TimeUnit timeUnit);</span><br><span class="line"></span><br><span class="line">    default void put(K key, V value, long expireAfterWrite, TimeUnit timeUnit) &#123;</span><br><span class="line">        PUT(key, value, expireAfterWrite, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default CacheResult PUT(K key, V value) &#123;</span><br><span class="line">        if (key == null) &#123;</span><br><span class="line">            return CacheResult.FAIL_ILLEGAL_ARGUMENT;</span><br><span class="line">        &#125;</span><br><span class="line">        return PUT(key, value, config().getExpireAfterWriteInMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CacheResult PUT(K key, V value, long expireAfterWrite, TimeUnit timeUnit);</span><br><span class="line"></span><br><span class="line">    default void putAll(Map&lt;? extends K, ? extends V&gt; map, long expireAfterWrite, TimeUnit timeUnit) &#123;</span><br><span class="line">        PUT_ALL(map, expireAfterWrite, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default CacheResult PUT_ALL(Map&lt;? extends K, ? extends V&gt; map) &#123;</span><br><span class="line">        if (map == null) &#123;</span><br><span class="line">            return CacheResult.FAIL_ILLEGAL_ARGUMENT;</span><br><span class="line">        &#125;</span><br><span class="line">        return PUT_ALL(map, config().getExpireAfterWriteInMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CacheResult PUT_ALL(Map&lt;? extends K, ? extends V&gt; map, long expireAfterWrite, TimeUnit timeUnit);</span><br><span class="line"></span><br><span class="line">    CacheResult REMOVE(K key);</span><br><span class="line"></span><br><span class="line">    CacheResult REMOVE_ALL(Set&lt;? extends K&gt; keys);</span><br><span class="line"></span><br><span class="line">    CacheResult PUT_IF_ABSENT(K key, V value, long expireAfterWrite, TimeUnit timeUnit);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>com.alicp.jetcache.Cache</code>定义的方法大都是关于缓存的获取、删除和存放操作</p>
<ol>
<li>其中大写的方法返回<code>JetCache</code>自定义的CacheResult（完整的返回值，可以清晰的知道执行结果，例如get返回null的时候，无法断定是对应的key不存在，还是访问缓存发生了异常）</li>
<li>小写的方法默认实现就是调用大写的方法</li>
<li><code>computeIfAbsent</code>方法最为核心，交由子类去实现</li>
<li><code>tryLockAndRun</code>方法会非堵塞的尝试获取一把AutoReleaseLock分布式锁（非严格）,获取过程：<ol>
<li>尝试往Redis中设置（已存在无法设置）一个键值对，key为缓存<code>key_#RL#</code>，value为<code>UUID</code>，并设置这个键值对的过期时间为60秒（默认）</li>
<li>如果获取到锁后进行加载任务，也就是重新加载方法并更新远程缓存</li>
<li>该锁实现了java.lang.AutoCloseable接口，使用try-with-resource方式，在执行完加载任务后会自动释放资源，也就是调用close方法将获取锁过程中设置的键值对从Redis中删除</li>
<li>在RefreshCache中会调用该方法，因为如果存在远程缓存需要刷新则需要采用分布式锁的方式</li>
</ol>
</li>
</ol>
<h4><span id="abstractcache抽象类">AbstractCache抽象类</span></h4><p><code>com.alicp.jetcache.AbstractCache</code>抽象类，实现了Cache接口，主要代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractCache&lt;K, V&gt; implements Cache&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当缓存未命中时，并发情况同一个Key是否只允许一个线程去加载，其他线程等待结果（可以设置timeout，超时则自己加载并直接返回）</span><br><span class="line">     * 如果是的话则由获取到Key对应的 LoaderLock.signal（采用了 CountDownLatch）的线程进行加载</span><br><span class="line">     * loaderMap临时保存 Key 对应的 LoaderLock 对象</span><br><span class="line">     */</span><br><span class="line">    private volatile ConcurrentHashMap&lt;Object, LoaderLock&gt; loaderMap;</span><br><span class="line"></span><br><span class="line">    ConcurrentHashMap&lt;Object, LoaderLock&gt; initOrGetLoaderMap() &#123;</span><br><span class="line">        if (loaderMap == null) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                if (loaderMap == null) &#123;</span><br><span class="line">                    loaderMap = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return loaderMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public final V computeIfAbsent(K key, Function&lt;K, V&gt; loader, boolean cacheNullWhenLoaderReturnNull) &#123;</span><br><span class="line">        return computeIfAbsentImpl(key, loader, cacheNullWhenLoaderReturnNull,</span><br><span class="line">                0, null, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public final V computeIfAbsent(K key, Function&lt;K, V&gt; loader, boolean cacheNullWhenLoaderReturnNull,</span><br><span class="line">                                   long expireAfterWrite, TimeUnit timeUnit) &#123;</span><br><span class="line">        return computeIfAbsentImpl(key, loader, cacheNullWhenLoaderReturnNull,</span><br><span class="line">                expireAfterWrite, timeUnit, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static &lt;K, V&gt; boolean needUpdate(V loadedValue, boolean cacheNullWhenLoaderReturnNull, Function&lt;K, V&gt; loader) &#123;</span><br><span class="line">        if (loadedValue == null &amp;&amp; !cacheNullWhenLoaderReturnNull) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (loader instanceof CacheLoader &amp;&amp; ((CacheLoader&lt;K, V&gt;) loader).vetoCacheUpdate()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &lt;K, V&gt; V computeIfAbsentImpl(K key, Function&lt;K, V&gt; loader, boolean cacheNullWhenLoaderReturnNull,</span><br><span class="line">                                               long expireAfterWrite, TimeUnit timeUnit, Cache&lt;K, V&gt; cache) &#123;</span><br><span class="line">    	// 获取内部的 Cache 对象</span><br><span class="line">        AbstractCache&lt;K, V&gt; abstractCache = CacheUtil.getAbstractCache(cache);</span><br><span class="line">        // 封装 loader 函数成一个 ProxyLoader 对象，主要在重新加载缓存后发出一个 CacheLoadEvent 到 CacheMonitor</span><br><span class="line">        CacheLoader&lt;K, V&gt; newLoader = CacheUtil.createProxyLoader(cache, loader, abstractCache::notify);</span><br><span class="line">        CacheGetResult&lt;V&gt; r;</span><br><span class="line">        if (cache instanceof RefreshCache) &#123; // 该缓存实例需要刷新</span><br><span class="line">            RefreshCache&lt;K, V&gt; refreshCache = ((RefreshCache&lt;K, V&gt;) cache);</span><br><span class="line">            /*</span><br><span class="line">             * 从缓存中获取数据</span><br><span class="line">             * 如果是多级缓存（先从本地缓存获取，获取不到则从远程缓存获取）</span><br><span class="line">             * 如果缓存数据是从远程缓存获取到的数据则会更新至本地缓存，并且如果本地缓存没有设置 localExpire 则使用远程缓存的到期时间作为自己的到期时间</span><br><span class="line">             * 我一般不设置 localExpire ，因为可能导致本地缓存的有效时间比远程缓存的有效时间更长</span><br><span class="line">             * 如果设置 localExpire 了记得设置 expireAfterAccessInMillis</span><br><span class="line">             */</span><br><span class="line">            r = refreshCache.GET(key);</span><br><span class="line">            // 添加/更新当前 RefreshCache 的刷新缓存任务，存放于 RefreshCache 的 taskMap 中</span><br><span class="line">            refreshCache.addOrUpdateRefreshTask(key, newLoader);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 从缓存中获取数据</span><br><span class="line">            r = cache.GET(key);</span><br><span class="line">        &#125;</span><br><span class="line">        if (r.isSuccess()) &#123; // 缓存命中</span><br><span class="line">            return r.getValue();</span><br><span class="line">        &#125; else &#123; // 缓存未命中</span><br><span class="line">            // 创建当缓存未命中去更新缓存的函数</span><br><span class="line">            Consumer&lt;V&gt; cacheUpdater = (loadedValue) -&gt; &#123;</span><br><span class="line">                if(needUpdate(loadedValue, cacheNullWhenLoaderReturnNull, newLoader)) &#123;</span><br><span class="line">                    /*</span><br><span class="line">                     * 未在缓存注解中配置 key 的生成方式则默认取入参作为缓存 key</span><br><span class="line">                     * 在进入当前方法时是否可以考虑为 key 创建一个副本？？？？</span><br><span class="line">                     * 因为缓存未命中然后通过 loader 重新加载方法时，如果方法内部对入参进行了修改，那么生成的缓存 key 也会被修改</span><br><span class="line">                     * 从而导致相同的 key 进入该方法时一直与缓存中的 key 不相同，一直出现缓存未命中</span><br><span class="line">                     */</span><br><span class="line">                    if (timeUnit != null) &#123;</span><br><span class="line">                        cache.PUT(key, loadedValue, expireAfterWrite, timeUnit).waitForResult();</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        cache.PUT(key, loadedValue).waitForResult();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            V loadedValue;</span><br><span class="line">            if (cache.config().isCachePenetrationProtect()) &#123; // 添加了 @CachePenetrationProtect 注解</span><br><span class="line">            	// 一个JVM只允许一个线程执行</span><br><span class="line">                loadedValue = synchronizedLoad(cache.config(), abstractCache, key, newLoader, cacheUpdater);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            	// 执行方法</span><br><span class="line">                loadedValue = newLoader.apply(key);</span><br><span class="line">                // 将新的结果异步缓存</span><br><span class="line">                cacheUpdater.accept(loadedValue);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return loadedValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &lt;K, V&gt; V synchronizedLoad(CacheConfig config, AbstractCache&lt;K,V&gt; abstractCache,</span><br><span class="line">                                     K key, Function&lt;K, V&gt; newLoader, Consumer&lt;V&gt; cacheUpdater) &#123;</span><br><span class="line">        ConcurrentHashMap&lt;Object, LoaderLock&gt; loaderMap = abstractCache.initOrGetLoaderMap();</span><br><span class="line">        Object lockKey = buildLoaderLockKey(abstractCache, key);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // 为什么加一个 create[] 数组 疑问？？</span><br><span class="line">            boolean create[] = new boolean[1];</span><br><span class="line">            LoaderLock ll = loaderMap.computeIfAbsent(lockKey, (unusedKey) -&gt; &#123;</span><br><span class="line">                create[0] = true;</span><br><span class="line">                LoaderLock loaderLock = new LoaderLock();</span><br><span class="line">                loaderLock.signal = new CountDownLatch(1);</span><br><span class="line">                loaderLock.loaderThread = Thread.currentThread();</span><br><span class="line">                return loaderLock;</span><br><span class="line">            &#125;);</span><br><span class="line">            if (create[0] || ll.loaderThread == Thread.currentThread()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 加载该 Key 实例的方法</span><br><span class="line">                    V loadedValue = newLoader.apply(key);</span><br><span class="line">                    ll.success = true;</span><br><span class="line">                    ll.value = loadedValue;</span><br><span class="line">                    // 将重新加载的数据更新至缓存</span><br><span class="line">                    cacheUpdater.accept(loadedValue);</span><br><span class="line">                    return loadedValue;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    // 标记已完成</span><br><span class="line">                    ll.signal.countDown();</span><br><span class="line">                    if (create[0]) &#123;</span><br><span class="line">                        loaderMap.remove(lockKey);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123; // 等待其他线程加载，如果出现异常或者超时则自己加载返回数据，但是不更新缓存</span><br><span class="line">                try &#123;</span><br><span class="line">                    Duration timeout = config.getPenetrationProtectTimeout();</span><br><span class="line">                    if (timeout == null) &#123;</span><br><span class="line">                        ll.signal.await();</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        boolean ok = ll.signal.await(timeout.toMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">                        if(!ok) &#123;</span><br><span class="line">                            logger.info(&quot;loader wait timeout:&quot; + timeout);</span><br><span class="line">                            return newLoader.apply(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    logger.warn(&quot;loader wait interrupted&quot;);</span><br><span class="line">                    return newLoader.apply(key);</span><br><span class="line">                &#125;</span><br><span class="line">                if (ll.success) &#123;</span><br><span class="line">                    return (V) ll.value;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Object buildLoaderLockKey(Cache c, Object key) &#123;</span><br><span class="line">        if (c instanceof AbstractEmbeddedCache) &#123;</span><br><span class="line">            return ((AbstractEmbeddedCache) c).buildKey(key);</span><br><span class="line">        &#125; else if (c instanceof AbstractExternalCache) &#123;</span><br><span class="line">            byte bytes[] = ((AbstractExternalCache) c).buildKey(key);</span><br><span class="line">            return ByteBuffer.wrap(bytes);</span><br><span class="line">        &#125; else if (c instanceof MultiLevelCache) &#123;</span><br><span class="line">            c = ((MultiLevelCache) c).caches()[0];</span><br><span class="line">            return buildLoaderLockKey(c, key);</span><br><span class="line">        &#125; else if(c instanceof ProxyCache) &#123;</span><br><span class="line">            c = ((ProxyCache) c).getTargetCache();</span><br><span class="line">            return buildLoaderLockKey(c, key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new CacheException(&quot;impossible&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重新加载数据锁</span><br><span class="line">     */</span><br><span class="line">    static class LoaderLock &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 栅栏</span><br><span class="line">         */</span><br><span class="line">        CountDownLatch signal;</span><br><span class="line">        /**</span><br><span class="line">         * 持有的线程</span><br><span class="line">         */</span><br><span class="line">        Thread loaderThread;</span><br><span class="line">        /**</span><br><span class="line">         * 是否加载成功</span><br><span class="line">         */</span><br><span class="line">        boolean success;</span><br><span class="line">        /**</span><br><span class="line">         * 加载出来的数据</span><br><span class="line">         */，</span><br><span class="line">        Object value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>com.alicp.jetcache.AbstractCache</code>实现了<code>Cache</code>接口的大写方法，内部调用自己定义的抽象方法（以<code>DO_</code>开头，交由不同的子类实现），操作缓存后发送相应的事件<code>CacheEvent</code>，也就是调用自己定义的notify方法，遍历每个<code>CacheMonitor</code>对该事件进行后置操作，用于统计信息。</p>
<p><code>computeIfAbsentImpl</code>方法实现了<code>Cache</code>接口的核心方法，从缓存实例中根据缓存key获取缓存value，逻辑如下：</p>
<ol>
<li>获取cache的targetCache，因为我们通过<code>@CreateCache</code>注解创建的缓存实例将生成<code>LazyInitCache</code>对象，需要调用其getTargetCache方法才会完成缓存实例的初始化</li>
<li>loader函数是对加载原有方法的封装，这里再进行一层封装，封装成<code>ProxyLoader</code>类型，目的是在加载原有方法后将发送<code>CacheLoadEvent</code>事件</li>
<li>从缓存实例中获取对应的缓存value，如果缓存实例对象是<code>RefreshCache</code>类型（在<code>com.alicp.jetcache.anno.support.CacheContext.buildCache</code>方法中会将cache包装成<code>CacheHandlerRefreshCache</code>），则调用<code>RefreshCache.addOrUpdateRefreshTask</code>方法，判断是否应该为它添加一个定时的刷新任务</li>
<li>如果缓存未命中，则执行loader函数，如果开启了保护模式，则调用自定义的synchronizedLoad方法，大致逻辑：根据缓存key从自己的loaderMap（线程安全）遍历中尝试获取（不存在则创建）<code>LoaderLock</code>加载锁，获取到这把加载锁才可以执行loader函数，如果已被其他线程占有则进行等待（没有设置超时时间则一直等待），通过<code>CountDownLatch</code>计数器实现</li>
</ol>
<h4><span id="abstractembeddedcache本地缓存">AbstractEmbeddedCache本地缓存</span></h4><p><code>com.alicp.jetcache.embedded.AbstractEmbeddedCache</code>抽象类继承AbstractCache抽象类，定义了本地缓存的存放缓存数据的对象为<code>com.alicp.jetcache.embedded.InnerMap</code>接口和一个初始化该接口的createAreaCache抽象方法，基于InnerMap接口实现以<code>DO_</code>开头的方法，完成缓存实例各种操作的具体实现，主要代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractEmbeddedCache&lt;K, V&gt; extends AbstractCache&lt;K, V&gt; &#123;</span><br><span class="line">    protected EmbeddedCacheConfig&lt;K, V&gt; config;</span><br><span class="line">    /**</span><br><span class="line">     * 本地缓存的 Map</span><br><span class="line">     */</span><br><span class="line">    protected InnerMap innerMap;</span><br><span class="line"></span><br><span class="line">    protected abstract InnerMap createAreaCache();</span><br><span class="line"></span><br><span class="line">    public AbstractEmbeddedCache(EmbeddedCacheConfig&lt;K, V&gt; config) &#123;</span><br><span class="line">        this.config = config;</span><br><span class="line">        innerMap = createAreaCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public CacheConfig&lt;K, V&gt; config() &#123;</span><br><span class="line">        return config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object buildKey(K key) &#123;</span><br><span class="line">        Object newKey = key;</span><br><span class="line">        Function&lt;K, Object&gt; keyConvertor = config.getKeyConvertor();</span><br><span class="line">        if (keyConvertor != null) &#123;</span><br><span class="line">            newKey = keyConvertor.apply(key);</span><br><span class="line">        &#125;</span><br><span class="line">        return newKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheGetResult&lt;V&gt; do_GET(K key) &#123;</span><br><span class="line">        Object newKey = buildKey(key);</span><br><span class="line">        CacheValueHolder&lt;V&gt; holder = (CacheValueHolder&lt;V&gt;) innerMap.getValue(newKey);</span><br><span class="line">        return parseHolderResult(holder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected CacheGetResult&lt;V&gt; parseHolderResult(CacheValueHolder&lt;V&gt; holder) &#123;</span><br><span class="line">        long now = System.currentTimeMillis();</span><br><span class="line">        if (holder == null) &#123;</span><br><span class="line">            return CacheGetResult.NOT_EXISTS_WITHOUT_MSG;</span><br><span class="line">        &#125; else if (now &gt;= holder.getExpireTime()) &#123;</span><br><span class="line">            return CacheGetResult.EXPIRED_WITHOUT_MSG;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            synchronized (holder) &#123;</span><br><span class="line">                long accessTime = holder.getAccessTime();</span><br><span class="line">                if (config.isExpireAfterAccess()) &#123;</span><br><span class="line">                    long expireAfterAccess = config.getExpireAfterAccessInMillis();</span><br><span class="line">                    if (now &gt;= accessTime + expireAfterAccess) &#123;</span><br><span class="line">                        return CacheGetResult.EXPIRED_WITHOUT_MSG;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 设置该缓存数据的最后一次访问时间</span><br><span class="line">                holder.setAccessTime(now);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return new CacheGetResult(CacheResultCode.SUCCESS, null, holder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected MultiGetResult&lt;K, V&gt; do_GET_ALL(Set&lt;? extends K&gt; keys) &#123;</span><br><span class="line">        ArrayList&lt;K&gt; keyList = new ArrayList&lt;K&gt;(keys.size());</span><br><span class="line">        ArrayList&lt;Object&gt; newKeyList = new ArrayList&lt;Object&gt;(keys.size());</span><br><span class="line">        keys.stream().forEach((k) -&gt; &#123;</span><br><span class="line">            Object newKey = buildKey(k);</span><br><span class="line">            keyList.add(k);</span><br><span class="line">            newKeyList.add(newKey);</span><br><span class="line">        &#125;);</span><br><span class="line">        Map&lt;Object, CacheValueHolder&lt;V&gt;&gt; innerResultMap = innerMap.getAllValues(newKeyList);</span><br><span class="line">        Map&lt;K, CacheGetResult&lt;V&gt;&gt; resultMap = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; keyList.size(); i++) &#123;</span><br><span class="line">            K key = keyList.get(i);</span><br><span class="line">            Object newKey = newKeyList.get(i);</span><br><span class="line">            CacheValueHolder&lt;V&gt; holder = innerResultMap.get(newKey);</span><br><span class="line">            resultMap.put(key, parseHolderResult(holder));</span><br><span class="line">        &#125;</span><br><span class="line">        MultiGetResult&lt;K, V&gt; result = new MultiGetResult&lt;&gt;(CacheResultCode.SUCCESS, null, resultMap);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheResult do_PUT(K key, V value, long expireAfterWrite, TimeUnit timeUnit) &#123;</span><br><span class="line">        CacheValueHolder&lt;V&gt; cacheObject = new CacheValueHolder(value ,timeUnit.toMillis(expireAfterWrite));</span><br><span class="line">        innerMap.putValue(buildKey(key), cacheObject);</span><br><span class="line">        return CacheResult.SUCCESS_WITHOUT_MSG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheResult do_PUT_ALL(Map&lt;? extends K, ? extends V&gt; map, long expireAfterWrite, TimeUnit timeUnit) &#123;</span><br><span class="line">        HashMap newKeyMap = new HashMap();</span><br><span class="line">        for (Map.Entry&lt;? extends K, ? extends V&gt; en : map.entrySet()) &#123;</span><br><span class="line">            CacheValueHolder&lt;V&gt; cacheObject = new CacheValueHolder(en.getValue(), timeUnit.toMillis(expireAfterWrite));</span><br><span class="line">            newKeyMap.put(buildKey(en.getKey()), cacheObject);</span><br><span class="line">        &#125;</span><br><span class="line">        innerMap.putAllValues(newKeyMap);</span><br><span class="line"></span><br><span class="line">        final HashMap resultMap = new HashMap();</span><br><span class="line">        map.keySet().forEach((k) -&gt; resultMap.put(k, CacheResultCode.SUCCESS));</span><br><span class="line">        return CacheResult.SUCCESS_WITHOUT_MSG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheResult do_REMOVE(K key) &#123;</span><br><span class="line">        innerMap.removeValue(buildKey(key));</span><br><span class="line">        return CacheResult.SUCCESS_WITHOUT_MSG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheResult do_REMOVE_ALL(Set&lt;? extends K&gt; keys) &#123;</span><br><span class="line">        Set newKeys = keys.stream().map((key) -&gt; buildKey(key)).collect(Collectors.toSet());</span><br><span class="line">        innerMap.removeAllValues(newKeys);</span><br><span class="line"></span><br><span class="line">        final HashMap resultMap = new HashMap();</span><br><span class="line">        keys.forEach((k) -&gt; resultMap.put(k, CacheResultCode.SUCCESS));</span><br><span class="line">        return CacheResult.SUCCESS_WITHOUT_MSG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheResult do_PUT_IF_ABSENT(K key, V value, long expireAfterWrite, TimeUnit timeUnit) &#123;</span><br><span class="line">        CacheValueHolder&lt;V&gt; cacheObject = new CacheValueHolder(value, timeUnit.toMillis(expireAfterWrite));</span><br><span class="line">        if (innerMap.putIfAbsentValue(buildKey(key), cacheObject)) &#123;</span><br><span class="line">            return CacheResult.SUCCESS_WITHOUT_MSG;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return CacheResult.EXISTS_WITHOUT_MSG;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>com.alicp.jetcache.embedded.AbstractEmbeddedCache</code>抽象类实现了操作本地缓存的相关方法</p>
<ol>
<li>定义了缓存实例对象本地缓存的配置信息<code>EmbeddedCacheConfig</code>对象</li>
<li>定义了缓存实例对象本地缓存基于内存操作缓存数据的<code>InnerMap</code>对象，它的初始化过程交由不同的内存缓存实例（LinkedHashMapCache和CaffeineCache）</li>
</ol>
<h5><span id="linkedhashmapcache">LinkedHashMapCache</span></h5><p><code>com.alicp.jetcache.embedded.LinkedHashMapCache</code>基于LinkedHashMap完成缓存实例对象本地缓存基于内存操作缓存数据的<code>InnerMap</code>对象的初始化工作，主要代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashMapCache&lt;K, V&gt; extends AbstractEmbeddedCache&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(LinkedHashMapCache.class);</span><br><span class="line"></span><br><span class="line">    public LinkedHashMapCache(EmbeddedCacheConfig&lt;K, V&gt; config) &#123;</span><br><span class="line">        super(config);</span><br><span class="line">        // 将缓存实例添加至 Cleaner</span><br><span class="line">        addToCleaner();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void addToCleaner() &#123;</span><br><span class="line">        Cleaner.add(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected InnerMap createAreaCache() &#123;</span><br><span class="line">        return new LRUMap(config.getLimit(), this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void cleanExpiredEntry() &#123;</span><br><span class="line">        ((LRUMap) innerMap).cleanExpiredEntry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于本地缓存类型为 linkedhashmap 缓存实例存储缓存数据</span><br><span class="line">     */</span><br><span class="line">    final class LRUMap extends LinkedHashMap implements InnerMap &#123;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 允许的最大缓存数量</span><br><span class="line">         */</span><br><span class="line">        private final int max;</span><br><span class="line">        /**</span><br><span class="line">         * 缓存实例锁</span><br><span class="line">         */</span><br><span class="line">        private Object lock;</span><br><span class="line"></span><br><span class="line">        public LRUMap(int max, Object lock) &#123;</span><br><span class="line">            super((int) (max * 1.4f), 0.75f, true);</span><br><span class="line">            this.max = max;</span><br><span class="line">            this.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 当元素大于最大值时移除最老的元素</span><br><span class="line">         *</span><br><span class="line">         * @param eldest 最老的元素</span><br><span class="line">         * @return 是否删除</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean removeEldestEntry(Map.Entry eldest) &#123;</span><br><span class="line">            return size() &gt; max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 清理过期的元素</span><br><span class="line">         */</span><br><span class="line">        void cleanExpiredEntry() &#123;</span><br><span class="line">            synchronized (lock) &#123; // 占有当前缓存实例这把锁</span><br><span class="line">                for (Iterator it = entrySet().iterator(); it.hasNext();) &#123;</span><br><span class="line">                    Map.Entry en = (Map.Entry) it.next();</span><br><span class="line">                    Object value = en.getValue();</span><br><span class="line">                    if (value != null &amp;&amp; value instanceof CacheValueHolder) &#123;</span><br><span class="line">                        CacheValueHolder h = (CacheValueHolder) value;</span><br><span class="line">                        /*</span><br><span class="line">                         * 缓存的数据已经失效了则删除</span><br><span class="line">                         * 为什么不对 expireAfterAccess 进行判断，取最小值，疑问？？？？</span><br><span class="line">                         */</span><br><span class="line">                        if (System.currentTimeMillis() &gt;= h.getExpireTime()) &#123;</span><br><span class="line">                            it.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // assert false</span><br><span class="line">                        if (value == null) &#123;</span><br><span class="line">                            logger.error(&quot;key &quot; + en.getKey() + &quot; is null&quot;);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            logger.error(&quot;value of key &quot; + en.getKey() + &quot; is not a CacheValueHolder. type=&quot; + value.getClass());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object getValue(Object key) &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                return get(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Map getAllValues(Collection keys) &#123;</span><br><span class="line">            Map values = new HashMap();</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                for (Object key : keys) &#123;</span><br><span class="line">                    Object v = get(key);</span><br><span class="line">                    if (v != null) &#123;</span><br><span class="line">                        values.put(key, v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return values;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void putValue(Object key, Object value) &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                put(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void putAllValues(Map map) &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                Set&lt;Map.Entry&gt; set = map.entrySet();</span><br><span class="line">                for (Map.Entry en : set) &#123;</span><br><span class="line">                    put(en.getKey(), en.getValue());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean removeValue(Object key) &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                return remove(key) != null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void removeAllValues(Collection keys) &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                for (Object k : keys) &#123;</span><br><span class="line">                    remove(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        public boolean putIfAbsentValue(Object key, Object value) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 如果缓存 key 不存在，或者对应的 value 已经失效则放入，否则返回 false</span><br><span class="line">             */</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                CacheValueHolder h = (CacheValueHolder) get(key);</span><br><span class="line">                if (h == null || parseHolderResult(h).getResultCode() == CacheResultCode.EXPIRED) &#123;</span><br><span class="line">                    put(key, value);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>com.alicp.jetcache.embedded.LinkedHashMapCache</code>自定义<code>LRUMap</code>继承LinkedHashMap并实现InnerMap接口</p>
<ol>
<li>自定义<code>max</code>字段，存储元素个数的最大值，并设置初始容量为(max * 1.4f)</li>
<li>自定义<code>lock</code>字段，每个缓存实例的锁，通过synchronized关键词保证线程安全，所以性能相对来说不好</li>
<li>覆盖LinkedHashMap的<code>removeEldestEntry</code>方法，当元素大于最大值时移除最老的元素</li>
<li>自定义<code>cleanExpiredEntry</code>方法，遍历Map，根据缓存value（被封装成的<code>com.alicp.jetcache.CacheValueHolder</code>对象，包含缓存数据、失效时间戳和第一次访问的时间），清理过期的元素</li>
<li>该对象初始化时会被添加至<code>com.alicp.jetcache.embedded.Cleaner</code>清理器中，Cleaner会周期性（每隔60秒）遍历LinkedHashMapCache缓存实例，调用其cleanExpiredEntry方法</li>
</ol>
<h5><span id="cleaner清理器">Cleaner清理器</span></h5><p><code>com.alicp.jetcache.embedded.Cleaner</code>用于清理缓存类型为LinkedHashMapCache的缓存数据，请查看相应注释，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 执行任务：定时清理（每分钟） LinkedHashMapCache 缓存实例中过期的缓存数据</span><br><span class="line"> */</span><br><span class="line">class Cleaner &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 存放弱引用对象，以防内存溢出</span><br><span class="line">     * 如果被弱引用的对象只被当前弱引用对象关联时，gc 时被弱引用的对象则会被回收（取决于被弱引用的对象是否还与其他强引用对象关联）</span><br><span class="line">     *</span><br><span class="line">     * 个人理解：当某个 LinkedHashMapCache 强引用对象没有被其他对象（除了这里）引用时，我们应该让这个对象被回收，</span><br><span class="line">     * 但是由于这里使用的也是强引用，这个对象被其他强引用对象关联了，不可能被回收，存在内存溢出的危险，</span><br><span class="line">     * 所以这里使用了弱引用对象，如果被弱引用的对象没有被其他对象（除了这里）引用时，这个对象会被回收</span><br><span class="line">     *</span><br><span class="line">     * 举个例子：如果我们往一个 Map&lt;Object, Object&gt; 中存放一个key-value键值对</span><br><span class="line">     * 假设对应的键已经不再使用被回收了，那我们无法再获取到对应的值，也无法被回收，占有一定的内存，存在风险</span><br><span class="line">     */</span><br><span class="line">    static LinkedList&lt;WeakReference&lt;LinkedHashMapCache&gt;&gt; linkedHashMapCaches = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        // 创建一个线程池，1个核心线程</span><br><span class="line">        ScheduledExecutorService executorService = JetCacheExecutor.defaultExecutor();</span><br><span class="line">        // 起一个循环任务一直清理 linkedHashMapCaches 过期的数据（每隔60秒）</span><br><span class="line">        executorService.scheduleWithFixedDelay(() -&gt; run(), 60, 60, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void add(LinkedHashMapCache cache) &#123;</span><br><span class="line">        synchronized (linkedHashMapCaches) &#123;</span><br><span class="line">            // 创建一个弱引用对象，并添加到清理对象中</span><br><span class="line">            linkedHashMapCaches.add(new WeakReference&lt;&gt;(cache));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void run() &#123;</span><br><span class="line">        synchronized (linkedHashMapCaches) &#123;</span><br><span class="line">            Iterator&lt;WeakReference&lt;LinkedHashMapCache&gt;&gt; it = linkedHashMapCaches.iterator();</span><br><span class="line">            while (it.hasNext()) &#123;</span><br><span class="line">                WeakReference&lt;LinkedHashMapCache&gt; ref = it.next();</span><br><span class="line">                // 获取被弱引用的对象（强引用）</span><br><span class="line">                LinkedHashMapCache c = ref.get();</span><br><span class="line">                if (c == null) &#123; // 表示被弱引用的对象被标记成了垃圾，则移除</span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    c.cleanExpiredEntry();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="caffeinecache">CaffeineCache</span></h5><p><code>com.alicp.jetcache.embedded.CaffeineCache</code>基于<a href="https://github.com/ben-manes/caffeine">Caffeine</a>完成缓存实例对象本地缓存基于内存操作缓存数据的<code>InnerMap</code>对象的初始化工作，主要代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">public class CaffeineCache&lt;K, V&gt; extends AbstractEmbeddedCache&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 缓存实例对象</span><br><span class="line">     */</span><br><span class="line">    private com.github.benmanes.caffeine.cache.Cache cache;</span><br><span class="line"></span><br><span class="line">    public CaffeineCache(EmbeddedCacheConfig&lt;K, V&gt; config) &#123;</span><br><span class="line">        super(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 初始化本地缓存的容器</span><br><span class="line">     *</span><br><span class="line">     * @return Map对象</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    protected InnerMap createAreaCache() &#123;</span><br><span class="line">        Caffeine&lt;Object, Object&gt; builder = Caffeine.newBuilder();</span><br><span class="line">        // 设置缓存实例的最大缓存数量</span><br><span class="line">        builder.maximumSize(config.getLimit());</span><br><span class="line">        final boolean isExpireAfterAccess = config.isExpireAfterAccess();</span><br><span class="line">        final long expireAfterAccess = config.getExpireAfterAccessInMillis();</span><br><span class="line">        // 设置缓存实例的缓存数据的失效策略</span><br><span class="line">        builder.expireAfter(new Expiry&lt;Object, CacheValueHolder&gt;() &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 获取缓存的有效时间</span><br><span class="line">             *</span><br><span class="line">             * @param value 缓存数据</span><br><span class="line">             * @return 有效时间</span><br><span class="line">             */</span><br><span class="line">            private long getRestTimeInNanos(CacheValueHolder value) &#123;</span><br><span class="line">                long now = System.currentTimeMillis();</span><br><span class="line">                long ttl = value.getExpireTime() - now;</span><br><span class="line">                /*</span><br><span class="line">                 * 如果本地缓存设置了多长时间没访问缓存则失效</span><br><span class="line">                 */</span><br><span class="line">                if(isExpireAfterAccess)&#123;</span><br><span class="line">                    // 设置缓存的失效时间</span><br><span class="line">                    // 多长时间没访问缓存则失效 and 缓存的有效时长取 min</span><br><span class="line">                    ttl = Math.min(ttl, expireAfterAccess);</span><br><span class="line">                &#125;</span><br><span class="line">                return TimeUnit.MILLISECONDS.toNanos(ttl);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public long expireAfterCreate(Object key, CacheValueHolder value, long currentTime) &#123;</span><br><span class="line">                return getRestTimeInNanos(value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public long expireAfterUpdate(Object key, CacheValueHolder value,</span><br><span class="line">                                          long currentTime, long currentDuration) &#123;</span><br><span class="line">                return currentDuration;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public long expireAfterRead(Object key, CacheValueHolder value,</span><br><span class="line">                                        long currentTime, long currentDuration) &#123;</span><br><span class="line">                return getRestTimeInNanos(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        // 构建 Cache 缓存实例</span><br><span class="line">        cache = builder.build();</span><br><span class="line">        return new InnerMap() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object getValue(Object key) &#123;</span><br><span class="line">                return cache.getIfPresent(key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Map getAllValues(Collection keys) &#123;</span><br><span class="line">                return cache.getAllPresent(keys);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void putValue(Object key, Object value) &#123;</span><br><span class="line">                cache.put(key, value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void putAllValues(Map map) &#123;</span><br><span class="line">                cache.putAll(map);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean removeValue(Object key) &#123;</span><br><span class="line">                return cache.asMap().remove(key) != null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void removeAllValues(Collection keys) &#123;</span><br><span class="line">                cache.invalidateAll(keys);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean putIfAbsentValue(Object key, Object value) &#123;</span><br><span class="line">                return cache.asMap().putIfAbsent(key, value) == null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>com.alicp.jetcache.embedded.CaffeineCache</code>通过<a href="https://github.com/ben-manes/caffeine">Caffeine</a>构建一个<code>com.github.benmanes.caffeine.cache.Cache</code>缓存对象，然后实现InnerMap接口，调用这个缓存对象的相关方法</p>
<ol>
<li>构建时设置每个元素的过期时间，也就是根据每个元素（<code>com.alicp.jetcache.CacheValueHolder</code>）的失效时间戳来设置，底层如何实现的可以参考<a href="https://github.com/ben-manes/caffeine">Caffeine</a>官方地址</li>
<li>调用<code>com.github.benmanes.caffeine.cache.Cache</code>的put方法我有遇到过’unable to create native thread’内存溢出的问题，所以请结合实际业务场景合理的设置缓存相关配置</li>
</ol>
<h4><span id="abstractexternalcache远程缓存">AbstractExternalCache远程缓存</span></h4><p><code>com.alicp.jetcache.embedded.AbstractExternalCache</code>抽象类继承AbstractCache抽象类，定义了缓存实例对象远程缓存的配置信息<code>ExternalCacheConfig</code>对象，提供了将缓存key转换成字节数组的方法，代码比较简单。</p>
<h5><span id="rediscache">RedisCache</span></h5><p><code>com.alicp.jetcache.redis.RedisCache</code>使用Jedis连接Redis，对远程的缓存数据进行操作，代码没有很复杂，可查看我的注释</p>
<ol>
<li>定义了<code>com.alicp.jetcache.redis.RedisCacheConfig</code>配置对象，包含Redis连接池的相关信息</li>
<li>实现了以<code>DO_</code>开头的方法，也就是通过Jedis操作缓存数据</li>
</ol>
<h5><span id="redislettucecache">RedisLettuceCache</span></h5><p><code>com.alicp.jetcache.redis.lettuce.RedisLettuceCache</code>使用<a href="https://github.com/lettuce-io/lettuce-core">Lettuce</a>连接Redis，对远程的缓存数据进行操作，代码没有很复杂，可查看我的注释</p>
<ol>
<li>定义了<code>com.alicp.jetcache.redis.lettuce.RedisLettuceCacheConfig</code>配置对象，包含Redis客户端、与Redis建立的安全连接等信息，因为底层是基于<a href="https://github.com/netty/netty">Netty</a>实现的，所以无需配置线程池</li>
<li>使用<code>com.alicp.jetcache.redis.lettuce.LettuceConnectionManager</code>自定义管理器将与Redis连接的相关信息封装成<code>LettuceObjects</code>对象，并管理RedisClient与LettuceObjects对应关系</li>
<li>相比Jedis更加安全高效</li>
<li>对<a href="https://github.com/lettuce-io/lettuce-core">Lettuce</a>不了解的可以参考我写的测试类<code>com.alicp.jetcache.test.external.LettuceTest</code></li>
</ol>
<h4><span id="multilevelcache两级缓存">MultiLevelCache两级缓存</span></h4><p>当你设置了缓存类型为BOTH两级缓存，那么创建的实例对象会被封装成<code>com.alicp.jetcache.MultiLevelCache</code>对象</p>
<ol>
<li>定义了<code>caches</code>字段类型为Cache[]，用于保存AbstractEmbeddedCache本地缓存实例和AbstractExternalCache远程缓存实例，本地缓存存放于远程缓存前面</li>
<li>实现了<code>do_GET</code>方法，遍历caches数组，也就是先从本地缓存获取，如果获取缓存不成功则从远程缓存获取，成功获取到缓存后会调用checkResultAndFillUpperCache方法</li>
<li>从<code>checkResultAndFillUpperCache</code>方法的逻辑可以看到，将获取到的缓存数据更新至更底层的缓存中，也就是说如果缓存数据是从远程获取到的，那么进入这个方法后会将获取到的缓存数据更新到本地缓存中去，这样下次请求可以直接从本地缓存获取，避免与Redis之间的网络消耗</li>
<li>实现了<code>do_PUT</code>方法，遍历caches数组，通过<code>CompletableFuture</code>进行异步编程，将所有的操作绑定在一条链上执行。</li>
<li>实现的了<code>PUT(K key, V value)</code>方法，会先判断是否单独配置了本地缓存时间localExipre，配置了则单独为本地缓存设置过期时间，没有配置则到期时间和远程缓存的一样</li>
<li>覆盖<code>tryLock</code>方法，调用caches[caches.length-1].tryLock方法，也就是只会调用最顶层远程缓存的这个方法</li>
</ol>
<p>主要代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line">public class MultiLevelCache&lt;K, V&gt; extends AbstractCache&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Cache[] caches;</span><br><span class="line"></span><br><span class="line">    private MultiLevelCacheConfig&lt;K, V&gt; config;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    @Deprecated</span><br><span class="line">    public MultiLevelCache(Cache... caches) throws CacheConfigException &#123;</span><br><span class="line">        this.caches = caches;</span><br><span class="line">        checkCaches();</span><br><span class="line">        CacheConfig lastConfig = caches[caches.length - 1].config();</span><br><span class="line">        config = new MultiLevelCacheConfig&lt;&gt;();</span><br><span class="line">        config.setCaches(Arrays.asList(caches));</span><br><span class="line">        config.setExpireAfterWriteInMillis(lastConfig.getExpireAfterWriteInMillis());</span><br><span class="line">        config.setCacheNullValue(lastConfig.isCacheNullValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public MultiLevelCache(MultiLevelCacheConfig&lt;K, V&gt; cacheConfig) throws CacheConfigException &#123;</span><br><span class="line">        this.config = cacheConfig;</span><br><span class="line">        this.caches = cacheConfig.getCaches().toArray(new Cache[]&#123;&#125;);</span><br><span class="line">        checkCaches();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void checkCaches() &#123;</span><br><span class="line">        if (caches == null || caches.length == 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        for (Cache c : caches) &#123;</span><br><span class="line">            if (c.config().getLoader() != null) &#123;</span><br><span class="line">                throw new CacheConfigException(&quot;Loader on sub cache is not allowed, set the loader into MultiLevelCache.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Cache[] caches() &#123;</span><br><span class="line">        return caches;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MultiLevelCacheConfig&lt;K, V&gt; config() &#123;</span><br><span class="line">        return config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public CacheResult PUT(K key, V value) &#123;</span><br><span class="line">        if (config.isUseExpireOfSubCache()) &#123; // 本地缓存使用自己的失效时间</span><br><span class="line">            // 设置了TimeUnit为null，本地缓存则使用自己的到期时间</span><br><span class="line">            return PUT(key, value, 0, null);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return PUT(key, value, config().getExpireAfterWriteInMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public CacheResult PUT_ALL(Map&lt;? extends K, ? extends V&gt; map) &#123;</span><br><span class="line">        if (config.isUseExpireOfSubCache()) &#123;</span><br><span class="line">            return PUT_ALL(map, 0, null);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return PUT_ALL(map, config().getExpireAfterWriteInMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheGetResult&lt;V&gt; do_GET(K key) &#123;</span><br><span class="line">    	// 遍历多级缓存（远程缓存排在后面）</span><br><span class="line">        for (int i = 0; i &lt; caches.length; i++) &#123;</span><br><span class="line">            Cache cache = caches[i];</span><br><span class="line">            CacheGetResult result = cache.GET(key);</span><br><span class="line">            if (result.isSuccess()) &#123;</span><br><span class="line">                CacheValueHolder&lt;V&gt; holder = unwrapHolder(result.getHolder());</span><br><span class="line">                /*</span><br><span class="line">                 * 这个遍历是从低层的缓存开始获取，获取成功则将该值设置到更低层的缓存中</span><br><span class="line">                 * 情景：</span><br><span class="line">                 * 本地没有获取到缓存，远程获取到了缓存，这里会将远程的缓存数据设置到本地中，</span><br><span class="line">                 * 这样下次请求则直接从本次获取，减少了远程获取的时间</span><br><span class="line">                 */</span><br><span class="line">                checkResultAndFillUpperCache(key, i, holder);</span><br><span class="line">                return new CacheGetResult(CacheResultCode.SUCCESS, null, holder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return CacheGetResult.NOT_EXISTS_WITHOUT_MSG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private CacheValueHolder&lt;V&gt; unwrapHolder(CacheValueHolder&lt;V&gt; h) &#123;</span><br><span class="line">        // if @Cached or @CacheCache change type from REMOTE to BOTH (or from BOTH to REMOTE),</span><br><span class="line">        // during the dev/publish process, the value type which different application server put into cache server will be different</span><br><span class="line">        // (CacheValueHolder&lt;V&gt; and CacheValueHolder&lt;CacheValueHolder&lt;V&gt;&gt;, respectively).</span><br><span class="line">        // So we need correct the problem at here and in CacheGetResult.</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line">        if (h.getValue() instanceof CacheValueHolder) &#123;</span><br><span class="line">            return (CacheValueHolder&lt;V&gt;) h.getValue();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void checkResultAndFillUpperCache(K key, int i, CacheValueHolder&lt;V&gt; h) &#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line">        long currentExpire = h.getExpireTime();</span><br><span class="line">        long now = System.currentTimeMillis();</span><br><span class="line">        if (now &lt;= currentExpire) &#123;</span><br><span class="line">            if(config.isUseExpireOfSubCache())&#123; // 如果使用本地自己的缓存过期时间</span><br><span class="line">                // 使用本地缓存自己的过期时间</span><br><span class="line">                PUT_caches(i, key, h.getValue(), 0, null);</span><br><span class="line">            &#125; else &#123; // 使用远程缓存的过期时间</span><br><span class="line">                long restTtl = currentExpire - now;</span><br><span class="line">                if (restTtl &gt; 0) &#123; // 远程缓存数据还未失效，则重新设置本地的缓存</span><br><span class="line">                    PUT_caches(i, key, h.getValue(), restTtl, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected MultiGetResult&lt;K, V&gt; do_GET_ALL(Set&lt;? extends K&gt; keys) &#123;</span><br><span class="line">        HashMap&lt;K, CacheGetResult&lt;V&gt;&gt; resultMap = new HashMap&lt;&gt;();</span><br><span class="line">        Set&lt;K&gt; restKeys = new HashSet&lt;&gt;(keys);</span><br><span class="line">        for (int i = 0; i &lt; caches.length; i++) &#123;</span><br><span class="line">            if (restKeys.size() == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            Cache&lt;K, CacheValueHolder&lt;V&gt;&gt; c = caches[i];</span><br><span class="line">            MultiGetResult&lt;K, CacheValueHolder&lt;V&gt;&gt; allResult = c.GET_ALL(restKeys);</span><br><span class="line">            if (allResult.isSuccess() &amp;&amp; allResult.getValues() != null) &#123;</span><br><span class="line">                for (Map.Entry&lt;K, CacheGetResult&lt;CacheValueHolder&lt;V&gt;&gt;&gt; en : allResult.getValues().entrySet()) &#123;</span><br><span class="line">                    K key = en.getKey();</span><br><span class="line">                    CacheGetResult result = en.getValue();</span><br><span class="line">                    if (result.isSuccess()) &#123;</span><br><span class="line">                        CacheValueHolder&lt;V&gt; holder = unwrapHolder(result.getHolder());</span><br><span class="line">                        checkResultAndFillUpperCache(key, i, holder);</span><br><span class="line">                        resultMap.put(key, new CacheGetResult(CacheResultCode.SUCCESS, null, holder));</span><br><span class="line">                        restKeys.remove(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (K k : restKeys) &#123;</span><br><span class="line">            resultMap.put(k, CacheGetResult.NOT_EXISTS_WITHOUT_MSG);</span><br><span class="line">        &#125;</span><br><span class="line">        return new MultiGetResult&lt;&gt;(CacheResultCode.SUCCESS, null, resultMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheResult do_PUT(K key, V value, long expireAfterWrite, TimeUnit timeUnit) &#123;</span><br><span class="line">        return PUT_caches(caches.length, key, value, expireAfterWrite, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheResult do_PUT_ALL(Map&lt;? extends K, ? extends V&gt; map, long expireAfterWrite, TimeUnit timeUnit) &#123;</span><br><span class="line">        CompletableFuture&lt;ResultData&gt; future = CompletableFuture.completedFuture(null);</span><br><span class="line">        for (Cache c : caches) &#123;</span><br><span class="line">            CacheResult r;</span><br><span class="line">            if(timeUnit == null) &#123;</span><br><span class="line">                r = c.PUT_ALL(map);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                r = c.PUT_ALL(map, expireAfterWrite, timeUnit);</span><br><span class="line">            &#125;</span><br><span class="line">            future = combine(future, r);</span><br><span class="line">        &#125;</span><br><span class="line">        return new CacheResult(future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private CacheResult PUT_caches(int lastIndex, K key, V value, long expire, TimeUnit timeUnit) &#123;</span><br><span class="line">        CompletableFuture&lt;ResultData&gt; future = CompletableFuture.completedFuture(null);</span><br><span class="line">        for (int i = 0; i &lt; lastIndex; i++) &#123;</span><br><span class="line">            Cache cache = caches[i];</span><br><span class="line">            CacheResult r;</span><br><span class="line">            if (timeUnit == null) &#123; // 表示本地缓存使用自己过期时间</span><br><span class="line">                r = cache.PUT(key, value);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                r = cache.PUT(key, value, expire, timeUnit);</span><br><span class="line">            &#125;</span><br><span class="line">            // 将多个 PUT 操作放在一条链上</span><br><span class="line">            future = combine(future, r);</span><br><span class="line">        &#125;</span><br><span class="line">        return new CacheResult(future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private CompletableFuture&lt;ResultData&gt; combine(CompletableFuture&lt;ResultData&gt; future, CacheResult result) &#123;</span><br><span class="line">        return future.thenCombine(result.future(), (d1, d2) -&gt; &#123;</span><br><span class="line">            if (d1 == null) &#123;</span><br><span class="line">                return d2;</span><br><span class="line">            &#125;</span><br><span class="line">            if (d1.getResultCode() != d2.getResultCode()) &#123;</span><br><span class="line">                return new ResultData(CacheResultCode.PART_SUCCESS, null, null);</span><br><span class="line">            &#125;</span><br><span class="line">            return d1;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheResult do_REMOVE(K key) &#123;</span><br><span class="line">        CompletableFuture&lt;ResultData&gt; future = CompletableFuture.completedFuture(null);</span><br><span class="line">        for (Cache cache : caches) &#123;</span><br><span class="line">            CacheResult r = cache.REMOVE(key);</span><br><span class="line">            future = combine(future, r);</span><br><span class="line">        &#125;</span><br><span class="line">        return new CacheResult(future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheResult do_REMOVE_ALL(Set&lt;? extends K&gt; keys) &#123;</span><br><span class="line">        CompletableFuture&lt;ResultData&gt; future = CompletableFuture.completedFuture(null);</span><br><span class="line">        for (Cache cache : caches) &#123;</span><br><span class="line">            CacheResult r = cache.REMOVE_ALL(keys);</span><br><span class="line">            future = combine(future, r);</span><br><span class="line">        &#125;</span><br><span class="line">        return new CacheResult(future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; T unwrap(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        Objects.requireNonNull(clazz);</span><br><span class="line">        for (Cache cache : caches) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                T obj = (T) cache.unwrap(clazz);</span><br><span class="line">                if (obj != null) &#123;</span><br><span class="line">                    return obj;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">                // ignore</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalArgumentException(clazz.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public AutoReleaseLock tryLock(K key, long expire, TimeUnit timeUnit) &#123;</span><br><span class="line">        if (key == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return caches[caches.length - 1].tryLock(key, expire, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean putIfAbsent(K key, V value) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;putIfAbsent is not supported by MultiLevelCache&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheResult do_PUT_IF_ABSENT(K key, V value, long expireAfterWrite, TimeUnit timeUnit) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;PUT_IF_ABSENT is not supported by MultiLevelCache&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        for (Cache c : caches) &#123;</span><br><span class="line">            c.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="refreshcache">RefreshCache</span></h4><p><code>com.alicp.jetcache.RefreshCache</code>为缓存实例添加刷新任务，前面在AbstractCache抽象类中讲到了，在<code>com.alicp.jetcache.anno.support.CacheContext.buildCache</code>方法中会将cache包装成<code>CacheHandlerRefreshCache</code>，所以说每个缓存实例都会调用一下<code>addOrUpdateRefreshTask</code>方法，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class RefreshCache&lt;K, V&gt; extends LoadingCache&lt;K, V&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    protected CacheConfig&lt;K, V&gt; config;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">	 * 用于保存刷新任务</span><br><span class="line">	 */</span><br><span class="line">	private ConcurrentHashMap&lt;Object, RefreshTask&gt; taskMap = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    protected void addOrUpdateRefreshTask(K key, CacheLoader&lt;K, V&gt; loader) &#123;</span><br><span class="line">		// 获取缓存刷新策略</span><br><span class="line">		RefreshPolicy refreshPolicy = config.getRefreshPolicy();</span><br><span class="line">		if (refreshPolicy == null) &#123; // 没有则不进行刷新</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		// 获取刷新时间间隔</span><br><span class="line">		long refreshMillis = refreshPolicy.getRefreshMillis();</span><br><span class="line">		if (refreshMillis &gt; 0) &#123;</span><br><span class="line">			// 获取线程任务的ID</span><br><span class="line">			Object taskId = getTaskId(key);</span><br><span class="line">			// 获取对应的RefreshTask，不存在则创建一个</span><br><span class="line">			RefreshTask refreshTask = taskMap.computeIfAbsent(taskId, tid -&gt; &#123;</span><br><span class="line">				logger.debug(&quot;add refresh task. interval=&#123;&#125;,  key=&#123;&#125;&quot;, refreshMillis, key);</span><br><span class="line">				RefreshTask task = new RefreshTask(taskId, key, loader);</span><br><span class="line">				task.lastAccessTime = System.currentTimeMillis();</span><br><span class="line">				/*</span><br><span class="line">				 * 获取 ScheduledExecutorService 周期/延迟线程池，10个核心线程，创建的线程都是守护线程</span><br><span class="line">				 * scheduleWithFixedDelay(Runnable command, long initialDelay, long period, TimeUnit unit)</span><br><span class="line">				 * 运行的任务task、多久延迟后开始执行、后续执行的周期间隔多长，时间单位</span><br><span class="line">				 * 通过其创建一个循环任务，用于刷新缓存数据</span><br><span class="line">				 */</span><br><span class="line">				ScheduledFuture&lt;?&gt; future = JetCacheExecutor.heavyIOExecutor().scheduleWithFixedDelay(task,</span><br><span class="line">						refreshMillis, refreshMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">				task.future = future;</span><br><span class="line">				return task;</span><br><span class="line">			&#125;);</span><br><span class="line">			// 设置最后一次访问时间</span><br><span class="line">			refreshTask.lastAccessTime = System.currentTimeMillis();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果缓存实例配置了刷新策略并且刷新间隔大于0，则会从<code>taskMap</code>（线程安全）中尝试获取对应的刷新任务<code>RefreshTask</code>，如果不存在则创建一个任务放入线程池周期性的执行</p>
<p><code>com.alicp.jetcache.RefreshCache.RefreshTask</code>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">public class RefreshCache&lt;K, V&gt; extends LoadingCache&lt;K, V&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    protected Cache concreteCache() &#123;</span><br><span class="line">		Cache c = getTargetCache();</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			if (c instanceof ProxyCache) &#123;</span><br><span class="line">				c = ((ProxyCache) c).getTargetCache();</span><br><span class="line">			&#125; else if (c instanceof MultiLevelCache) &#123;</span><br><span class="line">				Cache[] caches = ((MultiLevelCache) c).caches();</span><br><span class="line">				// 如果是两级缓存则返回远程缓存</span><br><span class="line">				c = caches[caches.length - 1];</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return c;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    class RefreshTask implements Runnable &#123;</span><br><span class="line">		/**</span><br><span class="line">		 * 唯一标志符，也就是Key转换后的值</span><br><span class="line">		 */</span><br><span class="line">		private Object taskId;</span><br><span class="line">		/**</span><br><span class="line">		 * 缓存的Key</span><br><span class="line">		 */</span><br><span class="line">		private K key;</span><br><span class="line">		/**</span><br><span class="line">		 * 执行方法的CacheLoader对象</span><br><span class="line">		 */</span><br><span class="line">		private CacheLoader&lt;K, V&gt; loader;</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 最后一次访问时间</span><br><span class="line">		 */</span><br><span class="line">		private long lastAccessTime;</span><br><span class="line">		/**</span><br><span class="line">		 * 该 Task 的执行策略</span><br><span class="line">		 */</span><br><span class="line">		private ScheduledFuture future;</span><br><span class="line"></span><br><span class="line">		RefreshTask(Object taskId, K key, CacheLoader&lt;K, V&gt; loader) &#123;</span><br><span class="line">			this.taskId = taskId;</span><br><span class="line">			this.key = key;</span><br><span class="line">			this.loader = loader;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		private void cancel() &#123;</span><br><span class="line">			logger.debug(&quot;cancel refresh: &#123;&#125;&quot;, key);</span><br><span class="line">			// 尝试中断当前任务</span><br><span class="line">			future.cancel(false);</span><br><span class="line">			// 从任务列表中删除</span><br><span class="line">			taskMap.remove(taskId);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 重新加载数据</span><br><span class="line">		 *</span><br><span class="line">		 * @throws Throwable 异常</span><br><span class="line">		 */</span><br><span class="line">		private void load() throws Throwable &#123;</span><br><span class="line">			CacheLoader&lt;K, V&gt; l = loader == null ? config.getLoader() : loader;</span><br><span class="line">			if (l != null) &#123;</span><br><span class="line">				// 封装 CacheLoader 成 ProxyLoader，加载后会发起 Load 事件</span><br><span class="line">				l = CacheUtil.createProxyLoader(cache, l, eventConsumer);</span><br><span class="line">				// 加载</span><br><span class="line">				V v = l.load(key);</span><br><span class="line">				if (needUpdate(v, l)) &#123;</span><br><span class="line">					// 将重新加载的数据放入缓存</span><br><span class="line">					cache.PUT(key, v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 远程加载数据</span><br><span class="line">		 *</span><br><span class="line">		 * @param concreteCache 缓存对象</span><br><span class="line">		 * @param currentTime   当前时间</span><br><span class="line">		 * @throws Throwable 异常</span><br><span class="line">		 */</span><br><span class="line">		private void externalLoad(final Cache concreteCache, final long currentTime) throws Throwable &#123;</span><br><span class="line">			// 获取 Key 转换后的值</span><br><span class="line">			byte[] newKey = ((AbstractExternalCache) concreteCache).buildKey(key);</span><br><span class="line">			// 创建分布式锁对应的Key</span><br><span class="line">			byte[] lockKey = combine(newKey, &quot;_#RL#&quot;.getBytes());</span><br><span class="line">			// 分布式锁的存在时间</span><br><span class="line">			long loadTimeOut = RefreshCache.this.config.getRefreshPolicy().getRefreshLockTimeoutMillis();</span><br><span class="line">			// 刷新间隔</span><br><span class="line">			long refreshMillis = config.getRefreshPolicy().getRefreshMillis();</span><br><span class="line">			// Key对应的时间戳Key（用于存放上次刷新时间）</span><br><span class="line">			byte[] timestampKey = combine(newKey, &quot;_#TS#&quot;.getBytes());</span><br><span class="line"></span><br><span class="line">			// AbstractExternalCache buildKey method will not convert byte[]</span><br><span class="line">			// 获取Key上一次刷新时间</span><br><span class="line">			CacheGetResult refreshTimeResult = concreteCache.GET(timestampKey);</span><br><span class="line">			boolean shouldLoad = false; // 是否需要重新加载</span><br><span class="line">			if (refreshTimeResult.isSuccess()) &#123;</span><br><span class="line">				// 当前时间与上一次刷新的时间间隔是否大于或等于刷新间隔</span><br><span class="line">				shouldLoad = currentTime &gt;= Long.parseLong(refreshTimeResult.getValue().toString()) + refreshMillis;</span><br><span class="line">			&#125; else if (refreshTimeResult.getResultCode() == CacheResultCode.NOT_EXISTS) &#123; // 无缓存</span><br><span class="line">				shouldLoad = true;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (!shouldLoad) &#123;</span><br><span class="line">				if (multiLevelCache) &#123;</span><br><span class="line">					// 将顶层的缓存数据更新至低层的缓存中，例如将远程的缓存数据放入本地缓存</span><br><span class="line">					// 因为如果是多级缓存，创建刷新任务后，我们只需更新远程的缓存，然后从远程缓存获取缓存数据更新低层的缓存，保证缓存一致</span><br><span class="line">					refreshUpperCaches(key);</span><br><span class="line">				&#125;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// 重新加载</span><br><span class="line">			Runnable r = () -&gt; &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					load();</span><br><span class="line">					// AbstractExternalCache buildKey method will not convert byte[]</span><br><span class="line">					// 保存一个key-value至redis，其中的信息为该value的生成时间，刷新缓存</span><br><span class="line">					concreteCache.put(timestampKey, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">				&#125; catch (Throwable e) &#123;</span><br><span class="line">					throw new CacheException(&quot;refresh error&quot;, e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			// AbstractExternalCache buildKey method will not convert byte[]</span><br><span class="line">			// 分布式缓存没有一个全局分配的功能，这里尝试获取一把非严格的分布式锁，获取锁的超时时间默认60秒，也就是获取到这把锁最多可以拥有60秒</span><br><span class="line">			// 只有获取Key对应的这把分布式锁，才执行重新加载的操作</span><br><span class="line">			boolean lockSuccess = concreteCache.tryLockAndRun(lockKey, loadTimeOut, TimeUnit.MILLISECONDS, r);</span><br><span class="line">			if (!lockSuccess &amp;&amp; multiLevelCache) &#123; // 没有获取到锁并且是多级缓存</span><br><span class="line">				// 这个时候应该有其他实例在刷新缓存，所以这里设置过一会直接获取远程的缓存数据更新到本地</span><br><span class="line">				// 创建一个延迟任务（1/5刷新间隔后），将最顶层的缓存数据更新至每一层</span><br><span class="line">				JetCacheExecutor.heavyIOExecutor().schedule(() -&gt; refreshUpperCaches(key), (long) (0.2 * refreshMillis),</span><br><span class="line">						TimeUnit.MILLISECONDS);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		private void refreshUpperCaches(K key) &#123;</span><br><span class="line">			MultiLevelCache&lt;K, V&gt; targetCache = (MultiLevelCache&lt;K, V&gt;) getTargetCache();</span><br><span class="line">			Cache[] caches = targetCache.caches();</span><br><span class="line">			int len = caches.length;</span><br><span class="line"></span><br><span class="line">			// 获取多级缓存中顶层的缓存数据</span><br><span class="line">			CacheGetResult cacheGetResult = caches[len - 1].GET(key);</span><br><span class="line">			if (!cacheGetResult.isSuccess()) &#123;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			// 将缓存数据重新放入低层缓存</span><br><span class="line">			for (int i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">				caches[i].PUT(key, cacheGetResult.getValue());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 刷新任务的具体执行</span><br><span class="line">		 */</span><br><span class="line">		@Override</span><br><span class="line">		public void run() &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				if (config.getRefreshPolicy() == null || (loader == null &amp;&amp; !hasLoader())) &#123;</span><br><span class="line">					// 取消执行</span><br><span class="line">					cancel();</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">				long now = System.currentTimeMillis();</span><br><span class="line">				long stopRefreshAfterLastAccessMillis = config.getRefreshPolicy().getStopRefreshAfterLastAccessMillis();</span><br><span class="line">				if (stopRefreshAfterLastAccessMillis &gt; 0) &#123;</span><br><span class="line">					// 最后一次访问到现在时间的间隔超过了设置的 stopRefreshAfterLastAccessMillis，则取消当前任务执行</span><br><span class="line">					if (lastAccessTime + stopRefreshAfterLastAccessMillis &lt; now) &#123;</span><br><span class="line">						logger.debug(&quot;cancel refresh: &#123;&#125;&quot;, key);</span><br><span class="line">						cancel();</span><br><span class="line">						return;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				logger.debug(&quot;refresh key: &#123;&#125;&quot;, key);</span><br><span class="line">				// 获取缓存实例对象，如果是多层则返回顶层，也就是远程缓存</span><br><span class="line">				Cache concreteCache = concreteCache();</span><br><span class="line">				if (concreteCache instanceof AbstractExternalCache) &#123; // 远程缓存刷新</span><br><span class="line">					externalLoad(concreteCache, now);</span><br><span class="line">				&#125; else &#123; // 本地缓存刷新</span><br><span class="line">					load();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (Throwable e) &#123;</span><br><span class="line">				logger.error(&quot;refresh error: key=&quot; + key, e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刷新逻辑：</p>
<ol>
<li>判断是否需要停止刷新了，需要的话调用其<code>future</code>的cancel方法取消执行，并从<code>taskMap</code>中删除</li>
<li>获取缓存实例对象，如果是多层则返回顶层，也就是远程缓存实例对象</li>
<li>如果是本地缓存，则调用<code>load</code>方法，也就是执行loader函数加载原有方法，将获取到的数据更新至缓存实例中（如果是多级缓存，则每级缓存都会更新）</li>
<li>如果是远程缓存对象，则调用<code>externalLoad</code>方法，刷新后会往Redis中存放一个键值对，key为<code>key_#TS#</code>，value为<code>上一次刷新时间</code><ol>
<li>先从Redis中获取上一次刷新时间的键值对，根据上一次刷新的时间判断是否大于刷新间隔，大于（或者没有上一次刷新时间）表示需要重新加载数据，否则不需要重新加载数据</li>
<li>如果不需要重新加载数据，但是又是多级缓存，则获取远程缓存数据更新至本地缓存，保证两级缓存的一致性</li>
<li>如果需要重新加载数据，则调用<code>tryLockAndRun</code>方法，尝试获取分布式锁，执行刷新任务（调用<code>load</code>方法，并往Redis中重新设置上一次的刷新时间），如果没有获取到分布式锁，则创建一个延迟任务（1/5刷新间隔后）将最顶层的缓存数据更新至每一层</li>
</ol>
</li>
</ol>
<h3><span id="解析配置">解析配置</span></h3><p>主要查看jetcache-autoconfigure子模块，解析application.yml中jetcache相关配置，初始化不同缓存类型的<code>CacheBuilder</code>构造器，用于生产缓存实例，也初始化以下对象：</p>
<p><code>com.alicp.jetcache.anno.support.ConfigProvider</code>：缓存管理器，注入了全局配置GlobalCacheConfig、缓存实例管理器SimpleCacheManager、缓存上下文CacheContext等大量信息</p>
<p><code>com.alicp.jetcache.autoconfigure.AutoConfigureBeans</code>：存储<code>CacheBuilder</code>构造器以及Redis的相关信息</p>
<p><code>com.alicp.jetcache.anno.support.GlobalCacheConfig</code>：全局配置类，保存了一些全局信息</p>
<h4><span id="初始化构造器">初始化构造器</span></h4><p>通过<code>@Conditional</code>注解将需要使用到的缓存类型对应的构造器初始化类注入到Spring容器并执行初始化过程，也就是创建CacheBuilder构造器</p>
<p>初始化构造器类的类型结构如下图所示：</p>
<p><a href="AbstractCacheAutoInit.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2021/10/01/etCache-%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/AbstractCacheAutoInit.png" alt="AbstractCacheAutoInit"></a></p>
<p>主要对象描述：</p>
<p>AbstractCacheAutoInit：抽象类，实现Spring的InitializingBean接口，注入至Spring容器时完成初始化</p>
<p>EmbeddedCacheAutoInit：抽象类，继承AbstractCacheAutoInit，解析本地缓存独有的配置</p>
<p>LinkedHashMapAutoConfiguration：初始化LinkedHashMapCacheBuilder构造器</p>
<p>CaffeineAutoConfiguration：初始化CaffeineCacheBuilder构造器</p>
<p>ExternalCacheAutoInit：抽象类，继承AbstractCacheAutoInit，解析远程缓存独有的配置</p>
<p>RedisAutoInit：初始化RedisCacheBuilder构造器</p>
<p>RedisLettuceAutoInit：初始化RedisLettuceCacheBuilder构造器</p>
<h5><span id="abstractcacheautoinit">AbstractCacheAutoInit</span></h5><p><code>com.alicp.jetcache.autoconfigure.AbstractCacheAutoInit</code>抽象类主要实现了Spring的InitializingBean接口，在注入Spring容器时，Spring会调用其afterPropertiesSet方法，完成本地缓存类型和远程缓存类型<code>CacheBuilder</code>构造器的初始化，主要代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractCacheAutoInit implements InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    protected ConfigurableEnvironment environment;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    protected AutoConfigureBeans autoConfigureBeans;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    protected ConfigProvider configProvider;</span><br><span class="line"></span><br><span class="line">    protected String[] typeNames;</span><br><span class="line"></span><br><span class="line">    private boolean inited = false;</span><br><span class="line"></span><br><span class="line">    public AbstractCacheAutoInit(String... cacheTypes) &#123;</span><br><span class="line">        Objects.requireNonNull(cacheTypes,&quot;cacheTypes can&#x27;t be null&quot;);</span><br><span class="line">        Assert.isTrue(cacheTypes.length &gt; 0, &quot;cacheTypes length is 0&quot;);</span><br><span class="line">        this.typeNames = cacheTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 初始化方法</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() &#123;</span><br><span class="line">        if (!inited) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                if (!inited) &#123;</span><br><span class="line">                    // 这里我们有两个指定前缀 &#x27;jetcache.local&#x27; &#x27;jetcache.remote&#x27;</span><br><span class="line">                    process(&quot;jetcache.local.&quot;, autoConfigureBeans.getLocalCacheBuilders(), true);</span><br><span class="line">                    process(&quot;jetcache.remote.&quot;, autoConfigureBeans.getRemoteCacheBuilders(), false);</span><br><span class="line">                    inited = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void process(String prefix, Map cacheBuilders, boolean local) &#123;</span><br><span class="line">        // 创建一个配置对象（本地或者远程）</span><br><span class="line">        ConfigTree resolver = new ConfigTree(environment, prefix);</span><br><span class="line">        // 获取本地或者远程的配置项</span><br><span class="line">        Map&lt;String, Object&gt; m = resolver.getProperties();</span><br><span class="line">        // 获取本地或者远程的 area ，这里我一般只有默认的 default</span><br><span class="line">        Set&lt;String&gt; cacheAreaNames = resolver.directChildrenKeys();</span><br><span class="line">        for (String cacheArea : cacheAreaNames) &#123;</span><br><span class="line">            // 获取本地或者远程存储类型，例如 caffeine，redis.lettuce</span><br><span class="line">            final Object configType = m.get(cacheArea + &quot;.type&quot;);</span><br><span class="line">            // 缓存类型是否和当前 CacheAutoInit 的某一个 typeName 匹配（不同的 CacheAutoInit 会设置一个或者多个 typename）</span><br><span class="line">            boolean match = Arrays.stream(typeNames).anyMatch((tn) -&gt; tn.equals(configType));</span><br><span class="line">            /*</span><br><span class="line">             * 因为有很多 CacheAutoInit 继承者，都会执行这个方法，不同的继承者解析不同的配置</span><br><span class="line">             * 例如 CaffeineAutoConfiguration 只解析 jetcache.local.default.type=caffeine 即可</span><br><span class="line">             * RedisLettuceAutoInit 只解析 jetcache.remote.default.type=redis.lettuce 即可</span><br><span class="line">             */</span><br><span class="line">            if (!match) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // 获取本地或者远程的 area 的子配置项</span><br><span class="line">            ConfigTree ct = resolver.subTree(cacheArea + &quot;.&quot;);</span><br><span class="line">            logger.info(&quot;init cache area &#123;&#125; , type= &#123;&#125;&quot;, cacheArea, typeNames[0]);</span><br><span class="line">            // 根据配置信息构建本地或者远程缓存的 CacheBuilder 构造器</span><br><span class="line">            CacheBuilder c = initCache(ct, local ? &quot;local.&quot; + cacheArea : &quot;remote.&quot; + cacheArea);</span><br><span class="line">            // 将 CacheBuilder 构造器存放至 AutoConfigureBeans</span><br><span class="line">            cacheBuilders.put(cacheArea, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置公共的配置到 CacheBuilder 构造器中</span><br><span class="line">     *</span><br><span class="line">     * @param builder 构造器</span><br><span class="line">     * @param ct      配置信息</span><br><span class="line">     */</span><br><span class="line">    protected void parseGeneralConfig(CacheBuilder builder, ConfigTree ct) &#123;</span><br><span class="line">        AbstractCacheBuilder acb = (AbstractCacheBuilder) builder;</span><br><span class="line">        // 设置 Key 的转换函数</span><br><span class="line">        acb.keyConvertor(configProvider.parseKeyConvertor(ct.getProperty(&quot;keyConvertor&quot;)));</span><br><span class="line">        // 设置超时时间</span><br><span class="line">        String expireAfterWriteInMillis = ct.getProperty(&quot;expireAfterWriteInMillis&quot;);</span><br><span class="line">        if (expireAfterWriteInMillis == null) &#123;</span><br><span class="line">            // compatible with 2.1 兼容老版本</span><br><span class="line">            expireAfterWriteInMillis = ct.getProperty(&quot;defaultExpireInMillis&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (expireAfterWriteInMillis != null) &#123;</span><br><span class="line">            acb.setExpireAfterWriteInMillis(Long.parseLong(expireAfterWriteInMillis));</span><br><span class="line">        &#125;</span><br><span class="line">        // 多长时间没有访问就让缓存失效，0表示不使用该功能（注意：只支持本地缓存）</span><br><span class="line">        String expireAfterAccessInMillis = ct.getProperty(&quot;expireAfterAccessInMillis&quot;);</span><br><span class="line">        if (expireAfterAccessInMillis != null) &#123;</span><br><span class="line">            acb.setExpireAfterAccessInMillis(Long.parseLong(expireAfterAccessInMillis));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 初始化 CacheBuilder 构造器交由子类去实现</span><br><span class="line">     *</span><br><span class="line">     * @param ct                  配置信息</span><br><span class="line">     * @param cacheAreaWithPrefix 配置前缀</span><br><span class="line">     * @return CacheBuilder 构造器</span><br><span class="line">     */</span><br><span class="line">    protected abstract CacheBuilder initCache(ConfigTree ct, String cacheAreaWithPrefix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>在<code>afterPropertiesSet()</code>方法中可以看到会调用<code>process</code>方法分别初始化本地缓存和远程缓存的构造器</p>
</li>
<li><p>定义的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process</span><br></pre></td></tr></table></figure>

<p>方法：</p>
<ol>
<li>首先会从当前环境中解析出JetCache的相关配置到ConfigTree对象中</li>
<li>然后遍历缓存区域，获取对应的缓存类型type，进行不同类型的缓存实例CacheBuilder构造器初始化过程</li>
<li>不同CacheBuilder构造器的初始化方法<code>initCache</code>交由子类实现</li>
<li>获取到CacheBuilder构造器后会将其放入<code>AutoConfigureBeans</code>对象中去</li>
</ol>
</li>
<li><p>另外也定义了<code>parseGeneralConfig</code>方法解析本地缓存和远程缓存都有的配置至CacheBuilder构造器中</p>
</li>
</ol>
<h5><span id="embeddedcacheautoinit">EmbeddedCacheAutoInit</span></h5><p><code>com.alicp.jetcache.autoconfigure.EmbeddedCacheAutoInit</code>抽象类继承了<code>AbstractCacheAutoInit</code>，主要是覆盖父类的<code>parseGeneralConfig</code>，解析本地缓存单有的配置<code>limit</code>，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public abstract class EmbeddedCacheAutoInit extends AbstractCacheAutoInit &#123;</span><br><span class="line"></span><br><span class="line">    public EmbeddedCacheAutoInit(String... cacheTypes) &#123;</span><br><span class="line">        super(cacheTypes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void parseGeneralConfig(CacheBuilder builder, ConfigTree ct) &#123;</span><br><span class="line">        super.parseGeneralConfig(builder, ct);</span><br><span class="line">        EmbeddedCacheBuilder ecb = (EmbeddedCacheBuilder) builder;</span><br><span class="line">        // 设置本地缓存每个缓存实例的缓存数量个数限制（默认100）</span><br><span class="line">        ecb.limit(Integer.parseInt(ct.getProperty(&quot;limit&quot;, String.valueOf(CacheConsts.DEFAULT_LOCAL_LIMIT))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6><span id="linkedhashmapautoconfiguration">LinkedHashMapAutoConfiguration</span></h6><p><code>com.alicp.jetcache.autoconfigure.LinkedHashMapAutoConfiguration</code>继承了<code>EmbeddedCacheAutoInit</code>，实现了<code>initCache</code>方法，先通过LinkedHashMapCacheBuilder创建一个默认实现类，然后解析相关配置至构造器中完成初始化，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Conditional(LinkedHashMapAutoConfiguration.LinkedHashMapCondition.class)</span><br><span class="line">public class LinkedHashMapAutoConfiguration extends EmbeddedCacheAutoInit &#123;</span><br><span class="line">    public LinkedHashMapAutoConfiguration() &#123;</span><br><span class="line">        super(&quot;linkedhashmap&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheBuilder initCache(ConfigTree ct, String cacheAreaWithPrefix) &#123;</span><br><span class="line">        // 创建一个 LinkedHashMapCacheBuilder 构造器</span><br><span class="line">        LinkedHashMapCacheBuilder builder = LinkedHashMapCacheBuilder.createLinkedHashMapCacheBuilder();</span><br><span class="line">        // 解析相关配置至 LinkedHashMapCacheBuilder 的 CacheConfig 中</span><br><span class="line">        parseGeneralConfig(builder, ct);</span><br><span class="line">        return builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class LinkedHashMapCondition extends JetCacheCondition &#123;</span><br><span class="line">        // 配置了缓存类型为 linkedhashmap 当前类才会被注入 Spring 容器</span><br><span class="line">        public LinkedHashMapCondition() &#123;</span><br><span class="line">            super(&quot;linkedhashmap&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>这里我们注意到<code>@Conditional</code>注解，这个注解的作用是：满足<code>SpringBootCondition</code>条件这个Bean才会被Spring容器管理</li>
<li>他的条件是<code>LinkedHashMapCondition</code>，继承了<code>JetCacheCondition</code>，也就是说配置文件中配置了缓存类型为<code>linkedhashmap</code>时这个类才会被Spring容器管理，才会完成LinkedHashMapCacheBuilder构造器的初始化</li>
<li><code>JetCacheCondition</code>逻辑并不复杂，可自行查看</li>
</ol>
<h6><span id="caffeineautoconfiguration">CaffeineAutoConfiguration</span></h6><p><code>com.alicp.jetcache.autoconfigure.CaffeineAutoConfiguration</code>继承了<code>EmbeddedCacheAutoInit</code>，实现了<code>initCache</code>方法，先通过CaffeineCacheBuilder创建一个默认实现类，然后解析相关配置至构造器中完成初始化，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Conditional(CaffeineAutoConfiguration.CaffeineCondition.class)</span><br><span class="line">public class CaffeineAutoConfiguration extends EmbeddedCacheAutoInit &#123;</span><br><span class="line">    public CaffeineAutoConfiguration() &#123;</span><br><span class="line">        super(&quot;caffeine&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheBuilder initCache(ConfigTree ct, String cacheAreaWithPrefix) &#123;</span><br><span class="line">        // 创建一个 CaffeineCacheBuilder 构造器</span><br><span class="line">        CaffeineCacheBuilder builder = CaffeineCacheBuilder.createCaffeineCacheBuilder();</span><br><span class="line">        // 解析相关配置至 CaffeineCacheBuilder 的 CacheConfig 中</span><br><span class="line">        parseGeneralConfig(builder, ct);</span><br><span class="line">        return builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class CaffeineCondition extends JetCacheCondition &#123;</span><br><span class="line">        // 配置了缓存类型为 caffeine 当前类才会被注入 Spring 容器</span><br><span class="line">        public CaffeineCondition() &#123;</span><br><span class="line">            super(&quot;caffeine&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>同样使用了<code>@Conditional</code>注解，这个注解的作用是：满足<code>SpringBootCondition</code>条件这个Bean才会被Spring容器管理</li>
<li>他的条件是<code>CaffeineCondition</code>，继承了<code>JetCacheCondition</code>，也就是说配置文件中配置了缓存类型为<code>caffeine</code>时这个类才会被Spring容器管理，才会完成LinkedHashMapCacheBuilder构造器的初始化</li>
</ol>
<h5><span id="externalcacheautoinit">ExternalCacheAutoInit</span></h5><p><code>com.alicp.jetcache.autoconfigure.ExternalCacheAutoInit</code>抽象类继承了<code>AbstractCacheAutoInit</code>，主要是覆盖父类的<code>parseGeneralConfig</code>，解析远程缓存单有的配置<code>keyPrefix</code>、<code>valueEncoder</code>和<code>valueDecoder</code>，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ExternalCacheAutoInit extends AbstractCacheAutoInit &#123;</span><br><span class="line">    public ExternalCacheAutoInit(String... cacheTypes) &#123;</span><br><span class="line">        super(cacheTypes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置远程缓存 CacheBuilder 构造器的相关配置</span><br><span class="line">     *</span><br><span class="line">     * @param builder 构造器</span><br><span class="line">     * @param ct      配置信息</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void parseGeneralConfig(CacheBuilder builder, ConfigTree ct) &#123;</span><br><span class="line">        super.parseGeneralConfig(builder, ct);</span><br><span class="line">        ExternalCacheBuilder ecb = (ExternalCacheBuilder) builder;</span><br><span class="line">        // 设置远程缓存 key 的前缀</span><br><span class="line">        ecb.setKeyPrefix(ct.getProperty(&quot;keyPrefix&quot;));</span><br><span class="line">        /*</span><br><span class="line">         * 根据配置创建缓存数据的编码函数和解码函数</span><br><span class="line">         */</span><br><span class="line">        ecb.setValueEncoder(configProvider.parseValueEncoder(ct.getProperty(&quot;valueEncoder&quot;, CacheConsts.DEFAULT_SERIAL_POLICY)));</span><br><span class="line">        ecb.setValueDecoder(configProvider.parseValueDecoder(ct.getProperty(&quot;valueDecoder&quot;, CacheConsts.DEFAULT_SERIAL_POLICY)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6><span id="redisautoinit">RedisAutoInit</span></h6><p><code>com.alicp.jetcache.autoconfigure.RedisAutoInit</code>继承了<code>ExternalCacheAutoInit</code>，实现<code>initCache</code>方法，完成了通过Jedis连接Redis的初始化操作，主要代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Conditional(RedisAutoConfiguration.RedisCondition.class)</span><br><span class="line">public class RedisAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    public static final String AUTO_INIT_BEAN_NAME = &quot;redisAutoInit&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean(name = AUTO_INIT_BEAN_NAME)</span><br><span class="line">    public RedisAutoInit redisAutoInit() &#123;</span><br><span class="line">        return new RedisAutoInit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class RedisCondition extends JetCacheCondition &#123;</span><br><span class="line">        // 配置了缓存类型为 redis 当前类才会被注入 Spring 容器</span><br><span class="line">        public RedisCondition() &#123;</span><br><span class="line">            super(&quot;redis&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class RedisAutoInit extends ExternalCacheAutoInit &#123;</span><br><span class="line">        public RedisAutoInit() &#123;</span><br><span class="line">            // 设置缓存类型</span><br><span class="line">            super(&quot;redis&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Autowired</span><br><span class="line">        private AutoConfigureBeans autoConfigureBeans;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected CacheBuilder initCache(ConfigTree ct, String cacheAreaWithPrefix) &#123;</span><br><span class="line">            Pool jedisPool = parsePool(ct);</span><br><span class="line">            Pool[] slavesPool = null;</span><br><span class="line">            int[] slavesPoolWeights = null;</span><br><span class="line">            // 是否只从 Redis 的从节点读取数据</span><br><span class="line">            boolean readFromSlave = Boolean.parseBoolean(ct.getProperty(&quot;readFromSlave&quot;, &quot;False&quot;));</span><br><span class="line">            // 获取从节点的配置信息</span><br><span class="line">            ConfigTree slaves = ct.subTree(&quot;slaves.&quot;);</span><br><span class="line">            Set&lt;String&gt; slaveNames = slaves.directChildrenKeys();</span><br><span class="line">            // 依次创建每个从节点的连接池</span><br><span class="line">            if (slaveNames.size() &gt; 0) &#123;</span><br><span class="line">                slavesPool = new Pool[slaveNames.size()];</span><br><span class="line">                slavesPoolWeights = new int[slaveNames.size()];</span><br><span class="line">                int i = 0;</span><br><span class="line">                for (String slaveName: slaveNames) &#123;</span><br><span class="line">                    ConfigTree slaveConfig = slaves.subTree(slaveName + &quot;.&quot;);</span><br><span class="line">                    slavesPool[i] = parsePool(slaveConfig);</span><br><span class="line">                    slavesPoolWeights[i] = Integer.parseInt(slaveConfig.getProperty(&quot;weight&quot;,&quot;100&quot;));</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 创建一个 RedisCacheBuilder 构造器</span><br><span class="line">            ExternalCacheBuilder externalCacheBuilder = RedisCacheBuilder.createRedisCacheBuilder()</span><br><span class="line">                    .jedisPool(jedisPool)</span><br><span class="line">                    .readFromSlave(readFromSlave)</span><br><span class="line">                    .jedisSlavePools(slavesPool)</span><br><span class="line">                    .slaveReadWeights(slavesPoolWeights);</span><br><span class="line"></span><br><span class="line">            // 解析相关配置至 RedisCacheBuilder 的 CacheConfig 中</span><br><span class="line">            parseGeneralConfig(externalCacheBuilder, ct);</span><br><span class="line"></span><br><span class="line">            // eg: &quot;jedisPool.remote.default&quot;</span><br><span class="line">            autoConfigureBeans.getCustomContainer().put(&quot;jedisPool.&quot; + cacheAreaWithPrefix, jedisPool);</span><br><span class="line"></span><br><span class="line">            return externalCacheBuilder;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 创建 Redis 连接池</span><br><span class="line">         *</span><br><span class="line">         * @param ct 配置信息</span><br><span class="line">         * @return 连接池</span><br><span class="line">         */</span><br><span class="line">        private Pool&lt;Jedis&gt; parsePool(ConfigTree ct) &#123;</span><br><span class="line">            // 创建连接池配置对象</span><br><span class="line">            GenericObjectPoolConfig poolConfig = parsePoolConfig(ct);</span><br><span class="line"></span><br><span class="line">            String host = ct.getProperty(&quot;host&quot;, (String) null);</span><br><span class="line">            int port = Integer.parseInt(ct.getProperty(&quot;port&quot;, &quot;0&quot;));</span><br><span class="line">            int timeout = Integer.parseInt(ct.getProperty(&quot;timeout&quot;, String.valueOf(Protocol.DEFAULT_TIMEOUT)));</span><br><span class="line">            String password = ct.getProperty(&quot;password&quot;, (String) null);</span><br><span class="line">            int database = Integer.parseInt(ct.getProperty(&quot;database&quot;, String.valueOf(Protocol.DEFAULT_DATABASE)));</span><br><span class="line">            String clientName = ct.getProperty(&quot;clientName&quot;, (String) null);</span><br><span class="line">            boolean ssl = Boolean.parseBoolean(ct.getProperty(&quot;ssl&quot;, &quot;false&quot;));</span><br><span class="line"></span><br><span class="line">            String masterName = ct.getProperty(&quot;masterName&quot;, (String) null);</span><br><span class="line">            String sentinels = ct.getProperty(&quot;sentinels&quot;, (String) null);//ip1:port,ip2:port</span><br><span class="line"></span><br><span class="line">            Pool&lt;Jedis&gt; jedisPool;</span><br><span class="line">            if (sentinels == null) &#123;</span><br><span class="line">                Objects.requireNonNull(host, &quot;host/port or sentinels/masterName is required&quot;);</span><br><span class="line">                if (port == 0) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;host/port or sentinels/masterName is required&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                // 创建一个 Jedis 连接池</span><br><span class="line">                jedisPool = new JedisPool(poolConfig, host, port, timeout, password, database, clientName, ssl);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Objects.requireNonNull(masterName, &quot;host/port or sentinels/masterName is required&quot;);</span><br><span class="line">                String[] strings = sentinels.split(&quot;,&quot;);</span><br><span class="line">                HashSet&lt;String&gt; sentinelsSet = new HashSet&lt;&gt;();</span><br><span class="line">                for (String s : strings) &#123;</span><br><span class="line">                    if (s != null &amp;&amp; !s.trim().equals(&quot;&quot;)) &#123;</span><br><span class="line">                        sentinelsSet.add(s.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 创建一个 Jedis Sentine 连接池</span><br><span class="line">                jedisPool = new JedisSentinelPool(masterName, sentinelsSet, poolConfig, timeout, password, database, clientName);</span><br><span class="line">            &#125;</span><br><span class="line">            return jedisPool;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>com.alicp.jetcache.autoconfigure.RedisAutoInit</code>是<code>com.alicp.jetcache.autoconfigure.RedisAutoConfiguration</code>内部的静态类，在RedisAutoConfiguration内通过<code>redisAutoInit()</code>方法定义RedisAutoInit作为Spring Bean</li>
<li>同样RedisAutoConfiguration使用了<code>@Conditional</code>注解，满足<code>SpringBootCondition</code>条件这个Bean才会被Spring容器管理，内部的RedisAutoInit也不会被管理，也就是说配置文件中配置了缓存类型为<code>redis</code>时RedisLettuceAutoInit才会被Spring容器管理，才会完成RedisLettuceCacheBuilder构造器的初始化</li>
<li>实现了<code>initCache</code>方法<ol>
<li>先解析Redis的相关配置</li>
<li>通过Jedis创建Redis连接池</li>
<li>通过RedisCacheBuilder创建一个默认实现类</li>
<li>解析相关配置至构造器中完成初始化</li>
<li>将Redis连接保存至<code>AutoConfigureBeans</code>中</li>
</ol>
</li>
</ol>
<h6><span id="redislettuceautoinit">RedisLettuceAutoInit</span></h6><p><code>com.alicp.jetcache.autoconfigure.RedisLettuceAutoInit</code>继承了<code>ExternalCacheAutoInit</code>，实现<code>initCache</code>方法，完成了通过Lettuce连接Redis的初始化操作，主要代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Conditional(RedisLettuceAutoConfiguration.RedisLettuceCondition.class)</span><br><span class="line">public class RedisLettuceAutoConfiguration &#123;</span><br><span class="line">    public static final String AUTO_INIT_BEAN_NAME = &quot;redisLettuceAutoInit&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 注入 spring 容器的条件</span><br><span class="line">     */</span><br><span class="line">    public static class RedisLettuceCondition extends JetCacheCondition &#123;</span><br><span class="line">        // 配置了缓存类型为 redis.lettuce 当前类才会被注入 Spring 容器</span><br><span class="line">        public RedisLettuceCondition() &#123;</span><br><span class="line">            super(&quot;redis.lettuce&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &#123;AUTO_INIT_BEAN_NAME&#125;)</span><br><span class="line">    public RedisLettuceAutoInit redisLettuceAutoInit() &#123;</span><br><span class="line">        return new RedisLettuceAutoInit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class RedisLettuceAutoInit extends ExternalCacheAutoInit &#123;</span><br><span class="line"></span><br><span class="line">        public RedisLettuceAutoInit() &#123;</span><br><span class="line">            // 设置缓存类型</span><br><span class="line">            super(&quot;redis.lettuce&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 初始化 RedisLettuceCacheBuilder 构造器</span><br><span class="line">         *</span><br><span class="line">         * @param ct                  配置信息</span><br><span class="line">         * @param cacheAreaWithPrefix 配置前缀</span><br><span class="line">         * @return 构造器</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        protected CacheBuilder initCache(ConfigTree ct, String cacheAreaWithPrefix) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; map = ct.subTree(&quot;uri&quot;/*there is no dot*/).getProperties();</span><br><span class="line">            // 数据节点偏好设置</span><br><span class="line">            String readFromStr = ct.getProperty(&quot;readFrom&quot;);</span><br><span class="line">            // 集群模式</span><br><span class="line">            String mode = ct.getProperty(&quot;mode&quot;);</span><br><span class="line">            // 异步获取结果的超时时间，默认1s</span><br><span class="line">            long asyncResultTimeoutInMillis = Long.parseLong(</span><br><span class="line">                    ct.getProperty(&quot;asyncResultTimeoutInMillis&quot;, Long.toString(CacheConsts.ASYNC_RESULT_TIMEOUT.toMillis())));</span><br><span class="line">            ReadFrom readFrom = null;</span><br><span class="line">            if (readFromStr != null) &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * MASTER：只从Master节点中读取。</span><br><span class="line">                 * MASTER_PREFERRED：优先从Master节点中读取。</span><br><span class="line">                 * SLAVE_PREFERRED：优先从Slave节点中读取。</span><br><span class="line">                 * SLAVE：只从Slave节点中读取。</span><br><span class="line">                 * NEAREST：使用最近一次连接的Redis实例读取。</span><br><span class="line">                 */</span><br><span class="line">                readFrom = ReadFrom.valueOf(readFromStr.trim());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AbstractRedisClient client;</span><br><span class="line">            StatefulConnection connection = null;</span><br><span class="line">            if (map == null || map.size() == 0) &#123;</span><br><span class="line">                throw new CacheConfigException(&quot;lettuce uri is required&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 创建对应的 RedisURI</span><br><span class="line">                List&lt;RedisURI&gt; uriList = map.values().stream().map((k) -&gt; RedisURI.create(URI.create(k.toString())))</span><br><span class="line">                        .collect(Collectors.toList());</span><br><span class="line">                if (uriList.size() == 1) &#123; // 只有一个 URI，集群模式只给一个域名怎么办 TODO 疑问？？</span><br><span class="line">                    RedisURI uri = uriList.get(0);</span><br><span class="line">                    if (readFrom == null) &#123;</span><br><span class="line">                        // 创建一个 Redis 客户端</span><br><span class="line">                        client = RedisClient.create(uri);</span><br><span class="line">                        // 设置失去连接时的行为，拒绝命令，默认为 DEFAULT</span><br><span class="line">                        ((RedisClient) client).setOptions(ClientOptions.builder().</span><br><span class="line">                                disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS).build());</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 创建一个 Redis 客户端</span><br><span class="line">                        client = RedisClient.create();</span><br><span class="line">                        ((RedisClient) client).setOptions(ClientOptions.builder().</span><br><span class="line">                                disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS).build());</span><br><span class="line">                        // 创建一个安全连接并设置数据节点偏好</span><br><span class="line">                        StatefulRedisMasterSlaveConnection c = MasterSlave.connect(</span><br><span class="line">                                (RedisClient) client, new JetCacheCodec(), uri);</span><br><span class="line">                        c.setReadFrom(readFrom);</span><br><span class="line">                        connection = c;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123; // 多个 URI，集群模式</span><br><span class="line">                    if (mode != null &amp;&amp; mode.equalsIgnoreCase(&quot;MasterSlave&quot;)) &#123;</span><br><span class="line">                        client = RedisClient.create();</span><br><span class="line">                        ((RedisClient) client).setOptions(ClientOptions.builder().</span><br><span class="line">                                disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS).build());</span><br><span class="line">                        StatefulRedisMasterSlaveConnection c = MasterSlave.connect(</span><br><span class="line">                                (RedisClient) client, new JetCacheCodec(), uriList);</span><br><span class="line">                        if (readFrom != null) &#123;</span><br><span class="line">                            c.setReadFrom(readFrom);</span><br><span class="line">                        &#125;</span><br><span class="line">                        connection = c;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 创建一个 Redis 客户端</span><br><span class="line">                        client = RedisClusterClient.create(uriList);</span><br><span class="line">                        ((RedisClusterClient) client).setOptions(ClusterClientOptions.builder().</span><br><span class="line">                                disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS).build());</span><br><span class="line">                        if (readFrom != null) &#123;</span><br><span class="line">                            StatefulRedisClusterConnection c = ((RedisClusterClient) client).connect(new JetCacheCodec());</span><br><span class="line">                            c.setReadFrom(readFrom);</span><br><span class="line">                            connection = c;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 创建一个 RedisLettuceCacheBuilder 构造器</span><br><span class="line">            ExternalCacheBuilder externalCacheBuilder = RedisLettuceCacheBuilder.createRedisLettuceCacheBuilder()</span><br><span class="line">                    .connection(connection)</span><br><span class="line">                    .redisClient(client)</span><br><span class="line">                    .asyncResultTimeoutInMillis(asyncResultTimeoutInMillis);</span><br><span class="line">            // 解析相关配置至 RedisLettuceCacheBuilder 的 CacheConfig 中</span><br><span class="line">            parseGeneralConfig(externalCacheBuilder, ct);</span><br><span class="line"></span><br><span class="line">            // eg: &quot;remote.default.client&quot;</span><br><span class="line">            autoConfigureBeans.getCustomContainer().put(cacheAreaWithPrefix + &quot;.client&quot;, client);</span><br><span class="line">            // 开始将 Redis 客户端和安全连接保存至 LettuceConnectionManager 管理器中</span><br><span class="line">            LettuceConnectionManager m = LettuceConnectionManager.defaultManager();</span><br><span class="line">            // 初始化 Lettuce 连接 Redis</span><br><span class="line">            m.init(client, connection);</span><br><span class="line">            // 初始化 Redis 连接的相关信息保存至 LettuceObjects 中，并将相关信息保存至 AutoConfigureBeans.customContainer</span><br><span class="line">            autoConfigureBeans.getCustomContainer().put(cacheAreaWithPrefix + &quot;.connection&quot;, m.connection(client));</span><br><span class="line">            autoConfigureBeans.getCustomContainer().put(cacheAreaWithPrefix + &quot;.commands&quot;, m.commands(client));</span><br><span class="line">            autoConfigureBeans.getCustomContainer().put(cacheAreaWithPrefix + &quot;.asyncCommands&quot;, m.asyncCommands(client));</span><br><span class="line">            autoConfigureBeans.getCustomContainer().put(cacheAreaWithPrefix + &quot;.reactiveCommands&quot;, m.reactiveCommands(client));</span><br><span class="line">            return externalCacheBuilder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>com.alicp.jetcache.autoconfigure.RedisLettuceAutoInit</code>是<code>com.alicp.jetcache.autoconfigure.RedisLettuceAutoConfiguration</code>内部的静态类，在RedisLettuceAutoConfiguration内通过<code>redisLettuceAutoInit()</code>方法定义RedisLettuceAutoInit作为Spring Bean</li>
<li>同样RedisLettuceAutoConfiguration使用了<code>@Conditional</code>注解，满足<code>SpringBootCondition</code>条件这个Bean才会被Spring容器管理，内部的RedisLettuceAutoInit也不会被管理，也就是说配置文件中配置了缓存类型为<code>redis.lettuce</code>时RedisLettuceAutoInit才会被Spring容器管理，才会完成RedisLettuceCacheBuilder构造器的初始化</li>
<li>实现了<code>initCache</code>方法<ol>
<li>先解析Redis的相关配置</li>
<li>通过Lettuce创建Redis客户端和与Redis的连接</li>
<li>通过RedisLettuceCacheBuilder创建一个默认实现类</li>
<li>解析相关配置至构造器中完成初始化</li>
<li>获取<code>LettuceConnectionManager</code>管理器，将通过Lettuce创建Redis客户端和与Redis的连接保存</li>
<li>将Redis客户端、与Redis的连接、同步命令、异步命令和反应式命令相关保存至<code>AutoConfigureBeans</code>中</li>
</ol>
</li>
</ol>
<h4><span id="jetcacheautoconfiguration自动配置">JetCacheAutoConfiguration自动配置</span></h4><p>上面的初始化构造器的类需要被Spring容器管理，就需被扫描到，我们一般会设置扫描路径，但是别人引入JetCache肯定是作为其他包不能够被扫描到的，这些Bean也就不会被Spring管理，这里我们查看<code>jetcache-autoconfigure</code>模块下src/main/resources/META-INF/<code>spring.factories</code>文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.alicp.jetcache.autoconfigure.JetCacheAutoConfiguration</span><br></pre></td></tr></table></figure>

<p>这应该是一种<code>SPI</code>机制，这样这个项目以外的JetCache包里面的<code>com.alicp.jetcache.autoconfigure.JetCacheAutoConfiguration</code>就会被Spring容器扫描到，我们来看看他的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 该 Bean 将会被 Spring 容器注入，依次注入下面几个 Bean</span><br><span class="line"> * SpringConfigProvider -&gt; AutoConfigureBeans -&gt; BeanDependencyManager(为 GlobalCacheConfig 添加 CacheAutoInit 依赖) -&gt; GlobalCacheConfig</span><br><span class="line"> * 由此会完成初始化配置操作，缓存实例构造器 CacheBuilder 也会被注入容器</span><br><span class="line"> *</span><br><span class="line"> * Created on 2016/11/17.</span><br><span class="line"> *</span><br><span class="line"> * @author &lt;a href=&quot;mailto:areyouok@gmail.com&quot;&gt;huangli&lt;/a&gt;</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(GlobalCacheConfig.class)</span><br><span class="line">@ConditionalOnMissingBean(GlobalCacheConfig.class)</span><br><span class="line">@EnableConfigurationProperties(JetCacheProperties.class)</span><br><span class="line">@Import(&#123;RedisAutoConfiguration.class,</span><br><span class="line">        CaffeineAutoConfiguration.class,</span><br><span class="line">        MockRemoteCacheAutoConfiguration.class,</span><br><span class="line">        LinkedHashMapAutoConfiguration.class,</span><br><span class="line">        RedisLettuceAutoConfiguration.class,</span><br><span class="line">        RedisSpringDataAutoConfiguration.class&#125;)</span><br><span class="line">public class JetCacheAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    public static final String GLOBAL_CACHE_CONFIG_NAME = &quot;globalCacheConfig&quot;;</span><br><span class="line"></span><br><span class="line">    private SpringConfigProvider _springConfigProvider = new SpringConfigProvider();</span><br><span class="line"></span><br><span class="line">    private AutoConfigureBeans _autoConfigureBeans = new AutoConfigureBeans();</span><br><span class="line"></span><br><span class="line">    private GlobalCacheConfig _globalCacheConfig;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean</span><br><span class="line">    public SpringConfigProvider springConfigProvider() &#123;</span><br><span class="line">        return _springConfigProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public AutoConfigureBeans autoConfigureBeans() &#123;</span><br><span class="line">        return _autoConfigureBeans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public static BeanDependencyManager beanDependencyManager()&#123;</span><br><span class="line">        return new BeanDependencyManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name = GLOBAL_CACHE_CONFIG_NAME)</span><br><span class="line">    public GlobalCacheConfig globalCacheConfig(SpringConfigProvider configProvider,</span><br><span class="line">                                                            AutoConfigureBeans autoConfigureBeans,</span><br><span class="line">                                                            JetCacheProperties props) &#123;</span><br><span class="line">        if (_globalCacheConfig != null) &#123;</span><br><span class="line">            return _globalCacheConfig;</span><br><span class="line">        &#125;</span><br><span class="line">        _globalCacheConfig = new GlobalCacheConfig();</span><br><span class="line">        _globalCacheConfig.setHiddenPackages(props.getHiddenPackages());</span><br><span class="line">        _globalCacheConfig.setStatIntervalMinutes(props.getStatIntervalMinutes());</span><br><span class="line">        _globalCacheConfig.setAreaInCacheName(props.isAreaInCacheName());</span><br><span class="line">        _globalCacheConfig.setPenetrationProtect(props.isPenetrationProtect());</span><br><span class="line">        _globalCacheConfig.setEnableMethodCache(props.isEnableMethodCache());</span><br><span class="line">        _globalCacheConfig.setLocalCacheBuilders(autoConfigureBeans.getLocalCacheBuilders());</span><br><span class="line">        _globalCacheConfig.setRemoteCacheBuilders(autoConfigureBeans.getRemoteCacheBuilders());</span><br><span class="line">        return _globalCacheConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>可以看到通过<code>@Import</code>注解，初始化构造器的那些类会被加入到Spring容器，加上<code>@Condotional</code>注解，只有我们配置过的缓存类型的构造器才会被加入，然后保存至AutoConfigureBeans对象中</li>
<li>注意到这里我们注入的是<code>SpringConfigProvider</code>对象，加上<code>@ConditionalOnMissingBean</code>注解，无法再次注册该对象至Spring容器，相比<code>ConfigProvider</code>对象，它的区别是设置了EncoderParser为DefaultSpringEncoderParser，设置了KeyConvertorParser为DefaultSpringKeyConvertorParser，目的是支持两个解析器能够解析自定义bean</li>
<li>在<code>BeanDependencyManager</code>中可以看到它是一个<code>BeanFactoryPostProcessor</code>，用于BeanFactory容器初始后执行操作，目的是往JetCacheAutoConfiguration的BeanDefinition的依赖中添加几个AbstractCacheAutoInit类型的beanName，保证几个CacheBuilder构造器已经初始化</li>
<li><code>globalCacheConfig</code>方法中设置全局的相关配置并添加已经初始化的CacheBuilder构造器，然后返回GlobalCacheConfig让Spring容器管理，这样一来就完成了JetCache的解析配置并初始化的功能</li>
</ol>
<h4><span id="cachebuilder构造器">CacheBuilder构造器</span></h4><p>构造器的作用就是根据配置构建一个对应类型的缓存实例</p>
<p>CacheBuilder的子类结构如下：</p>
<p><a href="CacheBuilder.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2021/10/01/etCache-%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/CacheBuilder.png" alt="CacheBuilder"></a></p>
<p>根据类名就可以知道其作用</p>
<p>CacheBuilder接口只定义了一个<code>buildCache()</code>方法，用于构建缓存实例，交由不同的实现类</p>
<p>AbstractCacheBuilder抽象类实现了<code>buildCache()</code>方法，主要代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractCacheBuilder&lt;T extends AbstractCacheBuilder&lt;T&gt;&gt; implements CacheBuilder, Cloneable &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 该缓存实例的配置</span><br><span class="line">     */</span><br><span class="line">    protected CacheConfig config;</span><br><span class="line">    /**</span><br><span class="line">     * 创建缓存实例函数</span><br><span class="line">     */</span><br><span class="line">    private Function&lt;CacheConfig, Cache&gt; buildFunc;</span><br><span class="line"></span><br><span class="line">    public abstract CacheConfig getConfig();</span><br><span class="line"></span><br><span class="line">    protected T self() &#123;</span><br><span class="line">        return (T) this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T buildFunc(Function&lt;CacheConfig, Cache&gt; buildFunc) &#123;</span><br><span class="line">        this.buildFunc = buildFunc;</span><br><span class="line">        return self();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void beforeBuild() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Deprecated</span><br><span class="line">    public final &lt;K, V&gt; Cache&lt;K, V&gt; build() &#123;</span><br><span class="line">        return buildCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public final &lt;K, V&gt; Cache&lt;K, V&gt; buildCache() &#123;</span><br><span class="line">        if (buildFunc == null) &#123;</span><br><span class="line">            throw new CacheConfigException(&quot;no buildFunc&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        beforeBuild();</span><br><span class="line">        // 克隆一份配置信息，因为这里获取到的是全局配置信息，以防后续被修改</span><br><span class="line">        CacheConfig c = getConfig().clone();</span><br><span class="line">        // 通过构建函数创建一个缓存实例</span><br><span class="line">        Cache&lt;K, V&gt; cache = buildFunc.apply(c);</span><br><span class="line">        /*</span><br><span class="line">         * 目前发现 c.getLoader() 都是 null，后续都会把 cache 封装成 CacheHandlerRefreshCache</span><br><span class="line">         * TODO 疑问？？？？</span><br><span class="line">         */</span><br><span class="line">        if (c.getLoader() != null) &#123;</span><br><span class="line">            if (c.getRefreshPolicy() == null) &#123;</span><br><span class="line">                cache = new LoadingCache&lt;&gt;(cache);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cache = new RefreshCache&lt;&gt;(cache);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        AbstractCacheBuilder copy = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            copy = (AbstractCacheBuilder) super.clone();</span><br><span class="line">            copy.config = getConfig().clone();</span><br><span class="line">            return copy;</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            throw new CacheException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>实现了<code>java.lang.Cloneable</code>的clone方法，支持克隆该对象，因为每个缓存实例的配置不一定相同，这个构造器中保存的是全局的一些配置，所以需要克隆一个构造器出来为每个缓存实例设置其自己的配置而不影响这个最初始的构造器</p>
</li>
<li><p>定义CacheConfig对象存放缓存配置，构建缓存实例需要根据这些配置</p>
</li>
<li><p>定义的<code>buildFunc</code>函数用于构建缓存实例，我们在初始化构造器中可以看到，不同的构造器设置的该函数都是new一个缓存实例并传入配置信息，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 设置构建 CaffeineCache 缓存实例的函数</span><br><span class="line">buildFunc((c) -&gt; new CaffeineCache((EmbeddedCacheConfig) c));</span><br><span class="line">// 进入CaffeineCache的构造器你就可以看到会根据配置完成缓存实例的初始化</span><br></pre></td></tr></table></figure></li>
</ol>
<p>不同类型的构造器区别在于CacheConfig类型不同，因为远程和本地的配置是有所区别的，还有就是设置的<code>buildFunc</code>函数不同，因为需要构建不同的缓存实例，和上面的例子差不多，都是new一个缓存实例并传入配置信息，这里就不一一讲述了</p>
<h3><span id="aop">AOP</span></h3><p>主要查看jetcache-anno子模块，提供AOP功能</p>
<h4><span id="启用jetcache">启用JetCache</span></h4><p>JetCache可以通过@EnableMethodCache和@EnableCreateCacheAnnotation注解完成AOP的初始化工作，我们在Spring Boot工程中的启动类上面添加这两个注解即可启用JetCache缓存。</p>
<h5><span id="enablemethodcache">@EnableMethodCache</span></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Import(&#123;CommonConfiguration.class, ConfigSelector.class&#125;)</span><br><span class="line">public @interface EnableMethodCache &#123;</span><br><span class="line"></span><br><span class="line">    boolean proxyTargetClass() default false;</span><br><span class="line"></span><br><span class="line">    AdviceMode mode() default AdviceMode.PROXY;</span><br><span class="line"></span><br><span class="line">    int order() default Ordered.LOWEST_PRECEDENCE;</span><br><span class="line"></span><br><span class="line">    String[] basePackages();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解的相关配置在上面的’如何使用’中已经讲过了，这里我们关注<code>@Import</code>注解中的<code>CommonConfiguration</code>和<code>ConfigSelector</code>两个类，将会被Spring容器管理</p>
<ol>
<li><code>com.alicp.jetcache.anno.config.CommonConfiguration</code>上面有@Configuration注解，所以会被作为一个Spring Bean，里面定义了一个Bean为<code>ConfigMap</code>，所以这个Bean也会被Spring容器管理，<code>com.alicp.jetcache.anno.support.ConfigMap</code>中保存方法与缓存注解配置信息的映射关系</li>
<li><code>com.alicp.jetcache.anno.config.ConfigSelector</code>继承了AdviceModeImportSelector，通过<code>@Import</code>注解他的<code>selectImports</code>方法会被调用，根据不同的AdviceMode导入不同的配置类，可以看到会返回一个JetCacheProxyConfiguration类名称，那么它也会被注入</li>
</ol>
<p><code>com.alicp.jetcache.anno.config.JetCacheProxyConfiguration</code>是配置AOP的配置类，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class JetCacheProxyConfiguration implements ImportAware, ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    protected AnnotationAttributes enableMethodCache;</span><br><span class="line">    private ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setImportMetadata(AnnotationMetadata importMetadata) &#123;</span><br><span class="line">        // 获取 @EnableMethodCache 注解信息</span><br><span class="line">        this.enableMethodCache = AnnotationAttributes.fromMap(</span><br><span class="line">                importMetadata.getAnnotationAttributes(EnableMethodCache.class.getName(), false));</span><br><span class="line">        if (this.enableMethodCache == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;@EnableMethodCache is not present on importing class &quot; + importMetadata.getClassName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        this.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name = CacheAdvisor.CACHE_ADVISOR_BEAN_NAME)</span><br><span class="line">    @Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">    public CacheAdvisor jetcacheAdvisor(JetCacheInterceptor jetCacheInterceptor) &#123;</span><br><span class="line">        CacheAdvisor advisor = new CacheAdvisor();</span><br><span class="line">        // bean的名称：jetcache2.internalCacheAdvisor</span><br><span class="line">        advisor.setAdviceBeanName(CacheAdvisor.CACHE_ADVISOR_BEAN_NAME);</span><br><span class="line">        // 设置缓存拦截器为 JetCacheInterceptor</span><br><span class="line">        advisor.setAdvice(jetCacheInterceptor);</span><br><span class="line">        // 设置需要扫描的包</span><br><span class="line">        advisor.setBasePackages(this.enableMethodCache.getStringArray(&quot;basePackages&quot;));</span><br><span class="line">        // 设置优先级，默认 Integer 的最大值，最低优先级</span><br><span class="line">        advisor.setOrder(this.enableMethodCache.&lt;Integer&gt;getNumber(&quot;order&quot;));</span><br><span class="line">        return advisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 注入一个 JetCacheInterceptor 拦截器，设置为框架内部的角色</span><br><span class="line">     *</span><br><span class="line">     * @return JetCacheInterceptor</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">    public JetCacheInterceptor jetCacheInterceptor() &#123;</span><br><span class="line">        return new JetCacheInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为JetCacheProxyConfiguration是通过<code>@Import</code>注解注入的并且实现了<code>ImportAware</code>接口，当被注入Bean的时候会先调用其<code>setImportMetadata</code>方法（这里好像必须添加@Configuration注解，不然无法被Spring识别出来）获取到<code>@EnableMethodCache</code>注解的元信息</p>
<p>其中定义了两个Bean：</p>
<p><code>com.alicp.jetcache.anno.aop.JetCacheInterceptor</code>：实现了aop中的MethodInterceptor方法拦截器，可用于aop拦截方法后执行相关处理</p>
<p><code>com.alicp.jetcache.anno.aop.CacheAdvisor</code>：</p>
<ol>
<li>继承了<code>org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor</code>，将会作为一个AOP切面</li>
<li>设置了通知advice为JetCacheInterceptor，也就是说被拦截的方法都会进入JetCacheInterceptor，JetCacheInterceptor就作为JetCache的入口了</li>
<li>根据注解设置了需要扫描的包路径以及优先级，默认是最低优先级</li>
<li>CacheAdvisor实现了<code>org.springframework.aopPointcutAdvisor</code>接口的<code>getPointcut()</code>方法，设置这个切面的切入点为<code>com.alicp.jetcache.anno.aop.CachePointcut</code></li>
<li>从CachePointcut作为切入点<ol>
<li>实现了<code>org.springframework.aop.ClassFilter</code>接口，用于判断哪些类需要被拦截</li>
<li>实现了<code>org.springframework.aop.MethodMatcher</code>接口，用于判断哪些类中的哪些方法会被拦截</li>
<li>在判断方法是否需要进入JetCache的JetCacheInterceptor过程中，会解析方法上面的JetCache相关缓存注解，将配置信息封装<code>com.alicp.jetcache.anno.methodCacheInvokeConfig</code>对象中，并把它保存至<code>com.alicp.jetcache.anno.support.ConfigMap</code>对象中</li>
</ol>
</li>
</ol>
<p>总结：@EnableMethodCache注解主要就是生成一个AOP切面用于拦截带有缓存注解的方法</p>
<h5><span id="enablecreatecacheannotation">@EnableCreateCacheAnnotation</span></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Import(&#123;CommonConfiguration.class, CreateCacheAnnotationBeanPostProcessor.class&#125;)</span><br><span class="line">public @interface EnableCreateCacheAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比@EnableMethodCache注解，没有相关属性，同样会导入CommonConfiguration类</p>
<p>不同的是将导入<code>com.alicp.jetcache.anno.field.CreateCacheAnnotationBeanPostProcessor</code>类，它继承了<code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor</code></p>
<p>作为一个BeanPostProcessor，用于在Spring初始化bean的时候做一些操作</p>
<p>从代码中可以看到他的作用是：如果这个bean内部存在添加了带有<code>@CreateCache</code>注解的字段（没有添加static），会将这个字段作为需要注入的对象，解析成 <code>com.alicp.jetcache.anno.field.LazyInitCache</code>缓存实例</p>
<p>LazyInitCache的主要代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">class LazyInitCache implements ProxyCache &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 是否初始化，用于懒加载</span><br><span class="line">     */</span><br><span class="line">    private boolean inited;</span><br><span class="line">    /**</span><br><span class="line">     * 缓存实例</span><br><span class="line">     */</span><br><span class="line">    private Cache cache;</span><br><span class="line">    /**</span><br><span class="line">     * 所处上下文</span><br><span class="line">     */</span><br><span class="line">    private ConfigurableListableBeanFactory beanFactory;</span><br><span class="line">    /**</span><br><span class="line">     * CreateCache 注解元信息</span><br><span class="line">     */</span><br><span class="line">    private CreateCache ann;</span><br><span class="line">    /**</span><br><span class="line">     * 字段</span><br><span class="line">     */</span><br><span class="line">    private Field field;</span><br><span class="line">    /**</span><br><span class="line">     * 刷新策略</span><br><span class="line">     */</span><br><span class="line">    private RefreshPolicy refreshPolicy;</span><br><span class="line">    /**</span><br><span class="line">     * 保护策略</span><br><span class="line">     */</span><br><span class="line">    private PenetrationProtectConfig protectConfig;</span><br><span class="line"></span><br><span class="line">    public LazyInitCache(ConfigurableListableBeanFactory beanFactory, CreateCache ann, Field field) &#123;</span><br><span class="line">        this.beanFactory = beanFactory;</span><br><span class="line">        this.ann = ann;</span><br><span class="line">        this.field = field;</span><br><span class="line">        CacheRefresh cr = field.getAnnotation(CacheRefresh.class);</span><br><span class="line">        if (cr != null) &#123;</span><br><span class="line">            refreshPolicy = CacheConfigUtil.parseRefreshPolicy(cr);</span><br><span class="line">        &#125;</span><br><span class="line">        CachePenetrationProtect penetrateProtect = field.getAnnotation(CachePenetrationProtect.class);</span><br><span class="line">        if (penetrateProtect != null) &#123;</span><br><span class="line">            protectConfig = CacheConfigUtil.parsePenetrationProtectConfig(penetrateProtect);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void checkInit() &#123;</span><br><span class="line">        if (!inited) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                if (!inited) &#123;</span><br><span class="line">                    init();</span><br><span class="line">                    inited = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取缓存实例，不存在则新建</span><br><span class="line">     *</span><br><span class="line">     * @return 缓存实例</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Cache getTargetCache() &#123;</span><br><span class="line">        checkInit();</span><br><span class="line">        return cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init() &#123;</span><br><span class="line">        if (inited) &#123;</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        // 从 spring 的容器中获取全局缓存配置 GlobalCacheConfig 对象</span><br><span class="line">        GlobalCacheConfig globalCacheConfig = beanFactory.getBean(GlobalCacheConfig.class);</span><br><span class="line">        ConfigProvider configProvider = beanFactory.getBean(ConfigProvider.class);</span><br><span class="line"></span><br><span class="line">        // 将注解信息封装到 CachedAnnoConfig 对象中</span><br><span class="line">        CachedAnnoConfig cac = new CachedAnnoConfig();</span><br><span class="line">        cac.setArea(ann.area());</span><br><span class="line">        cac.setName(ann.name());</span><br><span class="line">        cac.setTimeUnit(ann.timeUnit());</span><br><span class="line">        cac.setExpire(ann.expire());</span><br><span class="line">        cac.setLocalExpire(ann.localExpire());</span><br><span class="line">        cac.setCacheType(ann.cacheType());</span><br><span class="line">        cac.setLocalLimit(ann.localLimit());</span><br><span class="line">        cac.setSerialPolicy(ann.serialPolicy());</span><br><span class="line">        cac.setKeyConvertor(ann.keyConvertor());</span><br><span class="line"></span><br><span class="line">        cac.setRefreshPolicy(refreshPolicy);</span><br><span class="line">        cac.setPenetrationProtectConfig(protectConfig);</span><br><span class="line"></span><br><span class="line">        String cacheName = cac.getName();</span><br><span class="line">        if (CacheConsts.isUndefined(cacheName)) &#123;</span><br><span class="line">            String[] hiddenPackages = globalCacheConfig.getHiddenPackages();</span><br><span class="line">            CacheNameGenerator g = configProvider.createCacheNameGenerator(hiddenPackages);</span><br><span class="line">            cacheName = g.generateCacheName(field);</span><br><span class="line">        &#125;</span><br><span class="line">        // 从缓存实例管理器中获取或者创建对应的缓存实例</span><br><span class="line">        cache = configProvider.getCacheContext().__createOrGetCache(cac, ann.area(), cacheName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>可以看到通过<code>@CreateCache</code>创建的缓存实例也可以添加<code>@CacheRefresh</code>和<code>@CachePenetrationProtect</code>注解</li>
<li>在AbstractCache抽象类的computeIfAbsentImpl方法中我们有讲到，如果缓存实例是ProxyCache类型，则会先调用其<code>getTargetCache()</code>方法获取缓存实例对象，所以LazyInitCache在第一次访问的时候才进行初始化，并根据缓存注解配置信息创建（存在则直接获取）一个缓存实例</li>
</ol>
<p>总结：@EnableCreateCacheAnnotation注解主要是支持@CreateCache能够创建缓存实例</p>
<p>通过<code>@EnableMethodCache</code>和<code>@EnableCreateCacheAnnotation</code>两个注解，加上前面的<code>解析配置过程</code>，已经完成的JetCache的解析与初始化过程，那么接下来我们来看看JetCache如何处理被拦截的方法。</p>
<h4><span id="拦截器">拦截器</span></h4><p>从<code>com.alicp.jetcache.anno.aop.CachePointcut</code>切入点判断方法是否需要拦截的逻辑：</p>
<ol>
<li>方法所在的类对象是否匹配，除去以”java”、”org.springframework”开头和包含”$$EnhancerBySpringCGLIB$$”、”$$FastClassBySpringCGLIB$$”的类，该类是否在我们通过<code>@EnableMethodCache</code>注解配置的basePackages中</li>
<li>从<code>ConfigMap</code>获取方法对应的<code>CacheInvokeConfig</code>对象，也就是获取缓存配置信息<ol>
<li>如果是一个空对象，那么不需要被拦截，因为前面已经判断了所在的类是否需要被拦截，而这个类中并不是所有的方法都会添加缓存注解，所以这一类的方法会设置一个空对象（定义在CacheInvokeConfig内部的一个静态对象添加了final修饰），保存在ConfigMap中</li>
<li>如果不为null，则需被拦截</li>
<li>通过CacheConfigUtil解析这个方法的缓存注解，如果有@Cached注解或者@CacheInvalidate注解或者@CacheUpdate注解，先解析注解生成CacheInvokeConfig对象保存至ConfigMap中，然后该方法会被拦截，否在保存一个空对象不会被拦截</li>
</ol>
</li>
</ol>
<h5><span id="configprovider">ConfigProvider</span></h5><p><code>com.alicp.jetcache.anno.support.ConfigProvide</code>是一个配置提供者对象，包含了JetCache的全局配置、缓存实例管理器、缓存value转换器、缓存key转换器、上下文和监控指标相关信息，主要代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">public class ConfigProvider extends AbstractLifecycle &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 缓存的全局配置</span><br><span class="line">     */</span><br><span class="line">    @Resource</span><br><span class="line">    protected GlobalCacheConfig globalCacheConfig;</span><br><span class="line">    /**</span><br><span class="line">     * 缓存实例管理器</span><br><span class="line">     */</span><br><span class="line">    protected SimpleCacheManager cacheManager;</span><br><span class="line">    /**</span><br><span class="line">     * 根据不同类型生成缓存数据转换函数的转换器</span><br><span class="line">     */</span><br><span class="line">    protected EncoderParser encoderParser;</span><br><span class="line">    /**</span><br><span class="line">     * 根据不同类型生成缓存 Key 转换函数的转换器</span><br><span class="line">     */</span><br><span class="line">    protected KeyConvertorParser keyConvertorParser;</span><br><span class="line">    /**</span><br><span class="line">     * 缓存监控指标管理器</span><br><span class="line">     */</span><br><span class="line">    protected CacheMonitorManager cacheMonitorManager;</span><br><span class="line">    /**</span><br><span class="line">     * 打印缓存各项指标的函数</span><br><span class="line">     */</span><br><span class="line">    private Consumer&lt;StatInfo&gt; metricsCallback = new StatInfoLogger(false);</span><br><span class="line">    /**</span><br><span class="line">     * 缓存更新事件（REMOVE OR PUT）消息接收者，无实现类</span><br><span class="line">     * 我们可以自己实现 CacheMessagePublisher 用于统计一些缓存的命中信息</span><br><span class="line">     */</span><br><span class="line">    private CacheMessagePublisher cacheMessagePublisher;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 默认的缓存监控指标管理器</span><br><span class="line">     */</span><br><span class="line">    private CacheMonitorManager defaultCacheMonitorManager = new DefaultCacheMonitorManager();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 缓存上下文</span><br><span class="line">     */</span><br><span class="line">    private CacheContext cacheContext;</span><br><span class="line"></span><br><span class="line">    public ConfigProvider() &#123;</span><br><span class="line">        cacheManager = SimpleCacheManager.defaultManager;</span><br><span class="line">        encoderParser = new DefaultEncoderParser();</span><br><span class="line">        keyConvertorParser = new DefaultKeyConvertorParser();</span><br><span class="line">        cacheMonitorManager = defaultCacheMonitorManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doInit() &#123;</span><br><span class="line">        // 启动缓存指标监控器，周期性打印各项指标</span><br><span class="line">        initDefaultCacheMonitorInstaller();</span><br><span class="line">        // 初始化缓存上下文</span><br><span class="line">        cacheContext = newContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void initDefaultCacheMonitorInstaller() &#123;</span><br><span class="line">        if (cacheMonitorManager == defaultCacheMonitorManager) &#123;</span><br><span class="line">            DefaultCacheMonitorManager installer = (DefaultCacheMonitorManager) cacheMonitorManager;</span><br><span class="line">            installer.setGlobalCacheConfig(globalCacheConfig);</span><br><span class="line">            installer.setMetricsCallback(metricsCallback);</span><br><span class="line">            if (cacheMessagePublisher != null) &#123;</span><br><span class="line">                installer.setCacheMessagePublisher(cacheMessagePublisher);</span><br><span class="line">            &#125;</span><br><span class="line">            // 启动缓存指标监控器</span><br><span class="line">            installer.init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doShutdown() &#123;</span><br><span class="line">        shutdownDefaultCacheMonitorInstaller();</span><br><span class="line">        cacheManager.rebuild();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void shutdownDefaultCacheMonitorInstaller() &#123;</span><br><span class="line">        if (cacheMonitorManager == defaultCacheMonitorManager) &#123;</span><br><span class="line">            ((DefaultCacheMonitorManager) cacheMonitorManager).shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据编码类型通过缓存value转换器生成编码函数</span><br><span class="line">     *</span><br><span class="line">     * @param valueEncoder 编码类型</span><br><span class="line">     * @return 编码函数</span><br><span class="line">     */</span><br><span class="line">    public Function&lt;Object, byte[]&gt; parseValueEncoder(String valueEncoder) &#123;</span><br><span class="line">        return encoderParser.parseEncoder(valueEncoder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据解码类型通过缓存value转换器生成解码函数</span><br><span class="line">     *</span><br><span class="line">     * @param valueDecoder 解码类型</span><br><span class="line">     * @return 解码函数</span><br><span class="line">     */</span><br><span class="line">    public Function&lt;byte[], Object&gt; parseValueDecoder(String valueDecoder) &#123;</span><br><span class="line">        return encoderParser.parseDecoder(valueDecoder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据转换类型通过缓存key转换器生成转换函数</span><br><span class="line">     *</span><br><span class="line">     * @param convertor 转换类型</span><br><span class="line">     * @return 转换函数</span><br><span class="line">     */</span><br><span class="line">    public Function&lt;Object, Object&gt; parseKeyConvertor(String convertor) &#123;</span><br><span class="line">        return keyConvertorParser.parseKeyConvertor(convertor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CacheNameGenerator createCacheNameGenerator(String[] hiddenPackages) &#123;</span><br><span class="line">        return new DefaultCacheNameGenerator(hiddenPackages);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected CacheContext newContext() &#123;</span><br><span class="line">        return new CacheContext(this, globalCacheConfig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承了<code>com.alicp.jetcache.anno.support.AbstractLifecycle</code>，查看其代码可以看到有两个方法，分别为<code>init()</code>初始化方法和<code>shutdown()</code>销毁方法，因为分别添加了<code>@PostConstruct</code>注解和<code>@PreDestroy</code>注解，所以在Spring初始化时会调用init()，在Spring容器销毁时会调用shutdown()方法，内部分别调用doInit()和doShutdown()，这两个方法交由子类实现</p>
<p>在doInit()方法中先启动缓存指标监控器，用于周期性打印各项缓存指标，然后初始化CacheContext缓存上下文，SpringConfigProvider返回的是SpringConfigContext</p>
<p>在doShutdown()方法中关闭缓存指标监控器，清除缓存实例</p>
<h5><span id="cachecontext">CacheContext</span></h5><p><code>com.alicp.jetcache.anno.support.CacheContext</code>缓存上下文主要为每一个被拦截的请求创建缓存上下文，构建对应的缓存实例，主要代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line">public class CacheContext &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(CacheContext.class);</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;CacheThreadLocal&gt; cacheThreadLocal = new ThreadLocal&lt;CacheThreadLocal&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected CacheThreadLocal initialValue() &#123;</span><br><span class="line">            return new CacheThreadLocal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    /**</span><br><span class="line">     * JetCache 缓存的管理器（包含很多信息）</span><br><span class="line">     */</span><br><span class="line">    private ConfigProvider configProvider;</span><br><span class="line">    /**</span><br><span class="line">     * 缓存的全局配置</span><br><span class="line">     */</span><br><span class="line">    private GlobalCacheConfig globalCacheConfig;</span><br><span class="line">    /**</span><br><span class="line">     * 缓存实例管理器</span><br><span class="line">     */</span><br><span class="line">    protected SimpleCacheManager cacheManager;</span><br><span class="line"></span><br><span class="line">    public CacheContext(ConfigProvider configProvider, GlobalCacheConfig globalCacheConfig) &#123;</span><br><span class="line">        this.globalCacheConfig = globalCacheConfig;</span><br><span class="line">        this.configProvider = configProvider;</span><br><span class="line">        cacheManager = configProvider.getCacheManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CacheInvokeContext createCacheInvokeContext(ConfigMap configMap) &#123;</span><br><span class="line">    	// 创建一个本次调用的上下文</span><br><span class="line">        CacheInvokeContext c = newCacheInvokeContext();</span><br><span class="line">        // 添加一个函数，后续用于获取缓存实例</span><br><span class="line">        // 根据注解配置信息获取缓存实例对象，不存在则创建并设置到缓存注解配置类中</span><br><span class="line">        c.setCacheFunction((invokeContext, cacheAnnoConfig) -&gt; &#123;</span><br><span class="line">            Cache cache = cacheAnnoConfig.getCache();</span><br><span class="line">            if (cache == null) &#123;</span><br><span class="line">                if (cacheAnnoConfig instanceof CachedAnnoConfig) &#123; // 缓存注解</span><br><span class="line">                    // 根据配置创建一个缓存实例对象，通过 CacheBuilder</span><br><span class="line">                    cache = createCacheByCachedConfig((CachedAnnoConfig) cacheAnnoConfig, invokeContext);</span><br><span class="line">                &#125; else if ((cacheAnnoConfig instanceof CacheInvalidateAnnoConfig) || (cacheAnnoConfig instanceof CacheUpdateAnnoConfig)) &#123; // 更新/使失效缓存注解</span><br><span class="line">                    CacheInvokeConfig cacheDefineConfig = configMap.getByCacheName(cacheAnnoConfig.getArea(), cacheAnnoConfig.getName());</span><br><span class="line">                    if (cacheDefineConfig == null) &#123;</span><br><span class="line">                        String message = &quot;can&#x27;t find @Cached definition with area=&quot; + cacheAnnoConfig.getArea()</span><br><span class="line">                                + &quot; name=&quot; + cacheAnnoConfig.getName() +</span><br><span class="line">                                &quot;, specified in &quot; + cacheAnnoConfig.getDefineMethod();</span><br><span class="line">                        CacheConfigException e = new CacheConfigException(message);</span><br><span class="line">                        logger.error(&quot;Cache operation aborted because can&#x27;t find @Cached definition&quot;, e);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cache = createCacheByCachedConfig(cacheDefineConfig.getCachedAnnoConfig(), invokeContext);</span><br><span class="line">                &#125;</span><br><span class="line">                cacheAnnoConfig.setCache(cache);</span><br><span class="line">            &#125;</span><br><span class="line">            return cache;</span><br><span class="line">        &#125;);</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Cache createCacheByCachedConfig(CachedAnnoConfig ac, CacheInvokeContext invokeContext) &#123;</span><br><span class="line">    	// 缓存区域</span><br><span class="line">        String area = ac.getArea();</span><br><span class="line">        // 缓存实例名称</span><br><span class="line">        String cacheName = ac.getName();</span><br><span class="line">        if (CacheConsts.isUndefined(cacheName)) &#123; // 没有定义缓存实例名称</span><br><span class="line"></span><br><span class="line">        	// 生成缓存实例名称：类名+方法名+(参数类型)</span><br><span class="line">            cacheName = configProvider.createCacheNameGenerator(invokeContext.getHiddenPackages())</span><br><span class="line">                    .generateCacheName(invokeContext.getMethod(), invokeContext.getTargetObject());</span><br><span class="line">        &#125;</span><br><span class="line">        // 创建缓存实例对象</span><br><span class="line">        Cache cache = __createOrGetCache(ac, area, cacheName);</span><br><span class="line">        return cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Deprecated</span><br><span class="line">    public &lt;K, V&gt; Cache&lt;K, V&gt; getCache(String cacheName) &#123;</span><br><span class="line">        return getCache(CacheConsts.DEFAULT_AREA, cacheName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Deprecated</span><br><span class="line">    public &lt;K, V&gt; Cache&lt;K, V&gt; getCache(String area, String cacheName) &#123;</span><br><span class="line">        Cache cache = cacheManager.getCacheWithoutCreate(area, cacheName);</span><br><span class="line">        return cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Cache __createOrGetCache(CachedAnnoConfig cachedAnnoConfig, String area, String cacheName) &#123;</span><br><span class="line">    	// 缓存名称拼接</span><br><span class="line">        String fullCacheName = area + &quot;_&quot; + cacheName;</span><br><span class="line">        // 从缓存实例管理器中根据缓存区域和缓存实例名称获取缓存实例</span><br><span class="line">        Cache cache = cacheManager.getCacheWithoutCreate(area, cacheName);</span><br><span class="line">        if (cache == null) &#123;</span><br><span class="line">            synchronized (this) &#123; // 加锁</span><br><span class="line">                // 再次确认</span><br><span class="line">                cache = cacheManager.getCacheWithoutCreate(area, cacheName);</span><br><span class="line">                if (cache == null) &#123;</span><br><span class="line">                    /*</span><br><span class="line">                     * 缓存区域的名称是否作为缓存 key 名称前缀，默认为 true ，我一般设置为 false</span><br><span class="line">                     */</span><br><span class="line">                    if (globalCacheConfig.isAreaInCacheName()) &#123;</span><br><span class="line">                        // for compatible reason, if we use default configuration, the prefix should same to that version &lt;=2.4.3</span><br><span class="line">                        cache = buildCache(cachedAnnoConfig, area, fullCacheName);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 构建一个缓存实例</span><br><span class="line">                        cache = buildCache(cachedAnnoConfig, area, cacheName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    cacheManager.putCache(area, cacheName, cache);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Cache buildCache(CachedAnnoConfig cachedAnnoConfig, String area, String cacheName) &#123;</span><br><span class="line">        Cache cache;</span><br><span class="line">        if (cachedAnnoConfig.getCacheType() == CacheType.LOCAL) &#123; // 本地缓存</span><br><span class="line">            cache = buildLocal(cachedAnnoConfig, area);</span><br><span class="line">        &#125; else if (cachedAnnoConfig.getCacheType() == CacheType.REMOTE) &#123; // 远程缓存</span><br><span class="line">            cache = buildRemote(cachedAnnoConfig, area, cacheName);</span><br><span class="line">        &#125; else &#123; // 两级缓存</span><br><span class="line">        	// 构建本地缓存实例</span><br><span class="line">            Cache local = buildLocal(cachedAnnoConfig, area);</span><br><span class="line">            // 构建远程缓存实例</span><br><span class="line">            Cache remote = buildRemote(cachedAnnoConfig, area, cacheName);</span><br><span class="line">            // 两级缓存时是否单独设置了本地缓存失效时间 localExpire</span><br><span class="line">            boolean useExpireOfSubCache = cachedAnnoConfig.getLocalExpire() &gt; 0;</span><br><span class="line">            // 创建一个两级缓存CacheBuilder</span><br><span class="line">            cache = MultiLevelCacheBuilder.createMultiLevelCacheBuilder()</span><br><span class="line">                    .expireAfterWrite(remote.config().getExpireAfterWriteInMillis(), TimeUnit.MILLISECONDS)</span><br><span class="line">                    .addCache(local, remote)</span><br><span class="line">                    .useExpireOfSubCache(useExpireOfSubCache)</span><br><span class="line">                    .cacheNullValue(cachedAnnoConfig.isCacheNullValue())</span><br><span class="line">                    .buildCache();</span><br><span class="line">        &#125;</span><br><span class="line">        // 设置缓存刷新策略</span><br><span class="line">        cache.config().setRefreshPolicy(cachedAnnoConfig.getRefreshPolicy());</span><br><span class="line">        // 将 cache 封装成 CacheHandlerRefreshCache，也就是 RefreshCache 类型</span><br><span class="line">        // 后续添加刷新任务时会判断是否为 RefreshCache 类型，然后决定是否执行 addOrUpdateRefreshTask 方法，添加刷新任务，没有刷新策略不会添加</span><br><span class="line">        cache = new CacheHandler.CacheHandlerRefreshCache(cache);</span><br><span class="line"></span><br><span class="line">        // 设置缓存未命中时，JVM是否只允许一个线程执行方法，其他线程等待，全局配置默认为false</span><br><span class="line">        cache.config().setCachePenetrationProtect(globalCacheConfig.isPenetrationProtect());</span><br><span class="line">        PenetrationProtectConfig protectConfig = cachedAnnoConfig.getPenetrationProtectConfig();</span><br><span class="line">        if (protectConfig != null) &#123; // 方法的@CachePenetrationProtect注解</span><br><span class="line">            cache.config().setCachePenetrationProtect(protectConfig.isPenetrationProtect());</span><br><span class="line">            cache.config().setPenetrationProtectTimeout(protectConfig.getPenetrationProtectTimeout());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (configProvider.getCacheMonitorManager() != null) &#123;</span><br><span class="line">        	// 添加监控统计配置</span><br><span class="line">            configProvider.getCacheMonitorManager().addMonitors(area, cacheName, cache);</span><br><span class="line">        &#125;</span><br><span class="line">        return cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Cache buildRemote(CachedAnnoConfig cachedAnnoConfig, String area, String cacheName) &#123;</span><br><span class="line">        // 获取缓存区域对应的 CacheBuilder 构造器</span><br><span class="line">        ExternalCacheBuilder cacheBuilder = (ExternalCacheBuilder) globalCacheConfig.getRemoteCacheBuilders().get(area);</span><br><span class="line">        if (cacheBuilder == null) &#123;</span><br><span class="line">            throw new CacheConfigException(&quot;no remote cache builder: &quot; + area);</span><br><span class="line">        &#125;</span><br><span class="line">        // 克隆一个 CacheBuilder 构造器，因为不同缓存实例有不同的配置</span><br><span class="line">        cacheBuilder = (ExternalCacheBuilder) cacheBuilder.clone();</span><br><span class="line"></span><br><span class="line">        if (cachedAnnoConfig.getExpire() &gt; 0 ) &#123;</span><br><span class="line">        	// 设置失效时间</span><br><span class="line">            cacheBuilder.expireAfterWrite(cachedAnnoConfig.getExpire(), cachedAnnoConfig.getTimeUnit());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 设置缓存 key 的前缀</span><br><span class="line">        if (cacheBuilder.getConfig().getKeyPrefix() != null) &#123;</span><br><span class="line">            // 配置文件中配置了 prefix，则设置为 prefix+cacheName</span><br><span class="line">            cacheBuilder.setKeyPrefix(cacheBuilder.getConfig().getKeyPrefix() + cacheName);</span><br><span class="line">        &#125; else &#123; // 设置为 cacheName</span><br><span class="line">            cacheBuilder.setKeyPrefix(cacheName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!CacheConsts.isUndefined(cachedAnnoConfig.getKeyConvertor())) &#123; // 如果注解中设置了Key的转换方式则替换，否则还是使用全局的</span><br><span class="line">        	// 设置 key 的转换器，只支持 FASTJSON</span><br><span class="line">            cacheBuilder.setKeyConvertor(configProvider.parseKeyConvertor(cachedAnnoConfig.getKeyConvertor()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (!CacheConsts.isUndefined(cachedAnnoConfig.getSerialPolicy())) &#123;</span><br><span class="line">        	// 缓存数据保存至远程需要进行编码和解码，所以这里设置其编码和解码方式，KRYO 和 JAVA 可选择</span><br><span class="line">            cacheBuilder.setValueEncoder(configProvider.parseValueEncoder(cachedAnnoConfig.getSerialPolicy()));</span><br><span class="line">            cacheBuilder.setValueDecoder(configProvider.parseValueDecoder(cachedAnnoConfig.getSerialPolicy()));</span><br><span class="line">        &#125;</span><br><span class="line">        // 设置是否缓存 null 值</span><br><span class="line">        cacheBuilder.setCacheNullValue(cachedAnnoConfig.isCacheNullValue());</span><br><span class="line">        return cacheBuilder.buildCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Cache buildLocal(CachedAnnoConfig cachedAnnoConfig, String area) &#123;</span><br><span class="line">    	// 获取缓存区域对应的 CacheBuilder 构造器</span><br><span class="line">        EmbeddedCacheBuilder cacheBuilder = (EmbeddedCacheBuilder) globalCacheConfig.getLocalCacheBuilders().get(area);</span><br><span class="line">        if (cacheBuilder == null) &#123;</span><br><span class="line">            throw new CacheConfigException(&quot;no local cache builder: &quot; + area);</span><br><span class="line">        &#125;</span><br><span class="line">        // 克隆一个 CacheBuilder 构造器，因为不同缓存实例有不同的配置</span><br><span class="line">        cacheBuilder = (EmbeddedCacheBuilder) cacheBuilder.clone();</span><br><span class="line"></span><br><span class="line">        if (cachedAnnoConfig.getLocalLimit() != CacheConsts.UNDEFINED_INT) &#123;</span><br><span class="line">            // 本地缓存数量限制</span><br><span class="line">            cacheBuilder.setLimit(cachedAnnoConfig.getLocalLimit());</span><br><span class="line">        &#125;</span><br><span class="line">        if (cachedAnnoConfig.getCacheType() == CacheType.BOTH &amp;&amp; cachedAnnoConfig.getLocalExpire() &gt; 0) &#123;</span><br><span class="line">        	// 设置本地缓存失效时间，前提是多级缓存，一般和远程缓存保持一致不设置</span><br><span class="line">            cacheBuilder.expireAfterWrite(cachedAnnoConfig.getLocalExpire(), cachedAnnoConfig.getTimeUnit());</span><br><span class="line">        &#125; else if (cachedAnnoConfig.getExpire() &gt; 0) &#123;</span><br><span class="line">        	// 设置失效时间</span><br><span class="line">            cacheBuilder.expireAfterWrite(cachedAnnoConfig.getExpire(), cachedAnnoConfig.getTimeUnit());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!CacheConsts.isUndefined(cachedAnnoConfig.getKeyConvertor())) &#123;</span><br><span class="line">            cacheBuilder.setKeyConvertor(configProvider.parseKeyConvertor(cachedAnnoConfig.getKeyConvertor()));</span><br><span class="line">        &#125;</span><br><span class="line">        // 设置是否缓存 null 值</span><br><span class="line">        cacheBuilder.setCacheNullValue(cachedAnnoConfig.isCacheNullValue());</span><br><span class="line">        // 构建一个缓存实例</span><br><span class="line">        return cacheBuilder.buildCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected CacheInvokeContext newCacheInvokeContext() &#123;</span><br><span class="line">        return new CacheInvokeContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createCacheInvokeContext</code>方法返回一个本次调用的上下文CacheInvokeContext，为这个上下文设置缓存函数，用于获取或者构建缓存实例，这个函数在CacheHandler中会被调用，我们来看看这个函数的处理逻辑：有两个入参，分别为本次调用的上下文和缓存注解的配置信息</p>
<p>首先从缓存注解的配置信息中获取缓存实例，如果不为null则直接返回，否则调用<code>createCacheByCachedConfig</code>方法，根据配置通过CacheBuilder构造器创建一个缓存实例对象</p>
<p><code>createCacheByCachedConfig</code>方法：</p>
<ol>
<li>如果没有定义缓存实例名称（@Cached注解中的name配置），则生成<code>类名+方法名+(参数类型)</code>作为缓存实例名称</li>
<li>然后调用<code>__createOrGetCache</code>方法</li>
</ol>
<p><code>__createOrGetCache</code>方法：</p>
<ol>
<li>通过缓存实例管理器SimpleCacheManager根据缓存区域area和缓存实例名称cacheName获取缓存实例对象，如果不为null则直接返回，判断缓存实例对象是否为null为进行两次确认，第二次会给当前CacheContext加锁进行判断，避免线程不安全</li>
<li>缓存实例对象还是为null的话，先判断缓存区域area是否添加至缓存实例名称中，是的话”area_cacheName”为缓存实例名称，然后调用<code>buildCache</code>方法创建一个缓存实例对象</li>
</ol>
<p><code>buildCache</code>方法：根据缓存实例类型构建不同的缓存实例对象，处理逻辑如下：</p>
<ol>
<li>CacheType为<code>LOCAL</code>则调用<code>buildLocal</code>方法：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.1. 从GlobalCacheConfig全局配置的localCacheBuilders（保存本地缓存CacheBuilder构造器的集合）中的获取本地缓存该缓存区域的构造器，在之前讲到的&#x27;JetCacheAutoConfiguration自动配置&#x27;中有说到过，会将初始化好的构造器从AutoConfigureBeans中添加至GlobalCacheConfig中</span><br><span class="line"></span><br><span class="line">1.2. 克隆一个 CacheBuilder 构造器，因为不同缓存实例有不同的配置</span><br><span class="line"></span><br><span class="line">1.3. 将缓存注解的配置信息设置到构造器中，有以下配置：</span><br><span class="line"></span><br><span class="line">   - 如果配置了localLimit，则设置本地缓存最大数量limit的值</span><br><span class="line"></span><br><span class="line">   - 如果CacheType为BOTH并且配置了localExpire（大于0），则设置有效时间expireAfterWrite的值为localExpire，否则如果配置的expire大于0，则设置其值为expire</span><br><span class="line"></span><br><span class="line">   - 如果配置了keyConvertor，则根据该值生成一个转换函数，没有配置的话在初始化构造器的时候根据全局配置可能已经生成了一个转换函数（我一般在全局配置中设置）</span><br><span class="line"></span><br><span class="line">   - 设置是否缓存null值</span><br><span class="line"></span><br><span class="line">1.4. 通过调用构造器的buildCache()方法构建一个缓存实例对象，该方法在之前讲到的&#x27;CacheBuilder构造器&#x27;中有分析过</span><br></pre></td></tr></table></figure>

<ol>
<li>CacheType为<code>REMOTE</code>则调用<code>buildRemote</code>方法：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.1. 从GlobalCacheConfig全局配置的remoteCacheBuilders（保存远程缓存CacheBuilder构造器的集合）中的获取远程缓存该缓存区域的构造器</span><br><span class="line"></span><br><span class="line">1.2. 克隆一个 CacheBuilder 构造器，因为不同缓存实例有不同的配置</span><br><span class="line"></span><br><span class="line">1.3. 将缓存注解的配置信息设置到构造器中，有以下配置：</span><br><span class="line"></span><br><span class="line">   - 如果配置了expire，则设置远程缓存有效时间expireAfterWrite的值</span><br><span class="line"></span><br><span class="line">   - 如果全局设置远程缓存的缓存key的前缀keyPrefix，则设置缓存key的前缀为&quot;keyPrefix+cacheName&quot;，否则我为&quot;cacheName&quot;</span><br><span class="line"></span><br><span class="line">   - 如果配置了keyConvertor，则根据该值生成一个转换函数，没有配置的话在初始化构造器的时候根据全局配置可能已经生成了一个转换函数（我一般在全局配置中设置）</span><br><span class="line"></span><br><span class="line">   - 如果设置了serialPolicy，则根据该值生成编码和解码函数，没有配置的话在初始化构造器的时候根据全局配置可能已经生成了编码函数和解码函数（我一般在全局配置中设置）</span><br><span class="line"></span><br><span class="line">   - 设置是否缓存null值</span><br><span class="line"></span><br><span class="line">1.4. 通过调用构造器的buildCache()方法构建一个缓存实例对象</span><br></pre></td></tr></table></figure>

<ol>
<li>CacheType为<code>BOTH</code>则调用<code>buildLocal</code>方法构建本地缓存实例，调用<code>buildRemote</code>方法构建远程缓存实例：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.1. 创建一个MultiLevelCacheBuilder构造器</span><br><span class="line"></span><br><span class="line">1.2. 设置有效时间为远程缓存的有效时间、添加local和remote缓存实例、设置是否单独配置了本地缓存的失效时间（是否有配置localExpire）、设置是否缓存null值</span><br><span class="line"></span><br><span class="line">1.3. 通过调用构造器的buildCache()方法构建一个缓存实例对象</span><br></pre></td></tr></table></figure>

<ol>
<li>设置刷新策略RefreshPolicy，没有的话为null</li>
<li>将缓存实例对象封装成CacheHandlerRefreshCache对象，用于后续的添加刷新任务，在之前的’AbstractCache抽象类’有讲到</li>
<li>设置是否开启缓存未命中时加载方法的保护模式，全局默认为false</li>
<li>将缓存实例添加至监控管理器中</li>
</ol>
<h5><span id="jetcacheinterceptor">JetCacheInterceptor</span></h5><p>被拦截后的处理在<code>com.alicp.jetcache.anno.aop.JetCacheInterceptor</code>中，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">public class JetCacheInterceptor implements MethodInterceptor, ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(JetCacheInterceptor.class);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 缓存实例注解信息</span><br><span class="line">     */</span><br><span class="line">    @Autowired</span><br><span class="line">    private ConfigMap cacheConfigMap;</span><br><span class="line">    /**</span><br><span class="line">     * Spring 上下文</span><br><span class="line">     */</span><br><span class="line">    private ApplicationContext applicationContext;</span><br><span class="line">    /**</span><br><span class="line">     * 缓存的全局配置</span><br><span class="line">     */</span><br><span class="line">    private GlobalCacheConfig globalCacheConfig;</span><br><span class="line">    /**</span><br><span class="line">     * JetCache 缓存的管理器（包含很多信息）</span><br><span class="line">     */</span><br><span class="line">    ConfigProvider configProvider;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        this.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(final MethodInvocation invocation) throws Throwable &#123;</span><br><span class="line">        if (configProvider == null) &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 这里会获取到 SpringConfigProvider 可查看 &#123;@link com.alicp.jetcache.autoconfigure.JetCacheAutoConfiguration&#125;</span><br><span class="line">             */</span><br><span class="line">            configProvider = applicationContext.getBean(ConfigProvider.class);</span><br><span class="line">        &#125;</span><br><span class="line">        if (configProvider != null &amp;&amp; globalCacheConfig == null) &#123;</span><br><span class="line">            globalCacheConfig = configProvider.getGlobalCacheConfig();</span><br><span class="line">        &#125;</span><br><span class="line">        if (globalCacheConfig == null || !globalCacheConfig.isEnableMethodCache()) &#123;</span><br><span class="line">            return invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取被拦截的方法</span><br><span class="line">        Method method = invocation.getMethod();</span><br><span class="line">        // 获取被拦截的对象</span><br><span class="line">        Object obj = invocation.getThis();</span><br><span class="line">        CacheInvokeConfig cac = null;</span><br><span class="line">        if (obj != null) &#123;</span><br><span class="line">        	// 获取改方法的Key(方法所在类名+方法名+(参数类型)+方法返回类型+_被拦截的类名)</span><br><span class="line">            String key = CachePointcut.getKey(method, obj.getClass());</span><br><span class="line">            // 获取该方法的缓存注解信息，在 Pointcut 中已经对注解进行解析并放入 ConfigMap 中</span><br><span class="line">            cac  = cacheConfigMap.getByMethodInfo(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(logger.isTraceEnabled())&#123;</span><br><span class="line">            logger.trace(&quot;JetCacheInterceptor invoke. foundJetCacheConfig=&#123;&#125;, method=&#123;&#125;.&#123;&#125;(), targetClass=&#123;&#125;&quot;,</span><br><span class="line">                    cac != null,</span><br><span class="line">                    method.getDeclaringClass().getName(),</span><br><span class="line">                    method.getName(),</span><br><span class="line">                    invocation.getThis() == null ? null : invocation.getThis().getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 无缓存相关注解配置信息表明无须缓存，直接执行该方法</span><br><span class="line">        if (cac == null || cac == CacheInvokeConfig.getNoCacheInvokeConfigInstance()) &#123;</span><br><span class="line">            return invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 为本次调用创建一个上下文对象，包含对应的缓存实例</span><br><span class="line">        CacheInvokeContext context = configProvider.getCacheContext().createCacheInvokeContext(cacheConfigMap);</span><br><span class="line">        context.setTargetObject(invocation.getThis());</span><br><span class="line">        context.setInvoker(invocation::proceed);</span><br><span class="line">        context.setMethod(method);</span><br><span class="line">        context.setArgs(invocation.getArguments());</span><br><span class="line">        context.setCacheInvokeConfig(cac);</span><br><span class="line">        context.setHiddenPackages(globalCacheConfig.getHiddenPackages());</span><br><span class="line">        // 继续往下执行</span><br><span class="line">        return CacheHandler.invoke(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCacheConfigMap(ConfigMap cacheConfigMap) &#123;</span><br><span class="line">        this.cacheConfigMap = cacheConfigMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>ConfigMap</code>中获取被拦截的方法对象的缓存配置信息，如果没有则直接执行该方法，否则继续往下执行</p>
<p>根据<code>CacheContext</code>对象（SpringCacheContext，因为在之前讲到的’JetCacheAutoConfiguration自动配置’中有说到注入的是SpringConfigProvider对象，在其初始化方法中调用newContext()方法生成SpringCacheContext）调用其<code>createCacheInvokeContext</code>方法为本次调用创建一个上下文<code>CacheInvokeContext</code>，并设置获取缓存实例函数，具体实现逻辑查看上面讲到的<code>CacheContext</code></p>
<p>设置本次调用上下文的targetObject为被拦截对象，invoker为被拦截对象的调用器，method为被拦截方法，args为方法入参，cacheInvokeConfig为缓存配置信息，hiddenPackages为缓存实例名称需要截断的包名</p>
<p>通过CacheHandler的invoke方法继续往下执行</p>
<h5><span id="cachehandler">CacheHandler</span></h5><p><code>com.alicp.jetcache.anno.method.CacheHandler</code>用于JetCache处理被拦截的方法，部分代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">public class CacheHandler implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">	public static Object invoke(CacheInvokeContext context) throws Throwable &#123;</span><br><span class="line">		if (context.getCacheInvokeConfig().isEnableCacheContext()) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				CacheContextSupport._enable();</span><br><span class="line">				return doInvoke(context);</span><br><span class="line">			&#125; finally &#123;</span><br><span class="line">				CacheContextSupport._disable();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return doInvoke(context);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static Object doInvoke(CacheInvokeContext context) throws Throwable &#123;</span><br><span class="line">		// 获取缓存实例配置</span><br><span class="line">		CacheInvokeConfig cic = context.getCacheInvokeConfig();</span><br><span class="line">		// 获取注解配置信息</span><br><span class="line">		CachedAnnoConfig cachedConfig = cic.getCachedAnnoConfig();</span><br><span class="line">		if (cachedConfig != null &amp;&amp; (cachedConfig.isEnabled() || CacheContextSupport._isEnabled())) &#123;</span><br><span class="line">			// 经过缓存中获取结果</span><br><span class="line">			return invokeWithCached(context);</span><br><span class="line">		&#125; else if (cic.getInvalidateAnnoConfigs() != null || cic.getUpdateAnnoConfig() != null) &#123;</span><br><span class="line">			// 根据结果删除或者更新缓存</span><br><span class="line">			return invokeWithInvalidateOrUpdate(context);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			// 执行该方法</span><br><span class="line">			return invokeOrigin(context);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static Object invokeWithCached(CacheInvokeContext context) throws Throwable &#123;</span><br><span class="line">		// 获取本地调用的上下文</span><br><span class="line">		CacheInvokeConfig cic = context.getCacheInvokeConfig();</span><br><span class="line">		// 获取注解配置信息</span><br><span class="line">		CachedAnnoConfig cac = cic.getCachedAnnoConfig();</span><br><span class="line">		// 获取缓存实例对象（不存在则会创建并设置到 cac 中）</span><br><span class="line">		// 可在 JetCacheInterceptor 创建本次调用的上下文时，调用 createCacheInvokeContext(cacheConfigMap) 方法中查看详情</span><br><span class="line">		Cache cache = context.getCacheFunction().apply(context, cac);</span><br><span class="line">		if (cache == null) &#123;</span><br><span class="line">			logger.error(&quot;no cache with name: &quot; + context.getMethod());</span><br><span class="line">			// 无缓存实例对象，执行原有方法</span><br><span class="line">			return invokeOrigin(context);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 生成缓存 Key 对象（注解中没有配置的话就是入参，没有入参则为 &quot;_$JETCACHE_NULL_KEY$_&quot; ）</span><br><span class="line">		Object key = ExpressionUtil.evalKey(context, cic.getCachedAnnoConfig());</span><br><span class="line">		if (key == null) &#123;</span><br><span class="line">			 // 生成缓存 Key 失败则执行原方法，并记录 CacheLoadEvent 事件</span><br><span class="line">			return loadAndCount(context, cache, key);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * 根据配置的 condition 来决定是否走缓存</span><br><span class="line">		 * 缓存注解中没有配置 condition 表示所有请求都走缓存</span><br><span class="line">		 * 配置了 condition 表示满足条件的才走缓存</span><br><span class="line">		 */</span><br><span class="line">		if (!ExpressionUtil.evalCondition(context, cic.getCachedAnnoConfig())) &#123;</span><br><span class="line">			// 不满足 condition 则直接执行原方法，并记录 CacheLoadEvent 事件</span><br><span class="line">			return loadAndCount(context, cache, key);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			// 创建一个执行原有方法的函数</span><br><span class="line">			CacheLoader loader = new CacheLoader() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public Object load(Object k) throws Throwable &#123;</span><br><span class="line">					Object result = invokeOrigin(context);</span><br><span class="line">					context.setResult(result);</span><br><span class="line">					return result;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				@Override</span><br><span class="line">				public boolean vetoCacheUpdate() &#123;</span><br><span class="line">					// 本次执行原方法后是否需要更新缓存</span><br><span class="line">					return !ExpressionUtil.evalPostCondition(context, cic.getCachedAnnoConfig());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			// 获取结果</span><br><span class="line">			Object result = cache.computeIfAbsent(key, loader);</span><br><span class="line">			return result;</span><br><span class="line">		&#125; catch (CacheInvokeException e) &#123;</span><br><span class="line">			throw e.getCause();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static Object loadAndCount(CacheInvokeContext context, Cache cache, Object key) throws Throwable &#123;</span><br><span class="line">		long t = System.currentTimeMillis();</span><br><span class="line">		Object v = null;</span><br><span class="line">		boolean success = false;</span><br><span class="line">		try &#123;</span><br><span class="line">			// 调用原有方法</span><br><span class="line">			v = invokeOrigin(context);</span><br><span class="line">			success = true;</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			t = System.currentTimeMillis() - t;</span><br><span class="line">			// 发送 CacheLoadEvent 事件</span><br><span class="line">			CacheLoadEvent event = new CacheLoadEvent(cache, t, key, v, success);</span><br><span class="line">			while (cache instanceof ProxyCache) &#123;</span><br><span class="line">				cache = ((ProxyCache) cache).getTargetCache();</span><br><span class="line">			&#125;</span><br><span class="line">			if (cache instanceof AbstractCache) &#123;</span><br><span class="line">				((AbstractCache) cache).notify(event);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return v;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static Object invokeOrigin(CacheInvokeContext context) throws Throwable &#123;</span><br><span class="line">		// 执行被拦截的方法</span><br><span class="line">		return context.getInvoker().invoke();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接查看<code>invokeWithCached</code>方法：</p>
<ol>
<li>获取缓存注解信息</li>
<li>根据本地调用的上下文CacheInvokeContext获取缓存实例对象（调用其cacheFunction函数），在CacheContext中有讲到</li>
<li>如果缓存实例不存在则直接调用invokeOrigin方法，执行被拦截的对象的调用器</li>
<li>根据本次调用的上下文CacheInvokeContext生成缓存key，根据配置的缓存key的SpEL表达式生成，如果没有配置则返回入参对象，如果没有对象则返回”_ $JETCACHE_NULL_KEY$_”</li>
<li>根据配置condition表达式判断是否需要走缓存</li>
<li>创建一个<code>CacheLoader</code>对象，用于执行被拦截的对象的调用器，也就是加载原有方法</li>
<li>调用缓存实例的<code>computeIfAbsent(key, loader)</code>方法获取结果，这个方法的处理过程可查看’缓存API’这一小节</li>
</ol>
<p>至此结束！！！😄😄😄</p>
<p>文章转自：<a href="https://www.cnblogs.com/lifullmoon/p/13854158.html">https://www.cnblogs.com/lifullmoon/p/13854158.html</a></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">jlynet</div><div class="post-copyright__author_desc">--个人博客</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://jlynet.github.io/2021/10/01/etCache-%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://jlynet.github.io/2021/10/01/etCache-%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/')">etCache 缓存框架的使用以及源码分析</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/img/weixin.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/weixin.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://jlynet.github.io/2021/10/01/etCache-%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=etCache 缓存框架的使用以及源码分析&amp;url=https://jlynet.github.io/2021/10/01/etCache-%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jlynet.github.io" target="_blank">爱上猫的小鱼儿</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>技术笔记<span class="tagsPageCount">17</span></a><a class="post-meta__box__tags" href="/tags/java/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>java<span class="tagsPageCount">4</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/img/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/09/29/%E5%90%84%E7%A7%8D%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">各种开源协议介绍</div></div></a></div><div class="next-post pull-right"><a href="/2021/10/09/Docker-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Docker 私有仓库搭建</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2021/07/30/Arthas%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/" title="Arthas安装使用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-07-30</div><div class="title">Arthas安装使用</div></div></a></div><div><a href="/2021/08/16/PHP%E5%92%8CJava%E4%B8%AD%E7%9A%84SHA256/" title="PHP和Java中的SHA256"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-08-16</div><div class="title">PHP和Java中的SHA256</div></div></a></div><div><a href="/2021/10/21/%E8%A7%A3%E5%86%B3SpringBoot-2-3-MultipartFile%E4%B8%BA%E7%A9%BA%E7%9A%84%E9%97%AE%E9%A2%98/" title="解决SpringBoot 2.3 MultipartFile为空的问题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-10-21</div><div class="title">解决SpringBoot 2.3 MultipartFile为空的问题</div></div></a></div><div><a href="/2021/10/09/Docker-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/" title="Docker 私有仓库搭建"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-10-09</div><div class="title">Docker 私有仓库搭建</div></div></a></div><div><a href="/2022/06/30/GitHub%E5%8D%9A%E5%AE%A2hexo%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%AE%BE%E7%BD%AESSH%E5%AF%86%E9%92%A5/" title="GitHub博客hexo建站之设置SSH密钥"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-06-30</div><div class="title">GitHub博客hexo建站之设置SSH密钥</div></div></a></div><div><a href="/2021/10/18/Linux%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%EF%BC%8C%E8%B7%AF%E7%94%B1%E7%9A%84%E8%BF%BD%E8%B8%AA/" title="Linux网络基础，路由的追踪"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-10-18</div><div class="title">Linux网络基础，路由的追踪</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">技术决定未来....</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">一、简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.1.</span> <span class="toc-text">为什么使用缓存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.</span> <span class="toc-text">使用规范</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">二、如何使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.1.</span> <span class="toc-text">引入maven依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.2.</span> <span class="toc-text">添加配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.3.</span> <span class="toc-text">配置说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.4.</span> <span class="toc-text">注解说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.4.1.</span> <span class="toc-text">@EnableCreateCacheAnnotation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.4.2.</span> <span class="toc-text">@EnableMethodCache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.4.3.</span> <span class="toc-text">@Cached</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.4.4.</span> <span class="toc-text">@CacheInvalidate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.4.5.</span> <span class="toc-text">@CacheUpdate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.4.6.</span> <span class="toc-text">@CacheRefresh</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.4.7.</span> <span class="toc-text">@CachePenetrationProtect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.4.8.</span> <span class="toc-text">@CreateCache</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.5.</span> <span class="toc-text">使用示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">三、源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.1.</span> <span class="toc-text">项目的各个子模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.2.</span> <span class="toc-text">常用注解与变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.3.</span> <span class="toc-text">缓存API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.3.1.</span> <span class="toc-text">Cache接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.3.2.</span> <span class="toc-text">AbstractCache抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.3.3.</span> <span class="toc-text">AbstractEmbeddedCache本地缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">LinkedHashMapCache</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">Cleaner清理器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">3.3.3.3.</span> <span class="toc-text">CaffeineCache</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.3.4.</span> <span class="toc-text">AbstractExternalCache远程缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">RedisCache</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">3.3.4.2.</span> <span class="toc-text">RedisLettuceCache</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.3.5.</span> <span class="toc-text">MultiLevelCache两级缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.3.6.</span> <span class="toc-text">RefreshCache</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.4.</span> <span class="toc-text">解析配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.4.1.</span> <span class="toc-text">初始化构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">AbstractCacheAutoInit</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">EmbeddedCacheAutoInit</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">3.4.1.2.1.</span> <span class="toc-text">LinkedHashMapAutoConfiguration</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">3.4.1.2.2.</span> <span class="toc-text">CaffeineAutoConfiguration</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">ExternalCacheAutoInit</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">3.4.1.3.1.</span> <span class="toc-text">RedisAutoInit</span></a></li><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">3.4.1.3.2.</span> <span class="toc-text">RedisLettuceAutoInit</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.4.2.</span> <span class="toc-text">JetCacheAutoConfiguration自动配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.4.3.</span> <span class="toc-text">CacheBuilder构造器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.5.</span> <span class="toc-text">AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.5.1.</span> <span class="toc-text">启用JetCache</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">@EnableMethodCache</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">@EnableCreateCacheAnnotation</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.5.2.</span> <span class="toc-text">拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">ConfigProvider</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">CacheContext</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">3.5.2.3.</span> <span class="toc-text">JetCacheInterceptor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">3.5.2.4.</span> <span class="toc-text">CacheHandler</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/14/intellij-plugin-license/" title="intellij-plugin-license">intellij-plugin-license</a><time datetime="2024-08-14T01:33:24.000Z" title="发表于 2024-08-14 09:33:24">2024-08-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/29/SoftManageTools/" title="SoftManageTools">SoftManageTools</a><time datetime="2024-07-29T11:32:23.000Z" title="发表于 2024-07-29 19:32:23">2024-07-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/05/Unicode-character-issue-0-to-255/" title="Unicode character issue 0 to 255">Unicode character issue 0 to 255</a><time datetime="2024-06-05T03:16:29.000Z" title="发表于 2024-06-05 11:16:29">2024-06-05</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2022/08/04/HAProxy-%E5%8E%9F%E7%90%86-dash-board-%E5%90%84%E6%8C%87%E6%A0%87%E5%90%AB%E4%B9%89/" title="HAProxy 原理 &amp; dash board 各指标含义">HAProxy 原理 &amp; dash board 各指标含义</a><time datetime="2022-08-04T03:05:01.000Z" title="发表于 2022-08-04 11:05:01">2022-08-04</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2022/06/30/GitHub%E5%8D%9A%E5%AE%A2hexo%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%AE%BE%E7%BD%AESSH%E5%AF%86%E9%92%A5/" title="GitHub博客hexo建站之设置SSH密钥">GitHub博客hexo建站之设置SSH密钥</a><time datetime="2022-06-30T06:27:23.000Z" title="发表于 2022-06-30 14:27:23">2022-06-30</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="jlynet" target="_blank">jlynet</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" href="https://gitee.com/jlynet-openSrc" title="jlynet.cn开源">jlynet.cn开源</a><a class="footer-bar-link" href="https://beian.mps.gov.cn/#/query/webSearch" title="桂公网安备45010302003312号">桂公网安备45010302003312号</a><a class="footer-bar-link" href="https://beian.miit.gov.cn/" title="桂ICP备2024037367号">桂ICP备2024037367号</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">9</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" style="font-size: 0.88rem;">Java 诊断工具 Arthas 入门教程<sup>2</sup></a><a href="/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" style="font-size: 0.88rem;">Java 诊断工具 Arthas 最佳实践<sup>14</sup></a><a href="/tags/Java-%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-Arthas-%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/" style="font-size: 0.88rem;">Java 诊断工具 Arthas 高级命令教程<sup>25</sup></a><a href="/tags/Spring/" style="font-size: 0.88rem;">Spring<sup>1</sup></a><a href="/tags/SpringBoot/" style="font-size: 0.88rem;">SpringBoot<sup>1</sup></a><a href="/tags/Tomcat/" style="font-size: 0.88rem;">Tomcat<sup>1</sup></a><a href="/tags/docker/" style="font-size: 0.88rem;">docker<sup>2</sup></a><a href="/tags/hexo/" style="font-size: 0.88rem;">hexo<sup>3</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>4</sup></a><a href="/tags/linux/" style="font-size: 0.88rem;">linux<sup>8</sup></a><a href="/tags/nginx/" style="font-size: 0.88rem;">nginx<sup>2</sup></a><a href="/tags/php/" style="font-size: 0.88rem;">php<sup>1</sup></a><a href="/tags/shell/" style="font-size: 0.88rem;">shell<sup>6</sup></a><a href="/tags/ssh/" style="font-size: 0.88rem;">ssh<sup>1</sup></a><a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 0.88rem;">中间件<sup>1</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" style="font-size: 0.88rem;">技术笔记<sup>17</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>2</sup></a><a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 0.88rem;">随笔<sup>12</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 jlynet 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>