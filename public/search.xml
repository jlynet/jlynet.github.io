<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>intellij-plugin-license</title>
      <link href="/2024/08/14/intellij-plugin-license/"/>
      <url>/2024/08/14/intellij-plugin-license/</url>
      
        <content type="html"><![CDATA[<p>License<br>END USER LICENSE AGREEMENT (“EULA”)<br>Version 1.1, effective as of January 25, 2024</p><ol><li>DEFINITIONS<br>Capitalised terms used herein shall have the following meaning:<br>Developer – the author of Plugin: 爱上猫的小鱼儿.</li></ol><p>JetBrains – JetBrains s.r.o. with its registered office at Na Hřebenech II 1718/10, Prague, 14000, Czech Republic, registered with the Commercial Register kept by the Municipal Court of Prague, Section C, file 86211, ID.Nr.: 265 02 275.</p><p>JetBrains Affiliate – the subsidiary and/or any associated companies of JetBrains.</p><p>JetBrains Marketplace – any platform operated by JetBrains or a JetBrains Affiliate on which JetBrains or a JetBrains Affiliate markets Plugins for JetBrains Products, including the website <a href="https://plugins.jetbrains.com/">https://plugins.jetbrains.com</a> and/or any other website or other platform, whether named JetBrains Marketplace, JetBrains Plugins Repository, or otherwise.</p><p>JetBrains Product – any software program or service made available by JetBrains.</p><p>Plugin – Plugin for JetBrains Product that Developer makes available under this EULA.</p><p>Plugin Information – the following information and materials:</p><p>a. JetBrains Marketplace Plugin title, tags / category, name(s) of Developer(s), product description, icon, logo or banner images, and any other information related to Plugin;</p><p>b. the metadata, graphics, artwork, images, trademarks, trade names, logos and other descriptive or identifying information and materials associated with Developer or appears in connection with Plugin; and</p><p>c. in the case of a cloud-hosted Plugin, an XML/JSON descriptor of Plugin.</p><p>Plugin Users – users that are able to access and use Plugin concurrently.</p><p>Website – the website available at the domain address: <a href="http://www.mbpolis.com/">http://www.mbpolis.com</a></p><p>You – an individual or an entity concluding this EULA.</p><ol start="2"><li>SUBJECT MATTER OF THE EULA<br>2.1. This EULA is concluded between You and Developer. This EULA regulates your acquisition and use of Plugin made available to You via JetBrains Marketplace. You have to remember that Plugin is licensed, not sold. By downloading, installing or otherwise using Plugin, you agree to the terms of this EULA and agree to be bound by it. If you do not agree to the terms of this EULA, you should not download, install or otherwise use Plugin. If you have downloaded or installed Plugin, you should remove it from your system and destroy all copies.</li></ol><p>2.2. The Plugin is provided under License, which types are described at JetBrains Marketplace. Sharing may be made without fee, with certain functionality limitations, and for a fee, with no functionality limitations. The functionalities of Plugin and their limitations are described on <a href="http://www.mbpolis.com/">http://www.mbpolis.com</a>.</p><p>2.3. You are authorized to use Plugin in accordance with its documentation provided by Developer and for the period of time specified by Developer.</p><p>2.4. If Plugin is a paid Plugin, you must ensure that the maximum number of Plugin Users does not exceed the number of Plugin Users for which you have purchased Plugin.</p><p>2.5. You may not modify, reverse-engineer, decompile, or disassemble Plugin in whole or in part, or create any derivative works from Plugin, or sublicense any rights in Plugin, unless otherwise expressly authorized in writing by Developer.</p><p>2.6. All Plugins are provided to you on an “as is” and “as available” basis without warranties. Use of Plugins is at your own risk.</p><p>2.7. Developer makes no warranty as to Plugin’s use or performance. To the maximum extent permitted by applicable law, developer disclaims all other warranties and conditions, either express or implied, including, but not limited to, implied warranties of merchantability, fitness for a particular purpose, title, and non-infringement, with regard to Plugin, and the provision of or failure to provide support services. Developer does not warrant that Plugin is accurate, reliable, or correct; that Plugin meets your requirements; that Plugin will be available at any particular time or location, uninterrupted, or secure; that any defects or errors will be corrected; or that Plugin is free of viruses or other harmful components.</p><p>2.8. In no event will Developer be liable for any direct or indirect costs, losses, or damages associated with the use of Developer’s Plugin.</p><p>2.9. Developer shall not be liable to you for any lost profits or consequential damages, however caused, and in no event will Developer’s aggregate liability arising out of or related to this agreement or the use of Plugin exceed the fees which you paid for Plugin via JetBrains Marketplace service in the three-month period preceding the claim. This limitation will apply even if Developer has been advised of the possibility of the liability exceeding the amount and notwithstanding any failure of essential purpose of any limited remedy. JetBrains’ liability is excluded in its entirety as JetBrains is not a party to the contractual relationship between Developer and You.</p><p>2.10. You may not use Plugin in any manner that violates any applicable local, national or international law and for any purposes that, in the opinion of Developer, violate this EULA and/or purposes of Developer.</p><p>2.11. Developer reserves the right to discontinue support for Plugin and to change the price, features, specifications, capabilities, functionality, license terms, release date, general availability or other features of Plugin at any time.</p><p>2.12. Plugin is protected by copyright and other intellectual property laws and treaties. Developer or its licensors own all title, copyright and other intellectual property rights to Plugin.</p>]]></content>
      
      
      <categories>
          
          <category> 开源协议 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SoftManageTools</title>
      <link href="/2024/07/29/SoftManageTools/"/>
      <url>/2024/07/29/SoftManageTools/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unicode character issue 0 to 255</title>
      <link href="/2024/06/05/Unicode-character-issue-0-to-255/"/>
      <url>/2024/06/05/Unicode-character-issue-0-to-255/</url>
      
        <content type="html"><![CDATA[<h1><span id="代码实现">代码实现</span></h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">"test.html?name=我是中文aaaa"</span>);</span><br></pre></td></tr></tbody></table></figure><h1><span id="运行容器">运行容器</span></h1><blockquote><p>Tomcat 8.5.100</p></blockquote><h1><span id="出现的错误">出现的错误</span></h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalArgumentException: The Unicode character [Б] at code point [1,041] cannot be encoded as it is outside the permitted range of 0 to 255.</span><br><span class="line">        at org.apache.coyote.http2.HPackHuffman.encode(HPackHuffman.java:452)</span><br><span class="line">        at org.apache.coyote.http2.HpackEncoder.writeHuffmanEncodableValue(HpackEncoder.java:229)</span><br><span class="line">        at org.apache.coyote.http2.HpackEncoder.encode(HpackEncoder.java:191)</span><br><span class="line">        at org.apache.coyote.http2.Http2UpgradeHandler.doWriteHeaders(Http2UpgradeHandler.java:727)</span><br><span class="line">        at org.apache.coyote.http2.Http2UpgradeHandler.writeHeaders(Http2UpgradeHandler.java:680)</span><br><span class="line">        at org.apache.coyote.http2.Stream.writeHeaders(Stream.java:466)</span><br><span class="line">        at org.apache.coyote.http2.StreamProcessor.prepareResponse(StreamProcessor.java:151)</span><br><span class="line">        at org.apache.coyote.AbstractProcessor.action(AbstractProcessor.java:379)</span><br><span class="line">        at org.apache.coyote.Response.action(Response.java:211)</span><br><span class="line">        at org.apache.coyote.Response.sendHeaders(Response.java:440)</span><br><span class="line">        at org.apache.coyote.http2.Http2OutputBuffer.doWrite(Http2OutputBuffer.java:57)</span><br><span class="line">        at org.apache.coyote.Response.doWrite(Response.java:615)</span><br><span class="line">        at org.apache.catalina.connector.OutputBuffer.realWriteBytes(OutputBuffer.java:340)</span><br><span class="line">        at org.apache.catalina.connector.OutputBuffer.flushByteBuffer(OutputBuffer.java:784)</span><br><span class="line">        at org.apache.catalina.connector.OutputBuffer.append(OutputBuffer.java:689)</span><br><span class="line">        at org.apache.catalina.connector.OutputBuffer.writeBytes(OutputBuffer.java:388)</span><br><span class="line">        at org.apache.catalina.connector.OutputBuffer.write(OutputBuffer.java:366)</span><br><span class="line">        at org.apache.catalina.connector.CoyoteOutputStream.write(CoyoteOutputStream.java:96)</span><br></pre></td></tr></tbody></table></figure><h1><span id="解决">解决</span></h1><blockquote><p>参考 <code>https://gitee.com/jlynet-openSrc/jlynet-Tomcat.git</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术笔记 </tag>
            
            <tag> Tomcat </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HAProxy 原理 &amp; dash board 各指标含义</title>
      <link href="/2022/08/04/HAProxy-%E5%8E%9F%E7%90%86-dash-board-%E5%90%84%E6%8C%87%E6%A0%87%E5%90%AB%E4%B9%89/"/>
      <url>/2022/08/04/HAProxy-%E5%8E%9F%E7%90%86-dash-board-%E5%90%84%E6%8C%87%E6%A0%87%E5%90%AB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1><span id="原理">原理</span></h1><ol><li>HAProxy将客户端ip进行Hash计算并保存，由此确保相同IP访问时被转发到同一真实服务器上。</li><li>HAProxy依靠真实服务器发送给客户端的cookie信息进行回话保持。</li><li>HAProxy保存真实服务器的session及服务器标识，实现会话保持功能。</li></ol><p>Frontend 负责client，Backend 负责server</p><h1><span id="dash-board">Dash board</span></h1><p><img src="/2022/08/04/HAProxy-%E5%8E%9F%E7%90%86-dash-board-%E5%90%84%E6%8C%87%E6%A0%87%E5%90%AB%E4%B9%89/5838636e6baeef2e54c7ca7558d7ccab.png" alt="The HAProxy Stats Page"></p><p>rate分了：</p><ol><li>connection rate per second ：clients连接至HAProxy的频率（还没有创建完整的sessions）</li><li>session rate per second：session 作为一个持有端到端连接（client到HAProxy，HAProxy到后端服务器）状态的实体，被创建的速率</li><li>request rate per second：在建立的连接上，HTTP请求被接收的频率</li></ol><h1><span id="session-rate">Session rate</span></h1><p><img src="/2022/08/04/HAProxy-%E5%8E%9F%E7%90%86-dash-board-%E5%90%84%E6%8C%87%E6%A0%87%E5%90%AB%E4%B9%89/a3dffd6021911ebe8a2c1c09452180c9.png" alt="Frontend Session Rate"></p><p>描述client连接到HAProxy的速率。</p><p>Cur： session 作为一个持有端到端连接（client到HAProxy，HAProxy到后端服务器）状态的实体，被创建的速率<br>Max： 同一时刻，使用中的最多session数<br>Limit： 前端每秒可接收的最大session数。设置在 rate-limit sessions. 如果这个限制被超过，多出来的连接将被pending在socket的backlog中（在系统buffer里）</p><h1><span id="sessions">Sessions</span></h1><p><img src="/2022/08/04/HAProxy-%E5%8E%9F%E7%90%86-dash-board-%E5%90%84%E6%8C%87%E6%A0%87%E5%90%AB%E4%B9%89/d62d3b91aa1f5498149ee3537a423e73.png" alt="Frontend Sessions"></p><p>负载均衡器上，使用中的sessions或完整client-to-server连接的数量。</p><p>Cur： 当前建完sessions 数量<br>Max： 最多同时建过的sessions数<br>Limit：最大并发的sessions数，定义在 frontend中的maxconn。达到这个限制后，前端将停止接收新的连接。如果maxconn 没有设置，Limit将和您的配置中global那一节的maxconn 值相同。若这个也没设，那么Limit将基于您的系统（tnnd，在公司呆久了，都变您了）</p><h1><span id="denied">Denied</span></h1><p>基于安全考虑，拒掉的request or response 数量</p><h1><span id="errors">Errors</span></h1><p><img src="/2022/08/04/HAProxy-%E5%8E%9F%E7%90%86-dash-board-%E5%90%84%E6%8C%87%E6%A0%87%E5%90%AB%E4%B9%89/09a677f523174b9fb3a7bae5a61fb8b1.png" alt="Frontend Errors"></p><ul><li>Req：遇到错误的request数量</li><li>Conn：遇到错误的connection数量</li><li>Resp：遇到错误的responds数量<br>Server<br>对frontend而言，只有Status有值</li></ul><p><img src="/2022/08/04/HAProxy-%E5%8E%9F%E7%90%86-dash-board-%E5%90%84%E6%8C%87%E6%A0%87%E5%90%AB%E4%B9%89/60fc37abd9894acad88cf3caea02d18e.png" alt="Frontend Status"></p><p>Status：当Status为OPEN时，frontend处于正常运行状态，并且可以接收traffic。当你执行Runtime API 命令 disable frontend ，你可以disable frontend，这时status将变为STOP。<br>对backend而言，Server 展示了关于 状态、健康程度、各server的权重。</p><p><img src="/2022/08/04/HAProxy-%E5%8E%9F%E7%90%86-dash-board-%E5%90%84%E6%8C%87%E6%A0%87%E5%90%AB%E4%B9%89/44def4c4f3298be4aa2c2cf313c64115.png" alt="Backend Server Status"></p><p>Status：有如下的值</p><table><thead><tr><th>Status</th><th>What it means</th></tr></thead><tbody><tr><td>UP</td><td>The server is reporting as healthy.</td></tr><tr><td>DOWN</td><td>The server is reporting as unhealthy and unable to receive requests.</td></tr><tr><td>NOLB</td><td>You’ve added http-check disable-on-404 to the backend and the health checked URL has returned an HTTP 404 response.</td></tr><tr><td>MAINT</td><td>The server has been disabled or put into maintenance mode.</td></tr><tr><td>DRAIN</td><td>The server has been put into drain mode.</td></tr><tr><td>no check</td><td>Health checks are not enabled for this server.</td></tr></tbody></table><ul><li>LastChk :会有一个值 like L7OK/200 in 1ms。 表示已经执行了一个Layer 7的健康检查，并返回了一个HTTP 200 OK的response，且这一系列动作耗时&lt;=1ms。      若您看到L4OK in 0ms，意味着Haproxy可以和server建立一个 Layer 4 connection</li><li>Wght: traffic被接受的比例，as set by the weight parameter on the server line.</li><li>Act：该server为active（标为Y）还是backup（标为 a -）</li><li>Bck：该server为backup（标为Y） 还是 active（标为 a -）</li><li>Chk： 失败的健康检查数</li><li>Dwn：从UP到DOWN的transitions数量</li><li>Dwntme：server 下线多久了</li></ul><p>：session rate(每秒的连接会话信息)中的指标有cur,max,limit;其中cur表示每秒的当前会话数量；max表示每秒的最大会话数量；limit表示每秒新的会话限制量；sessions(会话信息)，cur:表示当前会话量；max:表示最大会话量；limit: 表示限制会话量；Total:表示总共会话量；</p><p>参考文献：</p><p><a href="https://blog.51cto.com/superleedo/1895570">https://blog.51cto.com/superleedo/1895570</a></p><p><a href="https://developer.aliyun.com/article/243184">https://developer.aliyun.com/article/243184</a></p><p><a href="https://www.haproxy.com/blog/exploring-the-haproxy-stats-page/">https://www.haproxy.com/blog/exploring-the-haproxy-stats-page/</a></p><p>来源： <a href="https://blog.csdn.net/qq_22498427/article/details/108736804">https://blog.csdn.net/qq_22498427/article/details/108736804</a></p>]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术笔记 </tag>
            
            <tag> linux </tag>
            
            <tag> 随笔 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub博客hexo建站之设置SSH密钥</title>
      <link href="/2022/06/30/GitHub%E5%8D%9A%E5%AE%A2hexo%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%AE%BE%E7%BD%AESSH%E5%AF%86%E9%92%A5/"/>
      <url>/2022/06/30/GitHub%E5%8D%9A%E5%AE%A2hexo%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%AE%BE%E7%BD%AESSH%E5%AF%86%E9%92%A5/</url>
      
        <content type="html"><![CDATA[<ul><li><p>我们十分建议大家在玩转GitHub时使用SSH连接。SSH keys是一种鉴定信任电脑的方式，同时不需要输入密码。以下步骤将会教你产生一个SSH keys并把这个公共的密钥添加到你的GitHub账户中。</p><blockquote><p>Tips：我们建议你经常审查你的SSH keys列表并取消那些用了一段时间的账户。</p></blockquote><p><strong>第一步：检查SSH keys</strong> </p><hr><p>首先，我们需要检查你的电脑中是否存在SSH keys。打开Git Bash 并输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al ~/.ssh</span><br><span class="line"># 列出你.ssh目录中的文件（如果存在文件的话）</span><br></pre></td></tr></table></figure><p>检查一下目录列表查看一下是否有 <code>id_rsa.pub</code>  或者 <code>id_dsa.pub</code>. 如果这两个文件都没有，查看第二步。否则，看第三步。</p><p><strong>第二步：创建一个新的SSH key</strong></p><hr><p>为了创建一个新的SSH key，复制粘贴下面的代码，一定要填上你的E-mail地址。默认的设置是非常棒的，所以你当你被提示“Enter a file in which to save the key”，仅仅按回车（<strong>Enter</strong>）继续。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br><span class="line"># 创建一个 ssh key, 用准备好的email作为标签</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]</span><br></pre></td></tr></table></figure><p>接下来，你将会被要求输入密码.</p><blockquote><p>Tips:我们强烈建议输入一个好的，安全的密码，更多信息查看 <a href="https://help.github.com/articles/working-with-ssh-key-passphrases">Working with SSH key passphrases</a>.</p><p>（译者注：这个密码需要记好，后面会用到）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase): [Type a passphrase]</span><br><span class="line">Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></table></figure><p>你将会看到以下提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Your identification has been saved in /c/Users/you/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com</span><br></pre></td></tr></table></figure><p>然后在你的ssh-代理上添加上你的新的密钥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># start the ssh-agent in the background</span><br><span class="line">$ eval &quot;$(ssh-agent -s)&quot;</span><br><span class="line"># Agent pid 59566</span><br><span class="line">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p><strong>第三步：在你的GitHub账户中添加上SSH key</strong></p><hr><p>运行下面的代码把key复制到你的粘贴板中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ clip &lt; ~/.ssh/id_rsa.pub</span><br><span class="line"># Copies the contents of the id_rsa.pub file to your clipboard</span><br></pre></td></tr></table></figure><p>或者，用你最喜欢的编辑器，打开<code>~/.ssh/id_rsa.pub</code> 文件，手动把文件中的内容复制到粘贴板。</p><p>现在有了key的复制版，是时候添加到GitHub中了：</p><p>1.在任意页面的右上角用户栏中，点击 <strong><a href="https://github.com/settings/admin">Account settings</a></strong></p><p><img src="/2022/06/30/GitHub%E5%8D%9A%E5%AE%A2hexo%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%AE%BE%E7%BD%AESSH%E5%AF%86%E9%92%A5/userbar-account-settings.png" alt="Account settings button"><img src="/2022/06/30/GitHub%E5%8D%9A%E5%AE%A2hexo%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%AE%BE%E7%BD%AESSH%E5%AF%86%E9%92%A5/settings-sidebar-ssh-keys.png" alt="SSH Keys menu"></p><p>2.左侧点击 <a href="https://github.com/settings/ssh"><strong>SSH Keys</strong></a>.</p><p>3.点击 <strong>Add SSH key</strong>.</p><p><img src="/2022/06/30/GitHub%E5%8D%9A%E5%AE%A2hexo%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%AE%BE%E7%BD%AESSH%E5%AF%86%E9%92%A5/ssh-add-ssh-key.png" alt="SSH Key button"></p><p>4.在标题框中，添加这个新key的描述标签。例如，如果你使用的是个人的Mac，你可以把这个key叫做“Personal MacBook Air”。</p><p>5.把你的key粘贴在 “Key” 标签下的文本框中.</p><p><img src="/2022/06/30/GitHub%E5%8D%9A%E5%AE%A2hexo%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%AE%BE%E7%BD%AESSH%E5%AF%86%E9%92%A5/ssh-key-paste.png" alt="The key field"></p><p>6.点击 <strong>Add key</strong>.</p><p><img src="/2022/06/30/GitHub%E5%8D%9A%E5%AE%A2hexo%E5%BB%BA%E7%AB%99%E4%B9%8B%E8%AE%BE%E7%BD%AESSH%E5%AF%86%E9%92%A5/ssh-add-key.png" alt="The Add key button"></p><p>7.输入你的GitHub 密码以确认身份.</p><p><strong>第四步：测试everything</strong></p><hr><p>为了确保所有的操作都在工作，现在需要SSHing一下GitHub。当你这么做的时候，你将会被要求输入密码以证实你的行为，就是之前你创建的密码。</p><p>打开Git Bash并输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line"># Attempts to ssh to github</span><br></pre></td></tr></table></figure><p>你可能会看到这样的警告：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#x27;github.com (207.97.227.239)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>不要担心，这必然会发生。这是为了证实你上面提供的终端机器中的fingerprint（指纹），然后输入“yes”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi username! You&#x27;ve successfully authenticated, but GitHub does not</span><br><span class="line">provide shell access.</span><br></pre></td></tr></table></figure><p>如果username是你的名字，那么说明你的SSH key成功安装！不用担心 “shell access” 这件事情，因为你根本用不到。</p><p>如果你收到的消息是”access denied,” 你可以<a href="https://help.github.com/articles/error-permission-denied-publickey">read these instructions for diagnosing the issue</a>.</p><p>如果你是将SSH转换为HTTPS，你将需要更新你的远端仓库中的URLs，更多信息查看<a href="https://help.github.com/articles/changing-a-remote-s-url">Changing a remote’s URL</a>.</p></li></ul><p>翻译原文地址：<a href="https://help.github.com/articles/generating-ssh-keys">https://help.github.com/articles/generating-ssh-keys</a></p>]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术笔记 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/11/17/hello-world/"/>
      <url>/2021/11/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ssh端口转发笔记</title>
      <link href="/2021/10/23/ssh%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/10/23/ssh%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3><span id="ssh端口转发笔记ssh反向代理隧道-动态代理-本地代理">ssh端口转发笔记：ssh反向代理(隧道)、动态代理、本地代理</span></h3><h4><span id="缩略词"><strong>缩略词</strong></span></h4><p><strong>本机</strong>：ssh命令发起方，即运行ssh命令的那台机器。也可简称<strong>客户端</strong><br><strong>远程机</strong>：ssh命令连接到的服务器，一般指运行ssh服务的那台机器。也可简称<strong>服务端</strong><br><strong>本地机群</strong>：能直接与本机通迅的主机集合，包含本机自身。<br><strong>远程机群</strong>： 能直接与远程机通迅的主机集合，包含远程自身。</p><h4><span id="动态代理"><strong>动态代理</strong></span></h4><p>动态代理一般用于代理服务器，应用场景为：本地机群不能直接访问某些地址/端口，但远程机可以。本机通过建立一个指定本机端口，远程机端口不指定（动态）的连接，让本地机群可以通过该连接去访问那些地址（基于socks4和socks5协议）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -o ServerAliveInterval=20 -g -Nf -D 6060 proxy@47.44.161.114               <span class="comment">#动态代理</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>-o ServerAliveInterval=20</strong></td><td>代表心跳包，ssh在一段时间没数据后会把连接给断开。</td></tr><tr><td><strong>-g</strong></td><td>允许其他主机连接到本机端口进行转发。 如果无效，要设置**本机*<em>sshd_config文件:*<em>gatewayports yes</em></em></td></tr><tr><td><strong>-N</strong></td><td>不执行远程命令。 仅做端口转发（仅适用于协议版本2）。</td></tr><tr><td><strong>-f</strong></td><td>将ssh切换到后台</td></tr><tr><td><strong>-D 6060</strong></td><td>指定以本机哪个端口做为转发端口</td></tr><tr><td><strong><a href="mailto:&#x70;&#x72;&#111;&#x78;&#x79;&#64;&#x34;&#55;&#x2e;&#x34;&#x34;&#x2e;&#x31;&#54;&#x31;&#x2e;&#49;&#x31;&#x34;">&#x70;&#x72;&#111;&#x78;&#x79;&#64;&#x34;&#55;&#x2e;&#x34;&#x34;&#x2e;&#x31;&#54;&#x31;&#x2e;&#49;&#x31;&#x34;</a></strong></td><td>以指定帐号连接远程机</td></tr></tbody></table><h4><span id="反向代理"><strong>反向代理</strong></span></h4><p>反向代理一般用于内网穿透，应用场景为：本机在防火墙内，并且防火墙未向外开放本机（或本地网络内其他主机）端口，远程机有向外开放的可用端口，本机通过建立一个指定本机（或本地网络内其他主机）端口和远程机端口的连接（也可以理解成端口映射），让外部应用可以通过远程机端口访问本机（或本地网络内其他主机）端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -o ServerAliveInterval=20 -g -Nf -R 5001:localhost:6060 proxy@47.44.161.114   <span class="comment">#反向代理</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>-o ServerAliveInterval=20</strong></td><td>代表心跳包，ssh在一段时间没数据后会把连接给断开。</td></tr><tr><td><strong>-g</strong></td><td>允许其<strong>远程机群</strong>连接到<strong>远程机</strong>端口进行转发。 如果无效，要修改**远程机*<em>sshd_config文件:*<em>gatewayports yes</em></em></td></tr><tr><td><strong>-N</strong></td><td>不执行远程命令。 仅做端口转发（仅适用于协议版本2）。</td></tr><tr><td><strong>-f</strong></td><td>将ssh切换到后台</td></tr><tr><td><strong>-R 15001:localhost:6060</strong></td><td>反向转发，用值用**:**分隔为三项,格式为： &lt;远程机端口&gt;:&lt;本地机群&gt;:&lt;端口&gt;。</td></tr><tr><td><strong><a href="mailto:&#112;&#x72;&#111;&#120;&#121;&#64;&#52;&#55;&#x2e;&#52;&#52;&#x2e;&#x31;&#54;&#49;&#x2e;&#x31;&#49;&#52;">&#112;&#x72;&#111;&#120;&#121;&#64;&#52;&#55;&#x2e;&#52;&#52;&#x2e;&#x31;&#54;&#49;&#x2e;&#x31;&#49;&#52;</a></strong></td><td>以指定帐号连接远程机</td></tr></tbody></table><h4><span id="本地代理"><strong>本地代理</strong></span></h4><p>本地代理应用场景一般是两类：一类是应用限制只能访问本机端口，而实际需要访问远程机端口；一类是某个网络环境只能允许一台主机访问远程机端口，而实际是网络区域内多台主机都有这个要求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -o ServerAliveInterval=20 -g -Nf  -L 5001:localhost:6060 proxy@47.44.161.114</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><strong>-o ServerAliveInterval=20</strong></td><td>代表心跳包，ssh在一段时间没数据后会把连接给断开。</td></tr><tr><td><strong>-g</strong></td><td>允许<strong>本地机群</strong>连接到<strong>本机</strong>端口进行转发。 如果无效，要修改**本机*<em>sshd_config文件:*<em>gatewayports yes</em></em></td></tr><tr><td><strong>-N</strong></td><td>不执行远程命令。 仅做端口转发（仅适用于协议版本2）。</td></tr><tr><td><strong>-f</strong></td><td>将ssh切换到后台</td></tr><tr><td><strong>-L 15001:localhost:6060</strong></td><td>本地转发，用值用**:<strong>分隔为三项,格式为： &lt;本机端口&gt;:&lt;远程机群&gt;:&lt;端口&gt;。 示例里第二项localhost,代表的是</strong>远程机**，用这种写法一般代表远程主机也只能本机访问该端口</td></tr><tr><td><strong><a href="mailto:&#112;&#114;&#111;&#120;&#121;&#64;&#x34;&#x37;&#46;&#52;&#x34;&#x2e;&#49;&#54;&#49;&#x2e;&#x31;&#x31;&#52;">&#112;&#114;&#111;&#120;&#121;&#64;&#x34;&#x37;&#46;&#52;&#x34;&#x2e;&#49;&#54;&#49;&#x2e;&#x31;&#x31;&#52;</a></strong></td><td>以指定帐号连接远程机</td></tr></tbody></table><h4><span id="连接检测脚本"><strong>连接检测脚本</strong></span></h4><p>ssh建立的连接有时候会因为网络原因断开，所以写了个定时任务脚本（基于centos)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">### reconnectproxy.sh ###</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">pid=` ps aux|grep ssh|grep -E <span class="string">&quot;6060[[:space:]]+proxy@47.44.161.114&quot;</span>|awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dt=`date`</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$pid</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;dt&#125;</span><span class="string">&quot;    INFO:proxy is connected&quot;</span>&gt;&gt;~/chkconn.log</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;dt&#125;</span><span class="string">&quot;    WARN:proxy is not connected&quot;</span>&gt;&gt;~/chkconn.log</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;dt&#125;</span><span class="string">&quot;    WARN:try to reconnect proxy &quot;</span>&gt;&gt;~/chkconn.log</span><br><span class="line">ssh -o ServerAliveInterval=20  -g -Nf -D 6060 proxy@47.44.161.114</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>再用<strong>crontab -e</strong>命令将脚本加入任务计划中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 */5 * * * * sh /root/reconnectproxy.sh</span><br></pre></td></tr></table></figure><p>文章转载：<a href="https://www.cnblogs.com/xinggg/p/8043227.html">https://www.cnblogs.com/xinggg/p/8043227.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术笔记 </tag>
            
            <tag> linux </tag>
            
            <tag> 随笔 </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决SpringBoot 2.3 MultipartFile为空的问题</title>
      <link href="/2021/10/21/%E8%A7%A3%E5%86%B3SpringBoot-2-3-MultipartFile%E4%B8%BA%E7%A9%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2021/10/21/%E8%A7%A3%E5%86%B3SpringBoot-2-3-MultipartFile%E4%B8%BA%E7%A9%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>原本用的2.0.x的版本上传文件是没有问题的，后来升级SpringBoot版本为2.3.3就无法上传文件了，我看到MultipartFile是为空的。</p><h3><span id="解决办法">解决办法</span></h3><p>不使用<code>Multipart</code>自动配置，再排除原有的Multipart配置<code>@EnableAutoConfiguration(exclude = &#123;MultipartAutoConfiguration.class&#125;)</code>，然后显示声明<code>CommonsMultipartResolver</code>为<code>mutipartResolver</code>。</p><ol><li><p>排除<code>MultipartAutoConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123;MultipartAutoConfiguration.class&#125;)</span></span><br></pre></td></tr></table></figure></li><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>显示声明<code>CommonsMultipartResolver</code>为<code>mutipartResolver</code>：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadResolverConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示声明CommonsMultipartResolver为mutipartResolver</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;multipartResolver&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MultipartResolver <span class="title">multipartResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CommonsMultipartResolver resolver = <span class="keyword">new</span> CommonsMultipartResolver();</span><br><span class="line">        resolver.setDefaultEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// resolveLazily属性启用是为了推迟文件解析，以在在UploadAction中捕获文件大小异常</span></span><br><span class="line">        resolver.setResolveLazily(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 设置了文件放入临时文件夹的大小限制</span></span><br><span class="line">        resolver.setMaxInMemorySize(<span class="number">40960</span>);</span><br><span class="line">        <span class="comment">// 设置单个上传数据总大小25M</span></span><br><span class="line">        resolver.setMaxUploadSizePerFile(<span class="number">25</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 设置总上传数据总大小50M</span></span><br><span class="line">        resolver.setMaxUploadSize(<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">return</span> resolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="multipartautoconfiguration源码">MultipartAutoConfiguration源码</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> EnableAutoConfiguration Auto-configuration&#125; for multi-part uploads. Adds a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> StandardServletMultipartResolver&#125; if none is present, and adds a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> javax.servlet.MultipartConfigElement multipartConfigElement&#125; if none is</span></span><br><span class="line"><span class="comment"> * otherwise defined. The &#123;<span class="doctag">@link</span> ServletWebServerApplicationContext&#125; will associate the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> MultipartConfigElement&#125; bean to any &#123;<span class="doctag">@link</span> Servlet&#125; beans.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> javax.servlet.MultipartConfigElement&#125; is a Servlet API that&#x27;s used to</span></span><br><span class="line"><span class="comment"> * configure how the server handles file uploads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Greg Turnquist</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Josh Long</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Toshiaki Maki</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.0.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; Servlet.class, StandardServletMultipartResolver.class, MultipartConfigElement.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.servlet.multipart&quot;, name = &quot;enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MultipartProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipartAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MultipartProperties multipartProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultipartAutoConfiguration</span><span class="params">(MultipartProperties multipartProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.multipartProperties = multipartProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(&#123; MultipartConfigElement.class, CommonsMultipartResolver.class &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MultipartConfigElement <span class="title">multipartConfigElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.multipartProperties.createMultipartConfig();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(MultipartResolver.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StandardServletMultipartResolver <span class="title">multipartResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StandardServletMultipartResolver multipartResolver = <span class="keyword">new</span> StandardServletMultipartResolver();</span><br><span class="line">        multipartResolver.setResolveLazily(<span class="keyword">this</span>.multipartProperties.isResolveLazily());</span><br><span class="line">        <span class="keyword">return</span> multipartResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="commonsmultipartresolver源码">CommonsMultipartResolver源码</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet-based &#123;<span class="doctag">@link</span> MultipartResolver&#125; implementation for</span></span><br><span class="line"><span class="comment"> * &lt;a href=&quot;https://commons.apache.org/proper/commons-fileupload&quot;&gt;Apache Commons FileUpload&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * 1.2 or above.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Provides &quot;maxUploadSize&quot;, &quot;maxInMemorySize&quot; and &quot;defaultEncoding&quot; settings as</span></span><br><span class="line"><span class="comment"> * bean properties (inherited from &#123;<span class="doctag">@link</span> CommonsFileUploadSupport&#125;). See corresponding</span></span><br><span class="line"><span class="comment"> * ServletFileUpload / DiskFileItemFactory properties (&quot;sizeMax&quot;, &quot;sizeThreshold&quot;,</span></span><br><span class="line"><span class="comment"> * &quot;headerEncoding&quot;) for details in terms of defaults and accepted values.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Saves temporary files to the servlet container&#x27;s temporary directory.</span></span><br><span class="line"><span class="comment"> * Needs to be initialized &lt;i&gt;either&lt;/i&gt; by an application context &lt;i&gt;or&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * via the constructor that takes a ServletContext (for standalone usage).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Trevor D. Cook</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 29.09.2003</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #CommonsMultipartResolver(ServletContext)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setResolveLazily</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.apache.commons.fileupload.servlet.ServletFileUpload</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.apache.commons.fileupload.disk.DiskFileItemFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonsMultipartResolver</span> <span class="keyword">extends</span> <span class="title">CommonsFileUploadSupport</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">MultipartResolver</span>, <span class="title">ServletContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> resolveLazily = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor for use as bean. Determines the servlet container&#x27;s</span></span><br><span class="line"><span class="comment">     * temporary directory via the ServletContext passed in as through the</span></span><br><span class="line"><span class="comment">     * ServletContextAware interface (typically by a WebApplicationContext).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setServletContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.web.context.ServletContextAware</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.web.context.WebApplicationContext</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonsMultipartResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor for standalone usage. Determines the servlet container&#x27;s</span></span><br><span class="line"><span class="comment">     * temporary directory via the given ServletContext.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletContext the ServletContext to use</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonsMultipartResolver</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        setServletContext(servletContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set whether to resolve the multipart request lazily at the time of</span></span><br><span class="line"><span class="comment">     * file or parameter access.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Default is &quot;false&quot;, resolving the multipart elements immediately, throwing</span></span><br><span class="line"><span class="comment">     * corresponding exceptions at the time of the &#123;<span class="doctag">@link</span> #resolveMultipart&#125; call.</span></span><br><span class="line"><span class="comment">     * Switch this to &quot;true&quot; for lazy multipart parsing, throwing parse exceptions</span></span><br><span class="line"><span class="comment">     * once the application attempts to obtain multipart files or parameters.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResolveLazily</span><span class="params">(<span class="keyword">boolean</span> resolveLazily)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resolveLazily = resolveLazily;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize the underlying &#123;<span class="doctag">@code</span> org.apache.commons.fileupload.servlet.ServletFileUpload&#125;</span></span><br><span class="line"><span class="comment">     * instance. Can be overridden to use a custom subclass, e.g. for testing purposes.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileItemFactory the Commons FileItemFactory to use</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new ServletFileUpload instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> FileUpload <span class="title">newFileUpload</span><span class="params">(FileItemFactory fileItemFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServletFileUpload(fileItemFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServletContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isUploadTempDirSpecified()) &#123;</span><br><span class="line">            getFileItemFactory().setRepository(WebUtils.getTempDir(servletContext));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMultipart</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ServletFileUpload.isMultipartContent(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MultipartHttpServletRequest <span class="title">resolveMultipart</span><span class="params">(<span class="keyword">final</span> HttpServletRequest request)</span> <span class="keyword">throws</span> MultipartException </span>&#123;</span><br><span class="line">        Assert.notNull(request, <span class="string">&quot;Request must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.resolveLazily) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultMultipartHttpServletRequest(request) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initializeMultipart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    MultipartParsingResult parsingResult = parseRequest(request);</span><br><span class="line">                    setMultipartFiles(parsingResult.getMultipartFiles());</span><br><span class="line">                    setMultipartParameters(parsingResult.getMultipartParameters());</span><br><span class="line">                    setMultipartParameterContentTypes(parsingResult.getMultipartParameterContentTypes());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            MultipartParsingResult parsingResult = parseRequest(request);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultMultipartHttpServletRequest(request, parsingResult.getMultipartFiles(),</span><br><span class="line">                    parsingResult.getMultipartParameters(), parsingResult.getMultipartParameterContentTypes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Parse the given servlet request, resolving its multipart elements.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request the request to parse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the parsing result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MultipartException if multipart resolution failed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> MultipartParsingResult <span class="title">parseRequest</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> MultipartException </span>&#123;</span><br><span class="line">        String encoding = determineEncoding(request);</span><br><span class="line">        FileUpload fileUpload = prepareFileUpload(encoding);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;FileItem&gt; fileItems = ((ServletFileUpload) fileUpload).parseRequest(request);</span><br><span class="line">            <span class="keyword">return</span> parseFileItems(fileItems, encoding);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (FileUploadBase.SizeLimitExceededException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MaxUploadSizeExceededException(fileUpload.getSizeMax(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (FileUploadBase.FileSizeLimitExceededException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MaxUploadSizeExceededException(fileUpload.getFileSizeMax(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (FileUploadException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MultipartException(<span class="string">&quot;Failed to parse multipart servlet request&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Determine the encoding for the given request.</span></span><br><span class="line"><span class="comment">     * Can be overridden in subclasses.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The default implementation checks the request encoding,</span></span><br><span class="line"><span class="comment">     * falling back to the default encoding specified for this resolver.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the encoding for the request (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> javax.servlet.ServletRequest#getCharacterEncoding</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setDefaultEncoding</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">determineEncoding</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String encoding = request.getCharacterEncoding();</span><br><span class="line">        <span class="keyword">if</span> (encoding == <span class="keyword">null</span>) &#123;</span><br><span class="line">            encoding = getDefaultEncoding();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> encoding;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanupMultipart</span><span class="params">(MultipartHttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(request <span class="keyword">instanceof</span> AbstractMultipartHttpServletRequest) ||</span><br><span class="line">                ((AbstractMultipartHttpServletRequest) request).isResolved()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cleanupFileItems(request.getMultiFileMap());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Failed to perform multipart cleanup for servlet request&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/upload&quot;)</span><br><span class="line">public void bigStopFile(@RequestParam Map&lt;String, MultipartFile&gt; map,HttpServletRequest request, HttpServletResponse response) throws IOException &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>MultipartResolver</code> 与 <code>MultipartConfigElement</code> 冲突，如果同时配置也会造成<code>MultipartFile</code>为空的情况，<code>MultipartConfigElement</code>配置方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public MultipartConfigElement multipartConfigElement() &#123;</span><br><span class="line">    MultipartConfigFactory factory = new MultipartConfigFactory();</span><br><span class="line">    //factory.setLocation(&quot;/app/sinova/tmp&quot;);</span><br><span class="line">    //文件最大</span><br><span class="line">    factory.setMaxFileSize(DataSize.of(50, DataUnit.MEGABYTES));</span><br><span class="line">    /// 设置总上传数据总大小</span><br><span class="line">    factory.setMaxRequestSize(DataSize.of(200, DataUnit.MEGABYTES));</span><br><span class="line">    return factory.createMultipartConfig();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术笔记 </tag>
            
            <tag> java </tag>
            
            <tag> 随笔 </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络基础，路由的追踪</title>
      <link href="/2021/10/18/Linux%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%EF%BC%8C%E8%B7%AF%E7%94%B1%E7%9A%84%E8%BF%BD%E8%B8%AA/"/>
      <url>/2021/10/18/Linux%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%EF%BC%8C%E8%B7%AF%E7%94%B1%E7%9A%84%E8%BF%BD%E8%B8%AA/</url>
      
        <content type="html"><![CDATA[<h1><span id="一-traceroute">一、 traceroute</span></h1><blockquote><p>Linux traceroute命令用于显示数据包到主机间的路径。<br>traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。</p></blockquote><h2><span id="语法">语法</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute [-46ndFT] [-f&lt;存活数值&gt;] [-g&lt;网关&gt;] [-i(--interface)&lt;device&gt;] [-I(--icmp)] [-m&lt;存活数值&gt;] [-N&lt;数据包数量&gt;] [-p&lt;通信端口&gt;] [-s&lt;来源地址&gt;] [-t&lt;服务类型&gt;] [-w&lt;超时秒数&gt;]</span><br></pre></td></tr></table></figure><h2><span id="参数说明">参数说明</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-4 ===&gt; IPV4</span><br><span class="line">-6 ===&gt; IPV6</span><br><span class="line">-d ===&gt; 使用Socket层级的排错功能</span><br><span class="line">-f ===&gt; 设置第一个检测数据包的存活数值TTL的大小</span><br><span class="line">-g ===&gt; 设置来源路由网关，最多可设置8个</span><br><span class="line">-i ===&gt; 指定traceroute应该通过哪个接口发送数据包；默认情况下，根据路由表选择接口</span><br><span class="line">-I ===&gt; 使用ICMP回应取代UDP资料信息</span><br><span class="line">-m ===&gt; 设置检测数据包的最大存活数值TTL的大小</span><br><span class="line">-p ===&gt; 设置UDP传输协议的通信端口</span><br><span class="line">-s ===&gt; 设置本地主机送出数据包的IP地址</span><br><span class="line">-t ===&gt; 对于IPV4来说是设置服务类型(TOS)和优先值；对于IPV6来说是设置流量控制值</span><br><span class="line">-T ===&gt; 使用TCP进行探测</span><br><span class="line">-w ===&gt; 设置等待远端主机回报的时间</span><br><span class="line">-F ===&gt; 不要分段探测数据包</span><br><span class="line">-n ===&gt; 在显示IP地址时，不要将它们映射到主机名</span><br><span class="line">-N ===&gt; 指定同时发送的探测包的数量;默认值是16</span><br></pre></td></tr></table></figure><h1><span id="二-tracepath">二、 tracepath</span></h1><blockquote><p>tracepath命令用来追踪并显示报文到达目的主机所经过的路由信息，能够发现路由中的MTU值。tracepath使用套接字API来实现其所有功能，不需要root权限。</p></blockquote><h2><span id="语法">语法</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracepath [-n] [-b] [-l pktlen] [-m max_hops] [-p port] [目的地址]</span><br></pre></td></tr></table></figure><h2><span id="参数说明">参数说明</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-n ===&gt; 输出主要的IP地址</span><br><span class="line">-b ===&gt; 同时输出主机名和IP地址</span><br><span class="line">-l ===&gt; 设置数据包大小；默认65535</span><br><span class="line">-m ===&gt; 设置最大跳数；默认30</span><br><span class="line">-p ===&gt; 设置要使用的初始目标端口</span><br></pre></td></tr></table></figure><h1><span id="三-mtr">三、 mtr</span></h1><blockquote><p>MTR是一种简单的跨平台命令行网络诊断工具，它将常用的traceroute和ping程序的功能组合到一个工具中。 与traceroute类似， mtr输出关于数据包从运行mtr的主机到用户指定的目标主机的路由信息​​。</p></blockquote><h2><span id="语法">语法</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtr [-lxu(--udp)T(--tcp)46] [-r (--report)] [-w (--report-wide)] [-c (--report-cycles)] [-l (--raw)] [-x (--xml)] [-a (--addres]  [-i (--interval)] [-m (--max-ttl)] [-f (--first-ttl)] [-B (--bitpattern)] [-Q (--tos)] [-s (--psize)] [-P (--port)] [--timeout] [目的地] [数据包大小]</span><br></pre></td></tr></table></figure><h2><span id="参数说明">参数说明</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-4 ===&gt; IPV4</span><br><span class="line">-6 ===&gt; IPV6</span><br><span class="line">-c ===&gt; 设置发送的ping的数量</span><br><span class="line">-r ===&gt; 进入report模式.此模式下，mtr将运行-c选项指定的周期数，然后输出统计信息并退出</span><br><span class="line">-w ===&gt; 进入wide report模式。在此模式下，mtr将不会删除报告中的主机名</span><br><span class="line">-s ===&gt; 设置探测包大小，字节数包括IP和ICMP头部信息</span><br><span class="line">-l ===&gt; 使用原始输出格式</span><br><span class="line">-x ===&gt; 使用xml输出格式</span><br><span class="line">-a ===&gt; 将发送数据包的插座绑定到特定的接口,这样任何数据包都可以通过这个接口发送</span><br><span class="line">-i ===&gt; 指定ICMP之间的请求间隔</span><br><span class="line">-m ===&gt; 指定最大跳数(最大生存时间值)默认30</span><br><span class="line">-f ===&gt; 指定开始跳数，默认为1</span><br><span class="line">-B ===&gt; 指定在有效负载中使用的位模式(0-255)</span><br><span class="line">-Q ===&gt; 指定IP报头中的服务字段（0-255）</span><br><span class="line">-P ===&gt; 指定TCP跟踪的目标端口号</span><br><span class="line">--timeout ===&gt; 在放弃连接之前，保持TCP套接字打开的秒数连接。这只会影响最后一跳</span><br></pre></td></tr></table></figure><h2><span id="应用举例1-基本展示">应用举例1 基本展示</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">zt-web6:/app/sinova$ mtr -4 -6 -x -c 1 -n --report miniapp.yun.139.com -P 443</span><br><span class="line">Start: Mon Oct 18 15:50:53 2021</span><br><span class="line">HOST: zt-web6                     Loss%   Snt   Last   Avg  Best  Wrst StDev</span><br><span class="line">  1.|-- 2409:805c:5c00::102        0.0%     1    1.6   1.6   1.6   1.6   0.0</span><br><span class="line">  2.|-- 2409:805c:5cff:ffff:ffff:  0.0%     1    0.1   0.1   0.1   0.1   0.0</span><br><span class="line">  3.|-- 2409:805c:0:614c::2        0.0%     1    3.3   3.3   3.3   3.3   0.0</span><br><span class="line">  4.|-- 2409:805c:0:6108::         0.0%     1    4.0   4.0   4.0   4.0   0.0</span><br><span class="line">  5.|-- 2409:805c:0:1003::         0.0%     1    0.6   0.6   0.6   0.6   0.0</span><br><span class="line">  6.|-- 2409:8080:0:2:1903:1971::  0.0%     1    0.9   0.9   0.9   0.9   0.0</span><br><span class="line">  7.|-- 2409:8080:0:1:305:1903::   0.0%     1   12.0  12.0  12.0  12.0   0.0</span><br><span class="line">  8.|-- 2409:8080:0:2:305:362:1f0  0.0%     1   17.0  17.0  17.0  17.0   0.0</span><br><span class="line">  9.|-- 2409:8055:3008:1116::a0    0.0%     1   14.3  14.3  14.3  14.3   0.0</span><br><span class="line"> 10.|-- 2409:8c54:813:5::1:0       0.0%     1   16.1  16.1  16.1  16.1   0.0</span><br><span class="line"> 11.|-- ???                       100.0     1    0.0   0.0   0.0   0.0   0.0</span><br><span class="line"> 12.|-- 2409:8c54:813:3::11        0.0%     1   19.2  19.2  19.2  19.2   0.0</span><br><span class="line"> 13.|-- ???                       100.0     1    0.0   0.0   0.0   0.0   0.0</span><br></pre></td></tr></table></figure><p>第一列：显示的是IP地址和本机域名；<br>第二列 Loss%：是显示的每个对应IP的丢包率；<br>第三列 snt：snt等于1，设置每秒发送数据包的数量，默认值是10 可以通过参数 -c来指定。<br>第四列 Last：显示的最近一次的返回时延。<br>第五列Avg：平均值，这个应该是发送ping包的平均时延。<br>第六列Best：最好或者说时延最短的时间。<br>第七列Wrst：最坏或者说时延最长的时间。<br>第八列StDev：标准偏差。</p><h2><span id="应用举例二设置每秒发送数据包的数量30">应用举例二：设置每秒发送数据包的数量30</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtr -r -c 30 www.xqblog.com</span><br></pre></td></tr></table></figure><h2><span id="应用举例3设置ping包大小为1024个字节">应用举例3：设置ping包大小为1024个字节</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtr -r -c 30 -s 1024 www.xqblog.com</span><br></pre></td></tr></table></figure><h1><span id="四-netstat">四、 netstat</span></h1><blockquote><p>Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。<br>显示网络连接，路由表，接口状态，伪装连接，网络链路信息和组播成员组。</p></blockquote><h2><span id="语法">语法</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">netstat [地址] [-t (--tcp)] [-u (--udp)] [-l (--listening)] [-a (--all)] [-n (--numeric)] [--numeric-hosts] [--numeric-ports] [-p (--program)] [-v (--verbose)] [-c (--continuous)] [delay]</span><br><span class="line"></span><br><span class="line">netstat &#123;-r (--route)&#125; [地址] [-e (--extend)] [-v (--verbose)] [-n (--numeric)]  [--numeric-hosts] [--numeric-ports] [--numeric-ports] [-c (--continuous)] [delay]</span><br><span class="line"></span><br><span class="line">netstat &#123;-i (--interfaces)&#125; [iface] [-a (--all)] [-e (--extend)] [-v (--verbose)] [-p (--program)] [-n (--numeric)] [--numeric-hosts] [--numeric-ports] [--numeric-ports] [-c (--continuous)] [delay]</span><br></pre></td></tr></table></figure><h2><span id="参数说明">参数说明</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">注意：[地址]无选项时,netstat显示打开的套接字.如果不指定任何地址族，那么打印出所有已配置地址族的有效套接字。</span><br><span class="line">-t ===&gt; 仅显示tcp连接</span><br><span class="line">-u ===&gt; 仅显示udp连接</span><br><span class="line">-l ===&gt; 只显示正在侦听的套接字(这是默认的选项)</span><br><span class="line">-a ===&gt; 显示所有正在或不在侦听的套接字。加上 --interfaces 选项将显示没有标记的接口</span><br><span class="line">-n ===&gt; 显示数字形式地址而不是去解析主机、端口或用户名</span><br><span class="line">--numeric-hosts ===&gt; 显示数字形式的主机但是不影响端口或用户名的解析</span><br><span class="line">--numeric-ports ===&gt; 显示数字端口号，但是不影响主机或用户名的解析</span><br><span class="line">-N ===&gt; </span><br><span class="line">delay === &gt; 每隔 delay 秒,循环输出统计信息</span><br><span class="line">-p ===&gt; 显示套接字所属进程的PID和名称</span><br><span class="line">-v ===&gt; 显示详细信息</span><br><span class="line">-c ===&gt; 将使 netstat 不断地每秒输出所选的信息</span><br></pre></td></tr></table></figure><h1><span id="五-route">五、 route</span></h1><h2><span id="语法">语法</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">route [-CFvne]</span><br><span class="line"></span><br><span class="line">route [-v] [-A] add [-net|-host] target [netmask] [gw Gw] [metric] [mss] [window] [irtt ] [reject] [mod] [dyn] [reinstate] [[dev] If]</span><br><span class="line"></span><br><span class="line">route [-v] [-A] del [-net|-host] target [gw] [netmask] [metric] [[dev] If]</span><br></pre></td></tr></table></figure><h2><span id="参数说明">参数说明</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-C ===&gt; 显示内核的路由缓存</span><br><span class="line">-F ===&gt; 显示内核的FIB选路表</span><br><span class="line">-n ===&gt; 以数字形式代替解释主机名形式来显示地址</span><br><span class="line">-e ===&gt; 用net‐stat(8)的格式来显示选路表</span><br><span class="line"></span><br><span class="line">-A ===&gt; 用指定的地址族(如`inet&#x27;，`inet6&#x27;)</span><br><span class="line">-v ===&gt; 选用细节操作模式</span><br><span class="line">-net ===&gt; 路由目标为网络</span><br><span class="line">-host ===&gt; 路由目标为主机</span><br><span class="line">add ===&gt; 添加一条路由</span><br><span class="line">del ===&gt; 删除一条路由</span><br><span class="line">target ===&gt; 指定目标网络或主机</span><br><span class="line">netmask ===&gt;为添加的路由指定网络掩码</span><br><span class="line">gw ===&gt; 为发往目标网络/主机的任何分组指定网关</span><br><span class="line">metric ===&gt; 设置路由值字段</span><br><span class="line">mss ===&gt; 设置基于此路由之上的连接的TCP最大报文段长度</span><br><span class="line">window ===&gt; 设置基于此路由之上的连接的TCP窗口长度</span><br><span class="line">irtt ===&gt; 设置基于此路由之上的TCP连接的初始往返时间</span><br><span class="line">reject ===&gt; 设置一条阻塞路由以使一条路由查找失败</span><br><span class="line">mod,dyn,reinstate ===&gt; 设置一条动态的或更改过的路由</span><br><span class="line">dev If ===&gt; 强制使路由与指定的设备关联</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术笔记 </tag>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
            <tag> 随笔 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ngx_lua 模块详细讲解（基于openresty）</title>
      <link href="/2021/10/17/ngx-lua-%E6%A8%A1%E5%9D%97%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%EF%BC%88%E5%9F%BA%E4%BA%8Eopenresty%EF%BC%89/"/>
      <url>/2021/10/17/ngx-lua-%E6%A8%A1%E5%9D%97%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3%EF%BC%88%E5%9F%BA%E4%BA%8Eopenresty%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>ngx_lua模块的原理：</p><p>1、每个worker（工作进程）创建一个Lua VM，worker内所有协程共享VM；<br>2、将Nginx I/O原语封装后注入 Lua VM，允许Lua代码直接访问；<br>3、每个外部请求都由一个Lua协程处理，协程之间数据隔离；<br>4、Lua代码调用I/O操作等异步接口时，会挂起当前协程（并保护上下文数据），而不阻塞worker；<br>5、I/O等异步操作完成时还原相关协程上下文数据，并继续运行；</p><p><strong>ngx_lua 模块提供的指令和API等：</strong></p><table><thead><tr><th>指令名称</th><th>说明</th></tr></thead><tbody><tr><td>lua_use_default_type</td><td>是否使用default_type指令定义的Content-Type默认值</td></tr><tr><td>lua_code_cache</td><td>*_by_lua_file文件是否cache</td></tr><tr><td>lua_regex_cache_max_entries</td><td></td></tr><tr><td>lua_regex_match_limit</td><td></td></tr><tr><td>lua_package_path</td><td>用Lua写的lua外部库路径（.lua文件）</td></tr><tr><td>lua_package_cpath</td><td>用C写的lua外部库路径（.so文件）</td></tr><tr><td>init_by_lua</td><td>master进程启动时挂载的lua代码</td></tr><tr><td>init_by_lua_file</td><td></td></tr><tr><td>init_worker_by_lua</td><td>worker进程启动时挂载的lua代码，常用来执行一些定时器任务</td></tr><tr><td>init_worker_by_lua_file</td><td></td></tr><tr><td>set_by_lua</td><td>设置变量</td></tr><tr><td>set_by_lua_file</td><td></td></tr><tr><td>content_by_lua</td><td>handler模块</td></tr><tr><td>content_by_lua_file</td><td></td></tr><tr><td>rewrite_by_lua</td><td></td></tr><tr><td>rewrite_by_lua_file</td><td></td></tr><tr><td>access_by_lua</td><td></td></tr><tr><td>access_by_lua_file</td><td></td></tr><tr><td>header_filter_by_lua</td><td>header filter模块</td></tr><tr><td>header_filter_by_lua_file</td><td></td></tr><tr><td>body_filter_by_lua</td><td>body filter模块，ngx.arg[1]代表输入的chunk，ngx.arg[2]代表当前chunk是否为last</td></tr><tr><td>body_filter_by_lua_file</td><td></td></tr><tr><td>log_by_lua</td><td></td></tr><tr><td>log_by_lua_file</td><td></td></tr><tr><td>lua_need_request_body</td><td>是否读请求体，跟ngx.req.read_body()函数作用类似</td></tr><tr><td>lua_shared_dict</td><td>创建全局共享的table（多个worker进程共享）</td></tr><tr><td>lua_socket_connect_timeout</td><td>TCP/unix 域socket对象connect方法的超时时间</td></tr><tr><td>lua_socket_send_timeout</td><td>TCP/unix 域socket对象send方法的超时时间</td></tr><tr><td>lua_socket_send_lowat</td><td>设置cosocket send buffer的low water值</td></tr><tr><td>lua_socket_read_timeout</td><td>TCP/unix 域socket对象receive方法的超时时间</td></tr><tr><td>lua_socket_buffer_size</td><td>cosocket读buffer大小</td></tr><tr><td>lua_socket_pool_size</td><td>cosocket连接池大小</td></tr><tr><td>lua_socket_keepalive_timeout</td><td>cosocket长连接超时时间</td></tr><tr><td>lua_socket_log_errors</td><td>是否打开cosocket错误日志</td></tr><tr><td>lua_ssl_ciphers</td><td></td></tr><tr><td>lua_ssl_crl</td><td></td></tr><tr><td>lua_ssl_protocols</td><td></td></tr><tr><td>lua_ssl_trusted_certificate</td><td></td></tr><tr><td>lua_ssl_verify_depth</td><td></td></tr><tr><td>lua_http10_buffering</td><td></td></tr><tr><td>rewrite_by_lua_no_postpone</td><td></td></tr><tr><td>lua_transform_underscores_in_response_headers</td><td></td></tr><tr><td>lua_check_client_abort</td><td>是否监视client提前关闭请求的事件，如果打开监视，会调用ngx.on_abort()注册的回调</td></tr><tr><td>lua_max_pending_timers</td><td></td></tr><tr><td>lua_max_running_timers</td><td></td></tr></tbody></table><table><thead><tr><th>table</th><th>说明</th></tr></thead><tbody><tr><td>ngx.arg</td><td>指令参数，如跟在content_by_lua_file后面的参数</td></tr><tr><td>ngx.var</td><td>变量，ngx.var.VARIABLE引用某个变量</td></tr><tr><td>ngx.ctx</td><td>请求的lua上下文</td></tr><tr><td>ngx.header</td><td>响应头，ngx.header.HEADER引用某个头</td></tr><tr><td>ngx.status</td><td>响应码</td></tr><tr><td></td><td></td></tr><tr><td>API</td><td>说明</td></tr><tr><td>ngx.log</td><td>输出到error.log</td></tr><tr><td>print</td><td>等价于 ngx.log(ngx.NOTICE, …)</td></tr><tr><td>ngx.send_headers</td><td>发送响应头</td></tr><tr><td>ngx.headers_sent</td><td>响应头是否已发送</td></tr><tr><td>ngx.resp.get_headers</td><td>获取响应头</td></tr><tr><td>ngx.timer.at</td><td>注册定时器事件</td></tr><tr><td>ngx.is_subrequest</td><td>当前请求是否是子请求</td></tr><tr><td>ngx.location.capture</td><td>发布一个子请求</td></tr><tr><td>ngx.location.capture_multi</td><td>发布多个子请求</td></tr><tr><td>ngx.exec</td><td></td></tr><tr><td>ngx.redirect</td><td></td></tr><tr><td>ngx.print</td><td>输出响应</td></tr><tr><td>ngx.say</td><td>输出响应，自动添加’\n’</td></tr><tr><td>ngx.flush</td><td>刷新响应</td></tr><tr><td>ngx.exit</td><td>结束请求</td></tr><tr><td>ngx.eof</td><td></td></tr><tr><td>ngx.sleep</td><td>无阻塞的休眠（使用定时器实现）</td></tr><tr><td>ngx.get_phase</td><td></td></tr><tr><td>ngx.on_abort</td><td>注册client断开请求时的回调函数</td></tr><tr><td>ndk.set_var.DIRECTIVE</td><td></td></tr><tr><td>ngx.req.start_time</td><td>请求的开始时间</td></tr><tr><td>ngx.req.http_version</td><td>请求的HTTP版本号</td></tr><tr><td>ngx.req.raw_header</td><td>请求头（包括请求行）</td></tr><tr><td>ngx.req.get_method</td><td>请求方法</td></tr><tr><td>ngx.req.set_method</td><td>请求方法重载</td></tr><tr><td>ngx.req.set_uri</td><td>请求URL重写</td></tr><tr><td>ngx.req.set_uri_args</td><td></td></tr><tr><td>ngx.req.get_uri_args</td><td>获取请求参数</td></tr><tr><td>ngx.req.get_post_args</td><td>获取请求表单</td></tr><tr><td>ngx.req.get_headers</td><td>获取请求头</td></tr><tr><td>ngx.req.set_header</td><td></td></tr><tr><td>ngx.req.clear_header</td><td></td></tr><tr><td>ngx.req.read_body</td><td>读取请求体</td></tr><tr><td>ngx.req.discard_body</td><td>扔掉请求体</td></tr><tr><td>ngx.req.get_body_data</td><td></td></tr><tr><td>ngx.req.get_body_file</td><td></td></tr><tr><td>ngx.req.set_body_data</td><td></td></tr><tr><td>ngx.req.set_body_file</td><td></td></tr><tr><td>ngx.req.init_body</td><td></td></tr><tr><td>ngx.req.append_body</td><td></td></tr><tr><td>ngx.req.finish_body</td><td></td></tr><tr><td>ngx.req.socket</td><td></td></tr><tr><td>ngx.escape_uri</td><td>字符串的url编码</td></tr><tr><td>ngx.unescape_uri</td><td>字符串url解码</td></tr><tr><td>ngx.encode_args</td><td>将table编码为一个参数字符串</td></tr><tr><td>ngx.decode_args</td><td>将参数字符串编码为一个table</td></tr><tr><td>ngx.encode_base64</td><td>字符串的base64编码</td></tr><tr><td>ngx.decode_base64</td><td>字符串的base64解码</td></tr><tr><td>ngx.crc32_short</td><td>字符串的crs32_short哈希</td></tr><tr><td>ngx.crc32_long</td><td>字符串的crs32_long哈希</td></tr><tr><td>ngx.hmac_sha1</td><td>字符串的hmac_sha1哈希</td></tr><tr><td>ngx.md5</td><td>返回16进制MD5</td></tr><tr><td>ngx.md5_bin</td><td>返回2进制MD5</td></tr><tr><td>ngx.sha1_bin</td><td>返回2进制sha1哈希值</td></tr><tr><td>ngx.quote_sql_str</td><td>SQL语句转义</td></tr><tr><td>ngx.today</td><td>返回当前日期</td></tr><tr><td>ngx.time</td><td>返回UNIX时间戳</td></tr><tr><td>ngx.now</td><td>返回当前时间</td></tr><tr><td>ngx.update_time</td><td>刷新时间后再返回</td></tr><tr><td>ngx.localtime</td><td></td></tr><tr><td>ngx.utctime</td><td></td></tr><tr><td>ngx.cookie_time</td><td>返回的时间可用于cookie值</td></tr><tr><td>ngx.http_time</td><td>返回的时间可用于HTTP头</td></tr><tr><td>ngx.parse_http_time</td><td>解析HTTP头的时间</td></tr><tr><td>ngx.re.match</td><td></td></tr><tr><td>ngx.re.find</td><td></td></tr><tr><td>ngx.re.gmatch</td><td></td></tr><tr><td>ngx.re.sub</td><td></td></tr><tr><td>ngx.re.gsub</td><td></td></tr><tr><td>ngx.shared.DICT</td><td></td></tr><tr><td>ngx.shared.DICT.get</td><td></td></tr><tr><td>ngx.shared.DICT.get_stale</td><td></td></tr><tr><td>ngx.shared.DICT.set</td><td></td></tr><tr><td>ngx.shared.DICT.safe_set</td><td></td></tr><tr><td>ngx.shared.DICT.add</td><td></td></tr><tr><td>ngx.shared.DICT.safe_add</td><td></td></tr><tr><td>ngx.shared.DICT.replace</td><td></td></tr><tr><td>ngx.shared.DICT.delete</td><td></td></tr><tr><td>ngx.shared.DICT.incr</td><td></td></tr><tr><td>ngx.shared.DICT.flush_all</td><td></td></tr><tr><td>ngx.shared.DICT.flush_expired</td><td></td></tr><tr><td>ngx.shared.DICT.get_keys</td><td></td></tr><tr><td>ngx.socket.udp</td><td></td></tr><tr><td>udpsock:setpeername</td><td></td></tr><tr><td>udpsock:send</td><td></td></tr><tr><td>udpsock:receive</td><td></td></tr><tr><td>udpsock:close</td><td></td></tr><tr><td>udpsock:settimeout</td><td></td></tr><tr><td>ngx.socket.tcp</td><td></td></tr><tr><td>tcpsock:connect</td><td></td></tr><tr><td>tcpsock:sslhandshake</td><td></td></tr><tr><td>tcpsock:send</td><td></td></tr><tr><td>tcpsock:receive</td><td></td></tr><tr><td>tcpsock:receiveuntil</td><td></td></tr><tr><td>tcpsock:close</td><td></td></tr><tr><td>tcpsock:settimeout</td><td></td></tr><tr><td>tcpsock:setoption</td><td></td></tr><tr><td>tcpsock:setkeepalive</td><td></td></tr><tr><td>tcpsock:getreusedtimes</td><td></td></tr><tr><td>ngx.socket.connect</td><td></td></tr><tr><td>ngx.thread.spawn</td><td></td></tr><tr><td>ngx.thread.wait</td><td></td></tr><tr><td>ngx.thread.kill</td><td></td></tr><tr><td>coroutine.create</td><td></td></tr><tr><td>coroutine.resume</td><td></td></tr><tr><td>coroutine.yield</td><td></td></tr><tr><td>coroutine.wrap</td><td></td></tr><tr><td>coroutine.running</td><td></td></tr><tr><td>coroutine.status</td><td></td></tr><tr><td>ngx.config.debug</td><td>编译时是否有 –with-debug选项</td></tr><tr><td>ngx.config.prefix</td><td>编译时的 –prefix选项</td></tr><tr><td>ngx.config.nginx_version</td><td>返回nginx版本号</td></tr><tr><td>ngx.config.nginx_configure</td><td>返回编译时 ./configure的命令行选项</td></tr><tr><td>ngx.config.ngx_lua_version</td><td>返回ngx_lua模块版本号</td></tr><tr><td>ngx.worker.exiting</td><td>当前worker进程是否正在关闭（如reload、shutdown期间）</td></tr><tr><td>ngx.worker.pid</td><td>返回当前worker进程的pid</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td>常量</td><td>说明</td></tr><tr><td>Core constants</td><td>ngx.OK (0) ngx.ERROR (-1) ngx.AGAIN (-2) ngx.DONE (-4) ngx.DECLINED (-5) ngx.nil</td></tr><tr><td>HTTP method constants</td><td>ngx.HTTP_GET ngx.HTTP_HEAD ngx.HTTP_PUT ngx.HTTP_POST ngx.HTTP_DELETE ngx.HTTP_OPTIONS  ngx.HTTP_MKCOL   ngx.HTTP_COPY    ngx.HTTP_MOVE    ngx.HTTP_PROPFIND  ngx.HTTP_PROPPATCH  ngx.HTTP_LOCK  ngx.HTTP_UNLOCK   ngx.HTTP_PATCH   ngx.HTTP_TRACE</td></tr><tr><td>HTTP status constants</td><td>ngx.HTTP_OK (200) ngx.HTTP_CREATED (201) ngx.HTTP_SPECIAL_RESPONSE (300) ngx.HTTP_MOVED_PERMANENTLY (301) ngx.HTTP_MOVED_TEMPORARILY (302) ngx.HTTP_SEE_OTHER (303) ngx.HTTP_NOT_MODIFIED (304) ngx.HTTP_BAD_REQUEST (400) ngx.HTTP_UNAUTHORIZED (401) ngx.HTTP_FORBIDDEN (403) ngx.HTTP_NOT_FOUND (404) ngx.HTTP_NOT_ALLOWED (405) ngx.HTTP_GONE (410) ngx.HTTP_INTERNAL_SERVER_ERROR (500) ngx.HTTP_METHOD_NOT_IMPLEMENTED (501) ngx.HTTP_SERVICE_UNAVAILABLE (503) ngx.HTTP_GATEWAY_TIMEOUT (504)</td></tr><tr><td>Nginx log level constants</td><td>ngx.STDERR ngx.EMERG ngx.ALERT ngx.CRIT ngx.ERR ngx.WARN ngx.NOTICE ngx.INFO ngx.DEBUG</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术笔记 </tag>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
            <tag> 随笔 </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenResty 执行流程阶段</title>
      <link href="/2021/10/17/OpenResty-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E9%98%B6%E6%AE%B5/"/>
      <url>/2021/10/17/OpenResty-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E9%98%B6%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<p>nginx有11个处理阶段，如下图所示：</p><p><img src="/2021/10/17/OpenResty-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E9%98%B6%E6%AE%B5/292052-20190628170848889-787127502.png" alt="img"></p><table><thead><tr><th align="center">指令</th><th align="center">所处处理阶段</th><th align="center">使用范围</th><th align="left">解释</th></tr></thead><tbody><tr><td align="center">init_by_lua init_by_lua_file</td><td align="center">loading-config</td><td align="center">http</td><td align="left">nginx Master进程加载配置时执行；通常用于初始化全局配置/预加载Lua模块</td></tr><tr><td align="center">init_worker_by_lua init_worker_by_lua_file</td><td align="center">starting-worker</td><td align="center">http</td><td align="left">每个Nginx Worker进程启动时调用的计时器，如果Master进程不允许则只会在init_by_lua之后调用；通常用于定时拉取配置/数据，或者后端服务的健康检查</td></tr><tr><td align="center">set_by_lua set_by_lua_file</td><td align="center">rewrite</td><td align="center">server,server if,location,location if</td><td align="left">设置nginx变量，可以实现复杂的赋值逻辑；此处是阻塞的，Lua代码要做到非常快；</td></tr><tr><td align="center">rewrite_by_lua rewrite_by_lua_file</td><td align="center">rewrite tail</td><td align="center">http,server,location,location if</td><td align="left">rrewrite阶段处理，可以实现复杂的转发/重定向逻辑；</td></tr><tr><td align="center">access_by_lua access_by_lua_file</td><td align="center">access tail</td><td align="center">http,server,location,location if</td><td align="left">请求访问阶段处理，用于访问控制</td></tr><tr><td align="center">content_by_lua content_by_lua_file</td><td align="center">content</td><td align="center">location，location if</td><td align="left">内容处理器，接收请求处理并输出响应</td></tr><tr><td align="center">header_filter_by_lua header_filter_by_lua_file</td><td align="center">output-header-filter</td><td align="center">http，server，location，location if</td><td align="left">设置header和cookie</td></tr><tr><td align="center">body_filter_by_lua body_filter_by_lua_file</td><td align="center">output-body-filter</td><td align="center">http，server，location，location if</td><td align="left">对响应数据进行过滤，比如截断、替换。</td></tr><tr><td align="center">log_by_lua log_by_lua_file</td><td align="center">log</td><td align="center">http，server，location，location if</td><td align="left">log阶段处理，比如记录访问量/统计平均响应时间</td></tr></tbody></table><h2><span id="指令解释">指令解释</span></h2><p>**init_by_lua***：初始化 nginx 和预加载 lua(nginx 启动和 reload 时执行)；<br>**init_worker_by_lua***：每个工作进程(worker_processes)被创建时执行，用于启动一些定时任务，<br>比如心跳检查，后端服务的健康检查，定时拉取服务器配置等；<br>**ssl_certificate_by_lua***：对 https 请求的处理，即将启动下游 SSL（https）连接的 SSL 握手时执行，用例：按照每个请求设置 SSL 证书链和相应的私钥，按照 SSL 协议有选择的拒绝请求等；<br>**set_by_lua***：设置 nginx 变量；<br>**rewrite_by_lua***：重写请求（从原生 nginx 的 rewrite 阶段进入），执行内部 URL 重写或者外部重定向，典型的如伪静态化的 URL 重写；<br>**access_by_lua***：处理请求（和 rewrite_by_lua 可以实现相同的功能，从原生 nginx 的 access阶段进入）；<br>**content_by_lua***：执行业务逻辑并产生响应，类似于 jsp 中的 servlet；<br>**balancer_by_lua***：负载均衡；<br>**header_filter_by_lua***：处理响应头；<br>**body_filter_by_lua***：处理响应体；<br>**log_by_lua***：记录访问日志；</p><p>一般我们在开发过程中常用到的阶段如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_by_lua、rewrite_by_lua、access_by_lua、content_by_lua、header_filter_by_lua、body_filter_by_lua、log_by_lua、</span><br></pre></td></tr></table></figure><p>1.set_by_lua</p><p>  做流程分支判断，判断变量初始化</p><p>2.rewrite_by_lua</p><p>  转发重定向，缓存功能</p><p>3.access_by_lua</p><p>  ip准入，接口合法权限判断，根据iptable做防火墙的功能</p><p>4.content_by_lua</p><p>  内容生产</p><p>5.header_filter_by_lua</p><p>  增加头部信息</p><p>6.body_filter_by_lua</p><p>  内容过滤</p><p>7.log_by_lua</p><p>  记录日志</p><p> 文章转载：<a href="https://www.cnblogs.com/fly-kaka/p/11102849.html">https://www.cnblogs.com/fly-kaka/p/11102849.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术笔记 </tag>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
            <tag> 随笔 </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从Clover到OpenCore</title>
      <link href="/2021/10/10/%E4%BB%8EClover%E5%88%B0OpenCore/"/>
      <url>/2021/10/10/%E4%BB%8EClover%E5%88%B0OpenCore/</url>
      
        <content type="html"><![CDATA[<p><a href="from-clover-to-opencore.png"><img src="/2021/10/10/%E4%BB%8EClover%E5%88%B0OpenCore/from-clover-to-opencore.png" alt="img"></a></p><blockquote><p>由于是转载文章，文章中的<code>我</code>特指作者：<a href="https://github.com/SukkaW">SukkaW</a></p></blockquote><p>随着 <code>OpenCore</code> 日渐成熟、<a href="https://github.com/acidanthera">acidanthera</a> 团队宣布放弃旗下绝大部分内核驱动（包括 <a href="https://github.com/acidanthera/Lilu">Lilu</a>、<a href="https://github.com/acidanthera/VirtualSMC">VirtualSMC</a>、<a href="https://github.com/acidanthera/WhateverGreen">WhateverGreen</a>、<a href="https://github.com/acidanthera/AppleALC">AppleALC</a> 等）对 <code>Clover</code> 的兼容性支持，与其届时被迫换到 <code>OpenCore</code>，不如主动开始迁移。</p><p>当然面对迁移，有的人会选择直接抛弃之前 <code>Clover</code> 的全部成果，直接从零开始配置 <code>OpenCore</code>。但是我相信对于大部分人来说更希望通过简简单单的修补，在现有的 EFI 的基础上迁移到 <code>OpenCore</code>，因此我开始撰写这篇文章。</p><p>然而不幸的是从 <code>Clover</code> 切换到 <code>OpenCore</code> 并不是一个简单的任务，因此这种迁移应该是渐进式的，不可能一蹴而就。那什么是「渐进式」呢？意思就是，如果你按照本文的步骤一步一步按顺序进行，那么大部分迁移步骤产生的修改，在 <code>Clover</code> 下一样可用，你不需要一下子就扔掉 <code>Clover</code> 。</p><h2><span id="序言以外应该写在最前面的话">序言以外应该写在最前面的话</span></h2><ol><li><code>OpenCore</code> 丢掉了不少 <code>Clover</code> 的历史包袱。毫无疑问依然有不少 <code>Clover</code> 设置在 <code>OpenCore</code> 是没有可以直接替代的。因此 <code>Clover</code> 完全照搬到 <code>OpenCore</code> 是肯定行不通的。</li><li>在迁移到 <code>OpenCore</code> 之前，Clover 的大部分设置都要精简：用 <code>SSDT</code> 代替、改为注入设备属性（Device Properties）。这篇教程的主题就是教你这些事情。</li><li>如果你一开始在组织 <code>Clover</code> 的 EFI 时就有洁癖的话，你会发现迁移到 <code>OpenCore</code> 出人意料地简单。</li><li>只有完美的 <code>Clover</code> 的 EFI，在按照本文档的步骤精简后能获得完美的 <code>OpenCore</code> 的 EFI。如果你的 EFI 是不完美的，那么迁移到 <code>OpenCore</code> 也一定是不完美的。因此，如果你是为了解决不完美、才想迁移到 <code>OpenCore</code>，那么我建议先在 <code>Clover</code> 下完善。</li><li>独木难成林。这篇教程初次发布以后，<a href="https://github.com/williambj1">Bat.bat</a> 等许多大佬在远景论坛、Telegram 上提供了许多意见，正是在他们的帮助下，这篇教程得以不断完善。</li></ol><h2><span id="修改-ssdt-dsdt-以搭配-opencore">修改 <code>SSDT</code> / <code>DSDT</code> 以搭配 <code>OpenCore</code></span></h2><p><code>OpenCore</code> 和 <code>Clover</code> 最大的不同其实是，<a href="https://github.com/acidanthera">acidanthera</a> 决定在 <code>OpenCore</code> 中设置的 SMBIOS 机型信息、DSDT 和 SSDT，都将一视同仁的对所有操作系统生效。这样做的目的是让黑苹果更像白苹果，但是却有可能导致在 macOS 上正常可用的 ACPI 表到了 Windows 上反而会出问题。因此，迁移的第一步我个人推荐从修改现有的 <code>SSDT</code> 和 <code>DSDT</code> 开始，因为在 <code>OpenCore</code> 下能用的 SSDT、DSDT，在 <code>Clover</code> 下是一定可用的。也就是说，当你完成这一步后，你可以继续使用 <code>Clover</code> 而不受影响。</p><p>这里主要介绍对 <code>Method</code> 函数的修改方法。以 GPRW（6D0D）补丁为例，在 <code>Clover</code> 上我们一般采用这种方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// In config ACPI, GPRW to XPRW</span><br><span class="line">// Find:     47505257 02</span><br><span class="line">// Replace:  58505257 02</span><br><span class="line">//</span><br><span class="line">DefinitionBlock (&quot;&quot;, &quot;SSDT&quot;, 2, &quot;SUKA&quot;, &quot;GPRW&quot;, 0)</span><br><span class="line">&#123;</span><br><span class="line">    External(XPRW, MethodObj)</span><br><span class="line">    Method (GPRW, 2, NotSerialized)</span><br><span class="line">    &#123;</span><br><span class="line">        If ((0x6D == Arg0))</span><br><span class="line">        &#123;</span><br><span class="line">            Return (Package ()</span><br><span class="line">            &#123;</span><br><span class="line">                0x6D, </span><br><span class="line">                Zero</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        If ((0x0D == Arg0))</span><br><span class="line">        &#123;</span><br><span class="line">            Return (Package ()</span><br><span class="line">            &#123;</span><br><span class="line">                0x0D, </span><br><span class="line">                Zero</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        Return (XPRW (Arg0, Arg1))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>SSDT</code> 的原理是，通过 <code>DSDT</code> 重命名将原始的 <code>GPRW,2</code> 函数重命名为 <code>XPRW,2</code> ，然后通过 <code>SSDT</code> 新增一个 <code>GPRW</code> 函数，这样实际 ACPI 调用 GPRW 函数时就是调用的 <code>SSDT</code> 里添加的 GPRW 函数。</p><p>但是现在，<code>OpenCore</code> 将会对所有操作系统一视同仁，所有 SSDT、DSDT 重命名对包括 Windows 在内的所有操作系统生效，那么 <code>SSDT</code> 中的 GPRW 函数也会在 Windows 生效，可能就会导致未知的后果。所以，我们需要通过 <code>OSI</code> 函数，判断当前操作系统，确保函数的行为只对某一个操作系统生效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// In config ACPI, GPRW to XPRW</span><br><span class="line">// Find:     47505257 02</span><br><span class="line">// Replace:  58505257 02</span><br><span class="line">//</span><br><span class="line">// 需要注意的是，ACPI 里不支持非 ASCII 字符注释，这里仅做示例，不可直接用于编译</span><br><span class="line">DefinitionBlock (&quot;&quot;, &quot;SSDT&quot;, 2, &quot;OCLT&quot;, &quot;GPRW&quot;, 0)</span><br><span class="line">&#123;</span><br><span class="line">    External(XPRW, MethodObj) // 对 XPRW 函数的外部引用</span><br><span class="line">    Method (GPRW, 2, NotSerialized)</span><br><span class="line">    &#123;</span><br><span class="line">        If (_OSI (&quot;Darwin&quot;)) // 如果当前的操作系统是 macOS，生效以下行为</span><br><span class="line">        &#123;</span><br><span class="line">            If ((0x6D == Arg0))</span><br><span class="line">            &#123;</span><br><span class="line">                Return (Package ()</span><br><span class="line">                &#123;</span><br><span class="line">                    0x6D, </span><br><span class="line">                    Zero</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            If ((0x0D == Arg0))</span><br><span class="line">            &#123;</span><br><span class="line">                Return (Package ()</span><br><span class="line">                &#123;</span><br><span class="line">                    0x0D, </span><br><span class="line">                    Zero</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 否则，直接返回 XPRW 函数。只有三种情况下会走到这一步：</span><br><span class="line">        // 第一个参数不是 0x6D、第一个参数不是 0x0D、当前操作系统不是 macOS</span><br><span class="line">        // XPRW 是 ` DSDT ` 中原始的 GPRW 函数重命名而来</span><br><span class="line">        // 所以这一步实际上是调用了原始 ` DSDT ` 中原始的 GPRW 方法</span><br><span class="line">        Return (XPRW (Arg0, Arg1))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面以 GPRW 为例介绍了相关思路，接下来我们以亮度快捷键补丁为例实际操作一下如何一步一步修改 SSDT。大部分亮度快捷键都是基于 EC Query 触发的，因此在 <code>Clover</code> 中我们的亮度快捷键 <code>SSDT</code> 可能是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// In config ACPI, _Q14 renamed XQ14</span><br><span class="line">// Find:     5F 51 31 34</span><br><span class="line">// Replace:  58 51 31 34</span><br><span class="line"></span><br><span class="line">// In config ACPI, _Q15 renamed XQ15</span><br><span class="line">// Find:     5F 51 31 35</span><br><span class="line">// Replace:  58 51 31 35</span><br><span class="line"></span><br><span class="line">DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;SUKA&quot;, &quot;BrightFN&quot;, 0)</span><br><span class="line">&#123;</span><br><span class="line">    External(_SB.PCI0.LPCB.KBD, DeviceObj)</span><br><span class="line">    External(_SB.PCI0.LPCB.EC, DeviceObj)</span><br><span class="line">    </span><br><span class="line">    Scope (_SB.PCI0.LPCB.EC)</span><br><span class="line">    &#123;</span><br><span class="line">        Method (_Q14, 0, NotSerialized)//up</span><br><span class="line">        &#123;</span><br><span class="line">            Notify(\_SB.PCI0.LPCB.KBD, 0x0406)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Method (_Q15, 0, NotSerialized)//down</span><br><span class="line">        &#123;</span><br><span class="line">            Notify(\_SB.PCI0.LPCB.KBD, 0x0405)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果想知道亮度快捷键补丁的工作原理，请参看我的另一篇文章「<a href="https://blog.skk.moe/post/ssdt-map-fn-shortcuts/">黑苹果自定义键盘 Fn 快捷键</a>」。</p></blockquote><p>根据同样的思路，我们先在 Method 定义中添加 <code>OSI</code> 函数判断操作系统：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;BrightFN&quot;, 0)</span><br><span class="line">&#123;</span><br><span class="line">    External(_SB.PCI0.LPCB.KBD, DeviceObj)</span><br><span class="line">    External(_SB.PCI0.LPCB.EC, DeviceObj)</span><br><span class="line">    </span><br><span class="line">    Scope (_SB.PCI0.LPCB.EC)</span><br><span class="line">    &#123;</span><br><span class="line">        Method (_Q14, 0, NotSerialized)//up</span><br><span class="line">        &#123;</span><br><span class="line">+            If (_OSI (&quot;Darwin&quot;))</span><br><span class="line">+            &#123;</span><br><span class="line">                  Notify(\_SB.PCI0.LPCB.KBD, 0x0406)</span><br><span class="line">+            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Method (_Q15, 0, NotSerialized)//down</span><br><span class="line">        &#123;</span><br><span class="line">+            If (_OSI (&quot;Darwin&quot;))</span><br><span class="line">+            &#123;</span><br><span class="line">                  Notify(\_SB.PCI0.LPCB.KBD, 0x0405)</span><br><span class="line">+            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这里不是以 Return 结束的，所以我们要为 <code>If</code> 加上 <code>Else</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;BrightFN&quot;, 0)</span><br><span class="line">&#123;</span><br><span class="line">    External(_SB.PCI0.LPCB.KBD, DeviceObj)</span><br><span class="line">    External(_SB.PCI0.LPCB.EC, DeviceObj)</span><br><span class="line"></span><br><span class="line">    Scope (_SB.PCI0.LPCB.EC)</span><br><span class="line">    &#123;</span><br><span class="line">        Method (_Q14, 0, NotSerialized)//up</span><br><span class="line">        &#123;</span><br><span class="line">+            If (_OSI (&quot;Darwin&quot;))</span><br><span class="line">+            &#123;</span><br><span class="line">                  Notify(\_SB.PCI0.LPCB.KBD, 0x0406)</span><br><span class="line">+            &#125; Else &#123;</span><br><span class="line">+</span><br><span class="line">+            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Method (_Q15, 0, NotSerialized)//down</span><br><span class="line">        &#123;</span><br><span class="line">+            If (_OSI (&quot;Darwin&quot;))</span><br><span class="line">+            &#123;</span><br><span class="line">                  Notify(\_SB.PCI0.LPCB.KBD, 0x0405)</span><br><span class="line">+            &#125; Else &#123;</span><br><span class="line">+</span><br><span class="line">+            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Else</code> 区域中，调用原始 <code>DSDT</code> 中原始的 <code>_Q14</code>、<code>_Q15</code> 函数、也就是现在已经被重命名为 <code>XQ14</code> 和 <code>XQ15</code> 的函数。当然，别忘了在文件头部添加对 <code>XQ14</code> 和 <code>XQ15</code> 的函数的外部引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">DefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;BrightFN&quot;, 0)</span><br><span class="line">&#123;</span><br><span class="line">    External(_SB.PCI0.LPCB.KBD, DeviceObj)</span><br><span class="line">    External(_SB.PCI0.LPCB.EC, DeviceObj)</span><br><span class="line">+    External(_SB.PCI0.LPCB.EC.XQ14, MethodObj)</span><br><span class="line">+    External(_SB.PCI0.LPCB.EC.XQ15, MethodObj)</span><br><span class="line">    </span><br><span class="line">    Scope (_SB.PCI0.LPCB.EC)</span><br><span class="line">    &#123;</span><br><span class="line">        Method (_Q14, 0, NotSerialized)//up</span><br><span class="line">        &#123;</span><br><span class="line">+            If (_OSI (&quot;Darwin&quot;))</span><br><span class="line">+            &#123;</span><br><span class="line">                  Notify(\_SB.PCI0.LPCB.KBD, 0x0406)</span><br><span class="line">+            &#125; Else &#123;</span><br><span class="line">+                  \_SB.PCI0.LPCB.EC.XQ14()</span><br><span class="line">+            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Method (_Q15, 0, NotSerialized)//down</span><br><span class="line">        &#123;</span><br><span class="line">+            If (_OSI (&quot;Darwin&quot;))</span><br><span class="line">+            &#123;</span><br><span class="line">                  Notify(\_SB.PCI0.LPCB.KBD, 0x0405)</span><br><span class="line">+            &#125; Else &#123;</span><br><span class="line">+                  \_SB.PCI0.LPCB.EC.XQ15()</span><br><span class="line">+            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就大功告成了。</p><p>是不是有些头昏脑涨？实际上，和 <code>Clover</code> 现成的 <code>SSDT</code> 补丁库一样，<code>OpenCore</code> 也有现成的 <code>SSDT</code> 补丁库 <a href="https://github.com/daliansky/OC-little">OC-little</a>，由资深黑苹果爱好者们维护。我也在其中贡献了一些补丁（如 PTWSAK 关机变重启修复）和说明。 你在 <code>Clover</code> 中使用的 <code>SSDT</code> 补丁，大部分都有对应的 <code>OpenCore</code> 下可用的 <code>SSDT</code> 替代，免去了你手动修改的痛苦。而且，你还可能通过 OC-little 库里的其他补丁修复了一些你之前的 <code>SSDT</code> 补丁没有解决的问题。</p><p>当然，对于一些 OC-little 中没有等价替代的补丁，你仍然需要手动修改、添加操作系统判断；对于直接修补的 DSDT，你也只能自己在 <code>Method</code> 中添加对应的判断。</p><p>如果你完成了对 SSDT、DSDT 的修改，现在备份你的 EFI、然后修改后的 SSDT、DSDT 放到 <code>EFI/Clover/ACPI/patched</code> 之中，然后以 <code>-v</code> 重启，看看能不能正常开机。如果可以正常开机，登录以后打开终端执行以下命令、查看日志中是否包括 ACPI Error：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ log show --last boot | grep -Ei &quot;ACPI&quot;</span><br></pre></td></tr></table></figure><p>如果正常开机，没有 ACPI Error，那么恭喜你，你已经迈出了向 <code>OpenCore</code> 迁移的第一步，而且此时你依然还在继续使用 <code>Clover</code> ，你的黑苹果没有收到任何影响。</p><h2><span id="减少不必要的-dsdt-重命名">减少不必要的 <code>DSDT</code> 重命名</span></h2><p><a href="https://github.com/acidanthera">acidanthera</a> 团队认为，应该尽可能减少 <code>DSDT</code> 重命名、减少改动以避免对设备硬件造成伤害。</p><p>以下是一些不再需要的重命名，你可以参考这个表自己精简 <code>DSDT</code> 重命名、使用 <code>SSDT</code> 代替：</p><ul><li><code>EHC1 to EH01</code> 和 <code>EHC2 to EH02</code> ：建议由 <code>OpenCore</code> 官方的 <a href="https://github.com/[acidanthera](https://github.com/acidanthera)/OpenCorePkg/blob/master/Docs/AcpiSamples/SSDT-EHCx_OFF.dsl"><code>SSDT-EHCx_OFF</code></a> 关闭 EHC 控制器。Skylake 这类六代以上已经没有 EHC 控制器了，可以直接删除。</li><li><code>SAT0 to SATA</code> 和 <code>SAT1 to SATA</code> ：实质上完全没用。</li><li><code>HECI to IMEI</code>、<code>HEC1 to IMEI</code>、<code>MEI to IMEI</code> 和 <code>IDER to MEID</code>：WhateverGreen 能够处理这个问题。</li><li><code>GFX0 to IGPU</code>、<code>PEG0 to GFX0</code>、<code>PEGP to GFX0</code> 和 <code>SL01 to PEGP</code>：WhateverGreen 能够处理这个问题。</li><li><code>EC0 to EC</code>、<code>H_EC to EC</code>、<code>ECDV to EC</code> 和 <code>PGEC to EC</code> ：虽然 macOS 的 USB 电源管理需要名称为 <code>EC</code> 的控制器，但是你完全可以在 OC-little 中找到「仿冒 EC」的相关 <code>SSDT</code> 补丁。</li><li><code>HDAS to HDEF</code>、<code>CAVS to HDEF</code> 和 <code>AZAL to HDEF</code> ：AppleALC 能够处理这个问题，除非你在用 VoodooHDA 万能声卡。</li><li><code>STAS to Noop</code> ：建议由 OC-little 中的 <code>SSDT-AWAC</code> 相关补丁替代。</li></ul><blockquote><p>经 <a href="https://github.com/williambj1">Bat.bat</a> 大佬指出，由于新的时钟设备 AWAC 的普及，用 Noop 会导致同时启用两个时钟设备，在 macOS 下只有一个能正常工作、但是在 Windows 下面暴露两个设备无疑对系统有害，同时也严重违反 ACPI 规范。<code>STAS</code> 这个变量的意义使 AWAC 和 RTC 互锁以避免这种危害。因此，使用 <code>SSDT-AWAC</code> 是更理想的办法。</p></blockquote><ul><li><code>PXSX to ANS1</code> 和 <code>PXSX to ANS2</code> ：建议用 <a href="https://github.com/[acidanthera](https://github.com/acidanthera)/NVMeFix">NVMeFix</a> 这个 kext 修复 NVMe SSD 的电源管理。</li><li><code>LPC0 to LPCB</code> ：如果你要添加 SMBUS 支持，OC-little 中分别有 SBUS 的 <code>SSDT</code> 注入补丁和 MCHC 设备补丁。</li></ul><blockquote><p>顺便提醒一下，使用 OC-little 的补丁的时候，需要注意设备的原始 <code>DSDT</code> 中的 LPC 总线名称，并且要自己修改 <code>SSDT</code> 以使 LPC 总线匹配。</p></blockquote><ul><li><code>PC00 to PCIO</code>、<code>FPU to MATH</code>、<code>TMR to TIMR</code>、<code>GBE1 to ETH0</code> 和 <code>PIC to IPIC</code> ：这些重命名也是实质上是完全没用的。</li><li><code>_OSI to XOSI</code> 和 <code>OSID to XSID</code> ：除非你的某些硬件设备只能在 Windows 下工作（比如 I2C 触摸板只能在 Windows 下使用，再比如 ThinkPad 对 FreeBSD 的特殊优化），否则完全没有必要使用 <code>SSDT-XOSI</code> 补丁来伪装操作系统。而且大部分情况下，直接定制 <code>SSDT</code> 也可以解除某些硬件的操作系统限制。</li></ul><blockquote><p>关于「定制 <code>SSDT</code> 以解除限制」，Bat.bat 大佬做了一些说明：一种方法是通过「预置变量法」（详见 OC-little 的「总述」章节）禁用原始设备的函数如 <code>_STA</code>，另一种方法是通过重命名实现对相关 <code>_STA</code> 的函数的精确重命名，然后通过 <code>SSDT</code> 添加新的 <code>_STA</code> 函数（SSDT 中可以添加 <code>OSI</code> 操作系统判断函数）。</p></blockquote><ul><li><code>_DSM to XDSM</code> ：首先遍历一下你的 <code>SSDT</code> 补丁中没有依赖 <code>_DSM</code> 的，如果没有，这个重命名也应该删除，因为这个重命名涉及的范围实在太大了、太过于危险。</li></ul><p>我的建议是，尽可能只添加和 <code>Method</code> 名称有关的重命名（如 <code>GPRW to XPRW</code>、<code>_Q14 to XQ14</code>），而且随后要通过 <code>SSDT</code> 确保在非 macOS 操作系统下要调用并返回原始函数，确保在非 macOS 操作系统下的原始 <code>DSDT</code> 行为不会被改变。如果万不得已要添加其它重命名（如通过重命名禁用某些设备），那么就要权衡这一重命名的后果。</p><p>如果你完成了精简 <code>DSDT</code> 重命名并保存了 config，接下来的操作还是一样的，备份原始 EFI、然后以 <code>-v</code> 重启，看看能不能正常开机。如果可以正常开机，登录以后打开终端执行以下命令、查看日志中是否包括 ACPI Error：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ log show --last boot | grep -Ei &quot;ACPI&quot;</span><br></pre></td></tr></table></figure><p>完成这一步，你依然没有必要离开 <code>Clover</code> 。我说过了，「渐进式」地迁移，嗯？</p><h2><span id="摆脱对-clover-acpi-quirks-的依赖">摆脱对 <code>Clover</code> ACPI Quirks 的依赖</span></h2><p>Clover 实在是非常方便。一个开关，关机变重启就修复了；三个开关，HPET、IRQ、TIMR 就修复了；等等等等。但是 <code>OpenCore</code> 是没有内置这些 ACPI 修复的，所以在 <code>Clover</code> 下用开关实现的 ACPI 修复现在都必须用 <code>SSDT</code> 实现。所幸的是，我们依然可以从 OC-little 里找到绝大部分我们需要的补丁。</p><ul><li><code>FixIPIC</code>：参考 OC-little 的「声卡 IRQ 补丁」章节</li><li><code>FixSBUS</code>：参考 OC-little 的「注入 SBUS 设备」</li><li><code>FixShutdown</code>：参考 OC-little 的「PTSWAK 综合补丁章节」，需要添加其中的 EXT1 插件补丁（该补丁由我贡献）</li><li><code>FixDisplay</code>：使用 WhateverGreen 和定制缓冲帧补丁解决</li><li><code>AddMCHC</code>：参考 OC-little 的「注入缺失的 MCHC」章节</li><li><code>FixHDA</code>：使用 AppleALC 即可</li><li><code>FixHPET</code>：参考 OC-little 的「声卡 IRQ 补丁」章节</li><li><code>FixSATA</code>：这个先不管它，<code>OpenCore</code> 中有个 <code>ExternalDiskIcons</code> 的 Quirk，也可以使用 <code>innie.kext</code> 解决。</li><li><code>FixADP1</code>：使用 <code>DSDT</code> 重命名 <code>AC0_ to ADP1</code>，可能还要额外注入 <code>Name (_PRW, Package (0x02) &#123;0x1C,0x03&#125;)</code>。</li><li><code>FixRTC</code>：参考 OC-little 的「声卡 IRQ 补丁」章节</li><li><code>FixTIMR</code>：参考 OC-little 的「声卡 IRQ 补丁」章节</li><li><code>AddPNLF</code>：参考 OC-little 的「注入 PNLF」章节</li><li><code>AddIMEI</code>：使用 WhateverGreen 即可</li><li><code>FixIntelGfx</code>：使用 WhateverGreen 即可</li><li><code>AddHDMI</code>：使用 WhateverGreen 即可</li></ul><p>除了这些开关以外，Clover 还有一些其它的 ACPI 设定，也有与之对应的替代。</p><ul><li><code>DisableASPM</code>：没有很好的代替方法，可以在设备属性（DeviceProperties）中分别添加相关设备的 PCI 总线位置并注入属性 <code>pci-aspm-default | DATA | &lt;00&gt;</code>。</li><li><code>PluginType</code>：参考 OC-little 的「注入 X86」章节</li><li><code>Generate P States</code> 和 <code>Generate C States</code>：这些是六代以前 CPU 才需要的设置，可以用 <a href="https://github.com/Piker-Alpha/ssdtPRGen.sh">ssdtPRGen.sh</a> 生成对应的 SSDT。</li></ul><p>当然之后的事情还是一样的，以 <code>-v</code> 重启，正常开机后打开终端查看日志中是否包括 ACPI Error：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ log show --last boot | grep -Ei &quot;ACPI&quot;</span><br></pre></td></tr></table></figure><p>当你把所有 <code>Clover</code> 的开关都用 <code>SSDT</code> 代替以后，你离迁移到 <code>OpenCore</code> 就越来越近了。</p><h2><span id="更新设备属性">更新设备属性</span></h2><h3><span id="使用缓冲帧补丁驱动-intel-核显">使用缓冲帧补丁驱动 Intel 核显</span></h3><p>如果你还在用 <code>Clover</code> 的 InjectIntel 的方式来驱动 Intel 核显的话，是时候更换到 WhateverGreen 和缓冲帧补丁的方式了。</p><p>建议参考以下几篇文章：</p><ul><li><a href="https://blog.zuiyu1818.cn/posts/Hac_Intel_Graphics.html">使用 WhateverGreen 驱动 Intel 核显 | 醉渔小站</a></li><li><a href="https://blog.daliansky.net/Intel-FB-Patcher-tutorial-and-insertion-pose.html#%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E7%BB%99%E7%BC%93%E5%86%B2%E5%B8%A7%E6%89%93%E8%A1%A5%E4%B8%81">Hackintool(原Intel FB-Patcher)使用教程及插入姿势 | 黑果小兵的部落阁</a></li><li><a href="https://github.com/[acidanthera](https://github.com/acidanthera)/WhateverGreen/blob/master/Manual/FAQ.IntelHD.en.md">Intel 核显驱动常见问题 | WhateverGreen</a> （务必看英文版，中文翻译严重过时）</li></ul><h3><span id="新的声卡-layout-id-注入方式">新的声卡 layout-id 注入方式</span></h3><p>大部分黑苹果的声卡教程都已经推荐此处留空、直接在设备属性中注入 layout-id 了，不过我还是再冗笔一下。</p><p>下载 <a href="https://github.com/acidanthera">acidanthera</a> 开发的工具 <a href="https://github.com/[acidanthera](https://github.com/acidanthera)/gfxutil/releases">gfxutils</a>，使用下述命令找出声卡的 PCI 总线位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ path/to/gfxutils -f HDEF</span><br><span class="line">$ path/to/gfxutils -f HDAS</span><br><span class="line">$ path/to/gfxutils -f HDAU</span><br></pre></td></tr></table></figure><p>然后在设备属性中添加 PCI 总线位置、注入 <code>layout-id</code> 属性。</p><p>至于 <code>AFGLowPowerState</code>，需要额外为声卡设备注入 <code>AFGLowPowerState</code> 属性，值为 <code>DATA | &lt;01000000&gt;</code>、至于 <code>ResetHDA</code>，推荐安装 <a href="https://github.com/fewtarius/jackfix">JackFix</a>。</p><h2><span id="开始组织-opencore-目录">开始组织 <code>OpenCore</code> 目录</span></h2><p>终于是时候了，所有的准备工作都做完了！你可以抽出一天（最好占卜一下是否是吉日），沐浴更衣，然后开始组织你的 <code>OpenCore</code> 目录。</p><h3><span id="下载-opencore-所需文件">下载 <code>OpenCore</code> 所需文件</span></h3><ul><li><p><a href="https://github.com/[acidanthera](https://github.com/acidanthera)/OpenCorePkg/releases">OpenCorePkg</a> - <code>OpenCore</code> 本体、一些 <code>SSDT</code> 补丁、目录结构</p></li><li><p><a href="https://github.com/[acidanthera](https://github.com/acidanthera)/MacInfoPkg/releases">MacInfoPkg</a> - 导出你当前的三码、以及生成新的三码</p></li><li><p><a href="https://github.com/[acidanthera](https://github.com/acidanthera)/AppleSupportPkg/releases">AppleSupportPkg</a> - 包括三个 EFI 驱动，<code>ApfsDriverLoader</code>、<code>VBoxHfs</code>、<code>AudioDxe</code></p></li><li><p>OcBinaryData</p><p>- 包含两个闭源驱动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HfsPlus.efi</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExFatDxe.efi</span><br></pre></td></tr></table></figure><p>，以及</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OpenCore</span><br></pre></td></tr></table></figure><p>官方主题的图标文件。</p><ul><li>非常推荐安装 <code>OpenCore</code> 官方做的主题，和真 Mac 的 BootPicker 一模一样（除了没有网络图标）。不过那可能是另一篇文章的主题了。</li></ul></li></ul><h3><span id="决定你使用的配置文件编辑器">决定你使用的配置文件编辑器</span></h3><ul><li><p><a href="https://github.com/corpnewt/ProperTree">ProperTree</a>：一个 Python 编写的 plist 编辑器，专门优化了 <code>OpenCore</code> 和 <code>Clover</code> 配置文件编写。</p></li><li><p>Xcode：非常不推荐，Xcode 11 不仅花里胡哨、而且处理 plist data 和大整数方面存在问题。</p><ul><li>简单来说，Apple 没有再开放旧版的 Xcode 10 下载、而且 Apple 的 CDN 还有防盗链。因此如果我要写一篇从 Apple 官方下载 Xcode 10 的教程，那么会比你现在看的这篇的「从 <code>Clover</code> 到 <code>OpenCore</code>」要长得多。</li><li>如果你和我一样成功下载了 Xcode 10 或者就没有升级到 Xcode 11：我刚才什么都没写，你什么都没看见。</li></ul></li><li><p><code>OpenCore</code> Configurator</p><p>：Clover Configurator 作者的新作品。很适合新手使用。</p><ul><li><code>OpenCore</code> 的配置文件变更非常频繁，因此只应该用 <strong>最新版的 <code>OpenCore</code> Configurator</strong> 搭配 **最新的正式版的 <code>OpenCore</code>**，否则配置文件格式错误将会导致无法引导。</li><li><code>OpenCore</code> Configurator 有不少低级 Bug（后来更新时都修复了），比如之前有一个版本，在应对 <code>VoodooPS2Controller</code> 和 <code>VooooI2C</code> 这种嵌套 kext 时，会只添加内部 kext 的 <code>dsYM</code> 签名文件、却不添加内部 kext 本体。</li><li>反正就是，使用后果自负。</li></ul></li></ul><h3><span id="生成目录结构">生成目录结构</span></h3><p>解压下载的 <code>OpenCore</code> 并解压，将其中的 EFI 目录 <strong>复制出来到别处</strong>。</p><blockquote><p>直到配置好以后，再将这个目录合并进硬盘上的 EFI 分区。</p></blockquote><p>将 Docs 目录下的 <code>Sample.list</code> 复制到 <code>EFI/OC</code> 目录下、并重命名为 <code>config.plist</code>。</p><blockquote><p>如果你下载的是 <code>OpenCore</code> 0.5.7 版本，还需要额外将 <code>Reources</code> 目录复制到 <code>EFI/OC</code> 目录之中。</p></blockquote><p>解压下载的 AppleSupportPkg，将其中的 Drivers 目录和 Tools 目录中的文件复制到 <code>EFI/OC/Drivers</code> 目录和 <code>EFI/OC/Tools</code> 目录中。</p><p>解压下载的 OcBinaryData，将其中 Drivers 目录复制到 <code>EFI/OC/Drivers</code> 目录中。</p><h3><span id="删除不需要的文件">删除不需要的文件</span></h3><p>删除 Drivers 目录中的这些文件：</p><ul><li><code>ExFatDxe</code> 和 <code>ExFatDxeLegacy</code>：除非你的 EFI 分区或者某个系统分区是 ExFAT 分区格式的，否则不需要保留。</li><li><code>HfsPlus</code>、<code>HfsPlusLegacy</code> 和 <code>VBoxHfs</code>：三者只要留其中一个即可。一般推荐用 HfsPlus，比 VBoxHfs 速度快三倍。在四代以前机型上应该用 HfsPlusLegcay 而不是 HfsPlus。</li><li><code>AppleUsbKbDxe</code> 或 <code>OpenUsbKbDxe</code>：这是为三代以前机型使用的，现代的机器应该使用 <code>OpenCore</code> 中的 <code>KeySupport</code> 这个 Quirk。</li><li><code>NvmExpressDxe</code>：这是为四代以前机型使用的 NVMe 硬盘加载驱动，现代的机器已经不需要了。</li><li><code>XhciDxe</code>：为二代以前的主板提供 XHCI 支持的，现代的机器已经不需要了。</li><li><code>HiiDatabase</code>：为四代以前的设备提供 UEFI 界面字体渲染支持的，现代的机器已经不需要了。</li></ul><p>删除 Tools 目录中的这些文件：</p><ul><li><code>BootKicker</code>：调用 Mac 内置的引导界面，是用于给白苹果安装 <code>OpenCore</code> 时用的，黑苹果用不上。</li></ul><hr><p>现在，你的 <code>OpenCore</code> EFI 目录的结构应该是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">EFI</span><br><span class="line">├── BOOT</span><br><span class="line">│   └── BOOTx64.efi</span><br><span class="line">└── OC</span><br><span class="line">    ├── ACPI</span><br><span class="line">    ├── Drivers</span><br><span class="line">    │   ├── ApfsDriverLoader.efi</span><br><span class="line">    │   ├── AudioDxe.efi</span><br><span class="line">    │   ├── HfsPlus.efi</span><br><span class="line">    │   ├── OpenCanopy.efi</span><br><span class="line">    │   └── OpenRuntime.efi</span><br><span class="line">    ├── Kexts</span><br><span class="line">    ├── OpenCore.efi</span><br><span class="line">    ├── Resources</span><br><span class="line">    └── Tools</span><br><span class="line">        ├── ChipTune.efi</span><br><span class="line">        ├── ......</span><br><span class="line">        └── VerifyMsrE2.efi</span><br></pre></td></tr></table></figure><p>现在，你可以把你的 SSDT、DSDT 从 <code>Clover</code> 里的 <code>Clover/ACPI/Patched</code> 复制出来、粘贴进 <code>EFI/OC/ACPI</code> 目录中；将 Kext 从 <code>Clover/Kexts/*/</code> 中复制出来粘贴进 <code>EFI/OC/Kexts</code> 目录中。</p><h2><span id="开始配置-opencore">开始配置 <code>OpenCore</code></span></h2><p>这里我就不再赘述 <code>OpenCore</code> 的配置教程了。这里推荐几个写的不错的教程和足够有用的参考资料。</p><ul><li><code>OpenCore</code> 参考文档。当你解压下载的 <code>OpenCore</code> 时，<code>Docs/Configuration.pdf</code> 文件就是 <code>OpenCore</code> 的官方文档。这是最权威的 <code>OpenCore</code> 参考资料、没有之一。</li><li><a href="https://oc.skk.moe/"><code>OpenCore</code> 简体中文参考手册</a>。<code>OpenCore</code> 参考手册的翻译，由我和一些黑苹果爱好者们共同在维护。</li></ul><blockquote><p>上面两份参考资料资料适合你在配置时不知道某个选项的具体作用、具体副作用时参考用，但是不适合直接对着它们配置 <code>config.plist</code>。<br>如果想要快速上手 <code>OpenCore</code> 配置，应该参考下面的教程：</p></blockquote><ul><li><a href="https://khronokernel-2.gitbook.io/opencore-vanilla-desktop-guide/"><code>OpenCore</code> Vanilla Guide</a>。<code>OpenCore</code> 官方认可写得较好的新手教程。这篇教程受众是第一次接触黑苹果就想用 <code>OpenCore</code> 的人，因此内容写得非常浅显</li><li><a href="https://blog.daliansky.net/OpenCore-BootLoader.html#%E9%85%8D%E7%BD%AE-opencore">精解 <code>OpenCore</code> | 黑果小兵的部落阁</a>。国内最早的 <code>OpenCore</code> 介绍文档之一，提供了不少配置思路和 Quirks 的推荐配置。</li><li><a href="https://blog.xjn819.com/?p=543">使用 <code>OpenCore</code> 引导黑苹果 | XJN’s Blog</a>。比较详细的 <code>OpenCore</code> 配置介绍，但是这篇文章的排版我实在是欣赏不来。</li><li><a href="https://kirainmoe.com/blog/post/opencore-migration-experience/#13-%E4%BF%AE%E6%94%B9-configplist"><code>OpenCore</code> 引导迁移折腾记录 | 宇宙よりも遠い場所</a>。内容详细的 <code>OpenCore</code> 配置介绍，提供了不少 Quirks 的推荐配置。</li></ul><p>Clover 中的部分配置，如 <code>DSDT</code> 重命名，由于在之前已经精简，因此可以将 Find 和 Replace 的十六进制字符串逐对复制到 <code>OpenCore</code> 的配置文件中。</p><h2><span id="clover-中的设置在-opencore-的等效配置">Clover 中的设置在 <code>OpenCore</code> 的等效配置</span></h2><p>现在你开始跟着我推荐的教程和参考资料开始配置 <code>OpenCore</code> 了。接下来我会写一些 <code>Clover</code> 中一些选项在 <code>OpenCore</code> 的对应等效配置，在配置 <code>OpenCore</code> 时别忘了跟着看看。</p><h3><span id="boot-的相关设置">Boot 的相关设置</span></h3><ul><li><p>引导参数：<code>OpenCore</code> 中 <code>NVRAM -&gt; Add -&gt; 7C436110-AB2A-4BBB-A880-FE41995C9F82 -&gt; boot-args</code></p></li><li><pre><code>NeverHibernate<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">：</span><br><span class="line"></span><br></pre></td></tr></table></figure>Misc -&gt; Boot -&gt; HibernateMode -&gt; None<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 其实不再建议禁用休眠，由于 `OpenCore` 的行为和白苹果更加接近，以至于已经可以实现 macOS 的完美休眠。</span><br><span class="line"></span><br><span class="line">- Default Boot Volume：</span><br><span class="line"></span><br></pre></td></tr></table></figure>OpenCore<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">中</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>Misc - Security - AllowSetDefaults - true<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 然后在 `OpenCore` 的引导菜单处使用 Ctrl + Enter 按键进行选择</span><br><span class="line">  - 你也可以直接用「系统偏好设置」中的「启动磁盘」设置</span><br><span class="line"></span><br><span class="line">- DefaultBackgroundColor：`OpenCore` 中的 `NVRAM -&gt; Add -&gt; 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14-&gt; DefaultBackgroundColor` ，需要自己将 RGB 转换为 HEX。</span><br><span class="line"></span><br><span class="line">- EFILoginHiDPI：</span><br><span class="line"></span><br></pre></td></tr></table></figure>OpenCore<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">中</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>NVRAM -&gt; Add -&gt; 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14 -&gt; EFILoginHiDPI | Data | &lt;&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 0 -&gt; `&lt;00000000&gt;`</span><br><span class="line">  - 1 -&gt; `&lt;01000000&gt;`</span><br><span class="line"></span><br><span class="line">- flagstate：</span><br><span class="line"></span><br></pre></td></tr></table></figure>OpenCore<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">中</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>NVRAM -&gt; Add -&gt; 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14 -&gt; flagstate | Data | &lt;&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 0 -&gt; `&lt;00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000&gt;`</span><br><span class="line">  - 注意自行判断 NVRAM 键值对位置</span><br><span class="line"></span><br><span class="line">- UIScale：</span><br><span class="line"></span><br></pre></td></tr></table></figure>NVRAM -&gt; Add -&gt; 4D1EDE05-38C7-4A6A-9CC6-4BCCA8B38C14 -&gt; UIScale | Data | &lt;&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 1 -&gt; `&lt;01&gt;`</span><br><span class="line">  - 2 -&gt; `Data | &lt;02&gt;`</span><br><span class="line"></span><br><span class="line">### CPU 相关配置</span><br><span class="line"></span><br><span class="line">- Type：在</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br></pre></td></tr></table></figure>OpenCore<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">中有对应的</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>Platforminfo -&gt; SMBIOS -&gt; ProcessorType<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  可以设置处理器类型</span><br><span class="line"></span><br><span class="line">  - 在 [这个文件](https://github.com/[acidanthera](https://github.com/acidanthera)/EfiPkg/blob/master/Include/IndustryStandard/AppleSmBios.h) 查看可以选用的值</span><br><span class="line"></span><br><span class="line">- HWPEnable：如果你真的要依赖 `MSR 0x770` （注意这里说的不是原生电源管理 `MSR 0xe2`）的 HWP 电源管理，建议安装 headkaze 开发的 [`HWPEnable.kext`](https://github.com/headkaze/HWPEnable/tree/master/binary)。HackinTool 也是他开发的。</span><br><span class="line"></span><br><span class="line">- QEMU：`OpenCore` 已经完整支持虚拟机，因此 `OpenCore` 中不包含这一选项。</span><br><span class="line"></span><br><span class="line">- TurboDisable：建议用 CPUFriend 或者 [ssdtPRGen.sh](http://ssdtprgen.sh/) 来修复电源管理。</span><br><span class="line"></span><br><span class="line">### 设备属性相关设置</span><br><span class="line"></span><br><span class="line">#### USB</span><br><span class="line"></span><br><span class="line">- FixOwnership：`OpenCore` 中 `UEFI -&gt; Quirk -&gt; ReleaseUsbOwnership`</span><br><span class="line"></span><br><span class="line">- ClockID：需要自己注入对应的设备属性（Device Properties），属性为 `AAPL,clock-id`</span><br><span class="line"></span><br><span class="line">- HighCurrent：需要自己注入对应的设备属性（Device Properties），属性为</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br></pre></td></tr></table></figure>AAPL,HighCurrent<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 对于 macOS 10.11 来说 HighCurrent 已经没啥用了。对于更新版的 macOS，推荐用 OC-little 中的 `SSDT-USBX` 补丁。</span><br><span class="line"></span><br><span class="line">#### FakeID</span><br><span class="line"></span><br><span class="line">同样使用 gfxutils 工具找到 PCI 总线位置，然后分别注入相关属性：</span><br><span class="line"></span><br><span class="line">- USB</span><br><span class="line"></span><br><span class="line">  - `device-id`</span><br><span class="line">  - `device_type`</span><br><span class="line">  - `device_type`</span><br><span class="line"></span><br><span class="line">- IMEI</span><br><span class="line"></span><br><span class="line">  - `device-id`</span><br><span class="line">  - `vendor-id`</span><br><span class="line"></span><br><span class="line">- WIFI</span><br><span class="line"></span><br><span class="line">  - `name`</span><br><span class="line">  - `compatible`</span><br><span class="line"></span><br><span class="line">- LAN</span><br><span class="line"></span><br><span class="line">  - `device-id`</span><br><span class="line">  - `compatible`</span><br><span class="line">  - `vendor-id`</span><br><span class="line"></span><br><span class="line">- XHCI</span><br><span class="line"></span><br><span class="line">  - `device-id`</span><br><span class="line"></span><br><span class="line">  - `device_type: UHCI`</span><br><span class="line"></span><br><span class="line">  - `device_type: OHCI`</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    device_type: EHCI</span><br></pre></td></tr></table></figure>  - `device-id`  - `AAPL,current-available`  - `AAPL,current-extra`  - `AAPL,current-available`  - `AAPL,current-extra`  - `AAPL,current-in-sleep`  - `built-in`- ```  device_type: XHCI  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - `device-id`</span><br><span class="line">    - `AAPL,current-available`</span><br><span class="line">    - `AAPL,current-extra`</span><br><span class="line">    - `AAPL,current-available`</span><br><span class="line">    - `AAPL,current-in-sleep`</span><br><span class="line">    - `built-in`</span><br><span class="line"></span><br><span class="line">### Clover 中相关的图形设置</span><br><span class="line"></span><br><span class="line">和前文一样，这些在 `Clover` 中设置的属性都需要改为注入对应的设备属性即可。</span><br><span class="line"></span><br><span class="line">- InjectAti</span><br><span class="line"></span><br><span class="line">  :</span><br><span class="line"></span><br><span class="line">  - `DeviceProperties -&gt; Add -&gt; PCIRoot... -&gt; deviceID`</span><br><span class="line">  - `DeviceProperties -&gt; Add -&gt; PCIRoot... -&gt; Connectors`</span><br><span class="line"></span><br><span class="line">- InjectNvidia</span><br><span class="line"></span><br><span class="line">  :</span><br><span class="line"></span><br><span class="line">  - `DeviceProperties -&gt; Add -&gt; PCIRoot... -&gt; DeviceID`</span><br><span class="line">  - `DeviceProperties -&gt; Add -&gt; PCIRoot... -&gt; Family`</span><br><span class="line"></span><br><span class="line">- FakeAti</span><br><span class="line"></span><br><span class="line">  :</span><br><span class="line"></span><br><span class="line">  - `DeviceProperties -&gt; Add -&gt; PCIRoot... -&gt; device-id`</span><br><span class="line">  - `DeviceProperties -&gt; Add -&gt; PCIRoot... -&gt; ATY,DeviceID`</span><br><span class="line">  - `DeviceProperties -&gt; Add -&gt; PCIRoot... -&gt; @0,compatible`</span><br><span class="line">  - `DeviceProperties -&gt; Add -&gt; PCIRoot... -&gt; vendor-id`</span><br><span class="line">  - `DeviceProperties -&gt; Add -&gt; PCIRoot... -&gt; ATY,VendorID`</span><br><span class="line"></span><br><span class="line">- BootDisplay</span><br><span class="line"></span><br><span class="line">  :</span><br><span class="line"></span><br><span class="line">  - `DeviceProperties -&gt; Add -&gt; PCIRoot... -&gt; @0,AAPL,boot-display`</span><br><span class="line"></span><br><span class="line">&gt; Intel 核显推荐使用 WhateverGreen 和缓冲帧补丁驱动。</span><br><span class="line"></span><br><span class="line">一般的，在注入仿造显卡或仿造 VBIOS 的时候，更推荐使用 `SSDT` 搭配 WhateverGreen 的方式。至于 EDID 注入，WhateverGreen 的文档中有 [详细介绍](https://github.com/[acidanthera](https://github.com/acidanthera)/WhateverGreen/blob/master/Manual/FAQ.IntelHD.en.md#edid)。</span><br><span class="line"></span><br><span class="line">### 内核扩展驱动（Kext）相关</span><br><span class="line"></span><br><span class="line">- **KernelPm** 和 **AppleIntelCPUPM**：对应 `OpenCore` 中 `Kernel -&gt; Quirks -&gt; AppleXcpmCfgLock -&gt; YES` 和 `Kernel -&gt; Quirks -&gt; AppleCpuPmCfgLock -&gt; YES`。</span><br><span class="line"></span><br><span class="line">- DellSMBIOSPatch</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  ：在</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br></pre></td></tr></table></figure>OpenCore<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  中对应了两个 Quirk：</span><br><span class="line"></span><br><span class="line">  - `Kernel -&gt; Quirks -&gt; CustomSMBIOSGuid -&gt; YES`</span><br><span class="line">  - `PlatformInfo -&gt; UpdateSMBIOSMode -&gt; Custom`</span><br><span class="line"></span><br><span class="line">- **Kernel LAPIC** 和 **KernelXCPM**：分别对应 `OpenCore` 中的 `Kernel -&gt; Quirks -&gt; LapicKernelPanic -&gt; YES` 和 `Kernel -&gt; Quirks -&gt; AppleXcpmExtraMsrs -&gt; YES`</span><br><span class="line"></span><br><span class="line">- AppleRTC</span><br><span class="line"></span><br><span class="line">  ：</span><br><span class="line"></span><br><span class="line">  - Comment：Disable RTC checksum update on poweroff</span><br><span class="line">  - Enabled：YES</span><br><span class="line">  - Count：1</span><br><span class="line">  - Base：`__ZN8AppleRTC14updateChecksumEv`</span><br><span class="line">  - Identifier：`com.apple.driver.AppleRTC`</span><br><span class="line">  - Limit：0</span><br><span class="line">  - Find：</span><br><span class="line">  - Replace：c3</span><br><span class="line"></span><br><span class="line">- **FakeCPUID**：`OpenCore` 提供了专门的 Emulate 功能。</span><br><span class="line"></span><br><span class="line">除此以外，一些常用的 Kext Patch 在 `OpenCore` 中也有了对应了 Quirk。</span><br><span class="line"></span><br><span class="line">- 解除 USB 15 端口限制，以前根据不同的系统需要打不同的 Kext Patch，现在只需要 `OpenCore` 一个 Quirk：`Kernel -&gt; Quirks -&gt; XhciPortLimit -&gt; YES`</span><br><span class="line"></span><br><span class="line">- 内置硬盘变外置硬盘，也只需要一个 Quirk：</span><br><span class="line"></span><br></pre></td></tr></table></figure>kernel -&gt; Quirks -&gt; ExternalDiskIcons -&gt; YES<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 和前面的 FixSATA 不同，FixSATA 顾名思义只修复 SATA 硬盘，而 `OpenCore` 这个 Quirks 会修复所有的硬盘。</span><br><span class="line"></span><br><span class="line">- 为 SATA SSD 提供 TRIM 现在也只需要启用一个 Quirk：`Kernel -&gt; Quirks -&gt; ThirdPartyDrive`</span><br><span class="line"></span><br><span class="line">### SMBIOS 机型信息和系统参数</span><br><span class="line"></span><br><span class="line">- **Product Name**：`PlatformInfo -&gt; Generic -&gt; SystemProductName`</span><br><span class="line"></span><br><span class="line">- **Serial Number**：`PlatformInfo --&gt; Generic -&gt; SystemSerialNumber`</span><br><span class="line"></span><br><span class="line">- **Board Serial Number**：`PlatformInfo -&gt; Generic -&gt; MLB`</span><br><span class="line"></span><br><span class="line">- **SmUUID**：`PlatformInfo -&gt; Generic -&gt; SystemUUID`</span><br><span class="line"></span><br><span class="line">- Slots AAPL Injection</span><br><span class="line"></span><br><span class="line">  ：需要注入到设备属性中</span><br><span class="line"></span><br><span class="line">  - `DeviceProperties -&gt; Add -&gt; PCIRoot... -&gt; APPL,slot-name | string | Add slot`</span><br><span class="line"></span><br><span class="line">- **CustomUUID**：就连 `Clover` 都不推荐配置这一项，`OpenCore` 直接就不提供硬件 UUID 配置功能</span><br><span class="line"></span><br><span class="line">- **InjectSystemID**：兼容变色龙的历史遗留配置，`OpenCore` 也不再提供</span><br><span class="line"></span><br><span class="line">- BacklightLevel</span><br><span class="line"></span><br><span class="line">  ：需要注入到 NVRAM 中</span><br><span class="line"></span><br><span class="line">  - `NVRAM -&gt; Add -&gt; 7C436110-AB2A-4BBB-A880-FE41995C9F82 -&gt; backlight-level | Data | &lt;Insert value&gt;`</span><br><span class="line"></span><br><span class="line">- NvidiaWeb</span><br><span class="line"></span><br><span class="line">  ：需要注入到 NVRAM 中</span><br><span class="line"></span><br><span class="line">  - `NVRAM -&gt; Add -&gt; 7C436110-AB2A-4BBB-A880-FE41995C9F82 -&gt; nvda_drv: &lt;31&gt;`</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">配置好 `OpenCore` 以后，可以将 `OpenCore` 复制到 U 盘或者硬盘中。需要注意的是，`EFI/BOOT/BOOTx64.efi` 需要直接替换。在添加引导项时，`OpenCore` **必须** 从 `EFI/BOOT/BOOTx64.efi` 启动而不是从 `EFI/OC/OpenCore.efi` 启动。如果启动项中添加的不是 `EFI/BOOT/BOOTx64.efi`，那么有很大的概率你会遇到各种奇怪的问题。</span><br><span class="line"></span><br><span class="line">## 清理 `Clover` 残余</span><br><span class="line"></span><br><span class="line">重启到 `OpenCore` 引导之前，务必清理掉 `Clover` 的残留文件：</span><br><span class="line"></span><br></pre></td></tr></table></figure>sudo rm -rf /Library/PreferencePanes/Clover.prefPane # 删除 `Clover` 位于系统偏好设置中的面板# 删除 `Clover` 的自动脚本rm -rf &quot;/etc/rc.clover.lib&quot;rm -rf &quot;/etc/rc.boot.d/10.save_and_rotate_boot_log.local&quot;rm -rf &quot;/etc/rc.boot.d/20.mount_ESP.local&quot;rm -rf &quot;/etc/rc.boot.d/70.disable_sleep_proxy_client.local.disabled&quot;rm -rf &quot;/etc/rc.boot.d/80.save_nvram_plist.local&quot;rm -rf &quot;/etc/rc.shutdown.local&quot;rm -rf &quot;/etc/rc.boot.d&quot;rm -rf &quot;/etc/rc.shutdown.d&quot;# 删除 `Clover` 的守护进程launchctl unload &#39;/Library/LaunchDaemons/com.slice.CloverDaemonNew.plist&#39;rm -rf &#39;/Library/LaunchDaemons/com.slice.CloverDaemonNew.plist&#39;rm -rf &#39;/Library/Application Support/Clover/CloverDaemonNew&#39;rm -rf &#39;/Library/Application Support/Clover/CloverLogOut&#39;rm -rf &#39;/Library/Application Support/Clover/CloverWrapper.sh&#39;</code></pre></li></ul><p>除此以外，还要删除 EFI 分区中的 <code>nvram.plist</code> 文件。</p><p>在 <code>OpenCore</code> 中还需要重置 NVRAM。可以在 <code>OpenCore</code> 引导菜单中，按下空格键显示隐藏条目，最后一个条目就是 <code>OpenCore</code> 的重置 NVRAM 功能。</p><h2><span id="原文链接">原文链接：</span></h2><p><a href="https://blog.skk.moe/post/from-clover-to-opencore/">https://blog.skk.moe/post/from-clover-to-opencore/</a></p><h2><span id="感谢名单">感谢名单</span></h2><ul><li><a href="https://www.apple.com/">Apple</a> 的 macOS</li><li><a href="https://github.com/rehabman">RehabMan</a>维护的项目：<a href="https://github.com/RehabMan/OS-X-Clover-Laptop-Config">OS-X-Clover-Laptop-Config</a> <a href="https://github.com/RehabMan/Laptop-DSDT-Patch">Laptop-DSDT-Patch</a> <a href="https://github.com/RehabMan/OS-X-USB-Inject-All">OS-X-USB-Inject-All</a>等</li><li><a href="https://github.com/acidanthera">Acidanthera</a> 维护的项目：<a href="https://github.com/acidanthera/OpenCorePkg">OpenCorePkg</a> <a href="https://github.com/acidanthera/Lilu">lilu</a> <a href="https://github.com/acidanthera/AirportBrcmFixup">AirportBrcmFixup</a> <a href="https://github.com/acidanthera/WhateverGreen">WhateverGreen</a> <a href="https://github.com/acidanthera/VirtualSMC">VirtualSMC</a> <a href="https://github.com/acidanthera/AppleALC">AppleALC</a> <a href="https://github.com/acidanthera/BrcmPatchRAM">BrcmPatchRAM</a> <a href="https://github.com/acidanthera/MaciASL">MaciASL</a> 等</li><li><a href="https://www.insanelymac.com/forum/profile/1364628-headkaze/">headkaze</a> 提供的工具：<a href="https://github.com/headkaze/Hackintool">hackintool</a> <a href="https://github.com/headkaze/PinConfigurator">PinConfigurator</a> <a href="https://www.insanelymac.com/forum/topic/339175-brcmpatchram2-for-1015-catalina-broadcom-bluetooth-firmware-upload/">BrcmPatchRAM</a></li><li><a href="https://github.com/CloverHackyColor">CloverHackyColor</a>维护的项目：<a href="https://github.com/CloverHackyColor/CloverBootloader">CloverBootloader</a> <a href="https://github.com/CloverHackyColor/CloverThemes">CloverThemes</a></li><li>宪武整理的：<a href="https://github.com/daliansky/P-little">P-little</a> <a href="https://github.com/daliansky/OC-little">OC-little</a></li><li><a href="https://github.com/chris1111">chris1111</a>维护的项目：<a href="https://github.com/chris1111/VoodooHDA-2.9.2-Clover-V15">VoodooHDA</a> <a href="https://github.com/chris1111/Wireless-USB-Adapter-Clover">Wireless USB Adapter Clover</a></li><li><a href="https://github.com/zxystd">zxystd</a>开发的<a href="https://github.com/zxystd/itlwm">itlwm</a> <a href="https://github.com/zxystd/IntelBluetoothFirmware">IntelBluetoothFirmware</a></li><li><a href="https://github.com/lihaoyun6">lihaoyun6</a>提供的工具：<a href="https://github.com/lihaoyun6/CPU-S">CPU-S</a> <a href="https://github.com/lihaoyun6/macOS-Displays-icon">macOS-Displays-icon</a> <a href="https://github.com/lihaoyun6/SidecarPatcher">SidecarPatcher</a></li><li><a href="https://github.com/SukkaW">sukka</a>更新维护的<a href="https://blog.skk.moe/post/from-clover-to-opencore/">从 Clover 到 OpenCore —— Clover 迁移 OpenCore 指南</a></li><li><a href="https://github.com/xzhih">xzhih</a>提供的工具：<a href="https://github.com/xzhih/one-key-hidpi">one-key-hidpi</a></li><li><a href="https://github.com/williambj1">Bat.bat</a>更新维护的<a href="https://blog.daliansky.net/OpenCore-BootLoader.html">精解OpenCore</a></li><li><a href="https://github.com/shuiyunxc">shuiyunxc</a> 更新维护的<a href="https://shuiyunxc.gitee.io/2020/04/06/Faults/index/">OpenCore配置错误、故障与解决办法</a></li><li><a href="https://github.com/athlonreg">athlonreg</a>更新维护的<a href="https://blog.cloudops.ml/ocbook/">OpenCore 0.5+ 部件补丁</a> <a href="https://github.com/athlonreg/Common-patches-for-hackintosh">Common-patches-for-hackintosh</a></li><li><a href="https://blog.daliansky.net/github.com">github.com</a></li><li><a href="https://blog.daliansky.net/gitee.io">码云 gitee.io</a></li><li><a href="https://blog.daliansky.net/coding.net">扣钉 coding.net</a></li></ul><h2><span id="参考及引用">参考及引用：</span></h2><ul><li><a href="https://deviwiki.com/wiki/Dell">https://deviwiki.com/wiki/Dell</a></li><li><a href="https://deviwiki.com/wiki/Dell_Wireless_1820A_(DW1820A)">https://deviwiki.com/wiki/Dell_Wireless_1820A_(DW1820A)</a></li><li><a href="https://blog.daliansky.net/[https://osxlatitude.com/profile/4953-herv%C3%A9/](https://osxlatitude.com/profile/4953-herv%C3%A9/)">Hervé</a> 更新的Broadcom 4350:<a href="https://osxlatitude.com/forums/topic/12169-bcm4350-cards-registry-of-cardslaptops-interop/">https://osxlatitude.com/forums/topic/12169-bcm4350-cards-registry-of-cardslaptops-interop/</a></li><li><a href="https://blog.daliansky.net/[https://osxlatitude.com/profile/4953-herv%C3%A9/](https://osxlatitude.com/profile/4953-herv%C3%A9/)">Hervé</a> 更新的DW1820A支持机型列表:<a href="https://osxlatitude.com/forums/topic/11322-broadcom-bcm4350-cards-under-high-sierramojave/">https://osxlatitude.com/forums/topic/11322-broadcom-bcm4350-cards-under-high-sierramojave/</a></li><li><a href="https://osxlatitude.com/profile/129953-nickhx/">nickhx</a> 提供的蓝牙驱动：<a href="https://osxlatitude.com/forums/topic/11540-dw1820a-for-7490-help/?do=findComment&amp;comment=92833">https://osxlatitude.com/forums/topic/11540-dw1820a-for-7490-help/?do=findComment&amp;comment=92833</a></li><li><a href="https://blog.xjn819.com/">xjn819</a>： <a href="https://blog.xjn819.com/?p=543">使用OpenCore引导黑苹果</a> <a href="https://blog.xjn819.com/?p=317">300系列主板正确使用AptioMemoryFix.efi的姿势(重写版）</a></li><li><a href="https://www.insanelymac.com/">insanelymac.com</a></li><li><a href="https://www.tonymacx86.com/">tonymacx86.com</a></li><li><a href="http://bbs.pcbeta.com/">远景论坛</a></li><li><a href="https://applelife.ru/">applelife.ru</a></li><li><a href="https://www.olarila.com/">olarila.com</a></li></ul><p>文章转载：<a href="https://blog.daliansky.net/From-Clover-To-OpenCore.html">https://blog.daliansky.net/From-Clover-To-OpenCore.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术笔记 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Portainer安装配置</title>
      <link href="/2021/10/09/Portainer%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/10/09/Portainer%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFportainer">什么是portainer</a></li><li><a href="#%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B">安装过程</a></li><li><a href="#%E6%B7%BB%E5%8A%A0endpoints">添加Endpoints</a></li></ul><!-- tocstop --><h2><span id="什么是portainer">什么是portainer</span></h2><p>官网：<a href="https://www.portainer.io/">https://www.portainer.io/</a></p><p>Portainer（基于 Go） 是一个轻量级的Web管理界面，可让您轻松管理 Docker 主机 或 Swarm 集群。<br>Portainer 的使用意图是简单部署。 它包含可以在任何 Docker 引擎上运行的单个容器（Docker for Linux 和 Docker for Windows）。<br>Portainer 允许您管理 Docker 容器、image、volume、network 等。 它与独立的 Docker 引擎和 Docker Swarm 兼容。</p><p>Portainer简化了Swarm和Kubernetes环境中的容器管理。它被软件工程师和DevOps团队用来简化和加速软件部署。</p><h2><span id="安装过程">安装过程</span></h2><p><strong>服务器A</strong>上安装docker 和 portainer，服务器A的IP是192.168.31.88</p><p>1、安装docker<br><a href="https://www.cnblogs.com/wudequn/p/11515610.html">https://www.cnblogs.com/wudequn/p/11515610.html</a><br>2、容器安装portainer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker pull portainer/portainer</span><br><span class="line">docker run -d -p 9000:9000 -v /root/portainer:/data -v /var/run/docker.sock:/var/run/docker.sock --name portainer portainer/portainer</span><br><span class="line"></span><br><span class="line">-d #容器在后台运行</span><br><span class="line">-p 9000:9000 # 宿主机9000端口映射容器中的9000端口</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock # 把宿主机的Docker守护进程(docker daemon)默认监听的Unix域套接字挂载到容器中</span><br><span class="line">-v /root/portainer:/data # 把宿主机目录 /root/portainer 挂载到容器 /data 目录；</span><br><span class="line">–name portainer # 指定运行容器的名称</span><br></pre></td></tr></table></figure><p>注意： 在启动容器时必须挂载本地 /var/run/docker.socker与容器内的/var/run/docker.socker连接。</p><p>3、访问 192.168.31.88:9000</p><p>第一次需要初始化密码，账号是admin</p><p><img src="/2021/10/09/Portainer%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/1122716-20200802184652699-1641613819.png" alt="img"></p><p> 单机版这里选择local即可，选择完毕，点击Connect即可连接到本地docker：</p><p><img src="/2021/10/09/Portainer%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/1122716-20200802191619195-1073028043.png" alt="img"></p><p> 注意：该页面上有提示需要挂载本地 /var/run/docker.socker与容器内的/var/run/docker.socker连接。因此，在启动时必须指定该挂载文件。</p><p><img src="/2021/10/09/Portainer%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/1122716-20200802193100848-231293653.png" alt="img"></p><h2><span id="添加endpoints">添加Endpoints</span></h2><p>上面安装后只是添加了本地的docker对应的Endpoints，现在添加一个其他<strong>服务器B</strong>的docker。</p><p>服务器B的ip 192.168.31.101</p><p>docker配置文件为/etc/docker/daemon.json</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">insecure-registries：私有镜像仓库</span><br><span class="line">&quot;insecure-registries&quot;:[&quot;ip:端口&quot;,&quot;ip:端口&quot;,]</span><br><span class="line"></span><br><span class="line">registry-mirrors：镜像加速地址，一般改为国内的</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;] </span><br><span class="line">Docker 官方中国区: https://registry.docker-cn.com</span><br><span class="line">网易: http://hub-mirror.c.163.com</span><br><span class="line">中科大: https://docker.mirrors.ustc.edu.cn</span><br><span class="line">  &quot;registry-mirrors&quot; : [</span><br><span class="line">    &quot;http://ovfftd6p.mirror.aliyuncs.com&quot;,</span><br><span class="line">    &quot;http://registry.docker-cn.com&quot;,</span><br><span class="line">    &quot;http://docker.mirrors.ustc.edu.cn&quot;,</span><br><span class="line">    &quot;http://hub-mirror.c.163.com&quot;</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">&quot;hosts&quot;: [&quot;tcp://0.0.0.0:2375&quot;, &quot;unix:///var/run/docker.sock&quot;]</span><br></pre></td></tr></table></figure><p>1、配置Docker主机，允许远程连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;hosts&quot;: [&quot;tcp://0.0.0.0:2375&quot;, &quot;unix:///var/run/docker.sock&quot;]&#125;</span><br></pre></td></tr></table></figure><p>或者</p><ol><li>编辑docker.service<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service</span><br><span class="line">找到 ExecStart字段修改如下</span><br><span class="line">ExecStart=/usr/bin/dockerd-current -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock </span><br></pre></td></tr></table></figure></li><li>重启docker重新读取配置文件，重新启动docker服务<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure></li></ol><p>2、重启docker引擎，使配置生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload </span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>3、Portainer添加endpoints</p><p><img src="/2021/10/09/Portainer%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/1122716-20200802205854088-1876842657.png" alt="img"></p><p><img src="/2021/10/09/Portainer%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/1122716-20200802210111306-984201563.png" alt="img"></p><p> 添加完后。</p><p><img src="/2021/10/09/Portainer%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/1122716-20200802210209846-1481039968.png" alt="img"></p><p>文章转载： <a href="https://www.cnblogs.com/wudequn/p/13419922.html">https://www.cnblogs.com/wudequn/p/13419922.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术笔记 </tag>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
            <tag> docker </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 私有仓库搭建</title>
      <link href="/2021/10/09/Docker-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/10/09/Docker-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E4%B8%80-%E7%AE%80%E4%BB%8B">一、简介</a></li><li><a href="#%E4%BA%8C-registry-%E7%9A%84%E6%90%AD%E5%BB%BA">二、registry 的搭建</a><ul><li><a href="#1-%E6%90%AD%E5%BB%BA">1. 搭建</a></li><li><a href="#2-%E9%AA%8C%E8%AF%81">2. 验证</a></li></ul></li><li><a href="#%E4%BA%8C-harbor-%E7%9A%84%E6%90%AD%E5%BB%BA">二、harbor 的搭建</a><ul><li><a href="#1%E6%90%AD%E5%BB%BA">1.搭建</a><ul><li><a href="#%E4%B8%8B%E8%BD%BD">下载</a></li><li><a href="#%E9%85%8D%E7%BD%AE">配置</a></li></ul></li><li><a href="#2-%E4%BD%BF%E7%94%A8">2. 使用</a></li><li><a href="#3-%E4%B8%8A%E4%BC%A0%E9%95%9C%E5%83%8F">3. 上传镜像</a></li></ul></li></ul><!-- tocstop --><h2><span id="一-简介">一、简介</span></h2><p>在 Docker 中，当我们执行 docker pull xxx 的时候 ，它实际上是从 registry.hub.docker.com 这个地址去查找，这就是Docker公司为我们提供的公共仓库。在工作中，我们不可能把企业项目push到公有仓库进行管理。所以为了更好的管理镜像，Docker不仅提供了一个中央仓库，同时也允许我们搭建本地私有仓库。这一篇介绍registry、harbor两种私有仓库搭建。</p><h2><span id="二-registry-的搭建">二、registry 的搭建</span></h2><h3><span id="1-搭建">1. 搭建</span></h3><p>Docker 官方提供了一个搭建私有仓库的镜像 <strong>registry</strong> ，只需把镜像下载下来，运行容器并暴露5000端口，就可以使用了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry:2</span><br><span class="line">docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 --name myregistry registry:2</span><br></pre></td></tr></table></figure><p>Registry服务默认会将上传的镜像保存在容器的/var/lib/registry，我们将主机的/opt/registry目录挂载到该目录，即可实现将镜像保存到主机的/opt/registry目录了。</p><p>浏览器访问<a href="http://127.0.0.1:5000/v2%EF%BC%8C%E5%87%BA%E7%8E%B0%E4%B8%8B%E9%9D%A2%E6%83%85%E5%86%B5%E8%AF%B4%E6%98%8Eregistry%E8%BF%90%E8%A1%8C%E6%AD%A3%E5%B8%B8%E3%80%82">http://127.0.0.1:5000/v2，出现下面情况说明registry运行正常。</a></p><p><img src="/2021/10/09/Docker-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/528977-20190510124454040-1840171525.png" alt="img"></p><h3><span id="2-验证">2. 验证</span></h3><p>现在通过push镜像到registry来验证一下。</p><p>查看本地镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker images</span></span><br><span class="line">REPOSITORY                                             TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx                                                  latest              568c4670fa80        5 weeks ago         109MB</span><br><span class="line">ubuntu                                                 latest              93fd78260bd1        7 weeks ago         86.2MB</span><br><span class="line">elasticsearch                                          6.5.1               32f93c89076d        7 weeks ago         773MB</span><br></pre></td></tr></table></figure><p>要通过docker tag将该镜像标志为要推送到私有仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:latest localhost:5000/nginx:latest</span><br></pre></td></tr></table></figure><p>通过 docker push 命令将 nginx 镜像 push到私有仓库中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push localhost:5000/nginx:latest</span><br></pre></td></tr></table></figure><p>访问 <a href="http://127.0.0.1:5000/v2/_catalog">http://127.0.0.1:5000/v2/_catalog</a> 查看私有仓库目录，可以看到刚上传的镜像了：</p><p><img src="/2021/10/09/Docker-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/528977-20190510124508006-1783029974.png" alt="img"></p><p>下载私有仓库的镜像，使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull localhost:5000/镜像名:版本号</span><br><span class="line">例如</span><br><span class="line">docker pull localhost:5000/nginx:latest</span><br></pre></td></tr></table></figure><h2><span id="二-harbor-的搭建">二、harbor 的搭建</span></h2><p>docker 官方提供的私有仓库 registry，用起来虽然简单 ，但在管理的功能上存在不足。 Harbor是一个用于存储和分发Docker镜像的企业级Registry服务器，harbor使用的是官方的docker registry(v2命名是distribution)服务去完成。harbor在docker distribution的基础上增加了一些安全、访问控制、管理的功能以满足企业对于镜像仓库的需求。</p><h3><span id="1搭建">1.搭建</span></h3><h4><span id="下载">下载</span></h4><p>地址：<a href="https://github.com/goharbor/harbor/releases">https://github.com/goharbor/harbor/releases</a> 本文是有 v1.2.2</p><h4><span id="配置">配置</span></h4><p>解压下载的安装包 harbor-offline-installer-v1.2.2.tgz</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf harbor-offline-installer-v1.2.2.tgz</span><br></pre></td></tr></table></figure><p>修改 harbor.cfg</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">hostname 改为本地ip，非 Mac OS系统 可以不指定端口</span></span><br><span class="line">hostname = 192.168.31.143:9090</span><br><span class="line"><span class="meta">#</span><span class="bash">设置secretkey_path 的路径为 当前目录的data下</span></span><br><span class="line">secretkey_path = ./data</span><br></pre></td></tr></table></figure><p><strong>需要注意的是，非 Mac 用户只需要 修改 harbor.cfg 中的 hostname ，就可以直接通过./install.sh 就可以构建镜像，并把服务启动起来。不需要 secretkey_path 和 下面 docker-compose.yml 的修改</strong></p><p>修改 docker-compose.yml</p><p>因为harbor使用了很多目录挂载，Mac有很多目录是不允许挂载的，所以如果是Mac用户，需要修改docker-compose.yml 中的挂载目录，修改后的 docker-compose.yml 如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;2&#x27;</span><br><span class="line">services:</span><br><span class="line">  log:</span><br><span class="line">    image: vmware/harbor-log:v1.2.2</span><br><span class="line">    container_name: harbor-log</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - ./log/:/var/log/docker/:z</span><br><span class="line">    ports:</span><br><span class="line">      - 127.0.0.1:1514:514</span><br><span class="line">    networks:</span><br><span class="line">      - harbor</span><br><span class="line">  registry:</span><br><span class="line">    image: vmware/registry:2.6.2-photon</span><br><span class="line">    container_name: registry</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/registry:/storage:z</span><br><span class="line">      - ./common/config/registry/:/etc/registry/:z</span><br><span class="line">    networks:</span><br><span class="line">      - harbor</span><br><span class="line">    environment:</span><br><span class="line">      - GODEBUG=netdns=cgo</span><br><span class="line">    command:</span><br><span class="line">      [&quot;serve&quot;, &quot;/etc/registry/config.yml&quot;]</span><br><span class="line">    depends_on:</span><br><span class="line">      - log</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;syslog&quot;</span><br><span class="line">      options:</span><br><span class="line">        syslog-address: &quot;tcp://127.0.0.1:1514&quot;</span><br><span class="line">        tag: &quot;registry&quot;</span><br><span class="line">  mysql:</span><br><span class="line">    image: vmware/harbor-db:v1.2.2</span><br><span class="line">    container_name: harbor-db</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/database:/var/lib/mysql:z</span><br><span class="line">    networks:</span><br><span class="line">      - harbor</span><br><span class="line">    env_file:</span><br><span class="line">      - ./common/config/db/env</span><br><span class="line">    depends_on:</span><br><span class="line">      - log</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;syslog&quot;</span><br><span class="line">      options:</span><br><span class="line">        syslog-address: &quot;tcp://127.0.0.1:1514&quot;</span><br><span class="line">        tag: &quot;mysql&quot;</span><br><span class="line">  adminserver:</span><br><span class="line">    image: vmware/harbor-adminserver:v1.2.2</span><br><span class="line">    container_name: harbor-adminserver</span><br><span class="line">    env_file:</span><br><span class="line">      - ./common/config/adminserver/env</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/config/:/etc/adminserver/config/:z</span><br><span class="line">      - ./data/secretkey:/etc/adminserver/key:z</span><br><span class="line">      - ./data/:/data/:z</span><br><span class="line">    networks:</span><br><span class="line">      - harbor</span><br><span class="line">    depends_on:</span><br><span class="line">      - log</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;syslog&quot;</span><br><span class="line">      options:</span><br><span class="line">        syslog-address: &quot;tcp://127.0.0.1:1514&quot;</span><br><span class="line">        tag: &quot;adminserver&quot;</span><br><span class="line">  ui:</span><br><span class="line">    image: vmware/harbor-ui:v1.2.2</span><br><span class="line">    container_name: harbor-ui</span><br><span class="line">    env_file:</span><br><span class="line">      - ./common/config/ui/env</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - ./common/config/ui/app.conf:/etc/ui/app.conf:z</span><br><span class="line">      - ./common/config/ui/private_key.pem:/etc/ui/private_key.pem:z</span><br><span class="line">      - ./data/secretkey:/etc/ui/key:z</span><br><span class="line">      - ./data/ca_download/:/etc/ui/ca/:z</span><br><span class="line">      - ./data/psc/:/etc/ui/token/:z</span><br><span class="line">    networks:</span><br><span class="line">      - harbor</span><br><span class="line">    depends_on:</span><br><span class="line">      - log</span><br><span class="line">      - adminserver</span><br><span class="line">      - registry</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;syslog&quot;</span><br><span class="line">      options:</span><br><span class="line">        syslog-address: &quot;tcp://127.0.0.1:1514&quot;</span><br><span class="line">        tag: &quot;ui&quot;</span><br><span class="line">  jobservice:</span><br><span class="line">    image: vmware/harbor-jobservice:v1.2.2</span><br><span class="line">    container_name: harbor-jobservice</span><br><span class="line">    env_file:</span><br><span class="line">      - ./common/config/jobservice/env</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/job_logs:/var/log/jobs:z</span><br><span class="line">      - ./common/config/jobservice/app.conf:/etc/jobservice/app.conf:z</span><br><span class="line">      - ./data/secretkey:/etc/jobservice/key:z</span><br><span class="line">    networks:</span><br><span class="line">      - harbor</span><br><span class="line">    depends_on:</span><br><span class="line">      - ui</span><br><span class="line">      - adminserver</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;syslog&quot;</span><br><span class="line">      options:</span><br><span class="line">        syslog-address: &quot;tcp://127.0.0.1:1514&quot;</span><br><span class="line">        tag: &quot;jobservice&quot;</span><br><span class="line">  proxy:</span><br><span class="line">    image: vmware/nginx-photon:1.11.13</span><br><span class="line">    container_name: nginx</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - ./common/config/nginx:/etc/nginx:z</span><br><span class="line">    networks:</span><br><span class="line">      - harbor</span><br><span class="line">    ports:</span><br><span class="line">      - 9090:80</span><br><span class="line">      - 443:443</span><br><span class="line">      - 4443:4443</span><br><span class="line">    depends_on:</span><br><span class="line">      - mysql</span><br><span class="line">      - registry</span><br><span class="line">      - ui</span><br><span class="line">      - log</span><br><span class="line">    logging:</span><br><span class="line">      driver: &quot;syslog&quot;</span><br><span class="line">      options:</span><br><span class="line">        syslog-address: &quot;tcp://127.0.0.1:1514&quot;</span><br><span class="line">        tag: &quot;proxy&quot;</span><br><span class="line">networks:</span><br><span class="line">  harbor:</span><br><span class="line">    external: false</span><br></pre></td></tr></table></figure><p>通过运行 install.sh 构建镜像，并把服务启动起来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./install.sh</span><br></pre></td></tr></table></figure><h3><span id="2-使用">2. 使用</span></h3><p>访问 <a href="http://127.0.0.1:9090/">http://127.0.0.1:9090/</a> 如下：</p><p><img src="/2021/10/09/Docker-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/528977-20190510124522460-1493599159.png" alt="img"></p><p>默认 admin 用户的密码为 Harbor12345 ，可以在 harbor.cfg 进行修改。登录后如下：</p><p><img src="/2021/10/09/Docker-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/528977-20190510124534293-1210147109.png" alt="img"></p><p>图中的项目是之前上传的 ，新部署的 Harbor 登录后项目下是空的。</p><p>可以创建项目，创建用户，给项目分配用户等等，操作都很简单 。</p><h3><span id="3-上传镜像">3. 上传镜像</span></h3><p>首先登录私有仓库，可以使用 admin 用户 ，也可以使用我们自己创建的具有上传权限的用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login -u admin -p Harbor12345 127.0.0.1:9090</span><br></pre></td></tr></table></figure><p>要通过docker tag将该镜像标志为要推送到私有仓库，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:latest 127.0.0.1:9090/library/nginx:latest</span><br></pre></td></tr></table></figure><p>上传镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 127.0.0.1:9090/library/nginx:latest</span><br></pre></td></tr></table></figure><p>访问 <a href="http://127.0.0.1:9090/harbor/projects">http://127.0.0.1:9090/harbor/projects</a> ，在 library 项目下可以看见刚上传的 nginx镜像了：</p><p><img src="/2021/10/09/Docker-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/528977-20190510124545176-1698547303.png" alt="img"></p><p>文章转载： <a href="https://www.cnblogs.com/huanchupkblog/p/10843800.html">https://www.cnblogs.com/huanchupkblog/p/10843800.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术笔记 </tag>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
            <tag> docker </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>etCache 缓存框架的使用以及源码分析</title>
      <link href="/2021/10/01/etCache-%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/10/01/etCache-%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E4%B8%80-%E7%AE%80%E4%BB%8B">一、简介</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98">为什么使用缓存？</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">使用场景</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83">使用规范</a></li></ul></li><li><a href="#%E4%BA%8C-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">二、如何使用</a><ul><li><a href="#%E5%BC%95%E5%85%A5maven%E4%BE%9D%E8%B5%96">引入maven依赖</a></li><li><a href="#%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE">添加配置</a></li><li><a href="#%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E">配置说明</a></li><li><a href="#%E6%B3%A8%E8%A7%A3%E8%AF%B4%E6%98%8E">注解说明</a><ul><li><a href="#enablecreatecacheannotation">@EnableCreateCacheAnnotation</a></li><li><a href="#enablemethodcache">@EnableMethodCache</a></li><li><a href="#cached">@Cached</a></li><li><a href="#cacheinvalidate">@CacheInvalidate</a></li><li><a href="#cacheupdate">@CacheUpdate</a></li><li><a href="#cacherefresh">@CacheRefresh</a></li><li><a href="#cachepenetrationprotect">@CachePenetrationProtect</a></li><li><a href="#createcache">@CreateCache</a></li></ul></li><li><a href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">使用示例</a></li></ul></li><li><a href="#%E4%B8%89-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">三、源码解析</a><ul><li><a href="#%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%90%84%E4%B8%AA%E5%AD%90%E6%A8%A1%E5%9D%97">项目的各个子模块</a></li><li><a href="#%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%98%E9%87%8F">常用注解与变量</a></li><li><a href="#%E7%BC%93%E5%AD%98api">缓存API</a><ul><li><a href="#cache%E6%8E%A5%E5%8F%A3">Cache接口</a></li><li><a href="#abstractcache%E6%8A%BD%E8%B1%A1%E7%B1%BB">AbstractCache抽象类</a></li><li><a href="#abstractembeddedcache%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98">AbstractEmbeddedCache本地缓存</a><ul><li><a href="#linkedhashmapcache">LinkedHashMapCache</a></li><li><a href="#cleaner%E6%B8%85%E7%90%86%E5%99%A8">Cleaner清理器</a></li><li><a href="#caffeinecache">CaffeineCache</a></li></ul></li><li><a href="#abstractexternalcache%E8%BF%9C%E7%A8%8B%E7%BC%93%E5%AD%98">AbstractExternalCache远程缓存</a><ul><li><a href="#rediscache">RedisCache</a></li><li><a href="#redislettucecache">RedisLettuceCache</a></li></ul></li><li><a href="#multilevelcache%E4%B8%A4%E7%BA%A7%E7%BC%93%E5%AD%98">MultiLevelCache两级缓存</a></li><li><a href="#refreshcache">RefreshCache</a></li></ul></li><li><a href="#%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE">解析配置</a><ul><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9E%84%E9%80%A0%E5%99%A8">初始化构造器</a><ul><li><a href="#abstractcacheautoinit">AbstractCacheAutoInit</a></li><li><a href="#embeddedcacheautoinit">EmbeddedCacheAutoInit</a><ul><li><a href="#linkedhashmapautoconfiguration">LinkedHashMapAutoConfiguration</a></li><li><a href="#caffeineautoconfiguration">CaffeineAutoConfiguration</a></li></ul></li><li><a href="#externalcacheautoinit">ExternalCacheAutoInit</a><ul><li><a href="#redisautoinit">RedisAutoInit</a></li><li><a href="#redislettuceautoinit">RedisLettuceAutoInit</a></li></ul></li></ul></li><li><a href="#jetcacheautoconfiguration%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE">JetCacheAutoConfiguration自动配置</a></li><li><a href="#cachebuilder%E6%9E%84%E9%80%A0%E5%99%A8">CacheBuilder构造器</a></li></ul></li><li><a href="#aop">AOP</a><ul><li><a href="#%E5%90%AF%E7%94%A8jetcache">启用JetCache</a><ul><li><a href="#enablemethodcache-1">@EnableMethodCache</a></li><li><a href="#enablecreatecacheannotation-1">@EnableCreateCacheAnnotation</a></li></ul></li><li><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8">拦截器</a><ul><li><a href="#configprovider">ConfigProvider</a></li><li><a href="#cachecontext">CacheContext</a></li><li><a href="#jetcacheinterceptor">JetCacheInterceptor</a></li><li><a href="#cachehandler">CacheHandler</a></li></ul></li></ul></li></ul></li></ul><!-- tocstop --><h2><span id="一-简介">一、简介</span></h2><p><a href="https://github.com/alibaba/jetcache"><code>JetCache</code></a>是一个基于Java的缓存系统封装，提供统一的API和注解来简化缓存的使用。 JetCache提供了比SpringCache更加强大的注解，可以原生的支持TTL、两级缓存、分布式自动刷新，还提供了<code>Cache</code>接口用于手工缓存操作。 当前有四个实现：<code>RedisCache</code>、<code>RedisLettuceCache</code>、<code>CaffeineCache</code>、<code>LinkedHashMapCache</code>。</p><p>特性：</p><ul><li>通过统一的API访问Cache系统</li><li>通过注解实现声明式的方法缓存，支持TTL和两级缓存</li><li>通过注解创建并配置<code>Cache</code>实例</li><li>针对所有<code>Cache</code>实例和方法缓存的自动统计</li><li>Key的生成策略和Value的序列化策略支持自定义配置</li><li>分布式缓存自动刷新，分布式锁</li><li>异步Cache API (使用Redis的Lettuce客户端时)</li></ul><p>缓存类型：</p><ul><li><p>本地</p><p><code>LinkedHashMap</code>：使用LinkedHashMap做LUR方式淘汰<br><a href="https://github.com/ben-manes/caffeine"><code>Caffeine</code></a>：基于Java8开发的提供了近乎最佳命中率的高性能的缓存库</p></li><li><p>远程（访问Redis的客户端）</p><p><code>Redis</code>：使用Jedis客户端，Redis官方首选的Java客户端<br><code>RedisSpringData</code>：使用SpringData访问Redis（官网未作介绍）<br><a href="https://github.com/lettuce-io/lettuce-core"><code>RedisLettuce</code></a>：使用Lettuce客户端，一个高性能基于Java的Redis驱动框架，支持线程安全的同步、异步操作，底层集成了<a href="https://projectreactor.io/">Project Reactor</a>，提供反应式编程，参考：<a href="https://www.cnblogs.com/throwable/p/11601538.html">Redis高级客户端Lettuce详解</a></p></li></ul><h3><span id="为什么使用缓存">为什么使用缓存？</span></h3><p>在高并发、大流量等场景下，降低系统延迟，缓解数据库压力，提高系统整体的性能，让用户有更好的体验。</p><h3><span id="使用场景">使用场景</span></h3><p>读多写少、不追求强一致性、请求入参不易变化</p><h3><span id="使用规范">使用规范</span></h3><p>选择了远程缓存请设置keyPrefix，保证存放至Redis的缓存key规范化，避免与其他系统出现冲突，例如这样设计：<code>系统简称:所属名字:</code>，这样存储到Redis的缓存key为：<code>系统简称:所属名字:缓存key</code></p><p>选择了本地缓存请设置limit，全局默认设置了100，本地缓存的数据存放于内存，减轻内存的损耗，如果使用了Caffeine，缓存的key过多可能导致内存溢出</p><p>请勿滥用缓存注解，对于非必要添加缓存的方法我们尽量不使用缓存</p><h2><span id="二-如何使用">二、如何使用</span></h2><p>说明：以下使用方式是基于SpringBoot引入<code>JetCache</code>缓存框架的，如果不是SpringBoot工程，请参考<a href="https://github.com/alibaba/jetcache"><code>JetCache</code></a>官网使用</p><h3><span id="引入maven依赖">引入maven依赖</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- 使用 jedis 客户端添加以下依赖 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alicp.jetcache&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jetcache-starter-redis&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- 使用 lettuce 客户端添加以下依赖 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alicp.jetcache&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jetcache-starter-redis-lettuce&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3><span id="添加配置">添加配置</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">jetcache:</span><br><span class="line">  statIntervalMinutes: 60</span><br><span class="line">  areaInCacheName: false</span><br><span class="line">  penetrationProtect: false</span><br><span class="line">  enableMethodCache: true</span><br><span class="line">  hiddenPackages: com.xxx.xxx,com.xxx.xxx</span><br><span class="line">  local:</span><br><span class="line">    default:</span><br><span class="line">      type: caffeine # 支持的类型：linkedhashmap、caffeine</span><br><span class="line">      limit: 100</span><br><span class="line">      keyConvertor: fastjson # 支持的类型：fastjson，可自定义转换器函数</span><br><span class="line">      expireAfterWriteInMillis: 600000</span><br><span class="line">      expireAfterAccessInMillis: 300000 </span><br><span class="line">  remote:</span><br><span class="line">    default:</span><br><span class="line">      type: redis.lettuce # 支持的类型：redis、redis.lettuce</span><br><span class="line">      keyPrefix: &#x27;系统简称:所属名字:&#x27;</span><br><span class="line">      keyConvertor: fastjson</span><br><span class="line">      valueEncoder: java # 支持的类型：kryo、java，可自定义编码器</span><br><span class="line">      valueDecoder: java # 支持的类型：kryo、java，可自定义解码器</span><br><span class="line">      expireAfterWriteInMillis: 3600000</span><br><span class="line">      #readFrom: slavePreferred # 优先从Slave节点中读取</span><br><span class="line">      uri: redis-sentinel://host1:26379,host2:26379,host3:26379/?sentinelMasterId=mymaster # 哨兵模式</span><br><span class="line">      #uri: redis://127.0.0.1:6379/ # 单节点模式</span><br><span class="line">      #mode: masterslave # 设置为主从模式</span><br><span class="line">      #uri: # 集群模式</span><br><span class="line">      #- redis://127.0.0.1:7000</span><br><span class="line">      #- redis://127.0.0.1:7001</span><br><span class="line">      #- redis://127.0.0.1:7002</span><br><span class="line">    example:</span><br><span class="line">      keyPrefix: &#x27;系统简称:所属名字:&#x27;</span><br><span class="line">      type: redis</span><br><span class="line">      keyConvertor: fastjson</span><br><span class="line">      valueEncoder: java</span><br><span class="line">      valueDecoder: java</span><br><span class="line">      expireAfterWriteInMillis: 3600000</span><br><span class="line">      poolConfig:</span><br><span class="line">        minIdle: 10</span><br><span class="line">        maxIdle: 20</span><br><span class="line">        maxTotal: 50</span><br><span class="line">      #password: xxx # 连接密码</span><br><span class="line">      #timeout: 2000 # 连接的超时时间，读取数据的超时时间</span><br><span class="line">      #database: 0 # 连接的数据库</span><br><span class="line">      #clientName: null # 客户端名称</span><br><span class="line">      #ssl: 是否使用SSL</span><br><span class="line">      host: $&#123;redis.host&#125;</span><br><span class="line">      port: $&#123;redis.port&#125;</span><br><span class="line">      #sentinel: host1:26379,host2:26379,host3:26379 # 哨兵模式</span><br><span class="line">      #masterName: mymaster</span><br></pre></td></tr></table></figure><h3><span id="配置说明">配置说明</span></h3><p>jetcache的全局配置</p><table><thead><tr><th align="left">属性</th><th align="left">默认值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">jetcache.statIntervalMinutes</td><td align="left">0</td><td align="left">用于统计缓存调用相关信息的统计间隔（分钟），0表示不统计。</td></tr><tr><td align="left">jetcache.areaInCacheName</td><td align="left">true</td><td align="left">缓存实例名称cacheName会作为缓存key的前缀，2.4.3以前的版本总是把areaName加在cacheName中，因此areaName也出现在key前缀中。我们一般设置为false。</td></tr><tr><td align="left">jetcache.penetrationProtect</td><td align="left">false</td><td align="left">当缓存访问未命中的情况下，对并发进行的加载行为进行保护。 当前版本实现的是单JVM内的保护，即同一个JVM中同一个key只有一个线程去加载，其它线程等待结果。这是全局配置，如果缓存实例没有指定则使用全局配置。</td></tr><tr><td align="left">jetcache.enableMethodCache</td><td align="left">true</td><td align="left">是否使用jetcache缓存。</td></tr><tr><td align="left">jetcache.hiddenPackages</td><td align="left">无</td><td align="left">自动生成缓存实例名称时，为了不让名称太长，hiddenPackages指定的包名前缀会被截掉，多个包名使用逗号分隔。我们一般会指定每个缓存实例的名称。</td></tr></tbody></table><p>本地缓存的全局配置</p><table><thead><tr><th align="left">属性</th><th align="left">默认值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">jetcache.local.${area}.type</td><td align="left">无</td><td align="left">本地缓存类型，支持 linkedhashmap、caffeine。</td></tr><tr><td align="left">jetcache.local.${area}.limit</td><td align="left">100</td><td align="left">每个缓存实例存储的缓存数量的全局配置，仅本地缓存需要配置，如果缓存实例没有指定则使用全局配置，请结合实例的业务场景进行配置该参数。</td></tr><tr><td align="left">jetcache.local.${area}.keyConvertor</td><td align="left">无</td><td align="left">缓存key转换器的全局配置，支持的类型：<code>fastjson</code>。仅当使用@CreateCache且缓存类型为LOCAL时可以指定为<code>none</code>，此时通过equals方法来识别key。方法缓存必须指定keyConvertor。支持自定义转换器函数，可设置为：<code>bean:beanName</code>，然后会从spring容器中获取该bean。</td></tr><tr><td align="left">jetcache.local.${area}.expireAfterWriteInMillis</td><td align="left">无穷大</td><td align="left">本地缓存超时时间的全局配置（毫秒）。</td></tr><tr><td align="left">jetcache.local.${area}.expireAfterAccessInMillis</td><td align="left">0</td><td align="left">多长时间没访问就让缓存失效的全局配置（毫秒），仅支持本地缓存。0表示不使用这个功能。</td></tr></tbody></table><p>远程缓存的全局配置</p><table><thead><tr><th align="left">属性</th><th align="left">默认值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">jetcache.remote.${area}.type</td><td align="left">无</td><td align="left">连接Redis的客户端类型，支持 <code>redis</code>、<code>redis.lettuce</code>、<code>redis.springdata</code>。</td></tr><tr><td align="left">jetcache.remote.${area}.keyPrefix</td><td align="left">无</td><td align="left">保存至远程缓存key的前缀，请规范使用。</td></tr><tr><td align="left">jetcache.remote.${area}.keyConvertor</td><td align="left">无</td><td align="left">参考上述说明。</td></tr><tr><td align="left">jetcache.remote.${area}.valueEncoder</td><td align="left">java</td><td align="left">保存至远程缓存value的编码函数，支持：<code>java</code>、<code>kryo</code>。支持自定义编码函数，可设置为：<code>bean:beanName</code>，然后会从spring容器中获取该bean。</td></tr><tr><td align="left">jetcache.remote.${area}.valueDecoder</td><td align="left">java</td><td align="left">保存至远程缓存value的解码函数，支持：<code>java</code>、<code>kryo</code>。支持自定义解码函数，可设置为：<code>bean:beanName</code>，然后会从spring容器中获取该bean。</td></tr><tr><td align="left">jetcache.remote.${area}.expireAfterWriteInMillis</td><td align="left">无穷大</td><td align="left">远程缓存超时时间的全局配置（毫秒）。</td></tr><tr><td align="left">jetcache.remote.${area}.uri</td><td align="left">无</td><td align="left">redis节点信息。</td></tr></tbody></table><p>上表中${area}对应@Cached和@CreateCache的area属性，如果注解上没有指定area，默认值是”default”。</p><p>关于缓存的超时时间：</p><ol><li>put等方法上指定了超时时间，则以此时间为准；</li><li>put等方法上未指定超时时间，使用Cache实例的默认超时时间；</li><li>Cache实例的默认超时时间，通过在@CreateCache和@Cached上的expire属性指定，如果没有指定，使用yml中定义的全局配置，例如@Cached(cacheType=local)使用jetcache.local.default.expireAfterWriteInMillis，如果仍未指定则是无穷大。</li></ol><h3><span id="注解说明">注解说明</span></h3><p>如果需要使用<code>jetcache</code>缓存，启动类添加两个注解：<code>@EnableCreateCacheAnnotation</code>、<code>@EnableMethodCache</code></p><h4><span id="enablecreatecacheannotation">@EnableCreateCacheAnnotation</span></h4><p>开启可通过@CreateCache注解创建Cache实例功能。</p><h4><span id="enablemethodcache">@EnableMethodCache</span></h4><p>开启可通过@Cached注解创建Cache实例功能，初始化spring aop，注解说明：</p><table><thead><tr><th align="left">属性</th><th align="left">默认值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">basePackages</td><td align="left">无</td><td align="left">jetcache需要拦截的包名，只有这些包名下的Cache实例才会生效</td></tr><tr><td align="left">order</td><td align="left">Ordered.LOWEST_PRECEDENCE</td><td align="left">指定AOP切面执行过程的顺序，默认最低优先级</td></tr><tr><td align="left">mode</td><td align="left">AdviceMode.PROXY</td><td align="left">Spring AOP的模式，目前就提供默认值让你修改</td></tr><tr><td align="left">proxyTargetClass</td><td align="left">false</td><td align="left">无</td></tr></tbody></table><h4><span id="cached">@Cached</span></h4><p>为一个方法添加缓存，创建对应的缓存实例，注解可以添加在接口或者类的方法上面，该类必须是spring bean，注解说明：</p><table><thead><tr><th align="left">属性</th><th align="left">默认值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">area</td><td align="left">“default”</td><td align="left">如果在配置中配置了多个缓存area，在这里指定使用哪个area。</td></tr><tr><td align="left">name</td><td align="left">未定义</td><td align="left">指定缓存实例名称，如果没有指定，会根据类名+方法名自动生成。name会被用于远程缓存的key前缀。另外在统计中，一个简短有意义的名字会提高可读性。</td></tr><tr><td align="left">enabled</td><td align="left">true</td><td align="left">是否激活缓存。</td></tr><tr><td align="left">timeUnit</td><td align="left">TimeUnit.SECONDS</td><td align="left">指定expire的单位。</td></tr><tr><td align="left">expire</td><td align="left">未定义</td><td align="left">超时时间。如果注解上没有定义，会使用全局配置，如果此时全局配置也没有定义，则为无穷大。</td></tr><tr><td align="left">localExpire</td><td align="left">未定义</td><td align="left">仅当cacheType为BOTH时适用，为本地缓存指定一个不一样的超时时间，通常应该小于expire。如果没有设置localExpire且cacheType为BOTH，那么本地缓存的超时时间和远程缓存保持一致。</td></tr><tr><td align="left">cacheType</td><td align="left">CacheType.REMOTE</td><td align="left">缓存的类型，支持：<code>REMOTE</code>、<code>LOCAL</code>、<code>BOTH</code>，如果定义为BOTH，会使用LOCAL和REMOTE组合成两级缓存。</td></tr><tr><td align="left">localLimit</td><td align="left">未定义</td><td align="left">如果cacheType为LOCAL或BOTH，这个参数指定本地缓存的最大元素数量，以控制内存占用。如果注解上没有定义，会使用全局配置，如果此时你没有定义全局配置，则使用默认的全局配置100。请结合实际业务场景进行设置该值。</td></tr><tr><td align="left">serialPolicy</td><td align="left">未定义</td><td align="left">指定远程缓存VALUE的序列化方式，支持<code>SerialPolicy.JAVA</code>、<code>SerialPolicy.KRYO</code>。如果注解上没有定义，会使用全局配置，如果你没有定义全局配置，则使用默认的全局配置SerialPolicy.JAVA。</td></tr><tr><td align="left">keyConvertor</td><td align="left">未定义</td><td align="left">指定KEY的转换方式，用于将复杂的KEY类型转换为缓存实现可以接受的类型，支持：<code>KeyConvertor.FASTJSON</code>、<code>KeyConvertor.NONE</code>。NONE表示不转换，FASTJSON可以将复杂对象KEY转换成String。如果注解上没有定义，会使用全局配置。</td></tr><tr><td align="left">key</td><td align="left">未定义</td><td align="left">使用<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html">SpEL</a>指定缓存key，如果没有指定会根据入参自动生成。</td></tr><tr><td align="left">cacheNullValue</td><td align="left">false</td><td align="left">当方法返回值为null的时候是否要缓存。</td></tr><tr><td align="left">condition</td><td align="left">未定义</td><td align="left">使用<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html">SpEL</a>指定条件，如果表达式返回true的时候才去缓存中查询。</td></tr><tr><td align="left">postCondition</td><td align="left">未定义</td><td align="left">使用<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html">SpEL</a>指定条件，如果表达式返回true的时候才更新缓存，该评估在方法执行后进行，因此可以访问到#result。</td></tr></tbody></table><h4><span id="cacheinvalidate">@CacheInvalidate</span></h4><p>用于移除缓存，配置说明：</p><table><thead><tr><th align="left">配置</th><th align="left">默认值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">area</td><td align="left">“default”</td><td align="left">如果在配置中配置了多个缓存area，在这里指定使用哪个area。</td></tr><tr><td align="left">name</td><td align="left">无</td><td align="left">指定缓存的唯一名称，一般指向对应的@Cached定义的name。</td></tr><tr><td align="left">key</td><td align="left">未定义</td><td align="left">使用<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html">SpEL</a>指定key，如果没有指定会根据入参自动生成。</td></tr><tr><td align="left">condition</td><td align="left">未定义</td><td align="left">使用<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html">SpEL</a>指定条件，如果表达式返回true才执行删除，可访问方法结果#result。删除缓存实例中key的元素。</td></tr><tr><td align="left">multi</td><td align="left">false</td><td align="left">如果根据<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html">SpEL</a>指定的key是一个集合，是否从缓存实例中删除对应的每个缓存。如果设置为true，但是key不是集合，则不会删除缓存。</td></tr></tbody></table><h4><span id="cacheupdate">@CacheUpdate</span></h4><p>用于更新缓存，配置说明：</p><table><thead><tr><th align="left">配置</th><th align="left">默认值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">area</td><td align="left">“default”</td><td align="left">如果在配置中配置了多个缓存area，在这里指定使用哪个area。</td></tr><tr><td align="left">name</td><td align="left">无</td><td align="left">指定缓存的唯一名称，一般指向对应的@Cached定义的name。</td></tr><tr><td align="left">key</td><td align="left">未定义</td><td align="left">使用<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html">SpEL</a>指定key，如果没有指定会根据入参自动生成。</td></tr><tr><td align="left">value</td><td align="left">无</td><td align="left">使用<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html">SpEL</a>指定value。</td></tr><tr><td align="left">condition</td><td align="left">未定义</td><td align="left">使用<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html">SpEL</a>指定条件，如果表达式返回true才执行更新，可访问方法结果#result。更新缓存实例中key的元素。</td></tr><tr><td align="left">multi</td><td align="left">false</td><td align="left">如果根据<a href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/expressions.html">SpEL</a>指定key和value都是集合并且元素的个数相同，则是否更新缓存实例中的对应的每个元素。如果设置为true，但是key不是集合或者value不是集合或者它们的元素的个数不相同，也不会更新缓存。</td></tr></tbody></table><h4><span id="cacherefresh">@CacheRefresh</span></h4><p>用于自定刷新缓存，配置说明：</p><table><thead><tr><th align="left">配置</th><th align="left">默认值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">refresh</td><td align="left">无</td><td align="left">刷新间隔</td></tr><tr><td align="left">stopRefreshAfterLastAccess</td><td align="left">未定义</td><td align="left">指定该key多长时间没有访问就停止刷新，如果不指定会一直刷新。</td></tr><tr><td align="left">refreshLockTimeout</td><td align="left">60秒</td><td align="left">类型为BOTH/REMOTE的缓存刷新时，同时只会有一台服务器在刷新，这台服务器会在远程缓存放置一个分布式锁，此配置指定该锁的超时时间。</td></tr><tr><td align="left">timeUnit</td><td align="left">TimeUnit.SECONDS</td><td align="left">指定refresh时间单位。</td></tr></tbody></table><h4><span id="cachepenetrationprotect">@CachePenetrationProtect</span></h4><p>当缓存访问未命中的情况下，对并发进行的加载行为进行保护。 当前版本实现的是单JVM内的保护，即同一个JVM中同一个key只有一个线程去加载，其它线程等待结果，配置说明：</p><table><thead><tr><th align="left">配置</th><th align="left">默认值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">value</td><td align="left">true</td><td align="left">是否开启保护模式。</td></tr><tr><td align="left">timeout</td><td align="left">未定义</td><td align="left">其他线程的等待超时时间，如果超时则自己执行方法直接返回结果。</td></tr><tr><td align="left">timeUnit</td><td align="left">TimeUnit.SECONDS</td><td align="left">指定timeout时间单位。</td></tr></tbody></table><h4><span id="createcache">@CreateCache</span></h4><p>在Spring Bean中使用该注解可创建一个Cache实例，配置说明：</p><table><thead><tr><th align="left">配置</th><th align="left">默认值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">area</td><td align="left">“default”</td><td align="left">如果在配置中配置了多个缓存area，在这里指定使用哪个area。</td></tr><tr><td align="left">name</td><td align="left">未定义</td><td align="left">指定缓存实例名称，如果没有指定，会根据类名+方法名自动生成。name会被用于远程缓存的key前缀。另外在统计中，一个简短有意义的名字会提高可读性。</td></tr><tr><td align="left">timeUnit</td><td align="left">TimeUnit.SECONDS</td><td align="left">指定expire的单位。</td></tr><tr><td align="left">expire</td><td align="left">未定义</td><td align="left">超时时间。如果注解上没有定义，会使用全局配置，如果此时全局配置也没有定义，则为无穷大。</td></tr><tr><td align="left">localExpire</td><td align="left">未定义</td><td align="left">仅当cacheType为BOTH时适用，为本地缓存指定一个不一样的超时时间，通常应该小于expire。如果没有设置localExpire且cacheType为BOTH，那么本地缓存的超时时间和远程缓存保持一致。</td></tr><tr><td align="left">cacheType</td><td align="left">CacheType.REMOTE</td><td align="left">缓存的类型，支持：<code>REMOTE</code>、<code>LOCAL</code>、<code>BOTH</code>，如果定义为BOTH，会使用LOCAL和REMOTE组合成两级缓存。</td></tr><tr><td align="left">localLimit</td><td align="left">未定义</td><td align="left">如果cacheType为LOCAL或BOTH，这个参数指定本地缓存的最大元素数量，以控制内存占用。如果注解上没有定义，会使用全局配置，如果此时你没有定义全局配置，则使用默认的全局配置100。请结合实际业务场景进行设置该值。</td></tr><tr><td align="left">serialPolicy</td><td align="left">未定义</td><td align="left">指定远程缓存VALUE的序列化方式，支持<code>SerialPolicy.JAVA</code>、<code>SerialPolicy.KRYO</code>。如果注解上没有定义，会使用全局配置，如果你没有定义全局配置，则使用默认的全局配置SerialPolicy.JAVA。</td></tr><tr><td align="left">keyConvertor</td><td align="left">未定义</td><td align="left">指定KEY的转换方式，用于将复杂的KEY类型转换为缓存实现可以接受的类型，支持：<code>KeyConvertor.FASTJSON</code>、<code>KeyConvertor.NONE</code>。NONE表示不转换，FASTJSON可以将复杂对象KEY转换成String。如果注解上没有定义，会使用全局配置。</td></tr></tbody></table><h3><span id="使用示例">使用示例</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 启动类</span><br><span class="line"> */</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableCreateCacheAnnotation</span><br><span class="line">@EnableMethodCache(basePackages = &quot;com.xxx.xxx&quot;)</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 接口</span><br><span class="line"> */</span><br><span class="line">public interface JetCacheExampleService &#123;</span><br><span class="line">    </span><br><span class="line">    User getValue(long userId);</span><br><span class="line">    </span><br><span class="line">    void updateValue(User  user);</span><br><span class="line">    </span><br><span class="line">    void deleteValue(User  user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 实现类</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class JetCacheExampleServiceImpl implements JetCacheExampleService &#123;</span><br><span class="line">    </span><br><span class="line">    @CreateCache(name = &quot;JetCacheExampleServiceImpl.exampleCache&quot; , localLimit = 50 ,cacheType = CacheType.LOCAL)</span><br><span class="line">    @CachePenetrationProtect</span><br><span class="line">    private Cache&lt;Long, User&gt; exampleCache;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    @Cached(name = &quot;JetCacheExampleService.getValue&quot;, expire = 3600 * 6, localLimit = 50, cacheType = CacheType.BOTH)</span><br><span class="line">    @CacheRefresh(refresh = 3600, stopRefreshAfterLastAccess = 3600 * 2)</span><br><span class="line">    @CachePenetrationProtect</span><br><span class="line">    public User getValue(long userId)&#123;</span><br><span class="line">        String result = new User();</span><br><span class="line">        // ... 处理逻辑</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    @CacheUpdate(name = &quot;JetCacheExampleService.getValue&quot;, key=&quot;#user.userId&quot;, value=&quot;#user&quot;)</span><br><span class="line">    public void updateValue(User user)&#123;</span><br><span class="line">        // 处理逻辑</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    @CacheInvalidate(name = &quot;JetCacheExampleService.getValue&quot;, key=&quot;#user.userId&quot;)</span><br><span class="line">    public void deleteValue(User user)&#123;</span><br><span class="line">        // 处理逻辑</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述所示</p><p>getValue方法会创建一个缓存实例，通过<code>@Cached</code>注解可以看到缓存实例名称<code>cacheName</code>为’JetCacheExampleService.getValue’，缓存的有效时长为6小时，本地缓存的数量最多为50，缓存类型为<code>BOTH</code>（优先从本地缓存获取）；通过<code>@CacheRefresh</code>注解可以看到会为该缓存实例设置一个刷新策略，刷新间隔为1小时，2个小时没访问后不再刷新，需要刷新的缓存实例会为其每一个缓存数据创建一个<code>RefreshTask</code>周期性任务；<code>@CachePenetrationProtect</code>注解表示该缓存实例开启保护模式，当缓存未命中，同一个JVM中同一个key只有一个线程去加载数据，其它线程等待结果。</p><p>updateValue方法可以更新缓存，通过<code>@CacheUpdate</code>注解可以看到会更新缓存实例’JetCacheExampleService.getValue’中缓存key为#user.userId的缓存value为#user。</p><p>deleteValue方法可以删除缓存，通过<code>@CacheInvalidate</code>注解可以看到会删除缓存实例’JetCacheExampleService.getValue’中缓存key为#user.userId缓存数据。</p><p>exampleCache字段会作为一个缓存实例对象，通过<code>@CreateCache</code>注解可以看到，会将该字段作为<code>cacheName</code>为’JetCacheExampleService.getValue’缓存实例对象，本地缓存的数量最多为50，缓存类型为<code>LOCAL</code>，<code>@CachePenetrationProtect</code>注解表示该缓存实例开启保护模式。</p><p>我的业务场景是使用上述的getValue方法创建缓存实例即可。</p><p>注意：</p><ul><li><code>@Cached</code>注解不能和<code>@CacheUpdate</code>或者<code>@CacheInvalidate</code>同时使用</li><li><code>@CacheInvalidate</code>可以多个同时使用</li></ul><p>另外通过@CreateCache注解创建缓存实例也可以这样初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class JetCacheExampleServiceImpl implements JetCacheExampleService &#123;</span><br><span class="line">    </span><br><span class="line">@CreateCache(name = &quot;JetCacheExampleServiceImpl.exampleCache&quot; , localLimit = 50 ,cacheType = CacheType.LOCAL)</span><br><span class="line">private Cache&lt;Long, User&gt; exampleCache;</span><br><span class="line"></span><br><span class="line">@PostConstruct</span><br><span class="line">public exampleCacheInit()&#123;</span><br><span class="line">    RefreshPolicy policy = RefreshPolicy.newPolicy(60, TimeUnit.MINUTES)</span><br><span class="line">                .stopRefreshAfterLastAccess(120, TimeUnit.MINUTES);</span><br><span class="line">        exampleCache.config().setLoader(this::loadFromDatabase);</span><br><span class="line">        exampleCache.config().setRefreshPolicy(policy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更加详细的使用方法请参考<a href="https://github.com/alibaba/jetcache"><code>JetCache</code></a>官方地址。</p><h2><span id="三-源码解析">三、源码解析</span></h2><p>参考本人Git仓库中的<a href="https://github.com/liu844869663/jetcache"><code>JetCache</code>项目</a>，已做详细的注释。</p><p>简单概括：利用Spring AOP功能，在调用需要缓存的方法前，通过解析注解获取缓存配置，根据这些配置创建不同的实例对象，进行缓存等操作。</p><p><code>JetCache</code>分为两部分，一部分是Cache API以及实现，另一部分是注解支持。</p><h3><span id="项目的各个子模块">项目的各个子模块</span></h3><ul><li>jetcache-anno-api：定义<code>JetCache</code>注解和常量。</li><li>jetcache-core：核心API，Cache接口的实现，提供各种缓存实例的操作，不依赖于Spring。</li><li>jetcache-autoconfigure：完成初始化，解析application.yml配置文件中的相关配置，以提供不同缓存实例的<code>CacheBuilder</code>构造器</li><li>jetcache-anno：基于Spring提供<code>@Cached</code>和<code>@CreateCache</code>注解支持，初始化Spring AOP以及<code>JetCache</code>注解等配置。</li><li>jetcache-redis：使用Jedis提供Redis支持。</li><li>jetcache-redis-lettuce：使用<a href="https://github.com/lettuce-io/lettuce-core">Lettuce</a>提供Redis支持，实现了<code>JetCache</code>异步访问缓存的的接口。</li><li>jetcache-redis-springdata：使用Spring Data提供Redis支持。</li><li>jetcache-starter-redis：提供pom文件，Spring Boot方式的Starter，基于Jedis。</li><li>jetcache-starter-redis-lettuce：提供pom文件，Spring Boot方式的Starter，基于Lettuce。</li><li>jetcache-starter-redis-springdata：提供pom文件，Spring Boot方式的Starter，基于Spring Data。</li><li>jetcache-test：提供相关测试。</li></ul><h3><span id="常用注解与变量">常用注解与变量</span></h3><p><a href="AnnoAPI.png"><img src="/2021/10/01/etCache-%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/AnnoAPI.png" alt="AnnoAPI"></a></p><p>在jetcache-anno-api模块中定义了需要用的缓存注解与常量，在上述已经详细的讲述过，其中<code>@CacheInvalidateContainer</code>注解定义value为<code>@CacheInvalidate</code>数组，然后通过jdk8新增的<code>@Repeatable</code>注解，在<code>@CacheInvalidate</code>注解上面添加<code>@Repeatable(CacheInvalidateContainer.class)</code>，即可支持同一个地方可以使用多个<code>@CacheInvalidate</code>注解。</p><h3><span id="缓存api">缓存API</span></h3><p>主要查看jetcache-core子模块，提供各种<code>Cache</code>缓存，以支持不同的缓存类型</p><p>Cache接口的子关系，结构如下图：</p><p><a href="Cache.png"><img src="/2021/10/01/etCache-%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Cache.png" alt="Cache"></a></p><p>主要对象描述：</p><ul><li>Cache：缓存接口，定义基本方法</li><li>AbstractCache：抽象类，缓存接口的继承者，提供基本实现，具体实现交由不同的子类</li><li>LinkedHashMapCache：基于LinkedHashMap设计的简易内存缓存</li><li>CaffeineCache：基于<a href="https://github.com/ben-manes/caffeine">Caffeine</a>工具设计的内存缓存</li><li>RedisCache：Redis实现，使用Jedis客户端</li><li>RedisLettuceCache：Redis实现，使用<a href="https://github.com/lettuce-io/lettuce-core">Lettuce</a>客户端</li><li>MultiLevelCache：两级缓存，用于封装EmbeddedCache（本地缓存）和ExternalCache（远程缓存）</li><li>RefreshCache：基于装饰器模式Decorator，提供自动刷新功能</li><li>LazyInitCache：用于@CreateCache注解创建的缓存实例，依赖于Spring</li></ul><h4><span id="cache接口">Cache接口</span></h4><p><code>com.alicp.jetcache.Cache</code>接口，定义了缓存实例的操作方法（部分有默认实现），以及获取分布式锁（非严格，用于刷新远程缓存）的实现，因为继承了<code>java.io.Closeable</code>接口，所以也提供了close方法的默认实现，空方法，交由不同缓存实例的实现去实现该方法用于释放资源，在<code>com.alicp.jetcache.anno.support.ConfigProvider.doShutdown()</code>方法中会调用每个缓存实例对象的close方法进行资源释放。主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">public interface Cache&lt;K, V&gt; extends Closeable &#123;</span><br><span class="line"></span><br><span class="line">    Logger logger = LoggerFactory.getLogger(Cache.class);</span><br><span class="line"></span><br><span class="line">    //-----------------------------JSR 107 style API------------------------------------------------</span><br><span class="line">    default V get(K key) throws CacheInvokeException &#123;</span><br><span class="line">        CacheGetResult&lt;V&gt; result = GET(key);</span><br><span class="line">        if (result.isSuccess()) &#123;</span><br><span class="line">            return result.getValue();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    default Map&lt;K, V&gt; getAll(Set&lt;? extends K&gt; keys) throws CacheInvokeException &#123;</span><br><span class="line">        MultiGetResult&lt;K, V&gt; cacheGetResults = GET_ALL(keys);</span><br><span class="line">        return cacheGetResults.unwrapValues();</span><br><span class="line">    &#125;</span><br><span class="line">    default void put(K key, V value) &#123;</span><br><span class="line">        PUT(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    default void putAll(Map&lt;? extends K, ? extends V&gt; map) &#123;</span><br><span class="line">        PUT_ALL(map);</span><br><span class="line">    &#125;</span><br><span class="line">    default boolean putIfAbsent(K key, V value) &#123; // 多级缓存MultiLevelCache不支持此方法</span><br><span class="line">        CacheResult result = PUT_IF_ABSENT(key, value, config().getExpireAfterWriteInMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">        return result.getResultCode() == CacheResultCode.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    default boolean remove(K key) &#123;</span><br><span class="line">        return REMOVE(key).isSuccess();</span><br><span class="line">    &#125;</span><br><span class="line">    default void removeAll(Set&lt;? extends K&gt; keys) &#123;</span><br><span class="line">        REMOVE_ALL(keys);</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;T&gt; T unwrap(Class&lt;T&gt; clazz);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    default void close() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //--------------------------JetCache API---------------------------------------------</span><br><span class="line">    CacheConfig&lt;K, V&gt; config();</span><br><span class="line"></span><br><span class="line">    default AutoReleaseLock tryLock(K key, long expire, TimeUnit timeUnit) &#123;</span><br><span class="line">        if (key == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        // 随机生成一个值</span><br><span class="line">        final String uuid = UUID.randomUUID().toString();</span><br><span class="line">        // 过期时间</span><br><span class="line">        final long expireTimestamp = System.currentTimeMillis() + timeUnit.toMillis(expire);</span><br><span class="line">        final CacheConfig config = config();</span><br><span class="line"></span><br><span class="line">        AutoReleaseLock lock = () -&gt; &#123; // 创建一把会自动释放资源的锁，实现其 close() 方法</span><br><span class="line">            int unlockCount = 0;</span><br><span class="line">            while (unlockCount++ &lt; config.getTryLockUnlockCount()) &#123;</span><br><span class="line">                if(System.currentTimeMillis() &lt; expireTimestamp) &#123; // 这把锁还没有过期，则删除</span><br><span class="line">                    // 删除对应的 Key 值</span><br><span class="line">                    // 出现的结果：成功，失败，Key 不存在</span><br><span class="line">                    CacheResult unlockResult = REMOVE(key);</span><br><span class="line">                    if (unlockResult.getResultCode() == CacheResultCode.FAIL</span><br><span class="line">                            || unlockResult.getResultCode() == CacheResultCode.PART_SUCCESS) &#123;</span><br><span class="line">                        // 删除对应的 Key 值过程中出现了异常，则重试</span><br><span class="line">                        logger.info(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] unlock failed. Key=&#123;&#125;, msg = &#123;&#125;&quot;,</span><br><span class="line">                                unlockCount, config.getTryLockUnlockCount(), uuid, key, unlockResult.getMessage());</span><br><span class="line">                        // retry</span><br><span class="line">                    &#125; else if (unlockResult.isSuccess()) &#123; // 释放成功</span><br><span class="line">                        logger.debug(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] successfully release the lock. Key=&#123;&#125;&quot;,</span><br><span class="line">                                unlockCount, config.getTryLockUnlockCount(), uuid, key);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125; else &#123; // 锁已经被释放了</span><br><span class="line">                        logger.warn(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] unexpected unlock result: Key=&#123;&#125;, result=&#123;&#125;&quot;,</span><br><span class="line">                                unlockCount, config.getTryLockUnlockCount(), uuid, key, unlockResult.getResultCode());</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123; // 该锁已失效</span><br><span class="line">                    logger.info(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] lock already expired: Key=&#123;&#125;&quot;,</span><br><span class="line">                            unlockCount, config.getTryLockUnlockCount(), uuid, key);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        int lockCount = 0;</span><br><span class="line">        Cache cache = this;</span><br><span class="line">        while (lockCount++ &lt; config.getTryLockLockCount()) &#123;</span><br><span class="line">            // 往 Redis（或者本地） 中存放 Key 值（_#RL#结尾的Key）</span><br><span class="line">            // 返回的结果：成功、已存在、失败</span><br><span class="line">            CacheResult lockResult = cache.PUT_IF_ABSENT(key, uuid, expire, timeUnit);</span><br><span class="line">            if (lockResult.isSuccess()) &#123; // 成功获取到锁</span><br><span class="line">                logger.debug(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] successfully get a lock. Key=&#123;&#125;&quot;,</span><br><span class="line">                        lockCount, config.getTryLockLockCount(), uuid, key);</span><br><span class="line">                return lock;</span><br><span class="line">            &#125; else if (lockResult.getResultCode() == CacheResultCode.FAIL || lockResult.getResultCode() == CacheResultCode.PART_SUCCESS) &#123;</span><br><span class="line">                logger.info(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] cache access failed during get lock, will inquiry &#123;&#125; times. Key=&#123;&#125;, msg=&#123;&#125;&quot;,</span><br><span class="line">                        lockCount, config.getTryLockLockCount(), uuid,</span><br><span class="line">                        config.getTryLockInquiryCount(), key, lockResult.getMessage());</span><br><span class="line">                // 尝试获取锁的过程中失败了，也就是往 Redis 中存放 Key 值出现异常</span><br><span class="line">                // 这个时候可能 Key 值已经存储了，但是由于其他原因导致返回的结果表示执行失败</span><br><span class="line">                int inquiryCount = 0;</span><br><span class="line">                while (inquiryCount++ &lt; config.getTryLockInquiryCount()) &#123;</span><br><span class="line">                    CacheGetResult inquiryResult = cache.GET(key);</span><br><span class="line">                    if (inquiryResult.isSuccess()) &#123;</span><br><span class="line">                        if (uuid.equals(inquiryResult.getValue())) &#123;</span><br><span class="line">                            logger.debug(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] successfully get a lock after inquiry. Key=&#123;&#125;&quot;,</span><br><span class="line">                                    inquiryCount, config.getTryLockInquiryCount(), uuid, key);</span><br><span class="line">                            return lock;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            logger.debug(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] not the owner of the lock, return null. Key=&#123;&#125;&quot;,</span><br><span class="line">                                    inquiryCount, config.getTryLockInquiryCount(), uuid, key);</span><br><span class="line">                            return null;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        logger.info(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] inquiry failed. Key=&#123;&#125;, msg=&#123;&#125;&quot;,</span><br><span class="line">                                inquiryCount, config.getTryLockInquiryCount(), uuid, key, inquiryResult.getMessage());</span><br><span class="line">                        // retry inquiry</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123; // 已存在表示该锁被其他人占有</span><br><span class="line">                // others holds the lock</span><br><span class="line">                logger.debug(&quot;[tryLock] [&#123;&#125; of &#123;&#125;] [&#123;&#125;] others holds the lock, return null. Key=&#123;&#125;&quot;,</span><br><span class="line">                        lockCount, config.getTryLockLockCount(), uuid, key);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.debug(&quot;[tryLock] [&#123;&#125;] return null after &#123;&#125; attempts. Key=&#123;&#125;&quot;, uuid, config.getTryLockLockCount(), key);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default boolean tryLockAndRun(K key, long expire, TimeUnit timeUnit, Runnable action)&#123;</span><br><span class="line">        // Release the lock use Java 7 try-with-resources.</span><br><span class="line">        try (AutoReleaseLock lock = tryLock(key, expire, timeUnit)) &#123; // 尝试获取锁</span><br><span class="line">            if (lock != null) &#123; // 获取到锁则执行下面的任务</span><br><span class="line">                action.run();</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            // 执行完锁的操作后会进行资源释放，调用 AutoCloseable 的 close() 方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CacheGetResult&lt;V&gt; GET(K key);</span><br><span class="line"></span><br><span class="line">    MultiGetResult&lt;K, V&gt; GET_ALL(Set&lt;? extends K&gt; keys);</span><br><span class="line"></span><br><span class="line">    default V computeIfAbsent(K key, Function&lt;K, V&gt; loader) &#123;</span><br><span class="line">        return computeIfAbsent(key, loader, config().isCacheNullValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V computeIfAbsent(K key, Function&lt;K, V&gt; loader, boolean cacheNullWhenLoaderReturnNull);</span><br><span class="line"></span><br><span class="line">    V computeIfAbsent(K key, Function&lt;K, V&gt; loader, boolean cacheNullWhenLoaderReturnNull, long expireAfterWrite, TimeUnit timeUnit);</span><br><span class="line"></span><br><span class="line">    default void put(K key, V value, long expireAfterWrite, TimeUnit timeUnit) &#123;</span><br><span class="line">        PUT(key, value, expireAfterWrite, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default CacheResult PUT(K key, V value) &#123;</span><br><span class="line">        if (key == null) &#123;</span><br><span class="line">            return CacheResult.FAIL_ILLEGAL_ARGUMENT;</span><br><span class="line">        &#125;</span><br><span class="line">        return PUT(key, value, config().getExpireAfterWriteInMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CacheResult PUT(K key, V value, long expireAfterWrite, TimeUnit timeUnit);</span><br><span class="line"></span><br><span class="line">    default void putAll(Map&lt;? extends K, ? extends V&gt; map, long expireAfterWrite, TimeUnit timeUnit) &#123;</span><br><span class="line">        PUT_ALL(map, expireAfterWrite, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default CacheResult PUT_ALL(Map&lt;? extends K, ? extends V&gt; map) &#123;</span><br><span class="line">        if (map == null) &#123;</span><br><span class="line">            return CacheResult.FAIL_ILLEGAL_ARGUMENT;</span><br><span class="line">        &#125;</span><br><span class="line">        return PUT_ALL(map, config().getExpireAfterWriteInMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CacheResult PUT_ALL(Map&lt;? extends K, ? extends V&gt; map, long expireAfterWrite, TimeUnit timeUnit);</span><br><span class="line"></span><br><span class="line">    CacheResult REMOVE(K key);</span><br><span class="line"></span><br><span class="line">    CacheResult REMOVE_ALL(Set&lt;? extends K&gt; keys);</span><br><span class="line"></span><br><span class="line">    CacheResult PUT_IF_ABSENT(K key, V value, long expireAfterWrite, TimeUnit timeUnit);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>com.alicp.jetcache.Cache</code>定义的方法大都是关于缓存的获取、删除和存放操作</p><ol><li>其中大写的方法返回<code>JetCache</code>自定义的CacheResult（完整的返回值，可以清晰的知道执行结果，例如get返回null的时候，无法断定是对应的key不存在，还是访问缓存发生了异常）</li><li>小写的方法默认实现就是调用大写的方法</li><li><code>computeIfAbsent</code>方法最为核心，交由子类去实现</li><li><code>tryLockAndRun</code>方法会非堵塞的尝试获取一把AutoReleaseLock分布式锁（非严格）,获取过程：<ol><li>尝试往Redis中设置（已存在无法设置）一个键值对，key为缓存<code>key_#RL#</code>，value为<code>UUID</code>，并设置这个键值对的过期时间为60秒（默认）</li><li>如果获取到锁后进行加载任务，也就是重新加载方法并更新远程缓存</li><li>该锁实现了java.lang.AutoCloseable接口，使用try-with-resource方式，在执行完加载任务后会自动释放资源，也就是调用close方法将获取锁过程中设置的键值对从Redis中删除</li><li>在RefreshCache中会调用该方法，因为如果存在远程缓存需要刷新则需要采用分布式锁的方式</li></ol></li></ol><h4><span id="abstractcache抽象类">AbstractCache抽象类</span></h4><p><code>com.alicp.jetcache.AbstractCache</code>抽象类，实现了Cache接口，主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractCache&lt;K, V&gt; implements Cache&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当缓存未命中时，并发情况同一个Key是否只允许一个线程去加载，其他线程等待结果（可以设置timeout，超时则自己加载并直接返回）</span><br><span class="line">     * 如果是的话则由获取到Key对应的 LoaderLock.signal（采用了 CountDownLatch）的线程进行加载</span><br><span class="line">     * loaderMap临时保存 Key 对应的 LoaderLock 对象</span><br><span class="line">     */</span><br><span class="line">    private volatile ConcurrentHashMap&lt;Object, LoaderLock&gt; loaderMap;</span><br><span class="line"></span><br><span class="line">    ConcurrentHashMap&lt;Object, LoaderLock&gt; initOrGetLoaderMap() &#123;</span><br><span class="line">        if (loaderMap == null) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                if (loaderMap == null) &#123;</span><br><span class="line">                    loaderMap = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return loaderMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public final V computeIfAbsent(K key, Function&lt;K, V&gt; loader, boolean cacheNullWhenLoaderReturnNull) &#123;</span><br><span class="line">        return computeIfAbsentImpl(key, loader, cacheNullWhenLoaderReturnNull,</span><br><span class="line">                0, null, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public final V computeIfAbsent(K key, Function&lt;K, V&gt; loader, boolean cacheNullWhenLoaderReturnNull,</span><br><span class="line">                                   long expireAfterWrite, TimeUnit timeUnit) &#123;</span><br><span class="line">        return computeIfAbsentImpl(key, loader, cacheNullWhenLoaderReturnNull,</span><br><span class="line">                expireAfterWrite, timeUnit, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static &lt;K, V&gt; boolean needUpdate(V loadedValue, boolean cacheNullWhenLoaderReturnNull, Function&lt;K, V&gt; loader) &#123;</span><br><span class="line">        if (loadedValue == null &amp;&amp; !cacheNullWhenLoaderReturnNull) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (loader instanceof CacheLoader &amp;&amp; ((CacheLoader&lt;K, V&gt;) loader).vetoCacheUpdate()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &lt;K, V&gt; V computeIfAbsentImpl(K key, Function&lt;K, V&gt; loader, boolean cacheNullWhenLoaderReturnNull,</span><br><span class="line">                                               long expireAfterWrite, TimeUnit timeUnit, Cache&lt;K, V&gt; cache) &#123;</span><br><span class="line">    // 获取内部的 Cache 对象</span><br><span class="line">        AbstractCache&lt;K, V&gt; abstractCache = CacheUtil.getAbstractCache(cache);</span><br><span class="line">        // 封装 loader 函数成一个 ProxyLoader 对象，主要在重新加载缓存后发出一个 CacheLoadEvent 到 CacheMonitor</span><br><span class="line">        CacheLoader&lt;K, V&gt; newLoader = CacheUtil.createProxyLoader(cache, loader, abstractCache::notify);</span><br><span class="line">        CacheGetResult&lt;V&gt; r;</span><br><span class="line">        if (cache instanceof RefreshCache) &#123; // 该缓存实例需要刷新</span><br><span class="line">            RefreshCache&lt;K, V&gt; refreshCache = ((RefreshCache&lt;K, V&gt;) cache);</span><br><span class="line">            /*</span><br><span class="line">             * 从缓存中获取数据</span><br><span class="line">             * 如果是多级缓存（先从本地缓存获取，获取不到则从远程缓存获取）</span><br><span class="line">             * 如果缓存数据是从远程缓存获取到的数据则会更新至本地缓存，并且如果本地缓存没有设置 localExpire 则使用远程缓存的到期时间作为自己的到期时间</span><br><span class="line">             * 我一般不设置 localExpire ，因为可能导致本地缓存的有效时间比远程缓存的有效时间更长</span><br><span class="line">             * 如果设置 localExpire 了记得设置 expireAfterAccessInMillis</span><br><span class="line">             */</span><br><span class="line">            r = refreshCache.GET(key);</span><br><span class="line">            // 添加/更新当前 RefreshCache 的刷新缓存任务，存放于 RefreshCache 的 taskMap 中</span><br><span class="line">            refreshCache.addOrUpdateRefreshTask(key, newLoader);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 从缓存中获取数据</span><br><span class="line">            r = cache.GET(key);</span><br><span class="line">        &#125;</span><br><span class="line">        if (r.isSuccess()) &#123; // 缓存命中</span><br><span class="line">            return r.getValue();</span><br><span class="line">        &#125; else &#123; // 缓存未命中</span><br><span class="line">            // 创建当缓存未命中去更新缓存的函数</span><br><span class="line">            Consumer&lt;V&gt; cacheUpdater = (loadedValue) -&gt; &#123;</span><br><span class="line">                if(needUpdate(loadedValue, cacheNullWhenLoaderReturnNull, newLoader)) &#123;</span><br><span class="line">                    /*</span><br><span class="line">                     * 未在缓存注解中配置 key 的生成方式则默认取入参作为缓存 key</span><br><span class="line">                     * 在进入当前方法时是否可以考虑为 key 创建一个副本？？？？</span><br><span class="line">                     * 因为缓存未命中然后通过 loader 重新加载方法时，如果方法内部对入参进行了修改，那么生成的缓存 key 也会被修改</span><br><span class="line">                     * 从而导致相同的 key 进入该方法时一直与缓存中的 key 不相同，一直出现缓存未命中</span><br><span class="line">                     */</span><br><span class="line">                    if (timeUnit != null) &#123;</span><br><span class="line">                        cache.PUT(key, loadedValue, expireAfterWrite, timeUnit).waitForResult();</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        cache.PUT(key, loadedValue).waitForResult();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            V loadedValue;</span><br><span class="line">            if (cache.config().isCachePenetrationProtect()) &#123; // 添加了 @CachePenetrationProtect 注解</span><br><span class="line">            // 一个JVM只允许一个线程执行</span><br><span class="line">                loadedValue = synchronizedLoad(cache.config(), abstractCache, key, newLoader, cacheUpdater);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            // 执行方法</span><br><span class="line">                loadedValue = newLoader.apply(key);</span><br><span class="line">                // 将新的结果异步缓存</span><br><span class="line">                cacheUpdater.accept(loadedValue);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return loadedValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &lt;K, V&gt; V synchronizedLoad(CacheConfig config, AbstractCache&lt;K,V&gt; abstractCache,</span><br><span class="line">                                     K key, Function&lt;K, V&gt; newLoader, Consumer&lt;V&gt; cacheUpdater) &#123;</span><br><span class="line">        ConcurrentHashMap&lt;Object, LoaderLock&gt; loaderMap = abstractCache.initOrGetLoaderMap();</span><br><span class="line">        Object lockKey = buildLoaderLockKey(abstractCache, key);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // 为什么加一个 create[] 数组 疑问？？</span><br><span class="line">            boolean create[] = new boolean[1];</span><br><span class="line">            LoaderLock ll = loaderMap.computeIfAbsent(lockKey, (unusedKey) -&gt; &#123;</span><br><span class="line">                create[0] = true;</span><br><span class="line">                LoaderLock loaderLock = new LoaderLock();</span><br><span class="line">                loaderLock.signal = new CountDownLatch(1);</span><br><span class="line">                loaderLock.loaderThread = Thread.currentThread();</span><br><span class="line">                return loaderLock;</span><br><span class="line">            &#125;);</span><br><span class="line">            if (create[0] || ll.loaderThread == Thread.currentThread()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 加载该 Key 实例的方法</span><br><span class="line">                    V loadedValue = newLoader.apply(key);</span><br><span class="line">                    ll.success = true;</span><br><span class="line">                    ll.value = loadedValue;</span><br><span class="line">                    // 将重新加载的数据更新至缓存</span><br><span class="line">                    cacheUpdater.accept(loadedValue);</span><br><span class="line">                    return loadedValue;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    // 标记已完成</span><br><span class="line">                    ll.signal.countDown();</span><br><span class="line">                    if (create[0]) &#123;</span><br><span class="line">                        loaderMap.remove(lockKey);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123; // 等待其他线程加载，如果出现异常或者超时则自己加载返回数据，但是不更新缓存</span><br><span class="line">                try &#123;</span><br><span class="line">                    Duration timeout = config.getPenetrationProtectTimeout();</span><br><span class="line">                    if (timeout == null) &#123;</span><br><span class="line">                        ll.signal.await();</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        boolean ok = ll.signal.await(timeout.toMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">                        if(!ok) &#123;</span><br><span class="line">                            logger.info(&quot;loader wait timeout:&quot; + timeout);</span><br><span class="line">                            return newLoader.apply(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    logger.warn(&quot;loader wait interrupted&quot;);</span><br><span class="line">                    return newLoader.apply(key);</span><br><span class="line">                &#125;</span><br><span class="line">                if (ll.success) &#123;</span><br><span class="line">                    return (V) ll.value;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Object buildLoaderLockKey(Cache c, Object key) &#123;</span><br><span class="line">        if (c instanceof AbstractEmbeddedCache) &#123;</span><br><span class="line">            return ((AbstractEmbeddedCache) c).buildKey(key);</span><br><span class="line">        &#125; else if (c instanceof AbstractExternalCache) &#123;</span><br><span class="line">            byte bytes[] = ((AbstractExternalCache) c).buildKey(key);</span><br><span class="line">            return ByteBuffer.wrap(bytes);</span><br><span class="line">        &#125; else if (c instanceof MultiLevelCache) &#123;</span><br><span class="line">            c = ((MultiLevelCache) c).caches()[0];</span><br><span class="line">            return buildLoaderLockKey(c, key);</span><br><span class="line">        &#125; else if(c instanceof ProxyCache) &#123;</span><br><span class="line">            c = ((ProxyCache) c).getTargetCache();</span><br><span class="line">            return buildLoaderLockKey(c, key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new CacheException(&quot;impossible&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重新加载数据锁</span><br><span class="line">     */</span><br><span class="line">    static class LoaderLock &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 栅栏</span><br><span class="line">         */</span><br><span class="line">        CountDownLatch signal;</span><br><span class="line">        /**</span><br><span class="line">         * 持有的线程</span><br><span class="line">         */</span><br><span class="line">        Thread loaderThread;</span><br><span class="line">        /**</span><br><span class="line">         * 是否加载成功</span><br><span class="line">         */</span><br><span class="line">        boolean success;</span><br><span class="line">        /**</span><br><span class="line">         * 加载出来的数据</span><br><span class="line">         */，</span><br><span class="line">        Object value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>com.alicp.jetcache.AbstractCache</code>实现了<code>Cache</code>接口的大写方法，内部调用自己定义的抽象方法（以<code>DO_</code>开头，交由不同的子类实现），操作缓存后发送相应的事件<code>CacheEvent</code>，也就是调用自己定义的notify方法，遍历每个<code>CacheMonitor</code>对该事件进行后置操作，用于统计信息。</p><p><code>computeIfAbsentImpl</code>方法实现了<code>Cache</code>接口的核心方法，从缓存实例中根据缓存key获取缓存value，逻辑如下：</p><ol><li>获取cache的targetCache，因为我们通过<code>@CreateCache</code>注解创建的缓存实例将生成<code>LazyInitCache</code>对象，需要调用其getTargetCache方法才会完成缓存实例的初始化</li><li>loader函数是对加载原有方法的封装，这里再进行一层封装，封装成<code>ProxyLoader</code>类型，目的是在加载原有方法后将发送<code>CacheLoadEvent</code>事件</li><li>从缓存实例中获取对应的缓存value，如果缓存实例对象是<code>RefreshCache</code>类型（在<code>com.alicp.jetcache.anno.support.CacheContext.buildCache</code>方法中会将cache包装成<code>CacheHandlerRefreshCache</code>），则调用<code>RefreshCache.addOrUpdateRefreshTask</code>方法，判断是否应该为它添加一个定时的刷新任务</li><li>如果缓存未命中，则执行loader函数，如果开启了保护模式，则调用自定义的synchronizedLoad方法，大致逻辑：根据缓存key从自己的loaderMap（线程安全）遍历中尝试获取（不存在则创建）<code>LoaderLock</code>加载锁，获取到这把加载锁才可以执行loader函数，如果已被其他线程占有则进行等待（没有设置超时时间则一直等待），通过<code>CountDownLatch</code>计数器实现</li></ol><h4><span id="abstractembeddedcache本地缓存">AbstractEmbeddedCache本地缓存</span></h4><p><code>com.alicp.jetcache.embedded.AbstractEmbeddedCache</code>抽象类继承AbstractCache抽象类，定义了本地缓存的存放缓存数据的对象为<code>com.alicp.jetcache.embedded.InnerMap</code>接口和一个初始化该接口的createAreaCache抽象方法，基于InnerMap接口实现以<code>DO_</code>开头的方法，完成缓存实例各种操作的具体实现，主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractEmbeddedCache&lt;K, V&gt; extends AbstractCache&lt;K, V&gt; &#123;</span><br><span class="line">    protected EmbeddedCacheConfig&lt;K, V&gt; config;</span><br><span class="line">    /**</span><br><span class="line">     * 本地缓存的 Map</span><br><span class="line">     */</span><br><span class="line">    protected InnerMap innerMap;</span><br><span class="line"></span><br><span class="line">    protected abstract InnerMap createAreaCache();</span><br><span class="line"></span><br><span class="line">    public AbstractEmbeddedCache(EmbeddedCacheConfig&lt;K, V&gt; config) &#123;</span><br><span class="line">        this.config = config;</span><br><span class="line">        innerMap = createAreaCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public CacheConfig&lt;K, V&gt; config() &#123;</span><br><span class="line">        return config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object buildKey(K key) &#123;</span><br><span class="line">        Object newKey = key;</span><br><span class="line">        Function&lt;K, Object&gt; keyConvertor = config.getKeyConvertor();</span><br><span class="line">        if (keyConvertor != null) &#123;</span><br><span class="line">            newKey = keyConvertor.apply(key);</span><br><span class="line">        &#125;</span><br><span class="line">        return newKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheGetResult&lt;V&gt; do_GET(K key) &#123;</span><br><span class="line">        Object newKey = buildKey(key);</span><br><span class="line">        CacheValueHolder&lt;V&gt; holder = (CacheValueHolder&lt;V&gt;) innerMap.getValue(newKey);</span><br><span class="line">        return parseHolderResult(holder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected CacheGetResult&lt;V&gt; parseHolderResult(CacheValueHolder&lt;V&gt; holder) &#123;</span><br><span class="line">        long now = System.currentTimeMillis();</span><br><span class="line">        if (holder == null) &#123;</span><br><span class="line">            return CacheGetResult.NOT_EXISTS_WITHOUT_MSG;</span><br><span class="line">        &#125; else if (now &gt;= holder.getExpireTime()) &#123;</span><br><span class="line">            return CacheGetResult.EXPIRED_WITHOUT_MSG;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            synchronized (holder) &#123;</span><br><span class="line">                long accessTime = holder.getAccessTime();</span><br><span class="line">                if (config.isExpireAfterAccess()) &#123;</span><br><span class="line">                    long expireAfterAccess = config.getExpireAfterAccessInMillis();</span><br><span class="line">                    if (now &gt;= accessTime + expireAfterAccess) &#123;</span><br><span class="line">                        return CacheGetResult.EXPIRED_WITHOUT_MSG;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 设置该缓存数据的最后一次访问时间</span><br><span class="line">                holder.setAccessTime(now);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return new CacheGetResult(CacheResultCode.SUCCESS, null, holder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected MultiGetResult&lt;K, V&gt; do_GET_ALL(Set&lt;? extends K&gt; keys) &#123;</span><br><span class="line">        ArrayList&lt;K&gt; keyList = new ArrayList&lt;K&gt;(keys.size());</span><br><span class="line">        ArrayList&lt;Object&gt; newKeyList = new ArrayList&lt;Object&gt;(keys.size());</span><br><span class="line">        keys.stream().forEach((k) -&gt; &#123;</span><br><span class="line">            Object newKey = buildKey(k);</span><br><span class="line">            keyList.add(k);</span><br><span class="line">            newKeyList.add(newKey);</span><br><span class="line">        &#125;);</span><br><span class="line">        Map&lt;Object, CacheValueHolder&lt;V&gt;&gt; innerResultMap = innerMap.getAllValues(newKeyList);</span><br><span class="line">        Map&lt;K, CacheGetResult&lt;V&gt;&gt; resultMap = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; keyList.size(); i++) &#123;</span><br><span class="line">            K key = keyList.get(i);</span><br><span class="line">            Object newKey = newKeyList.get(i);</span><br><span class="line">            CacheValueHolder&lt;V&gt; holder = innerResultMap.get(newKey);</span><br><span class="line">            resultMap.put(key, parseHolderResult(holder));</span><br><span class="line">        &#125;</span><br><span class="line">        MultiGetResult&lt;K, V&gt; result = new MultiGetResult&lt;&gt;(CacheResultCode.SUCCESS, null, resultMap);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheResult do_PUT(K key, V value, long expireAfterWrite, TimeUnit timeUnit) &#123;</span><br><span class="line">        CacheValueHolder&lt;V&gt; cacheObject = new CacheValueHolder(value ,timeUnit.toMillis(expireAfterWrite));</span><br><span class="line">        innerMap.putValue(buildKey(key), cacheObject);</span><br><span class="line">        return CacheResult.SUCCESS_WITHOUT_MSG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheResult do_PUT_ALL(Map&lt;? extends K, ? extends V&gt; map, long expireAfterWrite, TimeUnit timeUnit) &#123;</span><br><span class="line">        HashMap newKeyMap = new HashMap();</span><br><span class="line">        for (Map.Entry&lt;? extends K, ? extends V&gt; en : map.entrySet()) &#123;</span><br><span class="line">            CacheValueHolder&lt;V&gt; cacheObject = new CacheValueHolder(en.getValue(), timeUnit.toMillis(expireAfterWrite));</span><br><span class="line">            newKeyMap.put(buildKey(en.getKey()), cacheObject);</span><br><span class="line">        &#125;</span><br><span class="line">        innerMap.putAllValues(newKeyMap);</span><br><span class="line"></span><br><span class="line">        final HashMap resultMap = new HashMap();</span><br><span class="line">        map.keySet().forEach((k) -&gt; resultMap.put(k, CacheResultCode.SUCCESS));</span><br><span class="line">        return CacheResult.SUCCESS_WITHOUT_MSG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheResult do_REMOVE(K key) &#123;</span><br><span class="line">        innerMap.removeValue(buildKey(key));</span><br><span class="line">        return CacheResult.SUCCESS_WITHOUT_MSG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheResult do_REMOVE_ALL(Set&lt;? extends K&gt; keys) &#123;</span><br><span class="line">        Set newKeys = keys.stream().map((key) -&gt; buildKey(key)).collect(Collectors.toSet());</span><br><span class="line">        innerMap.removeAllValues(newKeys);</span><br><span class="line"></span><br><span class="line">        final HashMap resultMap = new HashMap();</span><br><span class="line">        keys.forEach((k) -&gt; resultMap.put(k, CacheResultCode.SUCCESS));</span><br><span class="line">        return CacheResult.SUCCESS_WITHOUT_MSG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheResult do_PUT_IF_ABSENT(K key, V value, long expireAfterWrite, TimeUnit timeUnit) &#123;</span><br><span class="line">        CacheValueHolder&lt;V&gt; cacheObject = new CacheValueHolder(value, timeUnit.toMillis(expireAfterWrite));</span><br><span class="line">        if (innerMap.putIfAbsentValue(buildKey(key), cacheObject)) &#123;</span><br><span class="line">            return CacheResult.SUCCESS_WITHOUT_MSG;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return CacheResult.EXISTS_WITHOUT_MSG;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>com.alicp.jetcache.embedded.AbstractEmbeddedCache</code>抽象类实现了操作本地缓存的相关方法</p><ol><li>定义了缓存实例对象本地缓存的配置信息<code>EmbeddedCacheConfig</code>对象</li><li>定义了缓存实例对象本地缓存基于内存操作缓存数据的<code>InnerMap</code>对象，它的初始化过程交由不同的内存缓存实例（LinkedHashMapCache和CaffeineCache）</li></ol><h5><span id="linkedhashmapcache">LinkedHashMapCache</span></h5><p><code>com.alicp.jetcache.embedded.LinkedHashMapCache</code>基于LinkedHashMap完成缓存实例对象本地缓存基于内存操作缓存数据的<code>InnerMap</code>对象的初始化工作，主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashMapCache&lt;K, V&gt; extends AbstractEmbeddedCache&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(LinkedHashMapCache.class);</span><br><span class="line"></span><br><span class="line">    public LinkedHashMapCache(EmbeddedCacheConfig&lt;K, V&gt; config) &#123;</span><br><span class="line">        super(config);</span><br><span class="line">        // 将缓存实例添加至 Cleaner</span><br><span class="line">        addToCleaner();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void addToCleaner() &#123;</span><br><span class="line">        Cleaner.add(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected InnerMap createAreaCache() &#123;</span><br><span class="line">        return new LRUMap(config.getLimit(), this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void cleanExpiredEntry() &#123;</span><br><span class="line">        ((LRUMap) innerMap).cleanExpiredEntry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于本地缓存类型为 linkedhashmap 缓存实例存储缓存数据</span><br><span class="line">     */</span><br><span class="line">    final class LRUMap extends LinkedHashMap implements InnerMap &#123;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 允许的最大缓存数量</span><br><span class="line">         */</span><br><span class="line">        private final int max;</span><br><span class="line">        /**</span><br><span class="line">         * 缓存实例锁</span><br><span class="line">         */</span><br><span class="line">        private Object lock;</span><br><span class="line"></span><br><span class="line">        public LRUMap(int max, Object lock) &#123;</span><br><span class="line">            super((int) (max * 1.4f), 0.75f, true);</span><br><span class="line">            this.max = max;</span><br><span class="line">            this.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 当元素大于最大值时移除最老的元素</span><br><span class="line">         *</span><br><span class="line">         * @param eldest 最老的元素</span><br><span class="line">         * @return 是否删除</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        protected boolean removeEldestEntry(Map.Entry eldest) &#123;</span><br><span class="line">            return size() &gt; max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 清理过期的元素</span><br><span class="line">         */</span><br><span class="line">        void cleanExpiredEntry() &#123;</span><br><span class="line">            synchronized (lock) &#123; // 占有当前缓存实例这把锁</span><br><span class="line">                for (Iterator it = entrySet().iterator(); it.hasNext();) &#123;</span><br><span class="line">                    Map.Entry en = (Map.Entry) it.next();</span><br><span class="line">                    Object value = en.getValue();</span><br><span class="line">                    if (value != null &amp;&amp; value instanceof CacheValueHolder) &#123;</span><br><span class="line">                        CacheValueHolder h = (CacheValueHolder) value;</span><br><span class="line">                        /*</span><br><span class="line">                         * 缓存的数据已经失效了则删除</span><br><span class="line">                         * 为什么不对 expireAfterAccess 进行判断，取最小值，疑问？？？？</span><br><span class="line">                         */</span><br><span class="line">                        if (System.currentTimeMillis() &gt;= h.getExpireTime()) &#123;</span><br><span class="line">                            it.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // assert false</span><br><span class="line">                        if (value == null) &#123;</span><br><span class="line">                            logger.error(&quot;key &quot; + en.getKey() + &quot; is null&quot;);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            logger.error(&quot;value of key &quot; + en.getKey() + &quot; is not a CacheValueHolder. type=&quot; + value.getClass());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object getValue(Object key) &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                return get(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Map getAllValues(Collection keys) &#123;</span><br><span class="line">            Map values = new HashMap();</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                for (Object key : keys) &#123;</span><br><span class="line">                    Object v = get(key);</span><br><span class="line">                    if (v != null) &#123;</span><br><span class="line">                        values.put(key, v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return values;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void putValue(Object key, Object value) &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                put(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void putAllValues(Map map) &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                Set&lt;Map.Entry&gt; set = map.entrySet();</span><br><span class="line">                for (Map.Entry en : set) &#123;</span><br><span class="line">                    put(en.getKey(), en.getValue());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean removeValue(Object key) &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                return remove(key) != null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void removeAllValues(Collection keys) &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                for (Object k : keys) &#123;</span><br><span class="line">                    remove(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        public boolean putIfAbsentValue(Object key, Object value) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * 如果缓存 key 不存在，或者对应的 value 已经失效则放入，否则返回 false</span><br><span class="line">             */</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                CacheValueHolder h = (CacheValueHolder) get(key);</span><br><span class="line">                if (h == null || parseHolderResult(h).getResultCode() == CacheResultCode.EXPIRED) &#123;</span><br><span class="line">                    put(key, value);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>com.alicp.jetcache.embedded.LinkedHashMapCache</code>自定义<code>LRUMap</code>继承LinkedHashMap并实现InnerMap接口</p><ol><li>自定义<code>max</code>字段，存储元素个数的最大值，并设置初始容量为(max * 1.4f)</li><li>自定义<code>lock</code>字段，每个缓存实例的锁，通过synchronized关键词保证线程安全，所以性能相对来说不好</li><li>覆盖LinkedHashMap的<code>removeEldestEntry</code>方法，当元素大于最大值时移除最老的元素</li><li>自定义<code>cleanExpiredEntry</code>方法，遍历Map，根据缓存value（被封装成的<code>com.alicp.jetcache.CacheValueHolder</code>对象，包含缓存数据、失效时间戳和第一次访问的时间），清理过期的元素</li><li>该对象初始化时会被添加至<code>com.alicp.jetcache.embedded.Cleaner</code>清理器中，Cleaner会周期性（每隔60秒）遍历LinkedHashMapCache缓存实例，调用其cleanExpiredEntry方法</li></ol><h5><span id="cleaner清理器">Cleaner清理器</span></h5><p><code>com.alicp.jetcache.embedded.Cleaner</code>用于清理缓存类型为LinkedHashMapCache的缓存数据，请查看相应注释，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 执行任务：定时清理（每分钟） LinkedHashMapCache 缓存实例中过期的缓存数据</span><br><span class="line"> */</span><br><span class="line">class Cleaner &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 存放弱引用对象，以防内存溢出</span><br><span class="line">     * 如果被弱引用的对象只被当前弱引用对象关联时，gc 时被弱引用的对象则会被回收（取决于被弱引用的对象是否还与其他强引用对象关联）</span><br><span class="line">     *</span><br><span class="line">     * 个人理解：当某个 LinkedHashMapCache 强引用对象没有被其他对象（除了这里）引用时，我们应该让这个对象被回收，</span><br><span class="line">     * 但是由于这里使用的也是强引用，这个对象被其他强引用对象关联了，不可能被回收，存在内存溢出的危险，</span><br><span class="line">     * 所以这里使用了弱引用对象，如果被弱引用的对象没有被其他对象（除了这里）引用时，这个对象会被回收</span><br><span class="line">     *</span><br><span class="line">     * 举个例子：如果我们往一个 Map&lt;Object, Object&gt; 中存放一个key-value键值对</span><br><span class="line">     * 假设对应的键已经不再使用被回收了，那我们无法再获取到对应的值，也无法被回收，占有一定的内存，存在风险</span><br><span class="line">     */</span><br><span class="line">    static LinkedList&lt;WeakReference&lt;LinkedHashMapCache&gt;&gt; linkedHashMapCaches = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        // 创建一个线程池，1个核心线程</span><br><span class="line">        ScheduledExecutorService executorService = JetCacheExecutor.defaultExecutor();</span><br><span class="line">        // 起一个循环任务一直清理 linkedHashMapCaches 过期的数据（每隔60秒）</span><br><span class="line">        executorService.scheduleWithFixedDelay(() -&gt; run(), 60, 60, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void add(LinkedHashMapCache cache) &#123;</span><br><span class="line">        synchronized (linkedHashMapCaches) &#123;</span><br><span class="line">            // 创建一个弱引用对象，并添加到清理对象中</span><br><span class="line">            linkedHashMapCaches.add(new WeakReference&lt;&gt;(cache));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void run() &#123;</span><br><span class="line">        synchronized (linkedHashMapCaches) &#123;</span><br><span class="line">            Iterator&lt;WeakReference&lt;LinkedHashMapCache&gt;&gt; it = linkedHashMapCaches.iterator();</span><br><span class="line">            while (it.hasNext()) &#123;</span><br><span class="line">                WeakReference&lt;LinkedHashMapCache&gt; ref = it.next();</span><br><span class="line">                // 获取被弱引用的对象（强引用）</span><br><span class="line">                LinkedHashMapCache c = ref.get();</span><br><span class="line">                if (c == null) &#123; // 表示被弱引用的对象被标记成了垃圾，则移除</span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    c.cleanExpiredEntry();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="caffeinecache">CaffeineCache</span></h5><p><code>com.alicp.jetcache.embedded.CaffeineCache</code>基于<a href="https://github.com/ben-manes/caffeine">Caffeine</a>完成缓存实例对象本地缓存基于内存操作缓存数据的<code>InnerMap</code>对象的初始化工作，主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">public class CaffeineCache&lt;K, V&gt; extends AbstractEmbeddedCache&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 缓存实例对象</span><br><span class="line">     */</span><br><span class="line">    private com.github.benmanes.caffeine.cache.Cache cache;</span><br><span class="line"></span><br><span class="line">    public CaffeineCache(EmbeddedCacheConfig&lt;K, V&gt; config) &#123;</span><br><span class="line">        super(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 初始化本地缓存的容器</span><br><span class="line">     *</span><br><span class="line">     * @return Map对象</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    protected InnerMap createAreaCache() &#123;</span><br><span class="line">        Caffeine&lt;Object, Object&gt; builder = Caffeine.newBuilder();</span><br><span class="line">        // 设置缓存实例的最大缓存数量</span><br><span class="line">        builder.maximumSize(config.getLimit());</span><br><span class="line">        final boolean isExpireAfterAccess = config.isExpireAfterAccess();</span><br><span class="line">        final long expireAfterAccess = config.getExpireAfterAccessInMillis();</span><br><span class="line">        // 设置缓存实例的缓存数据的失效策略</span><br><span class="line">        builder.expireAfter(new Expiry&lt;Object, CacheValueHolder&gt;() &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 获取缓存的有效时间</span><br><span class="line">             *</span><br><span class="line">             * @param value 缓存数据</span><br><span class="line">             * @return 有效时间</span><br><span class="line">             */</span><br><span class="line">            private long getRestTimeInNanos(CacheValueHolder value) &#123;</span><br><span class="line">                long now = System.currentTimeMillis();</span><br><span class="line">                long ttl = value.getExpireTime() - now;</span><br><span class="line">                /*</span><br><span class="line">                 * 如果本地缓存设置了多长时间没访问缓存则失效</span><br><span class="line">                 */</span><br><span class="line">                if(isExpireAfterAccess)&#123;</span><br><span class="line">                    // 设置缓存的失效时间</span><br><span class="line">                    // 多长时间没访问缓存则失效 and 缓存的有效时长取 min</span><br><span class="line">                    ttl = Math.min(ttl, expireAfterAccess);</span><br><span class="line">                &#125;</span><br><span class="line">                return TimeUnit.MILLISECONDS.toNanos(ttl);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public long expireAfterCreate(Object key, CacheValueHolder value, long currentTime) &#123;</span><br><span class="line">                return getRestTimeInNanos(value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public long expireAfterUpdate(Object key, CacheValueHolder value,</span><br><span class="line">                                          long currentTime, long currentDuration) &#123;</span><br><span class="line">                return currentDuration;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public long expireAfterRead(Object key, CacheValueHolder value,</span><br><span class="line">                                        long currentTime, long currentDuration) &#123;</span><br><span class="line">                return getRestTimeInNanos(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        // 构建 Cache 缓存实例</span><br><span class="line">        cache = builder.build();</span><br><span class="line">        return new InnerMap() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object getValue(Object key) &#123;</span><br><span class="line">                return cache.getIfPresent(key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Map getAllValues(Collection keys) &#123;</span><br><span class="line">                return cache.getAllPresent(keys);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void putValue(Object key, Object value) &#123;</span><br><span class="line">                cache.put(key, value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void putAllValues(Map map) &#123;</span><br><span class="line">                cache.putAll(map);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean removeValue(Object key) &#123;</span><br><span class="line">                return cache.asMap().remove(key) != null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void removeAllValues(Collection keys) &#123;</span><br><span class="line">                cache.invalidateAll(keys);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean putIfAbsentValue(Object key, Object value) &#123;</span><br><span class="line">                return cache.asMap().putIfAbsent(key, value) == null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>com.alicp.jetcache.embedded.CaffeineCache</code>通过<a href="https://github.com/ben-manes/caffeine">Caffeine</a>构建一个<code>com.github.benmanes.caffeine.cache.Cache</code>缓存对象，然后实现InnerMap接口，调用这个缓存对象的相关方法</p><ol><li>构建时设置每个元素的过期时间，也就是根据每个元素（<code>com.alicp.jetcache.CacheValueHolder</code>）的失效时间戳来设置，底层如何实现的可以参考<a href="https://github.com/ben-manes/caffeine">Caffeine</a>官方地址</li><li>调用<code>com.github.benmanes.caffeine.cache.Cache</code>的put方法我有遇到过’unable to create native thread’内存溢出的问题，所以请结合实际业务场景合理的设置缓存相关配置</li></ol><h4><span id="abstractexternalcache远程缓存">AbstractExternalCache远程缓存</span></h4><p><code>com.alicp.jetcache.embedded.AbstractExternalCache</code>抽象类继承AbstractCache抽象类，定义了缓存实例对象远程缓存的配置信息<code>ExternalCacheConfig</code>对象，提供了将缓存key转换成字节数组的方法，代码比较简单。</p><h5><span id="rediscache">RedisCache</span></h5><p><code>com.alicp.jetcache.redis.RedisCache</code>使用Jedis连接Redis，对远程的缓存数据进行操作，代码没有很复杂，可查看我的注释</p><ol><li>定义了<code>com.alicp.jetcache.redis.RedisCacheConfig</code>配置对象，包含Redis连接池的相关信息</li><li>实现了以<code>DO_</code>开头的方法，也就是通过Jedis操作缓存数据</li></ol><h5><span id="redislettucecache">RedisLettuceCache</span></h5><p><code>com.alicp.jetcache.redis.lettuce.RedisLettuceCache</code>使用<a href="https://github.com/lettuce-io/lettuce-core">Lettuce</a>连接Redis，对远程的缓存数据进行操作，代码没有很复杂，可查看我的注释</p><ol><li>定义了<code>com.alicp.jetcache.redis.lettuce.RedisLettuceCacheConfig</code>配置对象，包含Redis客户端、与Redis建立的安全连接等信息，因为底层是基于<a href="https://github.com/netty/netty">Netty</a>实现的，所以无需配置线程池</li><li>使用<code>com.alicp.jetcache.redis.lettuce.LettuceConnectionManager</code>自定义管理器将与Redis连接的相关信息封装成<code>LettuceObjects</code>对象，并管理RedisClient与LettuceObjects对应关系</li><li>相比Jedis更加安全高效</li><li>对<a href="https://github.com/lettuce-io/lettuce-core">Lettuce</a>不了解的可以参考我写的测试类<code>com.alicp.jetcache.test.external.LettuceTest</code></li></ol><h4><span id="multilevelcache两级缓存">MultiLevelCache两级缓存</span></h4><p>当你设置了缓存类型为BOTH两级缓存，那么创建的实例对象会被封装成<code>com.alicp.jetcache.MultiLevelCache</code>对象</p><ol><li>定义了<code>caches</code>字段类型为Cache[]，用于保存AbstractEmbeddedCache本地缓存实例和AbstractExternalCache远程缓存实例，本地缓存存放于远程缓存前面</li><li>实现了<code>do_GET</code>方法，遍历caches数组，也就是先从本地缓存获取，如果获取缓存不成功则从远程缓存获取，成功获取到缓存后会调用checkResultAndFillUpperCache方法</li><li>从<code>checkResultAndFillUpperCache</code>方法的逻辑可以看到，将获取到的缓存数据更新至更底层的缓存中，也就是说如果缓存数据是从远程获取到的，那么进入这个方法后会将获取到的缓存数据更新到本地缓存中去，这样下次请求可以直接从本地缓存获取，避免与Redis之间的网络消耗</li><li>实现了<code>do_PUT</code>方法，遍历caches数组，通过<code>CompletableFuture</code>进行异步编程，将所有的操作绑定在一条链上执行。</li><li>实现的了<code>PUT(K key, V value)</code>方法，会先判断是否单独配置了本地缓存时间localExipre，配置了则单独为本地缓存设置过期时间，没有配置则到期时间和远程缓存的一样</li><li>覆盖<code>tryLock</code>方法，调用caches[caches.length-1].tryLock方法，也就是只会调用最顶层远程缓存的这个方法</li></ol><p>主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line">public class MultiLevelCache&lt;K, V&gt; extends AbstractCache&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private Cache[] caches;</span><br><span class="line"></span><br><span class="line">    private MultiLevelCacheConfig&lt;K, V&gt; config;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    @Deprecated</span><br><span class="line">    public MultiLevelCache(Cache... caches) throws CacheConfigException &#123;</span><br><span class="line">        this.caches = caches;</span><br><span class="line">        checkCaches();</span><br><span class="line">        CacheConfig lastConfig = caches[caches.length - 1].config();</span><br><span class="line">        config = new MultiLevelCacheConfig&lt;&gt;();</span><br><span class="line">        config.setCaches(Arrays.asList(caches));</span><br><span class="line">        config.setExpireAfterWriteInMillis(lastConfig.getExpireAfterWriteInMillis());</span><br><span class="line">        config.setCacheNullValue(lastConfig.isCacheNullValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public MultiLevelCache(MultiLevelCacheConfig&lt;K, V&gt; cacheConfig) throws CacheConfigException &#123;</span><br><span class="line">        this.config = cacheConfig;</span><br><span class="line">        this.caches = cacheConfig.getCaches().toArray(new Cache[]&#123;&#125;);</span><br><span class="line">        checkCaches();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void checkCaches() &#123;</span><br><span class="line">        if (caches == null || caches.length == 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        for (Cache c : caches) &#123;</span><br><span class="line">            if (c.config().getLoader() != null) &#123;</span><br><span class="line">                throw new CacheConfigException(&quot;Loader on sub cache is not allowed, set the loader into MultiLevelCache.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Cache[] caches() &#123;</span><br><span class="line">        return caches;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MultiLevelCacheConfig&lt;K, V&gt; config() &#123;</span><br><span class="line">        return config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public CacheResult PUT(K key, V value) &#123;</span><br><span class="line">        if (config.isUseExpireOfSubCache()) &#123; // 本地缓存使用自己的失效时间</span><br><span class="line">            // 设置了TimeUnit为null，本地缓存则使用自己的到期时间</span><br><span class="line">            return PUT(key, value, 0, null);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return PUT(key, value, config().getExpireAfterWriteInMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public CacheResult PUT_ALL(Map&lt;? extends K, ? extends V&gt; map) &#123;</span><br><span class="line">        if (config.isUseExpireOfSubCache()) &#123;</span><br><span class="line">            return PUT_ALL(map, 0, null);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return PUT_ALL(map, config().getExpireAfterWriteInMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheGetResult&lt;V&gt; do_GET(K key) &#123;</span><br><span class="line">    // 遍历多级缓存（远程缓存排在后面）</span><br><span class="line">        for (int i = 0; i &lt; caches.length; i++) &#123;</span><br><span class="line">            Cache cache = caches[i];</span><br><span class="line">            CacheGetResult result = cache.GET(key);</span><br><span class="line">            if (result.isSuccess()) &#123;</span><br><span class="line">                CacheValueHolder&lt;V&gt; holder = unwrapHolder(result.getHolder());</span><br><span class="line">                /*</span><br><span class="line">                 * 这个遍历是从低层的缓存开始获取，获取成功则将该值设置到更低层的缓存中</span><br><span class="line">                 * 情景：</span><br><span class="line">                 * 本地没有获取到缓存，远程获取到了缓存，这里会将远程的缓存数据设置到本地中，</span><br><span class="line">                 * 这样下次请求则直接从本次获取，减少了远程获取的时间</span><br><span class="line">                 */</span><br><span class="line">                checkResultAndFillUpperCache(key, i, holder);</span><br><span class="line">                return new CacheGetResult(CacheResultCode.SUCCESS, null, holder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return CacheGetResult.NOT_EXISTS_WITHOUT_MSG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private CacheValueHolder&lt;V&gt; unwrapHolder(CacheValueHolder&lt;V&gt; h) &#123;</span><br><span class="line">        // if @Cached or @CacheCache change type from REMOTE to BOTH (or from BOTH to REMOTE),</span><br><span class="line">        // during the dev/publish process, the value type which different application server put into cache server will be different</span><br><span class="line">        // (CacheValueHolder&lt;V&gt; and CacheValueHolder&lt;CacheValueHolder&lt;V&gt;&gt;, respectively).</span><br><span class="line">        // So we need correct the problem at here and in CacheGetResult.</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line">        if (h.getValue() instanceof CacheValueHolder) &#123;</span><br><span class="line">            return (CacheValueHolder&lt;V&gt;) h.getValue();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void checkResultAndFillUpperCache(K key, int i, CacheValueHolder&lt;V&gt; h) &#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line">        long currentExpire = h.getExpireTime();</span><br><span class="line">        long now = System.currentTimeMillis();</span><br><span class="line">        if (now &lt;= currentExpire) &#123;</span><br><span class="line">            if(config.isUseExpireOfSubCache())&#123; // 如果使用本地自己的缓存过期时间</span><br><span class="line">                // 使用本地缓存自己的过期时间</span><br><span class="line">                PUT_caches(i, key, h.getValue(), 0, null);</span><br><span class="line">            &#125; else &#123; // 使用远程缓存的过期时间</span><br><span class="line">                long restTtl = currentExpire - now;</span><br><span class="line">                if (restTtl &gt; 0) &#123; // 远程缓存数据还未失效，则重新设置本地的缓存</span><br><span class="line">                    PUT_caches(i, key, h.getValue(), restTtl, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected MultiGetResult&lt;K, V&gt; do_GET_ALL(Set&lt;? extends K&gt; keys) &#123;</span><br><span class="line">        HashMap&lt;K, CacheGetResult&lt;V&gt;&gt; resultMap = new HashMap&lt;&gt;();</span><br><span class="line">        Set&lt;K&gt; restKeys = new HashSet&lt;&gt;(keys);</span><br><span class="line">        for (int i = 0; i &lt; caches.length; i++) &#123;</span><br><span class="line">            if (restKeys.size() == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            Cache&lt;K, CacheValueHolder&lt;V&gt;&gt; c = caches[i];</span><br><span class="line">            MultiGetResult&lt;K, CacheValueHolder&lt;V&gt;&gt; allResult = c.GET_ALL(restKeys);</span><br><span class="line">            if (allResult.isSuccess() &amp;&amp; allResult.getValues() != null) &#123;</span><br><span class="line">                for (Map.Entry&lt;K, CacheGetResult&lt;CacheValueHolder&lt;V&gt;&gt;&gt; en : allResult.getValues().entrySet()) &#123;</span><br><span class="line">                    K key = en.getKey();</span><br><span class="line">                    CacheGetResult result = en.getValue();</span><br><span class="line">                    if (result.isSuccess()) &#123;</span><br><span class="line">                        CacheValueHolder&lt;V&gt; holder = unwrapHolder(result.getHolder());</span><br><span class="line">                        checkResultAndFillUpperCache(key, i, holder);</span><br><span class="line">                        resultMap.put(key, new CacheGetResult(CacheResultCode.SUCCESS, null, holder));</span><br><span class="line">                        restKeys.remove(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (K k : restKeys) &#123;</span><br><span class="line">            resultMap.put(k, CacheGetResult.NOT_EXISTS_WITHOUT_MSG);</span><br><span class="line">        &#125;</span><br><span class="line">        return new MultiGetResult&lt;&gt;(CacheResultCode.SUCCESS, null, resultMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheResult do_PUT(K key, V value, long expireAfterWrite, TimeUnit timeUnit) &#123;</span><br><span class="line">        return PUT_caches(caches.length, key, value, expireAfterWrite, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheResult do_PUT_ALL(Map&lt;? extends K, ? extends V&gt; map, long expireAfterWrite, TimeUnit timeUnit) &#123;</span><br><span class="line">        CompletableFuture&lt;ResultData&gt; future = CompletableFuture.completedFuture(null);</span><br><span class="line">        for (Cache c : caches) &#123;</span><br><span class="line">            CacheResult r;</span><br><span class="line">            if(timeUnit == null) &#123;</span><br><span class="line">                r = c.PUT_ALL(map);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                r = c.PUT_ALL(map, expireAfterWrite, timeUnit);</span><br><span class="line">            &#125;</span><br><span class="line">            future = combine(future, r);</span><br><span class="line">        &#125;</span><br><span class="line">        return new CacheResult(future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private CacheResult PUT_caches(int lastIndex, K key, V value, long expire, TimeUnit timeUnit) &#123;</span><br><span class="line">        CompletableFuture&lt;ResultData&gt; future = CompletableFuture.completedFuture(null);</span><br><span class="line">        for (int i = 0; i &lt; lastIndex; i++) &#123;</span><br><span class="line">            Cache cache = caches[i];</span><br><span class="line">            CacheResult r;</span><br><span class="line">            if (timeUnit == null) &#123; // 表示本地缓存使用自己过期时间</span><br><span class="line">                r = cache.PUT(key, value);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                r = cache.PUT(key, value, expire, timeUnit);</span><br><span class="line">            &#125;</span><br><span class="line">            // 将多个 PUT 操作放在一条链上</span><br><span class="line">            future = combine(future, r);</span><br><span class="line">        &#125;</span><br><span class="line">        return new CacheResult(future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private CompletableFuture&lt;ResultData&gt; combine(CompletableFuture&lt;ResultData&gt; future, CacheResult result) &#123;</span><br><span class="line">        return future.thenCombine(result.future(), (d1, d2) -&gt; &#123;</span><br><span class="line">            if (d1 == null) &#123;</span><br><span class="line">                return d2;</span><br><span class="line">            &#125;</span><br><span class="line">            if (d1.getResultCode() != d2.getResultCode()) &#123;</span><br><span class="line">                return new ResultData(CacheResultCode.PART_SUCCESS, null, null);</span><br><span class="line">            &#125;</span><br><span class="line">            return d1;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheResult do_REMOVE(K key) &#123;</span><br><span class="line">        CompletableFuture&lt;ResultData&gt; future = CompletableFuture.completedFuture(null);</span><br><span class="line">        for (Cache cache : caches) &#123;</span><br><span class="line">            CacheResult r = cache.REMOVE(key);</span><br><span class="line">            future = combine(future, r);</span><br><span class="line">        &#125;</span><br><span class="line">        return new CacheResult(future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheResult do_REMOVE_ALL(Set&lt;? extends K&gt; keys) &#123;</span><br><span class="line">        CompletableFuture&lt;ResultData&gt; future = CompletableFuture.completedFuture(null);</span><br><span class="line">        for (Cache cache : caches) &#123;</span><br><span class="line">            CacheResult r = cache.REMOVE_ALL(keys);</span><br><span class="line">            future = combine(future, r);</span><br><span class="line">        &#125;</span><br><span class="line">        return new CacheResult(future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; T unwrap(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        Objects.requireNonNull(clazz);</span><br><span class="line">        for (Cache cache : caches) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                T obj = (T) cache.unwrap(clazz);</span><br><span class="line">                if (obj != null) &#123;</span><br><span class="line">                    return obj;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">                // ignore</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalArgumentException(clazz.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public AutoReleaseLock tryLock(K key, long expire, TimeUnit timeUnit) &#123;</span><br><span class="line">        if (key == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return caches[caches.length - 1].tryLock(key, expire, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean putIfAbsent(K key, V value) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;putIfAbsent is not supported by MultiLevelCache&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheResult do_PUT_IF_ABSENT(K key, V value, long expireAfterWrite, TimeUnit timeUnit) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;PUT_IF_ABSENT is not supported by MultiLevelCache&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        for (Cache c : caches) &#123;</span><br><span class="line">            c.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="refreshcache">RefreshCache</span></h4><p><code>com.alicp.jetcache.RefreshCache</code>为缓存实例添加刷新任务，前面在AbstractCache抽象类中讲到了，在<code>com.alicp.jetcache.anno.support.CacheContext.buildCache</code>方法中会将cache包装成<code>CacheHandlerRefreshCache</code>，所以说每个缓存实例都会调用一下<code>addOrUpdateRefreshTask</code>方法，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class RefreshCache&lt;K, V&gt; extends LoadingCache&lt;K, V&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    protected CacheConfig&lt;K, V&gt; config;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line"> * 用于保存刷新任务</span><br><span class="line"> */</span><br><span class="line">private ConcurrentHashMap&lt;Object, RefreshTask&gt; taskMap = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    protected void addOrUpdateRefreshTask(K key, CacheLoader&lt;K, V&gt; loader) &#123;</span><br><span class="line">// 获取缓存刷新策略</span><br><span class="line">RefreshPolicy refreshPolicy = config.getRefreshPolicy();</span><br><span class="line">if (refreshPolicy == null) &#123; // 没有则不进行刷新</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">// 获取刷新时间间隔</span><br><span class="line">long refreshMillis = refreshPolicy.getRefreshMillis();</span><br><span class="line">if (refreshMillis &gt; 0) &#123;</span><br><span class="line">// 获取线程任务的ID</span><br><span class="line">Object taskId = getTaskId(key);</span><br><span class="line">// 获取对应的RefreshTask，不存在则创建一个</span><br><span class="line">RefreshTask refreshTask = taskMap.computeIfAbsent(taskId, tid -&gt; &#123;</span><br><span class="line">logger.debug(&quot;add refresh task. interval=&#123;&#125;,  key=&#123;&#125;&quot;, refreshMillis, key);</span><br><span class="line">RefreshTask task = new RefreshTask(taskId, key, loader);</span><br><span class="line">task.lastAccessTime = System.currentTimeMillis();</span><br><span class="line">/*</span><br><span class="line"> * 获取 ScheduledExecutorService 周期/延迟线程池，10个核心线程，创建的线程都是守护线程</span><br><span class="line"> * scheduleWithFixedDelay(Runnable command, long initialDelay, long period, TimeUnit unit)</span><br><span class="line"> * 运行的任务task、多久延迟后开始执行、后续执行的周期间隔多长，时间单位</span><br><span class="line"> * 通过其创建一个循环任务，用于刷新缓存数据</span><br><span class="line"> */</span><br><span class="line">ScheduledFuture&lt;?&gt; future = JetCacheExecutor.heavyIOExecutor().scheduleWithFixedDelay(task,</span><br><span class="line">refreshMillis, refreshMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">task.future = future;</span><br><span class="line">return task;</span><br><span class="line">&#125;);</span><br><span class="line">// 设置最后一次访问时间</span><br><span class="line">refreshTask.lastAccessTime = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果缓存实例配置了刷新策略并且刷新间隔大于0，则会从<code>taskMap</code>（线程安全）中尝试获取对应的刷新任务<code>RefreshTask</code>，如果不存在则创建一个任务放入线程池周期性的执行</p><p><code>com.alicp.jetcache.RefreshCache.RefreshTask</code>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">public class RefreshCache&lt;K, V&gt; extends LoadingCache&lt;K, V&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    protected Cache concreteCache() &#123;</span><br><span class="line">Cache c = getTargetCache();</span><br><span class="line">while (true) &#123;</span><br><span class="line">if (c instanceof ProxyCache) &#123;</span><br><span class="line">c = ((ProxyCache) c).getTargetCache();</span><br><span class="line">&#125; else if (c instanceof MultiLevelCache) &#123;</span><br><span class="line">Cache[] caches = ((MultiLevelCache) c).caches();</span><br><span class="line">// 如果是两级缓存则返回远程缓存</span><br><span class="line">c = caches[caches.length - 1];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    class RefreshTask implements Runnable &#123;</span><br><span class="line">/**</span><br><span class="line"> * 唯一标志符，也就是Key转换后的值</span><br><span class="line"> */</span><br><span class="line">private Object taskId;</span><br><span class="line">/**</span><br><span class="line"> * 缓存的Key</span><br><span class="line"> */</span><br><span class="line">private K key;</span><br><span class="line">/**</span><br><span class="line"> * 执行方法的CacheLoader对象</span><br><span class="line"> */</span><br><span class="line">private CacheLoader&lt;K, V&gt; loader;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 最后一次访问时间</span><br><span class="line"> */</span><br><span class="line">private long lastAccessTime;</span><br><span class="line">/**</span><br><span class="line"> * 该 Task 的执行策略</span><br><span class="line"> */</span><br><span class="line">private ScheduledFuture future;</span><br><span class="line"></span><br><span class="line">RefreshTask(Object taskId, K key, CacheLoader&lt;K, V&gt; loader) &#123;</span><br><span class="line">this.taskId = taskId;</span><br><span class="line">this.key = key;</span><br><span class="line">this.loader = loader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void cancel() &#123;</span><br><span class="line">logger.debug(&quot;cancel refresh: &#123;&#125;&quot;, key);</span><br><span class="line">// 尝试中断当前任务</span><br><span class="line">future.cancel(false);</span><br><span class="line">// 从任务列表中删除</span><br><span class="line">taskMap.remove(taskId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 重新加载数据</span><br><span class="line"> *</span><br><span class="line"> * @throws Throwable 异常</span><br><span class="line"> */</span><br><span class="line">private void load() throws Throwable &#123;</span><br><span class="line">CacheLoader&lt;K, V&gt; l = loader == null ? config.getLoader() : loader;</span><br><span class="line">if (l != null) &#123;</span><br><span class="line">// 封装 CacheLoader 成 ProxyLoader，加载后会发起 Load 事件</span><br><span class="line">l = CacheUtil.createProxyLoader(cache, l, eventConsumer);</span><br><span class="line">// 加载</span><br><span class="line">V v = l.load(key);</span><br><span class="line">if (needUpdate(v, l)) &#123;</span><br><span class="line">// 将重新加载的数据放入缓存</span><br><span class="line">cache.PUT(key, v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 远程加载数据</span><br><span class="line"> *</span><br><span class="line"> * @param concreteCache 缓存对象</span><br><span class="line"> * @param currentTime   当前时间</span><br><span class="line"> * @throws Throwable 异常</span><br><span class="line"> */</span><br><span class="line">private void externalLoad(final Cache concreteCache, final long currentTime) throws Throwable &#123;</span><br><span class="line">// 获取 Key 转换后的值</span><br><span class="line">byte[] newKey = ((AbstractExternalCache) concreteCache).buildKey(key);</span><br><span class="line">// 创建分布式锁对应的Key</span><br><span class="line">byte[] lockKey = combine(newKey, &quot;_#RL#&quot;.getBytes());</span><br><span class="line">// 分布式锁的存在时间</span><br><span class="line">long loadTimeOut = RefreshCache.this.config.getRefreshPolicy().getRefreshLockTimeoutMillis();</span><br><span class="line">// 刷新间隔</span><br><span class="line">long refreshMillis = config.getRefreshPolicy().getRefreshMillis();</span><br><span class="line">// Key对应的时间戳Key（用于存放上次刷新时间）</span><br><span class="line">byte[] timestampKey = combine(newKey, &quot;_#TS#&quot;.getBytes());</span><br><span class="line"></span><br><span class="line">// AbstractExternalCache buildKey method will not convert byte[]</span><br><span class="line">// 获取Key上一次刷新时间</span><br><span class="line">CacheGetResult refreshTimeResult = concreteCache.GET(timestampKey);</span><br><span class="line">boolean shouldLoad = false; // 是否需要重新加载</span><br><span class="line">if (refreshTimeResult.isSuccess()) &#123;</span><br><span class="line">// 当前时间与上一次刷新的时间间隔是否大于或等于刷新间隔</span><br><span class="line">shouldLoad = currentTime &gt;= Long.parseLong(refreshTimeResult.getValue().toString()) + refreshMillis;</span><br><span class="line">&#125; else if (refreshTimeResult.getResultCode() == CacheResultCode.NOT_EXISTS) &#123; // 无缓存</span><br><span class="line">shouldLoad = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!shouldLoad) &#123;</span><br><span class="line">if (multiLevelCache) &#123;</span><br><span class="line">// 将顶层的缓存数据更新至低层的缓存中，例如将远程的缓存数据放入本地缓存</span><br><span class="line">// 因为如果是多级缓存，创建刷新任务后，我们只需更新远程的缓存，然后从远程缓存获取缓存数据更新低层的缓存，保证缓存一致</span><br><span class="line">refreshUpperCaches(key);</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 重新加载</span><br><span class="line">Runnable r = () -&gt; &#123;</span><br><span class="line">try &#123;</span><br><span class="line">load();</span><br><span class="line">// AbstractExternalCache buildKey method will not convert byte[]</span><br><span class="line">// 保存一个key-value至redis，其中的信息为该value的生成时间，刷新缓存</span><br><span class="line">concreteCache.put(timestampKey, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line">throw new CacheException(&quot;refresh error&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// AbstractExternalCache buildKey method will not convert byte[]</span><br><span class="line">// 分布式缓存没有一个全局分配的功能，这里尝试获取一把非严格的分布式锁，获取锁的超时时间默认60秒，也就是获取到这把锁最多可以拥有60秒</span><br><span class="line">// 只有获取Key对应的这把分布式锁，才执行重新加载的操作</span><br><span class="line">boolean lockSuccess = concreteCache.tryLockAndRun(lockKey, loadTimeOut, TimeUnit.MILLISECONDS, r);</span><br><span class="line">if (!lockSuccess &amp;&amp; multiLevelCache) &#123; // 没有获取到锁并且是多级缓存</span><br><span class="line">// 这个时候应该有其他实例在刷新缓存，所以这里设置过一会直接获取远程的缓存数据更新到本地</span><br><span class="line">// 创建一个延迟任务（1/5刷新间隔后），将最顶层的缓存数据更新至每一层</span><br><span class="line">JetCacheExecutor.heavyIOExecutor().schedule(() -&gt; refreshUpperCaches(key), (long) (0.2 * refreshMillis),</span><br><span class="line">TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void refreshUpperCaches(K key) &#123;</span><br><span class="line">MultiLevelCache&lt;K, V&gt; targetCache = (MultiLevelCache&lt;K, V&gt;) getTargetCache();</span><br><span class="line">Cache[] caches = targetCache.caches();</span><br><span class="line">int len = caches.length;</span><br><span class="line"></span><br><span class="line">// 获取多级缓存中顶层的缓存数据</span><br><span class="line">CacheGetResult cacheGetResult = caches[len - 1].GET(key);</span><br><span class="line">if (!cacheGetResult.isSuccess()) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">// 将缓存数据重新放入低层缓存</span><br><span class="line">for (int i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">caches[i].PUT(key, cacheGetResult.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 刷新任务的具体执行</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">if (config.getRefreshPolicy() == null || (loader == null &amp;&amp; !hasLoader())) &#123;</span><br><span class="line">// 取消执行</span><br><span class="line">cancel();</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">long now = System.currentTimeMillis();</span><br><span class="line">long stopRefreshAfterLastAccessMillis = config.getRefreshPolicy().getStopRefreshAfterLastAccessMillis();</span><br><span class="line">if (stopRefreshAfterLastAccessMillis &gt; 0) &#123;</span><br><span class="line">// 最后一次访问到现在时间的间隔超过了设置的 stopRefreshAfterLastAccessMillis，则取消当前任务执行</span><br><span class="line">if (lastAccessTime + stopRefreshAfterLastAccessMillis &lt; now) &#123;</span><br><span class="line">logger.debug(&quot;cancel refresh: &#123;&#125;&quot;, key);</span><br><span class="line">cancel();</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">logger.debug(&quot;refresh key: &#123;&#125;&quot;, key);</span><br><span class="line">// 获取缓存实例对象，如果是多层则返回顶层，也就是远程缓存</span><br><span class="line">Cache concreteCache = concreteCache();</span><br><span class="line">if (concreteCache instanceof AbstractExternalCache) &#123; // 远程缓存刷新</span><br><span class="line">externalLoad(concreteCache, now);</span><br><span class="line">&#125; else &#123; // 本地缓存刷新</span><br><span class="line">load();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line">logger.error(&quot;refresh error: key=&quot; + key, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刷新逻辑：</p><ol><li>判断是否需要停止刷新了，需要的话调用其<code>future</code>的cancel方法取消执行，并从<code>taskMap</code>中删除</li><li>获取缓存实例对象，如果是多层则返回顶层，也就是远程缓存实例对象</li><li>如果是本地缓存，则调用<code>load</code>方法，也就是执行loader函数加载原有方法，将获取到的数据更新至缓存实例中（如果是多级缓存，则每级缓存都会更新）</li><li>如果是远程缓存对象，则调用<code>externalLoad</code>方法，刷新后会往Redis中存放一个键值对，key为<code>key_#TS#</code>，value为<code>上一次刷新时间</code><ol><li>先从Redis中获取上一次刷新时间的键值对，根据上一次刷新的时间判断是否大于刷新间隔，大于（或者没有上一次刷新时间）表示需要重新加载数据，否则不需要重新加载数据</li><li>如果不需要重新加载数据，但是又是多级缓存，则获取远程缓存数据更新至本地缓存，保证两级缓存的一致性</li><li>如果需要重新加载数据，则调用<code>tryLockAndRun</code>方法，尝试获取分布式锁，执行刷新任务（调用<code>load</code>方法，并往Redis中重新设置上一次的刷新时间），如果没有获取到分布式锁，则创建一个延迟任务（1/5刷新间隔后）将最顶层的缓存数据更新至每一层</li></ol></li></ol><h3><span id="解析配置">解析配置</span></h3><p>主要查看jetcache-autoconfigure子模块，解析application.yml中jetcache相关配置，初始化不同缓存类型的<code>CacheBuilder</code>构造器，用于生产缓存实例，也初始化以下对象：</p><p><code>com.alicp.jetcache.anno.support.ConfigProvider</code>：缓存管理器，注入了全局配置GlobalCacheConfig、缓存实例管理器SimpleCacheManager、缓存上下文CacheContext等大量信息</p><p><code>com.alicp.jetcache.autoconfigure.AutoConfigureBeans</code>：存储<code>CacheBuilder</code>构造器以及Redis的相关信息</p><p><code>com.alicp.jetcache.anno.support.GlobalCacheConfig</code>：全局配置类，保存了一些全局信息</p><h4><span id="初始化构造器">初始化构造器</span></h4><p>通过<code>@Conditional</code>注解将需要使用到的缓存类型对应的构造器初始化类注入到Spring容器并执行初始化过程，也就是创建CacheBuilder构造器</p><p>初始化构造器类的类型结构如下图所示：</p><p><a href="AbstractCacheAutoInit.png"><img src="/2021/10/01/etCache-%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/AbstractCacheAutoInit.png" alt="AbstractCacheAutoInit"></a></p><p>主要对象描述：</p><p>AbstractCacheAutoInit：抽象类，实现Spring的InitializingBean接口，注入至Spring容器时完成初始化</p><p>EmbeddedCacheAutoInit：抽象类，继承AbstractCacheAutoInit，解析本地缓存独有的配置</p><p>LinkedHashMapAutoConfiguration：初始化LinkedHashMapCacheBuilder构造器</p><p>CaffeineAutoConfiguration：初始化CaffeineCacheBuilder构造器</p><p>ExternalCacheAutoInit：抽象类，继承AbstractCacheAutoInit，解析远程缓存独有的配置</p><p>RedisAutoInit：初始化RedisCacheBuilder构造器</p><p>RedisLettuceAutoInit：初始化RedisLettuceCacheBuilder构造器</p><h5><span id="abstractcacheautoinit">AbstractCacheAutoInit</span></h5><p><code>com.alicp.jetcache.autoconfigure.AbstractCacheAutoInit</code>抽象类主要实现了Spring的InitializingBean接口，在注入Spring容器时，Spring会调用其afterPropertiesSet方法，完成本地缓存类型和远程缓存类型<code>CacheBuilder</code>构造器的初始化，主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractCacheAutoInit implements InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    protected ConfigurableEnvironment environment;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    protected AutoConfigureBeans autoConfigureBeans;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    protected ConfigProvider configProvider;</span><br><span class="line"></span><br><span class="line">    protected String[] typeNames;</span><br><span class="line"></span><br><span class="line">    private boolean inited = false;</span><br><span class="line"></span><br><span class="line">    public AbstractCacheAutoInit(String... cacheTypes) &#123;</span><br><span class="line">        Objects.requireNonNull(cacheTypes,&quot;cacheTypes can&#x27;t be null&quot;);</span><br><span class="line">        Assert.isTrue(cacheTypes.length &gt; 0, &quot;cacheTypes length is 0&quot;);</span><br><span class="line">        this.typeNames = cacheTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 初始化方法</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() &#123;</span><br><span class="line">        if (!inited) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                if (!inited) &#123;</span><br><span class="line">                    // 这里我们有两个指定前缀 &#x27;jetcache.local&#x27; &#x27;jetcache.remote&#x27;</span><br><span class="line">                    process(&quot;jetcache.local.&quot;, autoConfigureBeans.getLocalCacheBuilders(), true);</span><br><span class="line">                    process(&quot;jetcache.remote.&quot;, autoConfigureBeans.getRemoteCacheBuilders(), false);</span><br><span class="line">                    inited = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void process(String prefix, Map cacheBuilders, boolean local) &#123;</span><br><span class="line">        // 创建一个配置对象（本地或者远程）</span><br><span class="line">        ConfigTree resolver = new ConfigTree(environment, prefix);</span><br><span class="line">        // 获取本地或者远程的配置项</span><br><span class="line">        Map&lt;String, Object&gt; m = resolver.getProperties();</span><br><span class="line">        // 获取本地或者远程的 area ，这里我一般只有默认的 default</span><br><span class="line">        Set&lt;String&gt; cacheAreaNames = resolver.directChildrenKeys();</span><br><span class="line">        for (String cacheArea : cacheAreaNames) &#123;</span><br><span class="line">            // 获取本地或者远程存储类型，例如 caffeine，redis.lettuce</span><br><span class="line">            final Object configType = m.get(cacheArea + &quot;.type&quot;);</span><br><span class="line">            // 缓存类型是否和当前 CacheAutoInit 的某一个 typeName 匹配（不同的 CacheAutoInit 会设置一个或者多个 typename）</span><br><span class="line">            boolean match = Arrays.stream(typeNames).anyMatch((tn) -&gt; tn.equals(configType));</span><br><span class="line">            /*</span><br><span class="line">             * 因为有很多 CacheAutoInit 继承者，都会执行这个方法，不同的继承者解析不同的配置</span><br><span class="line">             * 例如 CaffeineAutoConfiguration 只解析 jetcache.local.default.type=caffeine 即可</span><br><span class="line">             * RedisLettuceAutoInit 只解析 jetcache.remote.default.type=redis.lettuce 即可</span><br><span class="line">             */</span><br><span class="line">            if (!match) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // 获取本地或者远程的 area 的子配置项</span><br><span class="line">            ConfigTree ct = resolver.subTree(cacheArea + &quot;.&quot;);</span><br><span class="line">            logger.info(&quot;init cache area &#123;&#125; , type= &#123;&#125;&quot;, cacheArea, typeNames[0]);</span><br><span class="line">            // 根据配置信息构建本地或者远程缓存的 CacheBuilder 构造器</span><br><span class="line">            CacheBuilder c = initCache(ct, local ? &quot;local.&quot; + cacheArea : &quot;remote.&quot; + cacheArea);</span><br><span class="line">            // 将 CacheBuilder 构造器存放至 AutoConfigureBeans</span><br><span class="line">            cacheBuilders.put(cacheArea, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置公共的配置到 CacheBuilder 构造器中</span><br><span class="line">     *</span><br><span class="line">     * @param builder 构造器</span><br><span class="line">     * @param ct      配置信息</span><br><span class="line">     */</span><br><span class="line">    protected void parseGeneralConfig(CacheBuilder builder, ConfigTree ct) &#123;</span><br><span class="line">        AbstractCacheBuilder acb = (AbstractCacheBuilder) builder;</span><br><span class="line">        // 设置 Key 的转换函数</span><br><span class="line">        acb.keyConvertor(configProvider.parseKeyConvertor(ct.getProperty(&quot;keyConvertor&quot;)));</span><br><span class="line">        // 设置超时时间</span><br><span class="line">        String expireAfterWriteInMillis = ct.getProperty(&quot;expireAfterWriteInMillis&quot;);</span><br><span class="line">        if (expireAfterWriteInMillis == null) &#123;</span><br><span class="line">            // compatible with 2.1 兼容老版本</span><br><span class="line">            expireAfterWriteInMillis = ct.getProperty(&quot;defaultExpireInMillis&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (expireAfterWriteInMillis != null) &#123;</span><br><span class="line">            acb.setExpireAfterWriteInMillis(Long.parseLong(expireAfterWriteInMillis));</span><br><span class="line">        &#125;</span><br><span class="line">        // 多长时间没有访问就让缓存失效，0表示不使用该功能（注意：只支持本地缓存）</span><br><span class="line">        String expireAfterAccessInMillis = ct.getProperty(&quot;expireAfterAccessInMillis&quot;);</span><br><span class="line">        if (expireAfterAccessInMillis != null) &#123;</span><br><span class="line">            acb.setExpireAfterAccessInMillis(Long.parseLong(expireAfterAccessInMillis));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 初始化 CacheBuilder 构造器交由子类去实现</span><br><span class="line">     *</span><br><span class="line">     * @param ct                  配置信息</span><br><span class="line">     * @param cacheAreaWithPrefix 配置前缀</span><br><span class="line">     * @return CacheBuilder 构造器</span><br><span class="line">     */</span><br><span class="line">    protected abstract CacheBuilder initCache(ConfigTree ct, String cacheAreaWithPrefix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>在<code>afterPropertiesSet()</code>方法中可以看到会调用<code>process</code>方法分别初始化本地缓存和远程缓存的构造器</p></li><li><p>定义的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process</span><br></pre></td></tr></table></figure><p>方法：</p><ol><li>首先会从当前环境中解析出JetCache的相关配置到ConfigTree对象中</li><li>然后遍历缓存区域，获取对应的缓存类型type，进行不同类型的缓存实例CacheBuilder构造器初始化过程</li><li>不同CacheBuilder构造器的初始化方法<code>initCache</code>交由子类实现</li><li>获取到CacheBuilder构造器后会将其放入<code>AutoConfigureBeans</code>对象中去</li></ol></li><li><p>另外也定义了<code>parseGeneralConfig</code>方法解析本地缓存和远程缓存都有的配置至CacheBuilder构造器中</p></li></ol><h5><span id="embeddedcacheautoinit">EmbeddedCacheAutoInit</span></h5><p><code>com.alicp.jetcache.autoconfigure.EmbeddedCacheAutoInit</code>抽象类继承了<code>AbstractCacheAutoInit</code>，主要是覆盖父类的<code>parseGeneralConfig</code>，解析本地缓存单有的配置<code>limit</code>，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public abstract class EmbeddedCacheAutoInit extends AbstractCacheAutoInit &#123;</span><br><span class="line"></span><br><span class="line">    public EmbeddedCacheAutoInit(String... cacheTypes) &#123;</span><br><span class="line">        super(cacheTypes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void parseGeneralConfig(CacheBuilder builder, ConfigTree ct) &#123;</span><br><span class="line">        super.parseGeneralConfig(builder, ct);</span><br><span class="line">        EmbeddedCacheBuilder ecb = (EmbeddedCacheBuilder) builder;</span><br><span class="line">        // 设置本地缓存每个缓存实例的缓存数量个数限制（默认100）</span><br><span class="line">        ecb.limit(Integer.parseInt(ct.getProperty(&quot;limit&quot;, String.valueOf(CacheConsts.DEFAULT_LOCAL_LIMIT))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6><span id="linkedhashmapautoconfiguration">LinkedHashMapAutoConfiguration</span></h6><p><code>com.alicp.jetcache.autoconfigure.LinkedHashMapAutoConfiguration</code>继承了<code>EmbeddedCacheAutoInit</code>，实现了<code>initCache</code>方法，先通过LinkedHashMapCacheBuilder创建一个默认实现类，然后解析相关配置至构造器中完成初始化，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Conditional(LinkedHashMapAutoConfiguration.LinkedHashMapCondition.class)</span><br><span class="line">public class LinkedHashMapAutoConfiguration extends EmbeddedCacheAutoInit &#123;</span><br><span class="line">    public LinkedHashMapAutoConfiguration() &#123;</span><br><span class="line">        super(&quot;linkedhashmap&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheBuilder initCache(ConfigTree ct, String cacheAreaWithPrefix) &#123;</span><br><span class="line">        // 创建一个 LinkedHashMapCacheBuilder 构造器</span><br><span class="line">        LinkedHashMapCacheBuilder builder = LinkedHashMapCacheBuilder.createLinkedHashMapCacheBuilder();</span><br><span class="line">        // 解析相关配置至 LinkedHashMapCacheBuilder 的 CacheConfig 中</span><br><span class="line">        parseGeneralConfig(builder, ct);</span><br><span class="line">        return builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class LinkedHashMapCondition extends JetCacheCondition &#123;</span><br><span class="line">        // 配置了缓存类型为 linkedhashmap 当前类才会被注入 Spring 容器</span><br><span class="line">        public LinkedHashMapCondition() &#123;</span><br><span class="line">            super(&quot;linkedhashmap&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>这里我们注意到<code>@Conditional</code>注解，这个注解的作用是：满足<code>SpringBootCondition</code>条件这个Bean才会被Spring容器管理</li><li>他的条件是<code>LinkedHashMapCondition</code>，继承了<code>JetCacheCondition</code>，也就是说配置文件中配置了缓存类型为<code>linkedhashmap</code>时这个类才会被Spring容器管理，才会完成LinkedHashMapCacheBuilder构造器的初始化</li><li><code>JetCacheCondition</code>逻辑并不复杂，可自行查看</li></ol><h6><span id="caffeineautoconfiguration">CaffeineAutoConfiguration</span></h6><p><code>com.alicp.jetcache.autoconfigure.CaffeineAutoConfiguration</code>继承了<code>EmbeddedCacheAutoInit</code>，实现了<code>initCache</code>方法，先通过CaffeineCacheBuilder创建一个默认实现类，然后解析相关配置至构造器中完成初始化，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Conditional(CaffeineAutoConfiguration.CaffeineCondition.class)</span><br><span class="line">public class CaffeineAutoConfiguration extends EmbeddedCacheAutoInit &#123;</span><br><span class="line">    public CaffeineAutoConfiguration() &#123;</span><br><span class="line">        super(&quot;caffeine&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected CacheBuilder initCache(ConfigTree ct, String cacheAreaWithPrefix) &#123;</span><br><span class="line">        // 创建一个 CaffeineCacheBuilder 构造器</span><br><span class="line">        CaffeineCacheBuilder builder = CaffeineCacheBuilder.createCaffeineCacheBuilder();</span><br><span class="line">        // 解析相关配置至 CaffeineCacheBuilder 的 CacheConfig 中</span><br><span class="line">        parseGeneralConfig(builder, ct);</span><br><span class="line">        return builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class CaffeineCondition extends JetCacheCondition &#123;</span><br><span class="line">        // 配置了缓存类型为 caffeine 当前类才会被注入 Spring 容器</span><br><span class="line">        public CaffeineCondition() &#123;</span><br><span class="line">            super(&quot;caffeine&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>同样使用了<code>@Conditional</code>注解，这个注解的作用是：满足<code>SpringBootCondition</code>条件这个Bean才会被Spring容器管理</li><li>他的条件是<code>CaffeineCondition</code>，继承了<code>JetCacheCondition</code>，也就是说配置文件中配置了缓存类型为<code>caffeine</code>时这个类才会被Spring容器管理，才会完成LinkedHashMapCacheBuilder构造器的初始化</li></ol><h5><span id="externalcacheautoinit">ExternalCacheAutoInit</span></h5><p><code>com.alicp.jetcache.autoconfigure.ExternalCacheAutoInit</code>抽象类继承了<code>AbstractCacheAutoInit</code>，主要是覆盖父类的<code>parseGeneralConfig</code>，解析远程缓存单有的配置<code>keyPrefix</code>、<code>valueEncoder</code>和<code>valueDecoder</code>，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ExternalCacheAutoInit extends AbstractCacheAutoInit &#123;</span><br><span class="line">    public ExternalCacheAutoInit(String... cacheTypes) &#123;</span><br><span class="line">        super(cacheTypes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置远程缓存 CacheBuilder 构造器的相关配置</span><br><span class="line">     *</span><br><span class="line">     * @param builder 构造器</span><br><span class="line">     * @param ct      配置信息</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void parseGeneralConfig(CacheBuilder builder, ConfigTree ct) &#123;</span><br><span class="line">        super.parseGeneralConfig(builder, ct);</span><br><span class="line">        ExternalCacheBuilder ecb = (ExternalCacheBuilder) builder;</span><br><span class="line">        // 设置远程缓存 key 的前缀</span><br><span class="line">        ecb.setKeyPrefix(ct.getProperty(&quot;keyPrefix&quot;));</span><br><span class="line">        /*</span><br><span class="line">         * 根据配置创建缓存数据的编码函数和解码函数</span><br><span class="line">         */</span><br><span class="line">        ecb.setValueEncoder(configProvider.parseValueEncoder(ct.getProperty(&quot;valueEncoder&quot;, CacheConsts.DEFAULT_SERIAL_POLICY)));</span><br><span class="line">        ecb.setValueDecoder(configProvider.parseValueDecoder(ct.getProperty(&quot;valueDecoder&quot;, CacheConsts.DEFAULT_SERIAL_POLICY)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6><span id="redisautoinit">RedisAutoInit</span></h6><p><code>com.alicp.jetcache.autoconfigure.RedisAutoInit</code>继承了<code>ExternalCacheAutoInit</code>，实现<code>initCache</code>方法，完成了通过Jedis连接Redis的初始化操作，主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Conditional(RedisAutoConfiguration.RedisCondition.class)</span><br><span class="line">public class RedisAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    public static final String AUTO_INIT_BEAN_NAME = &quot;redisAutoInit&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean(name = AUTO_INIT_BEAN_NAME)</span><br><span class="line">    public RedisAutoInit redisAutoInit() &#123;</span><br><span class="line">        return new RedisAutoInit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class RedisCondition extends JetCacheCondition &#123;</span><br><span class="line">        // 配置了缓存类型为 redis 当前类才会被注入 Spring 容器</span><br><span class="line">        public RedisCondition() &#123;</span><br><span class="line">            super(&quot;redis&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class RedisAutoInit extends ExternalCacheAutoInit &#123;</span><br><span class="line">        public RedisAutoInit() &#123;</span><br><span class="line">            // 设置缓存类型</span><br><span class="line">            super(&quot;redis&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Autowired</span><br><span class="line">        private AutoConfigureBeans autoConfigureBeans;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected CacheBuilder initCache(ConfigTree ct, String cacheAreaWithPrefix) &#123;</span><br><span class="line">            Pool jedisPool = parsePool(ct);</span><br><span class="line">            Pool[] slavesPool = null;</span><br><span class="line">            int[] slavesPoolWeights = null;</span><br><span class="line">            // 是否只从 Redis 的从节点读取数据</span><br><span class="line">            boolean readFromSlave = Boolean.parseBoolean(ct.getProperty(&quot;readFromSlave&quot;, &quot;False&quot;));</span><br><span class="line">            // 获取从节点的配置信息</span><br><span class="line">            ConfigTree slaves = ct.subTree(&quot;slaves.&quot;);</span><br><span class="line">            Set&lt;String&gt; slaveNames = slaves.directChildrenKeys();</span><br><span class="line">            // 依次创建每个从节点的连接池</span><br><span class="line">            if (slaveNames.size() &gt; 0) &#123;</span><br><span class="line">                slavesPool = new Pool[slaveNames.size()];</span><br><span class="line">                slavesPoolWeights = new int[slaveNames.size()];</span><br><span class="line">                int i = 0;</span><br><span class="line">                for (String slaveName: slaveNames) &#123;</span><br><span class="line">                    ConfigTree slaveConfig = slaves.subTree(slaveName + &quot;.&quot;);</span><br><span class="line">                    slavesPool[i] = parsePool(slaveConfig);</span><br><span class="line">                    slavesPoolWeights[i] = Integer.parseInt(slaveConfig.getProperty(&quot;weight&quot;,&quot;100&quot;));</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 创建一个 RedisCacheBuilder 构造器</span><br><span class="line">            ExternalCacheBuilder externalCacheBuilder = RedisCacheBuilder.createRedisCacheBuilder()</span><br><span class="line">                    .jedisPool(jedisPool)</span><br><span class="line">                    .readFromSlave(readFromSlave)</span><br><span class="line">                    .jedisSlavePools(slavesPool)</span><br><span class="line">                    .slaveReadWeights(slavesPoolWeights);</span><br><span class="line"></span><br><span class="line">            // 解析相关配置至 RedisCacheBuilder 的 CacheConfig 中</span><br><span class="line">            parseGeneralConfig(externalCacheBuilder, ct);</span><br><span class="line"></span><br><span class="line">            // eg: &quot;jedisPool.remote.default&quot;</span><br><span class="line">            autoConfigureBeans.getCustomContainer().put(&quot;jedisPool.&quot; + cacheAreaWithPrefix, jedisPool);</span><br><span class="line"></span><br><span class="line">            return externalCacheBuilder;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 创建 Redis 连接池</span><br><span class="line">         *</span><br><span class="line">         * @param ct 配置信息</span><br><span class="line">         * @return 连接池</span><br><span class="line">         */</span><br><span class="line">        private Pool&lt;Jedis&gt; parsePool(ConfigTree ct) &#123;</span><br><span class="line">            // 创建连接池配置对象</span><br><span class="line">            GenericObjectPoolConfig poolConfig = parsePoolConfig(ct);</span><br><span class="line"></span><br><span class="line">            String host = ct.getProperty(&quot;host&quot;, (String) null);</span><br><span class="line">            int port = Integer.parseInt(ct.getProperty(&quot;port&quot;, &quot;0&quot;));</span><br><span class="line">            int timeout = Integer.parseInt(ct.getProperty(&quot;timeout&quot;, String.valueOf(Protocol.DEFAULT_TIMEOUT)));</span><br><span class="line">            String password = ct.getProperty(&quot;password&quot;, (String) null);</span><br><span class="line">            int database = Integer.parseInt(ct.getProperty(&quot;database&quot;, String.valueOf(Protocol.DEFAULT_DATABASE)));</span><br><span class="line">            String clientName = ct.getProperty(&quot;clientName&quot;, (String) null);</span><br><span class="line">            boolean ssl = Boolean.parseBoolean(ct.getProperty(&quot;ssl&quot;, &quot;false&quot;));</span><br><span class="line"></span><br><span class="line">            String masterName = ct.getProperty(&quot;masterName&quot;, (String) null);</span><br><span class="line">            String sentinels = ct.getProperty(&quot;sentinels&quot;, (String) null);//ip1:port,ip2:port</span><br><span class="line"></span><br><span class="line">            Pool&lt;Jedis&gt; jedisPool;</span><br><span class="line">            if (sentinels == null) &#123;</span><br><span class="line">                Objects.requireNonNull(host, &quot;host/port or sentinels/masterName is required&quot;);</span><br><span class="line">                if (port == 0) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;host/port or sentinels/masterName is required&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                // 创建一个 Jedis 连接池</span><br><span class="line">                jedisPool = new JedisPool(poolConfig, host, port, timeout, password, database, clientName, ssl);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Objects.requireNonNull(masterName, &quot;host/port or sentinels/masterName is required&quot;);</span><br><span class="line">                String[] strings = sentinels.split(&quot;,&quot;);</span><br><span class="line">                HashSet&lt;String&gt; sentinelsSet = new HashSet&lt;&gt;();</span><br><span class="line">                for (String s : strings) &#123;</span><br><span class="line">                    if (s != null &amp;&amp; !s.trim().equals(&quot;&quot;)) &#123;</span><br><span class="line">                        sentinelsSet.add(s.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 创建一个 Jedis Sentine 连接池</span><br><span class="line">                jedisPool = new JedisSentinelPool(masterName, sentinelsSet, poolConfig, timeout, password, database, clientName);</span><br><span class="line">            &#125;</span><br><span class="line">            return jedisPool;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>com.alicp.jetcache.autoconfigure.RedisAutoInit</code>是<code>com.alicp.jetcache.autoconfigure.RedisAutoConfiguration</code>内部的静态类，在RedisAutoConfiguration内通过<code>redisAutoInit()</code>方法定义RedisAutoInit作为Spring Bean</li><li>同样RedisAutoConfiguration使用了<code>@Conditional</code>注解，满足<code>SpringBootCondition</code>条件这个Bean才会被Spring容器管理，内部的RedisAutoInit也不会被管理，也就是说配置文件中配置了缓存类型为<code>redis</code>时RedisLettuceAutoInit才会被Spring容器管理，才会完成RedisLettuceCacheBuilder构造器的初始化</li><li>实现了<code>initCache</code>方法<ol><li>先解析Redis的相关配置</li><li>通过Jedis创建Redis连接池</li><li>通过RedisCacheBuilder创建一个默认实现类</li><li>解析相关配置至构造器中完成初始化</li><li>将Redis连接保存至<code>AutoConfigureBeans</code>中</li></ol></li></ol><h6><span id="redislettuceautoinit">RedisLettuceAutoInit</span></h6><p><code>com.alicp.jetcache.autoconfigure.RedisLettuceAutoInit</code>继承了<code>ExternalCacheAutoInit</code>，实现<code>initCache</code>方法，完成了通过Lettuce连接Redis的初始化操作，主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Conditional(RedisLettuceAutoConfiguration.RedisLettuceCondition.class)</span><br><span class="line">public class RedisLettuceAutoConfiguration &#123;</span><br><span class="line">    public static final String AUTO_INIT_BEAN_NAME = &quot;redisLettuceAutoInit&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 注入 spring 容器的条件</span><br><span class="line">     */</span><br><span class="line">    public static class RedisLettuceCondition extends JetCacheCondition &#123;</span><br><span class="line">        // 配置了缓存类型为 redis.lettuce 当前类才会被注入 Spring 容器</span><br><span class="line">        public RedisLettuceCondition() &#123;</span><br><span class="line">            super(&quot;redis.lettuce&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name = &#123;AUTO_INIT_BEAN_NAME&#125;)</span><br><span class="line">    public RedisLettuceAutoInit redisLettuceAutoInit() &#123;</span><br><span class="line">        return new RedisLettuceAutoInit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class RedisLettuceAutoInit extends ExternalCacheAutoInit &#123;</span><br><span class="line"></span><br><span class="line">        public RedisLettuceAutoInit() &#123;</span><br><span class="line">            // 设置缓存类型</span><br><span class="line">            super(&quot;redis.lettuce&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 初始化 RedisLettuceCacheBuilder 构造器</span><br><span class="line">         *</span><br><span class="line">         * @param ct                  配置信息</span><br><span class="line">         * @param cacheAreaWithPrefix 配置前缀</span><br><span class="line">         * @return 构造器</span><br><span class="line">         */</span><br><span class="line">        @Override</span><br><span class="line">        protected CacheBuilder initCache(ConfigTree ct, String cacheAreaWithPrefix) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; map = ct.subTree(&quot;uri&quot;/*there is no dot*/).getProperties();</span><br><span class="line">            // 数据节点偏好设置</span><br><span class="line">            String readFromStr = ct.getProperty(&quot;readFrom&quot;);</span><br><span class="line">            // 集群模式</span><br><span class="line">            String mode = ct.getProperty(&quot;mode&quot;);</span><br><span class="line">            // 异步获取结果的超时时间，默认1s</span><br><span class="line">            long asyncResultTimeoutInMillis = Long.parseLong(</span><br><span class="line">                    ct.getProperty(&quot;asyncResultTimeoutInMillis&quot;, Long.toString(CacheConsts.ASYNC_RESULT_TIMEOUT.toMillis())));</span><br><span class="line">            ReadFrom readFrom = null;</span><br><span class="line">            if (readFromStr != null) &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * MASTER：只从Master节点中读取。</span><br><span class="line">                 * MASTER_PREFERRED：优先从Master节点中读取。</span><br><span class="line">                 * SLAVE_PREFERRED：优先从Slave节点中读取。</span><br><span class="line">                 * SLAVE：只从Slave节点中读取。</span><br><span class="line">                 * NEAREST：使用最近一次连接的Redis实例读取。</span><br><span class="line">                 */</span><br><span class="line">                readFrom = ReadFrom.valueOf(readFromStr.trim());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AbstractRedisClient client;</span><br><span class="line">            StatefulConnection connection = null;</span><br><span class="line">            if (map == null || map.size() == 0) &#123;</span><br><span class="line">                throw new CacheConfigException(&quot;lettuce uri is required&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 创建对应的 RedisURI</span><br><span class="line">                List&lt;RedisURI&gt; uriList = map.values().stream().map((k) -&gt; RedisURI.create(URI.create(k.toString())))</span><br><span class="line">                        .collect(Collectors.toList());</span><br><span class="line">                if (uriList.size() == 1) &#123; // 只有一个 URI，集群模式只给一个域名怎么办 TODO 疑问？？</span><br><span class="line">                    RedisURI uri = uriList.get(0);</span><br><span class="line">                    if (readFrom == null) &#123;</span><br><span class="line">                        // 创建一个 Redis 客户端</span><br><span class="line">                        client = RedisClient.create(uri);</span><br><span class="line">                        // 设置失去连接时的行为，拒绝命令，默认为 DEFAULT</span><br><span class="line">                        ((RedisClient) client).setOptions(ClientOptions.builder().</span><br><span class="line">                                disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS).build());</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 创建一个 Redis 客户端</span><br><span class="line">                        client = RedisClient.create();</span><br><span class="line">                        ((RedisClient) client).setOptions(ClientOptions.builder().</span><br><span class="line">                                disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS).build());</span><br><span class="line">                        // 创建一个安全连接并设置数据节点偏好</span><br><span class="line">                        StatefulRedisMasterSlaveConnection c = MasterSlave.connect(</span><br><span class="line">                                (RedisClient) client, new JetCacheCodec(), uri);</span><br><span class="line">                        c.setReadFrom(readFrom);</span><br><span class="line">                        connection = c;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123; // 多个 URI，集群模式</span><br><span class="line">                    if (mode != null &amp;&amp; mode.equalsIgnoreCase(&quot;MasterSlave&quot;)) &#123;</span><br><span class="line">                        client = RedisClient.create();</span><br><span class="line">                        ((RedisClient) client).setOptions(ClientOptions.builder().</span><br><span class="line">                                disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS).build());</span><br><span class="line">                        StatefulRedisMasterSlaveConnection c = MasterSlave.connect(</span><br><span class="line">                                (RedisClient) client, new JetCacheCodec(), uriList);</span><br><span class="line">                        if (readFrom != null) &#123;</span><br><span class="line">                            c.setReadFrom(readFrom);</span><br><span class="line">                        &#125;</span><br><span class="line">                        connection = c;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 创建一个 Redis 客户端</span><br><span class="line">                        client = RedisClusterClient.create(uriList);</span><br><span class="line">                        ((RedisClusterClient) client).setOptions(ClusterClientOptions.builder().</span><br><span class="line">                                disconnectedBehavior(ClientOptions.DisconnectedBehavior.REJECT_COMMANDS).build());</span><br><span class="line">                        if (readFrom != null) &#123;</span><br><span class="line">                            StatefulRedisClusterConnection c = ((RedisClusterClient) client).connect(new JetCacheCodec());</span><br><span class="line">                            c.setReadFrom(readFrom);</span><br><span class="line">                            connection = c;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 创建一个 RedisLettuceCacheBuilder 构造器</span><br><span class="line">            ExternalCacheBuilder externalCacheBuilder = RedisLettuceCacheBuilder.createRedisLettuceCacheBuilder()</span><br><span class="line">                    .connection(connection)</span><br><span class="line">                    .redisClient(client)</span><br><span class="line">                    .asyncResultTimeoutInMillis(asyncResultTimeoutInMillis);</span><br><span class="line">            // 解析相关配置至 RedisLettuceCacheBuilder 的 CacheConfig 中</span><br><span class="line">            parseGeneralConfig(externalCacheBuilder, ct);</span><br><span class="line"></span><br><span class="line">            // eg: &quot;remote.default.client&quot;</span><br><span class="line">            autoConfigureBeans.getCustomContainer().put(cacheAreaWithPrefix + &quot;.client&quot;, client);</span><br><span class="line">            // 开始将 Redis 客户端和安全连接保存至 LettuceConnectionManager 管理器中</span><br><span class="line">            LettuceConnectionManager m = LettuceConnectionManager.defaultManager();</span><br><span class="line">            // 初始化 Lettuce 连接 Redis</span><br><span class="line">            m.init(client, connection);</span><br><span class="line">            // 初始化 Redis 连接的相关信息保存至 LettuceObjects 中，并将相关信息保存至 AutoConfigureBeans.customContainer</span><br><span class="line">            autoConfigureBeans.getCustomContainer().put(cacheAreaWithPrefix + &quot;.connection&quot;, m.connection(client));</span><br><span class="line">            autoConfigureBeans.getCustomContainer().put(cacheAreaWithPrefix + &quot;.commands&quot;, m.commands(client));</span><br><span class="line">            autoConfigureBeans.getCustomContainer().put(cacheAreaWithPrefix + &quot;.asyncCommands&quot;, m.asyncCommands(client));</span><br><span class="line">            autoConfigureBeans.getCustomContainer().put(cacheAreaWithPrefix + &quot;.reactiveCommands&quot;, m.reactiveCommands(client));</span><br><span class="line">            return externalCacheBuilder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>com.alicp.jetcache.autoconfigure.RedisLettuceAutoInit</code>是<code>com.alicp.jetcache.autoconfigure.RedisLettuceAutoConfiguration</code>内部的静态类，在RedisLettuceAutoConfiguration内通过<code>redisLettuceAutoInit()</code>方法定义RedisLettuceAutoInit作为Spring Bean</li><li>同样RedisLettuceAutoConfiguration使用了<code>@Conditional</code>注解，满足<code>SpringBootCondition</code>条件这个Bean才会被Spring容器管理，内部的RedisLettuceAutoInit也不会被管理，也就是说配置文件中配置了缓存类型为<code>redis.lettuce</code>时RedisLettuceAutoInit才会被Spring容器管理，才会完成RedisLettuceCacheBuilder构造器的初始化</li><li>实现了<code>initCache</code>方法<ol><li>先解析Redis的相关配置</li><li>通过Lettuce创建Redis客户端和与Redis的连接</li><li>通过RedisLettuceCacheBuilder创建一个默认实现类</li><li>解析相关配置至构造器中完成初始化</li><li>获取<code>LettuceConnectionManager</code>管理器，将通过Lettuce创建Redis客户端和与Redis的连接保存</li><li>将Redis客户端、与Redis的连接、同步命令、异步命令和反应式命令相关保存至<code>AutoConfigureBeans</code>中</li></ol></li></ol><h4><span id="jetcacheautoconfiguration自动配置">JetCacheAutoConfiguration自动配置</span></h4><p>上面的初始化构造器的类需要被Spring容器管理，就需被扫描到，我们一般会设置扫描路径，但是别人引入JetCache肯定是作为其他包不能够被扫描到的，这些Bean也就不会被Spring管理，这里我们查看<code>jetcache-autoconfigure</code>模块下src/main/resources/META-INF/<code>spring.factories</code>文件，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.alicp.jetcache.autoconfigure.JetCacheAutoConfiguration</span><br></pre></td></tr></table></figure><p>这应该是一种<code>SPI</code>机制，这样这个项目以外的JetCache包里面的<code>com.alicp.jetcache.autoconfigure.JetCacheAutoConfiguration</code>就会被Spring容器扫描到，我们来看看他的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 该 Bean 将会被 Spring 容器注入，依次注入下面几个 Bean</span><br><span class="line"> * SpringConfigProvider -&gt; AutoConfigureBeans -&gt; BeanDependencyManager(为 GlobalCacheConfig 添加 CacheAutoInit 依赖) -&gt; GlobalCacheConfig</span><br><span class="line"> * 由此会完成初始化配置操作，缓存实例构造器 CacheBuilder 也会被注入容器</span><br><span class="line"> *</span><br><span class="line"> * Created on 2016/11/17.</span><br><span class="line"> *</span><br><span class="line"> * @author &lt;a href=&quot;mailto:areyouok@gmail.com&quot;&gt;huangli&lt;/a&gt;</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(GlobalCacheConfig.class)</span><br><span class="line">@ConditionalOnMissingBean(GlobalCacheConfig.class)</span><br><span class="line">@EnableConfigurationProperties(JetCacheProperties.class)</span><br><span class="line">@Import(&#123;RedisAutoConfiguration.class,</span><br><span class="line">        CaffeineAutoConfiguration.class,</span><br><span class="line">        MockRemoteCacheAutoConfiguration.class,</span><br><span class="line">        LinkedHashMapAutoConfiguration.class,</span><br><span class="line">        RedisLettuceAutoConfiguration.class,</span><br><span class="line">        RedisSpringDataAutoConfiguration.class&#125;)</span><br><span class="line">public class JetCacheAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    public static final String GLOBAL_CACHE_CONFIG_NAME = &quot;globalCacheConfig&quot;;</span><br><span class="line"></span><br><span class="line">    private SpringConfigProvider _springConfigProvider = new SpringConfigProvider();</span><br><span class="line"></span><br><span class="line">    private AutoConfigureBeans _autoConfigureBeans = new AutoConfigureBeans();</span><br><span class="line"></span><br><span class="line">    private GlobalCacheConfig _globalCacheConfig;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean</span><br><span class="line">    public SpringConfigProvider springConfigProvider() &#123;</span><br><span class="line">        return _springConfigProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public AutoConfigureBeans autoConfigureBeans() &#123;</span><br><span class="line">        return _autoConfigureBeans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public static BeanDependencyManager beanDependencyManager()&#123;</span><br><span class="line">        return new BeanDependencyManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name = GLOBAL_CACHE_CONFIG_NAME)</span><br><span class="line">    public GlobalCacheConfig globalCacheConfig(SpringConfigProvider configProvider,</span><br><span class="line">                                                            AutoConfigureBeans autoConfigureBeans,</span><br><span class="line">                                                            JetCacheProperties props) &#123;</span><br><span class="line">        if (_globalCacheConfig != null) &#123;</span><br><span class="line">            return _globalCacheConfig;</span><br><span class="line">        &#125;</span><br><span class="line">        _globalCacheConfig = new GlobalCacheConfig();</span><br><span class="line">        _globalCacheConfig.setHiddenPackages(props.getHiddenPackages());</span><br><span class="line">        _globalCacheConfig.setStatIntervalMinutes(props.getStatIntervalMinutes());</span><br><span class="line">        _globalCacheConfig.setAreaInCacheName(props.isAreaInCacheName());</span><br><span class="line">        _globalCacheConfig.setPenetrationProtect(props.isPenetrationProtect());</span><br><span class="line">        _globalCacheConfig.setEnableMethodCache(props.isEnableMethodCache());</span><br><span class="line">        _globalCacheConfig.setLocalCacheBuilders(autoConfigureBeans.getLocalCacheBuilders());</span><br><span class="line">        _globalCacheConfig.setRemoteCacheBuilders(autoConfigureBeans.getRemoteCacheBuilders());</span><br><span class="line">        return _globalCacheConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>可以看到通过<code>@Import</code>注解，初始化构造器的那些类会被加入到Spring容器，加上<code>@Condotional</code>注解，只有我们配置过的缓存类型的构造器才会被加入，然后保存至AutoConfigureBeans对象中</li><li>注意到这里我们注入的是<code>SpringConfigProvider</code>对象，加上<code>@ConditionalOnMissingBean</code>注解，无法再次注册该对象至Spring容器，相比<code>ConfigProvider</code>对象，它的区别是设置了EncoderParser为DefaultSpringEncoderParser，设置了KeyConvertorParser为DefaultSpringKeyConvertorParser，目的是支持两个解析器能够解析自定义bean</li><li>在<code>BeanDependencyManager</code>中可以看到它是一个<code>BeanFactoryPostProcessor</code>，用于BeanFactory容器初始后执行操作，目的是往JetCacheAutoConfiguration的BeanDefinition的依赖中添加几个AbstractCacheAutoInit类型的beanName，保证几个CacheBuilder构造器已经初始化</li><li><code>globalCacheConfig</code>方法中设置全局的相关配置并添加已经初始化的CacheBuilder构造器，然后返回GlobalCacheConfig让Spring容器管理，这样一来就完成了JetCache的解析配置并初始化的功能</li></ol><h4><span id="cachebuilder构造器">CacheBuilder构造器</span></h4><p>构造器的作用就是根据配置构建一个对应类型的缓存实例</p><p>CacheBuilder的子类结构如下：</p><p><a href="CacheBuilder.png"><img src="/2021/10/01/etCache-%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/CacheBuilder.png" alt="CacheBuilder"></a></p><p>根据类名就可以知道其作用</p><p>CacheBuilder接口只定义了一个<code>buildCache()</code>方法，用于构建缓存实例，交由不同的实现类</p><p>AbstractCacheBuilder抽象类实现了<code>buildCache()</code>方法，主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractCacheBuilder&lt;T extends AbstractCacheBuilder&lt;T&gt;&gt; implements CacheBuilder, Cloneable &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 该缓存实例的配置</span><br><span class="line">     */</span><br><span class="line">    protected CacheConfig config;</span><br><span class="line">    /**</span><br><span class="line">     * 创建缓存实例函数</span><br><span class="line">     */</span><br><span class="line">    private Function&lt;CacheConfig, Cache&gt; buildFunc;</span><br><span class="line"></span><br><span class="line">    public abstract CacheConfig getConfig();</span><br><span class="line"></span><br><span class="line">    protected T self() &#123;</span><br><span class="line">        return (T) this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T buildFunc(Function&lt;CacheConfig, Cache&gt; buildFunc) &#123;</span><br><span class="line">        this.buildFunc = buildFunc;</span><br><span class="line">        return self();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void beforeBuild() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Deprecated</span><br><span class="line">    public final &lt;K, V&gt; Cache&lt;K, V&gt; build() &#123;</span><br><span class="line">        return buildCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public final &lt;K, V&gt; Cache&lt;K, V&gt; buildCache() &#123;</span><br><span class="line">        if (buildFunc == null) &#123;</span><br><span class="line">            throw new CacheConfigException(&quot;no buildFunc&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        beforeBuild();</span><br><span class="line">        // 克隆一份配置信息，因为这里获取到的是全局配置信息，以防后续被修改</span><br><span class="line">        CacheConfig c = getConfig().clone();</span><br><span class="line">        // 通过构建函数创建一个缓存实例</span><br><span class="line">        Cache&lt;K, V&gt; cache = buildFunc.apply(c);</span><br><span class="line">        /*</span><br><span class="line">         * 目前发现 c.getLoader() 都是 null，后续都会把 cache 封装成 CacheHandlerRefreshCache</span><br><span class="line">         * TODO 疑问？？？？</span><br><span class="line">         */</span><br><span class="line">        if (c.getLoader() != null) &#123;</span><br><span class="line">            if (c.getRefreshPolicy() == null) &#123;</span><br><span class="line">                cache = new LoadingCache&lt;&gt;(cache);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cache = new RefreshCache&lt;&gt;(cache);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        AbstractCacheBuilder copy = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            copy = (AbstractCacheBuilder) super.clone();</span><br><span class="line">            copy.config = getConfig().clone();</span><br><span class="line">            return copy;</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            throw new CacheException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>实现了<code>java.lang.Cloneable</code>的clone方法，支持克隆该对象，因为每个缓存实例的配置不一定相同，这个构造器中保存的是全局的一些配置，所以需要克隆一个构造器出来为每个缓存实例设置其自己的配置而不影响这个最初始的构造器</p></li><li><p>定义CacheConfig对象存放缓存配置，构建缓存实例需要根据这些配置</p></li><li><p>定义的<code>buildFunc</code>函数用于构建缓存实例，我们在初始化构造器中可以看到，不同的构造器设置的该函数都是new一个缓存实例并传入配置信息，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 设置构建 CaffeineCache 缓存实例的函数</span><br><span class="line">buildFunc((c) -&gt; new CaffeineCache((EmbeddedCacheConfig) c));</span><br><span class="line">// 进入CaffeineCache的构造器你就可以看到会根据配置完成缓存实例的初始化</span><br></pre></td></tr></table></figure></li></ol><p>不同类型的构造器区别在于CacheConfig类型不同，因为远程和本地的配置是有所区别的，还有就是设置的<code>buildFunc</code>函数不同，因为需要构建不同的缓存实例，和上面的例子差不多，都是new一个缓存实例并传入配置信息，这里就不一一讲述了</p><h3><span id="aop">AOP</span></h3><p>主要查看jetcache-anno子模块，提供AOP功能</p><h4><span id="启用jetcache">启用JetCache</span></h4><p>JetCache可以通过@EnableMethodCache和@EnableCreateCacheAnnotation注解完成AOP的初始化工作，我们在Spring Boot工程中的启动类上面添加这两个注解即可启用JetCache缓存。</p><h5><span id="enablemethodcache">@EnableMethodCache</span></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Import(&#123;CommonConfiguration.class, ConfigSelector.class&#125;)</span><br><span class="line">public @interface EnableMethodCache &#123;</span><br><span class="line"></span><br><span class="line">    boolean proxyTargetClass() default false;</span><br><span class="line"></span><br><span class="line">    AdviceMode mode() default AdviceMode.PROXY;</span><br><span class="line"></span><br><span class="line">    int order() default Ordered.LOWEST_PRECEDENCE;</span><br><span class="line"></span><br><span class="line">    String[] basePackages();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的相关配置在上面的’如何使用’中已经讲过了，这里我们关注<code>@Import</code>注解中的<code>CommonConfiguration</code>和<code>ConfigSelector</code>两个类，将会被Spring容器管理</p><ol><li><code>com.alicp.jetcache.anno.config.CommonConfiguration</code>上面有@Configuration注解，所以会被作为一个Spring Bean，里面定义了一个Bean为<code>ConfigMap</code>，所以这个Bean也会被Spring容器管理，<code>com.alicp.jetcache.anno.support.ConfigMap</code>中保存方法与缓存注解配置信息的映射关系</li><li><code>com.alicp.jetcache.anno.config.ConfigSelector</code>继承了AdviceModeImportSelector，通过<code>@Import</code>注解他的<code>selectImports</code>方法会被调用，根据不同的AdviceMode导入不同的配置类，可以看到会返回一个JetCacheProxyConfiguration类名称，那么它也会被注入</li></ol><p><code>com.alicp.jetcache.anno.config.JetCacheProxyConfiguration</code>是配置AOP的配置类，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class JetCacheProxyConfiguration implements ImportAware, ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    protected AnnotationAttributes enableMethodCache;</span><br><span class="line">    private ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setImportMetadata(AnnotationMetadata importMetadata) &#123;</span><br><span class="line">        // 获取 @EnableMethodCache 注解信息</span><br><span class="line">        this.enableMethodCache = AnnotationAttributes.fromMap(</span><br><span class="line">                importMetadata.getAnnotationAttributes(EnableMethodCache.class.getName(), false));</span><br><span class="line">        if (this.enableMethodCache == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;@EnableMethodCache is not present on importing class &quot; + importMetadata.getClassName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        this.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name = CacheAdvisor.CACHE_ADVISOR_BEAN_NAME)</span><br><span class="line">    @Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">    public CacheAdvisor jetcacheAdvisor(JetCacheInterceptor jetCacheInterceptor) &#123;</span><br><span class="line">        CacheAdvisor advisor = new CacheAdvisor();</span><br><span class="line">        // bean的名称：jetcache2.internalCacheAdvisor</span><br><span class="line">        advisor.setAdviceBeanName(CacheAdvisor.CACHE_ADVISOR_BEAN_NAME);</span><br><span class="line">        // 设置缓存拦截器为 JetCacheInterceptor</span><br><span class="line">        advisor.setAdvice(jetCacheInterceptor);</span><br><span class="line">        // 设置需要扫描的包</span><br><span class="line">        advisor.setBasePackages(this.enableMethodCache.getStringArray(&quot;basePackages&quot;));</span><br><span class="line">        // 设置优先级，默认 Integer 的最大值，最低优先级</span><br><span class="line">        advisor.setOrder(this.enableMethodCache.&lt;Integer&gt;getNumber(&quot;order&quot;));</span><br><span class="line">        return advisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 注入一个 JetCacheInterceptor 拦截器，设置为框架内部的角色</span><br><span class="line">     *</span><br><span class="line">     * @return JetCacheInterceptor</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    @Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">    public JetCacheInterceptor jetCacheInterceptor() &#123;</span><br><span class="line">        return new JetCacheInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为JetCacheProxyConfiguration是通过<code>@Import</code>注解注入的并且实现了<code>ImportAware</code>接口，当被注入Bean的时候会先调用其<code>setImportMetadata</code>方法（这里好像必须添加@Configuration注解，不然无法被Spring识别出来）获取到<code>@EnableMethodCache</code>注解的元信息</p><p>其中定义了两个Bean：</p><p><code>com.alicp.jetcache.anno.aop.JetCacheInterceptor</code>：实现了aop中的MethodInterceptor方法拦截器，可用于aop拦截方法后执行相关处理</p><p><code>com.alicp.jetcache.anno.aop.CacheAdvisor</code>：</p><ol><li>继承了<code>org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor</code>，将会作为一个AOP切面</li><li>设置了通知advice为JetCacheInterceptor，也就是说被拦截的方法都会进入JetCacheInterceptor，JetCacheInterceptor就作为JetCache的入口了</li><li>根据注解设置了需要扫描的包路径以及优先级，默认是最低优先级</li><li>CacheAdvisor实现了<code>org.springframework.aopPointcutAdvisor</code>接口的<code>getPointcut()</code>方法，设置这个切面的切入点为<code>com.alicp.jetcache.anno.aop.CachePointcut</code></li><li>从CachePointcut作为切入点<ol><li>实现了<code>org.springframework.aop.ClassFilter</code>接口，用于判断哪些类需要被拦截</li><li>实现了<code>org.springframework.aop.MethodMatcher</code>接口，用于判断哪些类中的哪些方法会被拦截</li><li>在判断方法是否需要进入JetCache的JetCacheInterceptor过程中，会解析方法上面的JetCache相关缓存注解，将配置信息封装<code>com.alicp.jetcache.anno.methodCacheInvokeConfig</code>对象中，并把它保存至<code>com.alicp.jetcache.anno.support.ConfigMap</code>对象中</li></ol></li></ol><p>总结：@EnableMethodCache注解主要就是生成一个AOP切面用于拦截带有缓存注解的方法</p><h5><span id="enablecreatecacheannotation">@EnableCreateCacheAnnotation</span></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Import(&#123;CommonConfiguration.class, CreateCacheAnnotationBeanPostProcessor.class&#125;)</span><br><span class="line">public @interface EnableCreateCacheAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比@EnableMethodCache注解，没有相关属性，同样会导入CommonConfiguration类</p><p>不同的是将导入<code>com.alicp.jetcache.anno.field.CreateCacheAnnotationBeanPostProcessor</code>类，它继承了<code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor</code></p><p>作为一个BeanPostProcessor，用于在Spring初始化bean的时候做一些操作</p><p>从代码中可以看到他的作用是：如果这个bean内部存在添加了带有<code>@CreateCache</code>注解的字段（没有添加static），会将这个字段作为需要注入的对象，解析成 <code>com.alicp.jetcache.anno.field.LazyInitCache</code>缓存实例</p><p>LazyInitCache的主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">class LazyInitCache implements ProxyCache &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 是否初始化，用于懒加载</span><br><span class="line">     */</span><br><span class="line">    private boolean inited;</span><br><span class="line">    /**</span><br><span class="line">     * 缓存实例</span><br><span class="line">     */</span><br><span class="line">    private Cache cache;</span><br><span class="line">    /**</span><br><span class="line">     * 所处上下文</span><br><span class="line">     */</span><br><span class="line">    private ConfigurableListableBeanFactory beanFactory;</span><br><span class="line">    /**</span><br><span class="line">     * CreateCache 注解元信息</span><br><span class="line">     */</span><br><span class="line">    private CreateCache ann;</span><br><span class="line">    /**</span><br><span class="line">     * 字段</span><br><span class="line">     */</span><br><span class="line">    private Field field;</span><br><span class="line">    /**</span><br><span class="line">     * 刷新策略</span><br><span class="line">     */</span><br><span class="line">    private RefreshPolicy refreshPolicy;</span><br><span class="line">    /**</span><br><span class="line">     * 保护策略</span><br><span class="line">     */</span><br><span class="line">    private PenetrationProtectConfig protectConfig;</span><br><span class="line"></span><br><span class="line">    public LazyInitCache(ConfigurableListableBeanFactory beanFactory, CreateCache ann, Field field) &#123;</span><br><span class="line">        this.beanFactory = beanFactory;</span><br><span class="line">        this.ann = ann;</span><br><span class="line">        this.field = field;</span><br><span class="line">        CacheRefresh cr = field.getAnnotation(CacheRefresh.class);</span><br><span class="line">        if (cr != null) &#123;</span><br><span class="line">            refreshPolicy = CacheConfigUtil.parseRefreshPolicy(cr);</span><br><span class="line">        &#125;</span><br><span class="line">        CachePenetrationProtect penetrateProtect = field.getAnnotation(CachePenetrationProtect.class);</span><br><span class="line">        if (penetrateProtect != null) &#123;</span><br><span class="line">            protectConfig = CacheConfigUtil.parsePenetrationProtectConfig(penetrateProtect);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void checkInit() &#123;</span><br><span class="line">        if (!inited) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                if (!inited) &#123;</span><br><span class="line">                    init();</span><br><span class="line">                    inited = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取缓存实例，不存在则新建</span><br><span class="line">     *</span><br><span class="line">     * @return 缓存实例</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Cache getTargetCache() &#123;</span><br><span class="line">        checkInit();</span><br><span class="line">        return cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init() &#123;</span><br><span class="line">        if (inited) &#123;</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        // 从 spring 的容器中获取全局缓存配置 GlobalCacheConfig 对象</span><br><span class="line">        GlobalCacheConfig globalCacheConfig = beanFactory.getBean(GlobalCacheConfig.class);</span><br><span class="line">        ConfigProvider configProvider = beanFactory.getBean(ConfigProvider.class);</span><br><span class="line"></span><br><span class="line">        // 将注解信息封装到 CachedAnnoConfig 对象中</span><br><span class="line">        CachedAnnoConfig cac = new CachedAnnoConfig();</span><br><span class="line">        cac.setArea(ann.area());</span><br><span class="line">        cac.setName(ann.name());</span><br><span class="line">        cac.setTimeUnit(ann.timeUnit());</span><br><span class="line">        cac.setExpire(ann.expire());</span><br><span class="line">        cac.setLocalExpire(ann.localExpire());</span><br><span class="line">        cac.setCacheType(ann.cacheType());</span><br><span class="line">        cac.setLocalLimit(ann.localLimit());</span><br><span class="line">        cac.setSerialPolicy(ann.serialPolicy());</span><br><span class="line">        cac.setKeyConvertor(ann.keyConvertor());</span><br><span class="line"></span><br><span class="line">        cac.setRefreshPolicy(refreshPolicy);</span><br><span class="line">        cac.setPenetrationProtectConfig(protectConfig);</span><br><span class="line"></span><br><span class="line">        String cacheName = cac.getName();</span><br><span class="line">        if (CacheConsts.isUndefined(cacheName)) &#123;</span><br><span class="line">            String[] hiddenPackages = globalCacheConfig.getHiddenPackages();</span><br><span class="line">            CacheNameGenerator g = configProvider.createCacheNameGenerator(hiddenPackages);</span><br><span class="line">            cacheName = g.generateCacheName(field);</span><br><span class="line">        &#125;</span><br><span class="line">        // 从缓存实例管理器中获取或者创建对应的缓存实例</span><br><span class="line">        cache = configProvider.getCacheContext().__createOrGetCache(cac, ann.area(), cacheName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>可以看到通过<code>@CreateCache</code>创建的缓存实例也可以添加<code>@CacheRefresh</code>和<code>@CachePenetrationProtect</code>注解</li><li>在AbstractCache抽象类的computeIfAbsentImpl方法中我们有讲到，如果缓存实例是ProxyCache类型，则会先调用其<code>getTargetCache()</code>方法获取缓存实例对象，所以LazyInitCache在第一次访问的时候才进行初始化，并根据缓存注解配置信息创建（存在则直接获取）一个缓存实例</li></ol><p>总结：@EnableCreateCacheAnnotation注解主要是支持@CreateCache能够创建缓存实例</p><p>通过<code>@EnableMethodCache</code>和<code>@EnableCreateCacheAnnotation</code>两个注解，加上前面的<code>解析配置过程</code>，已经完成的JetCache的解析与初始化过程，那么接下来我们来看看JetCache如何处理被拦截的方法。</p><h4><span id="拦截器">拦截器</span></h4><p>从<code>com.alicp.jetcache.anno.aop.CachePointcut</code>切入点判断方法是否需要拦截的逻辑：</p><ol><li>方法所在的类对象是否匹配，除去以”java”、”org.springframework”开头和包含”$$EnhancerBySpringCGLIB$$”、”$$FastClassBySpringCGLIB$$”的类，该类是否在我们通过<code>@EnableMethodCache</code>注解配置的basePackages中</li><li>从<code>ConfigMap</code>获取方法对应的<code>CacheInvokeConfig</code>对象，也就是获取缓存配置信息<ol><li>如果是一个空对象，那么不需要被拦截，因为前面已经判断了所在的类是否需要被拦截，而这个类中并不是所有的方法都会添加缓存注解，所以这一类的方法会设置一个空对象（定义在CacheInvokeConfig内部的一个静态对象添加了final修饰），保存在ConfigMap中</li><li>如果不为null，则需被拦截</li><li>通过CacheConfigUtil解析这个方法的缓存注解，如果有@Cached注解或者@CacheInvalidate注解或者@CacheUpdate注解，先解析注解生成CacheInvokeConfig对象保存至ConfigMap中，然后该方法会被拦截，否在保存一个空对象不会被拦截</li></ol></li></ol><h5><span id="configprovider">ConfigProvider</span></h5><p><code>com.alicp.jetcache.anno.support.ConfigProvide</code>是一个配置提供者对象，包含了JetCache的全局配置、缓存实例管理器、缓存value转换器、缓存key转换器、上下文和监控指标相关信息，主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">public class ConfigProvider extends AbstractLifecycle &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 缓存的全局配置</span><br><span class="line">     */</span><br><span class="line">    @Resource</span><br><span class="line">    protected GlobalCacheConfig globalCacheConfig;</span><br><span class="line">    /**</span><br><span class="line">     * 缓存实例管理器</span><br><span class="line">     */</span><br><span class="line">    protected SimpleCacheManager cacheManager;</span><br><span class="line">    /**</span><br><span class="line">     * 根据不同类型生成缓存数据转换函数的转换器</span><br><span class="line">     */</span><br><span class="line">    protected EncoderParser encoderParser;</span><br><span class="line">    /**</span><br><span class="line">     * 根据不同类型生成缓存 Key 转换函数的转换器</span><br><span class="line">     */</span><br><span class="line">    protected KeyConvertorParser keyConvertorParser;</span><br><span class="line">    /**</span><br><span class="line">     * 缓存监控指标管理器</span><br><span class="line">     */</span><br><span class="line">    protected CacheMonitorManager cacheMonitorManager;</span><br><span class="line">    /**</span><br><span class="line">     * 打印缓存各项指标的函数</span><br><span class="line">     */</span><br><span class="line">    private Consumer&lt;StatInfo&gt; metricsCallback = new StatInfoLogger(false);</span><br><span class="line">    /**</span><br><span class="line">     * 缓存更新事件（REMOVE OR PUT）消息接收者，无实现类</span><br><span class="line">     * 我们可以自己实现 CacheMessagePublisher 用于统计一些缓存的命中信息</span><br><span class="line">     */</span><br><span class="line">    private CacheMessagePublisher cacheMessagePublisher;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 默认的缓存监控指标管理器</span><br><span class="line">     */</span><br><span class="line">    private CacheMonitorManager defaultCacheMonitorManager = new DefaultCacheMonitorManager();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 缓存上下文</span><br><span class="line">     */</span><br><span class="line">    private CacheContext cacheContext;</span><br><span class="line"></span><br><span class="line">    public ConfigProvider() &#123;</span><br><span class="line">        cacheManager = SimpleCacheManager.defaultManager;</span><br><span class="line">        encoderParser = new DefaultEncoderParser();</span><br><span class="line">        keyConvertorParser = new DefaultKeyConvertorParser();</span><br><span class="line">        cacheMonitorManager = defaultCacheMonitorManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doInit() &#123;</span><br><span class="line">        // 启动缓存指标监控器，周期性打印各项指标</span><br><span class="line">        initDefaultCacheMonitorInstaller();</span><br><span class="line">        // 初始化缓存上下文</span><br><span class="line">        cacheContext = newContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void initDefaultCacheMonitorInstaller() &#123;</span><br><span class="line">        if (cacheMonitorManager == defaultCacheMonitorManager) &#123;</span><br><span class="line">            DefaultCacheMonitorManager installer = (DefaultCacheMonitorManager) cacheMonitorManager;</span><br><span class="line">            installer.setGlobalCacheConfig(globalCacheConfig);</span><br><span class="line">            installer.setMetricsCallback(metricsCallback);</span><br><span class="line">            if (cacheMessagePublisher != null) &#123;</span><br><span class="line">                installer.setCacheMessagePublisher(cacheMessagePublisher);</span><br><span class="line">            &#125;</span><br><span class="line">            // 启动缓存指标监控器</span><br><span class="line">            installer.init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doShutdown() &#123;</span><br><span class="line">        shutdownDefaultCacheMonitorInstaller();</span><br><span class="line">        cacheManager.rebuild();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void shutdownDefaultCacheMonitorInstaller() &#123;</span><br><span class="line">        if (cacheMonitorManager == defaultCacheMonitorManager) &#123;</span><br><span class="line">            ((DefaultCacheMonitorManager) cacheMonitorManager).shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据编码类型通过缓存value转换器生成编码函数</span><br><span class="line">     *</span><br><span class="line">     * @param valueEncoder 编码类型</span><br><span class="line">     * @return 编码函数</span><br><span class="line">     */</span><br><span class="line">    public Function&lt;Object, byte[]&gt; parseValueEncoder(String valueEncoder) &#123;</span><br><span class="line">        return encoderParser.parseEncoder(valueEncoder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据解码类型通过缓存value转换器生成解码函数</span><br><span class="line">     *</span><br><span class="line">     * @param valueDecoder 解码类型</span><br><span class="line">     * @return 解码函数</span><br><span class="line">     */</span><br><span class="line">    public Function&lt;byte[], Object&gt; parseValueDecoder(String valueDecoder) &#123;</span><br><span class="line">        return encoderParser.parseDecoder(valueDecoder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据转换类型通过缓存key转换器生成转换函数</span><br><span class="line">     *</span><br><span class="line">     * @param convertor 转换类型</span><br><span class="line">     * @return 转换函数</span><br><span class="line">     */</span><br><span class="line">    public Function&lt;Object, Object&gt; parseKeyConvertor(String convertor) &#123;</span><br><span class="line">        return keyConvertorParser.parseKeyConvertor(convertor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CacheNameGenerator createCacheNameGenerator(String[] hiddenPackages) &#123;</span><br><span class="line">        return new DefaultCacheNameGenerator(hiddenPackages);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected CacheContext newContext() &#123;</span><br><span class="line">        return new CacheContext(this, globalCacheConfig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承了<code>com.alicp.jetcache.anno.support.AbstractLifecycle</code>，查看其代码可以看到有两个方法，分别为<code>init()</code>初始化方法和<code>shutdown()</code>销毁方法，因为分别添加了<code>@PostConstruct</code>注解和<code>@PreDestroy</code>注解，所以在Spring初始化时会调用init()，在Spring容器销毁时会调用shutdown()方法，内部分别调用doInit()和doShutdown()，这两个方法交由子类实现</p><p>在doInit()方法中先启动缓存指标监控器，用于周期性打印各项缓存指标，然后初始化CacheContext缓存上下文，SpringConfigProvider返回的是SpringConfigContext</p><p>在doShutdown()方法中关闭缓存指标监控器，清除缓存实例</p><h5><span id="cachecontext">CacheContext</span></h5><p><code>com.alicp.jetcache.anno.support.CacheContext</code>缓存上下文主要为每一个被拦截的请求创建缓存上下文，构建对应的缓存实例，主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line">public class CacheContext &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(CacheContext.class);</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;CacheThreadLocal&gt; cacheThreadLocal = new ThreadLocal&lt;CacheThreadLocal&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected CacheThreadLocal initialValue() &#123;</span><br><span class="line">            return new CacheThreadLocal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    /**</span><br><span class="line">     * JetCache 缓存的管理器（包含很多信息）</span><br><span class="line">     */</span><br><span class="line">    private ConfigProvider configProvider;</span><br><span class="line">    /**</span><br><span class="line">     * 缓存的全局配置</span><br><span class="line">     */</span><br><span class="line">    private GlobalCacheConfig globalCacheConfig;</span><br><span class="line">    /**</span><br><span class="line">     * 缓存实例管理器</span><br><span class="line">     */</span><br><span class="line">    protected SimpleCacheManager cacheManager;</span><br><span class="line"></span><br><span class="line">    public CacheContext(ConfigProvider configProvider, GlobalCacheConfig globalCacheConfig) &#123;</span><br><span class="line">        this.globalCacheConfig = globalCacheConfig;</span><br><span class="line">        this.configProvider = configProvider;</span><br><span class="line">        cacheManager = configProvider.getCacheManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CacheInvokeContext createCacheInvokeContext(ConfigMap configMap) &#123;</span><br><span class="line">    // 创建一个本次调用的上下文</span><br><span class="line">        CacheInvokeContext c = newCacheInvokeContext();</span><br><span class="line">        // 添加一个函数，后续用于获取缓存实例</span><br><span class="line">        // 根据注解配置信息获取缓存实例对象，不存在则创建并设置到缓存注解配置类中</span><br><span class="line">        c.setCacheFunction((invokeContext, cacheAnnoConfig) -&gt; &#123;</span><br><span class="line">            Cache cache = cacheAnnoConfig.getCache();</span><br><span class="line">            if (cache == null) &#123;</span><br><span class="line">                if (cacheAnnoConfig instanceof CachedAnnoConfig) &#123; // 缓存注解</span><br><span class="line">                    // 根据配置创建一个缓存实例对象，通过 CacheBuilder</span><br><span class="line">                    cache = createCacheByCachedConfig((CachedAnnoConfig) cacheAnnoConfig, invokeContext);</span><br><span class="line">                &#125; else if ((cacheAnnoConfig instanceof CacheInvalidateAnnoConfig) || (cacheAnnoConfig instanceof CacheUpdateAnnoConfig)) &#123; // 更新/使失效缓存注解</span><br><span class="line">                    CacheInvokeConfig cacheDefineConfig = configMap.getByCacheName(cacheAnnoConfig.getArea(), cacheAnnoConfig.getName());</span><br><span class="line">                    if (cacheDefineConfig == null) &#123;</span><br><span class="line">                        String message = &quot;can&#x27;t find @Cached definition with area=&quot; + cacheAnnoConfig.getArea()</span><br><span class="line">                                + &quot; name=&quot; + cacheAnnoConfig.getName() +</span><br><span class="line">                                &quot;, specified in &quot; + cacheAnnoConfig.getDefineMethod();</span><br><span class="line">                        CacheConfigException e = new CacheConfigException(message);</span><br><span class="line">                        logger.error(&quot;Cache operation aborted because can&#x27;t find @Cached definition&quot;, e);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cache = createCacheByCachedConfig(cacheDefineConfig.getCachedAnnoConfig(), invokeContext);</span><br><span class="line">                &#125;</span><br><span class="line">                cacheAnnoConfig.setCache(cache);</span><br><span class="line">            &#125;</span><br><span class="line">            return cache;</span><br><span class="line">        &#125;);</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Cache createCacheByCachedConfig(CachedAnnoConfig ac, CacheInvokeContext invokeContext) &#123;</span><br><span class="line">    // 缓存区域</span><br><span class="line">        String area = ac.getArea();</span><br><span class="line">        // 缓存实例名称</span><br><span class="line">        String cacheName = ac.getName();</span><br><span class="line">        if (CacheConsts.isUndefined(cacheName)) &#123; // 没有定义缓存实例名称</span><br><span class="line"></span><br><span class="line">        // 生成缓存实例名称：类名+方法名+(参数类型)</span><br><span class="line">            cacheName = configProvider.createCacheNameGenerator(invokeContext.getHiddenPackages())</span><br><span class="line">                    .generateCacheName(invokeContext.getMethod(), invokeContext.getTargetObject());</span><br><span class="line">        &#125;</span><br><span class="line">        // 创建缓存实例对象</span><br><span class="line">        Cache cache = __createOrGetCache(ac, area, cacheName);</span><br><span class="line">        return cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Deprecated</span><br><span class="line">    public &lt;K, V&gt; Cache&lt;K, V&gt; getCache(String cacheName) &#123;</span><br><span class="line">        return getCache(CacheConsts.DEFAULT_AREA, cacheName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Deprecated</span><br><span class="line">    public &lt;K, V&gt; Cache&lt;K, V&gt; getCache(String area, String cacheName) &#123;</span><br><span class="line">        Cache cache = cacheManager.getCacheWithoutCreate(area, cacheName);</span><br><span class="line">        return cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Cache __createOrGetCache(CachedAnnoConfig cachedAnnoConfig, String area, String cacheName) &#123;</span><br><span class="line">    // 缓存名称拼接</span><br><span class="line">        String fullCacheName = area + &quot;_&quot; + cacheName;</span><br><span class="line">        // 从缓存实例管理器中根据缓存区域和缓存实例名称获取缓存实例</span><br><span class="line">        Cache cache = cacheManager.getCacheWithoutCreate(area, cacheName);</span><br><span class="line">        if (cache == null) &#123;</span><br><span class="line">            synchronized (this) &#123; // 加锁</span><br><span class="line">                // 再次确认</span><br><span class="line">                cache = cacheManager.getCacheWithoutCreate(area, cacheName);</span><br><span class="line">                if (cache == null) &#123;</span><br><span class="line">                    /*</span><br><span class="line">                     * 缓存区域的名称是否作为缓存 key 名称前缀，默认为 true ，我一般设置为 false</span><br><span class="line">                     */</span><br><span class="line">                    if (globalCacheConfig.isAreaInCacheName()) &#123;</span><br><span class="line">                        // for compatible reason, if we use default configuration, the prefix should same to that version &lt;=2.4.3</span><br><span class="line">                        cache = buildCache(cachedAnnoConfig, area, fullCacheName);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 构建一个缓存实例</span><br><span class="line">                        cache = buildCache(cachedAnnoConfig, area, cacheName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    cacheManager.putCache(area, cacheName, cache);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Cache buildCache(CachedAnnoConfig cachedAnnoConfig, String area, String cacheName) &#123;</span><br><span class="line">        Cache cache;</span><br><span class="line">        if (cachedAnnoConfig.getCacheType() == CacheType.LOCAL) &#123; // 本地缓存</span><br><span class="line">            cache = buildLocal(cachedAnnoConfig, area);</span><br><span class="line">        &#125; else if (cachedAnnoConfig.getCacheType() == CacheType.REMOTE) &#123; // 远程缓存</span><br><span class="line">            cache = buildRemote(cachedAnnoConfig, area, cacheName);</span><br><span class="line">        &#125; else &#123; // 两级缓存</span><br><span class="line">        // 构建本地缓存实例</span><br><span class="line">            Cache local = buildLocal(cachedAnnoConfig, area);</span><br><span class="line">            // 构建远程缓存实例</span><br><span class="line">            Cache remote = buildRemote(cachedAnnoConfig, area, cacheName);</span><br><span class="line">            // 两级缓存时是否单独设置了本地缓存失效时间 localExpire</span><br><span class="line">            boolean useExpireOfSubCache = cachedAnnoConfig.getLocalExpire() &gt; 0;</span><br><span class="line">            // 创建一个两级缓存CacheBuilder</span><br><span class="line">            cache = MultiLevelCacheBuilder.createMultiLevelCacheBuilder()</span><br><span class="line">                    .expireAfterWrite(remote.config().getExpireAfterWriteInMillis(), TimeUnit.MILLISECONDS)</span><br><span class="line">                    .addCache(local, remote)</span><br><span class="line">                    .useExpireOfSubCache(useExpireOfSubCache)</span><br><span class="line">                    .cacheNullValue(cachedAnnoConfig.isCacheNullValue())</span><br><span class="line">                    .buildCache();</span><br><span class="line">        &#125;</span><br><span class="line">        // 设置缓存刷新策略</span><br><span class="line">        cache.config().setRefreshPolicy(cachedAnnoConfig.getRefreshPolicy());</span><br><span class="line">        // 将 cache 封装成 CacheHandlerRefreshCache，也就是 RefreshCache 类型</span><br><span class="line">        // 后续添加刷新任务时会判断是否为 RefreshCache 类型，然后决定是否执行 addOrUpdateRefreshTask 方法，添加刷新任务，没有刷新策略不会添加</span><br><span class="line">        cache = new CacheHandler.CacheHandlerRefreshCache(cache);</span><br><span class="line"></span><br><span class="line">        // 设置缓存未命中时，JVM是否只允许一个线程执行方法，其他线程等待，全局配置默认为false</span><br><span class="line">        cache.config().setCachePenetrationProtect(globalCacheConfig.isPenetrationProtect());</span><br><span class="line">        PenetrationProtectConfig protectConfig = cachedAnnoConfig.getPenetrationProtectConfig();</span><br><span class="line">        if (protectConfig != null) &#123; // 方法的@CachePenetrationProtect注解</span><br><span class="line">            cache.config().setCachePenetrationProtect(protectConfig.isPenetrationProtect());</span><br><span class="line">            cache.config().setPenetrationProtectTimeout(protectConfig.getPenetrationProtectTimeout());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (configProvider.getCacheMonitorManager() != null) &#123;</span><br><span class="line">        // 添加监控统计配置</span><br><span class="line">            configProvider.getCacheMonitorManager().addMonitors(area, cacheName, cache);</span><br><span class="line">        &#125;</span><br><span class="line">        return cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Cache buildRemote(CachedAnnoConfig cachedAnnoConfig, String area, String cacheName) &#123;</span><br><span class="line">        // 获取缓存区域对应的 CacheBuilder 构造器</span><br><span class="line">        ExternalCacheBuilder cacheBuilder = (ExternalCacheBuilder) globalCacheConfig.getRemoteCacheBuilders().get(area);</span><br><span class="line">        if (cacheBuilder == null) &#123;</span><br><span class="line">            throw new CacheConfigException(&quot;no remote cache builder: &quot; + area);</span><br><span class="line">        &#125;</span><br><span class="line">        // 克隆一个 CacheBuilder 构造器，因为不同缓存实例有不同的配置</span><br><span class="line">        cacheBuilder = (ExternalCacheBuilder) cacheBuilder.clone();</span><br><span class="line"></span><br><span class="line">        if (cachedAnnoConfig.getExpire() &gt; 0 ) &#123;</span><br><span class="line">        // 设置失效时间</span><br><span class="line">            cacheBuilder.expireAfterWrite(cachedAnnoConfig.getExpire(), cachedAnnoConfig.getTimeUnit());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 设置缓存 key 的前缀</span><br><span class="line">        if (cacheBuilder.getConfig().getKeyPrefix() != null) &#123;</span><br><span class="line">            // 配置文件中配置了 prefix，则设置为 prefix+cacheName</span><br><span class="line">            cacheBuilder.setKeyPrefix(cacheBuilder.getConfig().getKeyPrefix() + cacheName);</span><br><span class="line">        &#125; else &#123; // 设置为 cacheName</span><br><span class="line">            cacheBuilder.setKeyPrefix(cacheName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!CacheConsts.isUndefined(cachedAnnoConfig.getKeyConvertor())) &#123; // 如果注解中设置了Key的转换方式则替换，否则还是使用全局的</span><br><span class="line">        // 设置 key 的转换器，只支持 FASTJSON</span><br><span class="line">            cacheBuilder.setKeyConvertor(configProvider.parseKeyConvertor(cachedAnnoConfig.getKeyConvertor()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (!CacheConsts.isUndefined(cachedAnnoConfig.getSerialPolicy())) &#123;</span><br><span class="line">        // 缓存数据保存至远程需要进行编码和解码，所以这里设置其编码和解码方式，KRYO 和 JAVA 可选择</span><br><span class="line">            cacheBuilder.setValueEncoder(configProvider.parseValueEncoder(cachedAnnoConfig.getSerialPolicy()));</span><br><span class="line">            cacheBuilder.setValueDecoder(configProvider.parseValueDecoder(cachedAnnoConfig.getSerialPolicy()));</span><br><span class="line">        &#125;</span><br><span class="line">        // 设置是否缓存 null 值</span><br><span class="line">        cacheBuilder.setCacheNullValue(cachedAnnoConfig.isCacheNullValue());</span><br><span class="line">        return cacheBuilder.buildCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Cache buildLocal(CachedAnnoConfig cachedAnnoConfig, String area) &#123;</span><br><span class="line">    // 获取缓存区域对应的 CacheBuilder 构造器</span><br><span class="line">        EmbeddedCacheBuilder cacheBuilder = (EmbeddedCacheBuilder) globalCacheConfig.getLocalCacheBuilders().get(area);</span><br><span class="line">        if (cacheBuilder == null) &#123;</span><br><span class="line">            throw new CacheConfigException(&quot;no local cache builder: &quot; + area);</span><br><span class="line">        &#125;</span><br><span class="line">        // 克隆一个 CacheBuilder 构造器，因为不同缓存实例有不同的配置</span><br><span class="line">        cacheBuilder = (EmbeddedCacheBuilder) cacheBuilder.clone();</span><br><span class="line"></span><br><span class="line">        if (cachedAnnoConfig.getLocalLimit() != CacheConsts.UNDEFINED_INT) &#123;</span><br><span class="line">            // 本地缓存数量限制</span><br><span class="line">            cacheBuilder.setLimit(cachedAnnoConfig.getLocalLimit());</span><br><span class="line">        &#125;</span><br><span class="line">        if (cachedAnnoConfig.getCacheType() == CacheType.BOTH &amp;&amp; cachedAnnoConfig.getLocalExpire() &gt; 0) &#123;</span><br><span class="line">        // 设置本地缓存失效时间，前提是多级缓存，一般和远程缓存保持一致不设置</span><br><span class="line">            cacheBuilder.expireAfterWrite(cachedAnnoConfig.getLocalExpire(), cachedAnnoConfig.getTimeUnit());</span><br><span class="line">        &#125; else if (cachedAnnoConfig.getExpire() &gt; 0) &#123;</span><br><span class="line">        // 设置失效时间</span><br><span class="line">            cacheBuilder.expireAfterWrite(cachedAnnoConfig.getExpire(), cachedAnnoConfig.getTimeUnit());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!CacheConsts.isUndefined(cachedAnnoConfig.getKeyConvertor())) &#123;</span><br><span class="line">            cacheBuilder.setKeyConvertor(configProvider.parseKeyConvertor(cachedAnnoConfig.getKeyConvertor()));</span><br><span class="line">        &#125;</span><br><span class="line">        // 设置是否缓存 null 值</span><br><span class="line">        cacheBuilder.setCacheNullValue(cachedAnnoConfig.isCacheNullValue());</span><br><span class="line">        // 构建一个缓存实例</span><br><span class="line">        return cacheBuilder.buildCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected CacheInvokeContext newCacheInvokeContext() &#123;</span><br><span class="line">        return new CacheInvokeContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createCacheInvokeContext</code>方法返回一个本次调用的上下文CacheInvokeContext，为这个上下文设置缓存函数，用于获取或者构建缓存实例，这个函数在CacheHandler中会被调用，我们来看看这个函数的处理逻辑：有两个入参，分别为本次调用的上下文和缓存注解的配置信息</p><p>首先从缓存注解的配置信息中获取缓存实例，如果不为null则直接返回，否则调用<code>createCacheByCachedConfig</code>方法，根据配置通过CacheBuilder构造器创建一个缓存实例对象</p><p><code>createCacheByCachedConfig</code>方法：</p><ol><li>如果没有定义缓存实例名称（@Cached注解中的name配置），则生成<code>类名+方法名+(参数类型)</code>作为缓存实例名称</li><li>然后调用<code>__createOrGetCache</code>方法</li></ol><p><code>__createOrGetCache</code>方法：</p><ol><li>通过缓存实例管理器SimpleCacheManager根据缓存区域area和缓存实例名称cacheName获取缓存实例对象，如果不为null则直接返回，判断缓存实例对象是否为null为进行两次确认，第二次会给当前CacheContext加锁进行判断，避免线程不安全</li><li>缓存实例对象还是为null的话，先判断缓存区域area是否添加至缓存实例名称中，是的话”area_cacheName”为缓存实例名称，然后调用<code>buildCache</code>方法创建一个缓存实例对象</li></ol><p><code>buildCache</code>方法：根据缓存实例类型构建不同的缓存实例对象，处理逻辑如下：</p><ol><li>CacheType为<code>LOCAL</code>则调用<code>buildLocal</code>方法：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.1. 从GlobalCacheConfig全局配置的localCacheBuilders（保存本地缓存CacheBuilder构造器的集合）中的获取本地缓存该缓存区域的构造器，在之前讲到的&#x27;JetCacheAutoConfiguration自动配置&#x27;中有说到过，会将初始化好的构造器从AutoConfigureBeans中添加至GlobalCacheConfig中</span><br><span class="line"></span><br><span class="line">1.2. 克隆一个 CacheBuilder 构造器，因为不同缓存实例有不同的配置</span><br><span class="line"></span><br><span class="line">1.3. 将缓存注解的配置信息设置到构造器中，有以下配置：</span><br><span class="line"></span><br><span class="line">   - 如果配置了localLimit，则设置本地缓存最大数量limit的值</span><br><span class="line"></span><br><span class="line">   - 如果CacheType为BOTH并且配置了localExpire（大于0），则设置有效时间expireAfterWrite的值为localExpire，否则如果配置的expire大于0，则设置其值为expire</span><br><span class="line"></span><br><span class="line">   - 如果配置了keyConvertor，则根据该值生成一个转换函数，没有配置的话在初始化构造器的时候根据全局配置可能已经生成了一个转换函数（我一般在全局配置中设置）</span><br><span class="line"></span><br><span class="line">   - 设置是否缓存null值</span><br><span class="line"></span><br><span class="line">1.4. 通过调用构造器的buildCache()方法构建一个缓存实例对象，该方法在之前讲到的&#x27;CacheBuilder构造器&#x27;中有分析过</span><br></pre></td></tr></table></figure><ol><li>CacheType为<code>REMOTE</code>则调用<code>buildRemote</code>方法：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.1. 从GlobalCacheConfig全局配置的remoteCacheBuilders（保存远程缓存CacheBuilder构造器的集合）中的获取远程缓存该缓存区域的构造器</span><br><span class="line"></span><br><span class="line">1.2. 克隆一个 CacheBuilder 构造器，因为不同缓存实例有不同的配置</span><br><span class="line"></span><br><span class="line">1.3. 将缓存注解的配置信息设置到构造器中，有以下配置：</span><br><span class="line"></span><br><span class="line">   - 如果配置了expire，则设置远程缓存有效时间expireAfterWrite的值</span><br><span class="line"></span><br><span class="line">   - 如果全局设置远程缓存的缓存key的前缀keyPrefix，则设置缓存key的前缀为&quot;keyPrefix+cacheName&quot;，否则我为&quot;cacheName&quot;</span><br><span class="line"></span><br><span class="line">   - 如果配置了keyConvertor，则根据该值生成一个转换函数，没有配置的话在初始化构造器的时候根据全局配置可能已经生成了一个转换函数（我一般在全局配置中设置）</span><br><span class="line"></span><br><span class="line">   - 如果设置了serialPolicy，则根据该值生成编码和解码函数，没有配置的话在初始化构造器的时候根据全局配置可能已经生成了编码函数和解码函数（我一般在全局配置中设置）</span><br><span class="line"></span><br><span class="line">   - 设置是否缓存null值</span><br><span class="line"></span><br><span class="line">1.4. 通过调用构造器的buildCache()方法构建一个缓存实例对象</span><br></pre></td></tr></table></figure><ol><li>CacheType为<code>BOTH</code>则调用<code>buildLocal</code>方法构建本地缓存实例，调用<code>buildRemote</code>方法构建远程缓存实例：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.1. 创建一个MultiLevelCacheBuilder构造器</span><br><span class="line"></span><br><span class="line">1.2. 设置有效时间为远程缓存的有效时间、添加local和remote缓存实例、设置是否单独配置了本地缓存的失效时间（是否有配置localExpire）、设置是否缓存null值</span><br><span class="line"></span><br><span class="line">1.3. 通过调用构造器的buildCache()方法构建一个缓存实例对象</span><br></pre></td></tr></table></figure><ol><li>设置刷新策略RefreshPolicy，没有的话为null</li><li>将缓存实例对象封装成CacheHandlerRefreshCache对象，用于后续的添加刷新任务，在之前的’AbstractCache抽象类’有讲到</li><li>设置是否开启缓存未命中时加载方法的保护模式，全局默认为false</li><li>将缓存实例添加至监控管理器中</li></ol><h5><span id="jetcacheinterceptor">JetCacheInterceptor</span></h5><p>被拦截后的处理在<code>com.alicp.jetcache.anno.aop.JetCacheInterceptor</code>中，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">public class JetCacheInterceptor implements MethodInterceptor, ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(JetCacheInterceptor.class);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 缓存实例注解信息</span><br><span class="line">     */</span><br><span class="line">    @Autowired</span><br><span class="line">    private ConfigMap cacheConfigMap;</span><br><span class="line">    /**</span><br><span class="line">     * Spring 上下文</span><br><span class="line">     */</span><br><span class="line">    private ApplicationContext applicationContext;</span><br><span class="line">    /**</span><br><span class="line">     * 缓存的全局配置</span><br><span class="line">     */</span><br><span class="line">    private GlobalCacheConfig globalCacheConfig;</span><br><span class="line">    /**</span><br><span class="line">     * JetCache 缓存的管理器（包含很多信息）</span><br><span class="line">     */</span><br><span class="line">    ConfigProvider configProvider;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        this.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(final MethodInvocation invocation) throws Throwable &#123;</span><br><span class="line">        if (configProvider == null) &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 这里会获取到 SpringConfigProvider 可查看 &#123;@link com.alicp.jetcache.autoconfigure.JetCacheAutoConfiguration&#125;</span><br><span class="line">             */</span><br><span class="line">            configProvider = applicationContext.getBean(ConfigProvider.class);</span><br><span class="line">        &#125;</span><br><span class="line">        if (configProvider != null &amp;&amp; globalCacheConfig == null) &#123;</span><br><span class="line">            globalCacheConfig = configProvider.getGlobalCacheConfig();</span><br><span class="line">        &#125;</span><br><span class="line">        if (globalCacheConfig == null || !globalCacheConfig.isEnableMethodCache()) &#123;</span><br><span class="line">            return invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取被拦截的方法</span><br><span class="line">        Method method = invocation.getMethod();</span><br><span class="line">        // 获取被拦截的对象</span><br><span class="line">        Object obj = invocation.getThis();</span><br><span class="line">        CacheInvokeConfig cac = null;</span><br><span class="line">        if (obj != null) &#123;</span><br><span class="line">        // 获取改方法的Key(方法所在类名+方法名+(参数类型)+方法返回类型+_被拦截的类名)</span><br><span class="line">            String key = CachePointcut.getKey(method, obj.getClass());</span><br><span class="line">            // 获取该方法的缓存注解信息，在 Pointcut 中已经对注解进行解析并放入 ConfigMap 中</span><br><span class="line">            cac  = cacheConfigMap.getByMethodInfo(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(logger.isTraceEnabled())&#123;</span><br><span class="line">            logger.trace(&quot;JetCacheInterceptor invoke. foundJetCacheConfig=&#123;&#125;, method=&#123;&#125;.&#123;&#125;(), targetClass=&#123;&#125;&quot;,</span><br><span class="line">                    cac != null,</span><br><span class="line">                    method.getDeclaringClass().getName(),</span><br><span class="line">                    method.getName(),</span><br><span class="line">                    invocation.getThis() == null ? null : invocation.getThis().getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 无缓存相关注解配置信息表明无须缓存，直接执行该方法</span><br><span class="line">        if (cac == null || cac == CacheInvokeConfig.getNoCacheInvokeConfigInstance()) &#123;</span><br><span class="line">            return invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 为本次调用创建一个上下文对象，包含对应的缓存实例</span><br><span class="line">        CacheInvokeContext context = configProvider.getCacheContext().createCacheInvokeContext(cacheConfigMap);</span><br><span class="line">        context.setTargetObject(invocation.getThis());</span><br><span class="line">        context.setInvoker(invocation::proceed);</span><br><span class="line">        context.setMethod(method);</span><br><span class="line">        context.setArgs(invocation.getArguments());</span><br><span class="line">        context.setCacheInvokeConfig(cac);</span><br><span class="line">        context.setHiddenPackages(globalCacheConfig.getHiddenPackages());</span><br><span class="line">        // 继续往下执行</span><br><span class="line">        return CacheHandler.invoke(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCacheConfigMap(ConfigMap cacheConfigMap) &#123;</span><br><span class="line">        this.cacheConfigMap = cacheConfigMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>ConfigMap</code>中获取被拦截的方法对象的缓存配置信息，如果没有则直接执行该方法，否则继续往下执行</p><p>根据<code>CacheContext</code>对象（SpringCacheContext，因为在之前讲到的’JetCacheAutoConfiguration自动配置’中有说到注入的是SpringConfigProvider对象，在其初始化方法中调用newContext()方法生成SpringCacheContext）调用其<code>createCacheInvokeContext</code>方法为本次调用创建一个上下文<code>CacheInvokeContext</code>，并设置获取缓存实例函数，具体实现逻辑查看上面讲到的<code>CacheContext</code></p><p>设置本次调用上下文的targetObject为被拦截对象，invoker为被拦截对象的调用器，method为被拦截方法，args为方法入参，cacheInvokeConfig为缓存配置信息，hiddenPackages为缓存实例名称需要截断的包名</p><p>通过CacheHandler的invoke方法继续往下执行</p><h5><span id="cachehandler">CacheHandler</span></h5><p><code>com.alicp.jetcache.anno.method.CacheHandler</code>用于JetCache处理被拦截的方法，部分代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">public class CacheHandler implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">public static Object invoke(CacheInvokeContext context) throws Throwable &#123;</span><br><span class="line">if (context.getCacheInvokeConfig().isEnableCacheContext()) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">CacheContextSupport._enable();</span><br><span class="line">return doInvoke(context);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">CacheContextSupport._disable();</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return doInvoke(context);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Object doInvoke(CacheInvokeContext context) throws Throwable &#123;</span><br><span class="line">// 获取缓存实例配置</span><br><span class="line">CacheInvokeConfig cic = context.getCacheInvokeConfig();</span><br><span class="line">// 获取注解配置信息</span><br><span class="line">CachedAnnoConfig cachedConfig = cic.getCachedAnnoConfig();</span><br><span class="line">if (cachedConfig != null &amp;&amp; (cachedConfig.isEnabled() || CacheContextSupport._isEnabled())) &#123;</span><br><span class="line">// 经过缓存中获取结果</span><br><span class="line">return invokeWithCached(context);</span><br><span class="line">&#125; else if (cic.getInvalidateAnnoConfigs() != null || cic.getUpdateAnnoConfig() != null) &#123;</span><br><span class="line">// 根据结果删除或者更新缓存</span><br><span class="line">return invokeWithInvalidateOrUpdate(context);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 执行该方法</span><br><span class="line">return invokeOrigin(context);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Object invokeWithCached(CacheInvokeContext context) throws Throwable &#123;</span><br><span class="line">// 获取本地调用的上下文</span><br><span class="line">CacheInvokeConfig cic = context.getCacheInvokeConfig();</span><br><span class="line">// 获取注解配置信息</span><br><span class="line">CachedAnnoConfig cac = cic.getCachedAnnoConfig();</span><br><span class="line">// 获取缓存实例对象（不存在则会创建并设置到 cac 中）</span><br><span class="line">// 可在 JetCacheInterceptor 创建本次调用的上下文时，调用 createCacheInvokeContext(cacheConfigMap) 方法中查看详情</span><br><span class="line">Cache cache = context.getCacheFunction().apply(context, cac);</span><br><span class="line">if (cache == null) &#123;</span><br><span class="line">logger.error(&quot;no cache with name: &quot; + context.getMethod());</span><br><span class="line">// 无缓存实例对象，执行原有方法</span><br><span class="line">return invokeOrigin(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生成缓存 Key 对象（注解中没有配置的话就是入参，没有入参则为 &quot;_$JETCACHE_NULL_KEY$_&quot; ）</span><br><span class="line">Object key = ExpressionUtil.evalKey(context, cic.getCachedAnnoConfig());</span><br><span class="line">if (key == null) &#123;</span><br><span class="line"> // 生成缓存 Key 失败则执行原方法，并记录 CacheLoadEvent 事件</span><br><span class="line">return loadAndCount(context, cache, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 根据配置的 condition 来决定是否走缓存</span><br><span class="line"> * 缓存注解中没有配置 condition 表示所有请求都走缓存</span><br><span class="line"> * 配置了 condition 表示满足条件的才走缓存</span><br><span class="line"> */</span><br><span class="line">if (!ExpressionUtil.evalCondition(context, cic.getCachedAnnoConfig())) &#123;</span><br><span class="line">// 不满足 condition 则直接执行原方法，并记录 CacheLoadEvent 事件</span><br><span class="line">return loadAndCount(context, cache, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">// 创建一个执行原有方法的函数</span><br><span class="line">CacheLoader loader = new CacheLoader() &#123;</span><br><span class="line">@Override</span><br><span class="line">public Object load(Object k) throws Throwable &#123;</span><br><span class="line">Object result = invokeOrigin(context);</span><br><span class="line">context.setResult(result);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean vetoCacheUpdate() &#123;</span><br><span class="line">// 本次执行原方法后是否需要更新缓存</span><br><span class="line">return !ExpressionUtil.evalPostCondition(context, cic.getCachedAnnoConfig());</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 获取结果</span><br><span class="line">Object result = cache.computeIfAbsent(key, loader);</span><br><span class="line">return result;</span><br><span class="line">&#125; catch (CacheInvokeException e) &#123;</span><br><span class="line">throw e.getCause();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Object loadAndCount(CacheInvokeContext context, Cache cache, Object key) throws Throwable &#123;</span><br><span class="line">long t = System.currentTimeMillis();</span><br><span class="line">Object v = null;</span><br><span class="line">boolean success = false;</span><br><span class="line">try &#123;</span><br><span class="line">// 调用原有方法</span><br><span class="line">v = invokeOrigin(context);</span><br><span class="line">success = true;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">t = System.currentTimeMillis() - t;</span><br><span class="line">// 发送 CacheLoadEvent 事件</span><br><span class="line">CacheLoadEvent event = new CacheLoadEvent(cache, t, key, v, success);</span><br><span class="line">while (cache instanceof ProxyCache) &#123;</span><br><span class="line">cache = ((ProxyCache) cache).getTargetCache();</span><br><span class="line">&#125;</span><br><span class="line">if (cache instanceof AbstractCache) &#123;</span><br><span class="line">((AbstractCache) cache).notify(event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Object invokeOrigin(CacheInvokeContext context) throws Throwable &#123;</span><br><span class="line">// 执行被拦截的方法</span><br><span class="line">return context.getInvoker().invoke();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接查看<code>invokeWithCached</code>方法：</p><ol><li>获取缓存注解信息</li><li>根据本地调用的上下文CacheInvokeContext获取缓存实例对象（调用其cacheFunction函数），在CacheContext中有讲到</li><li>如果缓存实例不存在则直接调用invokeOrigin方法，执行被拦截的对象的调用器</li><li>根据本次调用的上下文CacheInvokeContext生成缓存key，根据配置的缓存key的SpEL表达式生成，如果没有配置则返回入参对象，如果没有对象则返回”_ $JETCACHE_NULL_KEY$_”</li><li>根据配置condition表达式判断是否需要走缓存</li><li>创建一个<code>CacheLoader</code>对象，用于执行被拦截的对象的调用器，也就是加载原有方法</li><li>调用缓存实例的<code>computeIfAbsent(key, loader)</code>方法获取结果，这个方法的处理过程可查看’缓存API’这一小节</li></ol><p>至此结束！！！😄😄😄</p><p>文章转自：<a href="https://www.cnblogs.com/lifullmoon/p/13854158.html">https://www.cnblogs.com/lifullmoon/p/13854158.html</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术笔记 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各种开源协议介绍</title>
      <link href="/2021/09/29/%E5%90%84%E7%A7%8D%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/"/>
      <url>/2021/09/29/%E5%90%84%E7%A7%8D%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>世界上的开源许可证（Open Source License）大概有上百种，今天我们来介绍下几种我们常见的开源协议。大致有GPL、BSD、MIT、Mozilla、Apache和LGPL等。</p><p><img src="/2021/09/29/%E5%90%84%E7%A7%8D%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/da68b98e404578126b87c5afd9ba9bc3.png" alt="img"></p><h3><span id="apache-license">Apache License</span></h3><p>Apache License（Apache许可证），是Apache软件基金会发布的一个自由软件许可证。</p><p>Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和最终原作者的著作权，同样允许源代码修改和再发布。但是也需要遵循以下条件：</p><ul><li>需要给代码的用户一份Apache Licence。</li><li>如果修改了代码，需要再被修改的文件中说明。</li><li>在衍生的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。</li><li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以再Notice中增加自己的许可，但是不可以表现为对Apache Licence构成更改。</li><li>Apache Licence也是对商业应用友好的许可。使用者也可以再需要的时候修改代码来满足并作为开源或商业产品发布/销售。</li></ul><p>使用这个协议的好处是:</p><ul><li>永久权利 一旦被授权，永久拥有。</li><li>全球范围的权利 在一个国家获得授权，适用于所有国家。假如你在美国，许可是从印度授权的，也没有问题。</li><li>授权免费 无版税， 前期、后期均无任何费用。</li><li>授权无排他性 任何人都可以获得授权</li><li>授权不可撤消 一旦获得授权，没有任何人可以取消。比如，你基于该产品代码开发了衍生产品，你不用担心会在某一天被禁止使用该代码</li></ul><h3><span id="bsd">BSD</span></h3><p>BSD是”Berkeley Software Distribution”的缩写，意思是”伯克利软件发行版”。</p><p>BSD开源协议：是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。 当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：</p><ul><li>1． 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</li><li>2． 如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li><li>3． 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</li></ul><p>BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p><h3><span id="gpl">GPL</span></h3><p>GPL （GNU General Public License） ：GNU通用公共许可协议。</p><p><strong>Linux 采用了 GPL</strong>。</p><p>GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。</p><h3><span id="lgpl">LGPL</span></h3><p>LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。</p><p>但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p><p>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。</p><h3><span id="mit">MIT</span></h3><p>MIT是和BSD一样宽范的许可协议,源自麻省理工学院（Massachusetts Institute of Technology, MIT），又称X11协议。作者只想保留版权,而无任何其他了限制。MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。</p><p>MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。</p><h3><span id="mpl-mozilla-public-license-11">MPL (Mozilla Public License 1.1)</span></h3><p>MPL协议允许免费重发布、免费修改，但要求修改后的代码版权归软件的发起者 。这种授权维护了商业软件的利益，它要求基于这种软件的修改无偿贡献版权给该软件。这样，围绕该软件的所有代码的版权都集中在发起开发人的手中。但MPL是允许修改，无偿使用得。MPL软件对链接没有要求。</p><h3><span id="epl-eclipse-public-license-10">EPL (Eclipse Public License 1.0)</span></h3><p>EPL允许Recipients任意使用、复制、分发、传播、展示、修改以及改后闭源的二次商业发布。</p><p>使用EPL协议，需要遵守以下规则：</p><ul><li>当一个Contributors将源码的整体或部分再次开源发布的时候,必须继续遵循EPL开源协议来发布,而不能改用其他协议发布.除非你得到了原”源码”Owner 的授权；</li><li>EPL协议下,你可以将源码不做任何修改来商业发布.但如果你要发布修改后的源码,或者当你再发布的是Object Code的时候,你必须声明它的Source Code是可以获取的,而且要告知获取方法；</li><li>当你需要将EPL下的源码作为一部分跟其他私有的源码混和着成为一个Project发布的时候,你可以将整个Project/Product以私人的协议发布,但要声明哪一部分代码是EPL下的,而且声明那部分代码继续遵循EPL；</li><li>4.独立的模块(Separate Module),不需要开源。</li></ul><h3><span id="creative-commons-知识共享协议">Creative Commons 知识共享协议</span></h3><p>Creative Commons (CC) 许可协议并不能说是真正的开源协议，它们大多是被使用于设计类的工程上。 CC 协议种类繁多，每一种都授权特定的权利。 一个 CC 许可协议具有四个基本部分，这几个部分可以单独起作用，也可以组合起来。下面是这几部分的简介：</p><ul><li>1、署名 作品上必须附有作品的归属。如此之后，作品可以被修改，分发，复制和其它用途。</li><li>2、相同方式共享 作品可以被修改、分发或其它操作，但所有的衍生品都要置于CC许可协议下。</li><li>3、非商业用途 作品可以被修改、分发等等，但不能用于商业目的。但语言上对什么是”商业”的说明十分含糊不清 (没有提供精确的定义)，所以你可以在你的工程里对其进行说明。例如，有些人简单的解释”非商业”为不能出售这个作品。而另外一些人认为你甚至不能在有广告的网站上使用它们。 还有些人认为”商业”仅仅指你用它获取利益。</li><li>4、禁止衍生作品</li></ul><p>CC 许可协议的这些条款可以自由组合使用。大多数的比较严格的CC协议会声明 “署名权，非商业用途，禁止衍生”条款，这意味着你可以自由的分享这个作品，但你不能改变它和对其收费，而且必须声明作品的归属。这个许可协议非常的有用，它可以让你的作品传播出去，但又可以对作品的使用保留部分或完全的控制。最少限制的CC协议类型当属 “署名”协议，这意味着只要人们能维护你的名誉，他们对你的作品怎么使用都行。</p><p>CC 许可协议更多的是在设计类工程中使用，而不是开发类，但没有人或妨碍你将之使用与后者。只是你必须要清楚各部分条款能覆盖到的和不能覆盖到的权利。</p><hr><h3><span id="图解分析">图解分析</span></h3><p><img src="/2021/09/29/%E5%90%84%E7%A7%8D%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/bg2011050101.png" alt="img"></p><p><img src="/2021/09/29/%E5%90%84%E7%A7%8D%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/61590003177751b9d5bd.jpeg" alt="img"></p><p><img src="/2021/09/29/%E5%90%84%E7%A7%8D%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/f1989e42b25bb73fead5cb1d09036e6f.png" alt="img"></p><p>文章拷贝来源：<a href="https://www.runoob.com/w3cnote/open-source-license.html">https://www.runoob.com/w3cnote/open-source-license.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术笔记 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP和Java中的SHA256</title>
      <link href="/2021/08/16/PHP%E5%92%8CJava%E4%B8%AD%E7%9A%84SHA256/"/>
      <url>/2021/08/16/PHP%E5%92%8CJava%E4%B8%AD%E7%9A%84SHA256/</url>
      
        <content type="html"><![CDATA[<p>我正在将一些<a href="https://codeday.me/tag/Java">Java</a>代码移植到<a href="https://codeday.me/tag/PHP">PHP</a>代码中.在Java中,我有一个哈希SHA256代码,如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static String hashSHA256(String input)</span><br><span class="line">        throws NoSuchAlgorithmException &#123;</span><br><span class="line">    MessageDigest mDigest = MessageDigest.getInstance(&quot;SHA-256&quot;);</span><br><span class="line">byte[] shaByteArr = mDigest.digest(input.getBytes(Charset.forName(&quot;UTF-8&quot;)));</span><br><span class="line">    StringBuilder hexStrBuilder = new StringBuilder();</span><br><span class="line">    for (int i = 0; i &lt; shaByteArr.length; i++) &#123;</span><br><span class="line">        hexStrBuilder.append(Integer.toHexString(0xFF &amp; shaByteArr[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return hexStrBuilder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在PHP中,我哈希如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$hash = hash(&quot;sha256&quot;, utf8_encode($input));</span><br></pre></td></tr></table></figure><p>我用input =“test”运行示例代码.但是,我得到了2个不同的哈希字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java: 9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2bb822cd15d6c15b0f0a8</span><br><span class="line">PHP: 9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08</span><br></pre></td></tr></table></figure><p>有人可以向我解释为什么以及如何让它们相互匹配？请注意,我无法修改Java实现代码,只能修改PHP.</p><p>万分感激！</p><p>解决方法:<br>PHP版本是正确的;测试的SHA-256校验和是9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08.<br>Java版本返回相同的校验和,其中两个0被剥离.这是因为您将字节转换为十六进制的方式.而不是使用0xFF&amp; ing使用它们,使用String.format(),如<a href="https://stackoverflow.com/a/2817883/2765666">this answer</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexStrBuilder.append(String.format(&quot;%02x&quot;, shaByteArr[i]));</span><br></pre></td></tr></table></figure><p>修改方法：</p><pre><code>public static String hashSHA256(String input)        throws NoSuchAlgorithmException &#123;    MessageDigest mDigest = MessageDigest.getInstance(&quot;SHA-256&quot;);byte[] shaByteArr = mDigest.digest(input.getBytes(Charset.forName(&quot;UTF-8&quot;)));    StringBuilder hexStrBuilder = new StringBuilder();    for (int i = 0; i &lt; shaByteArr.length; i++) &#123;        //hexStrBuilder.append(Integer.toHexString(0xFF &amp; shaByteArr[i]));        hexStrBuilder.append(String.format(&quot;%02x&quot;, shaByteArr[i]));    &#125;    return hexStrBuilder.toString();&#125;我意识到你说你不能修改Java代码,但它是不正确的！来源： https://codeday.me/bug/20190725/1530972.html</code></pre>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术笔记 </tag>
            
            <tag> java </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas classloader命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasclassloader%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasclassloader%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8demo">启动demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#classloader%E5%91%BD%E4%BB%A4">classloader命令</a><ul><li><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">参数说明</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83">使用参考</a></li><li><a href="#%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89classloader">列出所有ClassLoader</a></li><li><a href="#%E5%88%97%E5%87%BAclassloader%E9%87%8C%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%89%80%E6%9C%89%E7%B1%BB">列出ClassLoader里加载的所有类</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E7%B1%BB%E7%9A%84classloader%E5%B1%82%E6%AC%A1">查看类的classloader层次</a></li><li><a href="#%E6%9F%A5%E7%9C%8Bclassloader%E6%A0%91">查看ClassLoader树</a></li><li><a href="#%E6%9F%A5%E7%9C%8Burlclassloader%E5%AE%9E%E9%99%85%E7%9A%84urls">查看URLClassLoader实际的urls</a></li><li><a href="#%E5%8A%A0%E8%BD%BD%E6%8C%87%E5%AE%9Aclassloader%E9%87%8C%E7%9A%84%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6">加载指定ClassLoader里的资源文件</a></li><li><a href="#%E5%B0%9D%E8%AF%95%E5%8A%A0%E8%BD%BD%E6%8C%87%E5%AE%9A%E7%9A%84%E7%B1%BB">尝试加载指定的类</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasclassloader%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个普通的Spring Boot应用为例，演示classloader命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动demo">启动demo</span></h2><p>下载<code>demo-arthas-spring-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar</span><br></pre></td></tr></table></figure><p><code>demo-arthas-spring-boot</code>是一个很简单的spring boot应用，源代码：<a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-arthas-spring-boot">查看</a></p><p>启动之后，可以访问61000端口： 点击查看</p><p><img src="https://img.alicdn.com/imgextra/i2/O1CN010Qbzcz1ctPSWSZI6L_!!6000000003658-2-tps-333-182.png" alt="Demo Web"></p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasclassloader%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="classloader命令">classloader命令</span></h2><blockquote><p>查看classloader的继承树，urls，类加载信息</p></blockquote><p><code>classloader</code> 命令将 JVM 中所有的classloader的信息统计出来，并可以展示继承树，urls等。</p><p>可以让指定的classloader去getResources，打印出所有查找到的resources的url。对于<code>ResourceNotFoundException</code>比较有用。</p><h4><span id="参数说明">参数说明</span></h4><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td>[l]</td><td>按类加载实例进行统计</td></tr><tr><td>[t]</td><td>打印所有ClassLoader的继承树</td></tr><tr><td>[a]</td><td>列出所有ClassLoader加载的类，请谨慎使用</td></tr><tr><td><code>[c:]</code></td><td>ClassLoader的hashcode</td></tr><tr><td><code>[classLoaderClass:]</code></td><td>指定执行表达式的 ClassLoader 的 class name</td></tr><tr><td><code>[c: r:]</code></td><td>用ClassLoader去查找resource</td></tr><tr><td><code>[c: load:]</code></td><td>用ClassLoader去加载指定的类</td></tr></tbody></table><h4><span id="使用参考">使用参考</span></h4><p>先访问一个jsp网页，触发jsp的加载： hello</p><h4><span id="列出所有classloader">列出所有ClassLoader</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader -l</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> classloader -l</span></span><br><span class="line"> name                                                             loadedCount  hash      parent</span><br><span class="line"> BootstrapClassLoader                                             2724         null      null</span><br><span class="line"> com.taobao.arthas.agent.ArthasClassloader@411ce1ab               2009         411ce1ab  sun.misc.Launcher$ExtClassLoader@7494e528</span><br><span class="line"> com.taobao.arthas.agent.ArthasClassloader@22ae1234               1253         22ae1234  sun.misc.Launcher$ExtClassLoader@7494e528</span><br><span class="line"> org.apache.jasper.servlet.JasperLoader@65361d9a                  1            65361d9a  TomcatEmbeddedWebappClassLoader</span><br><span class="line">                                                                                           context: ROOT</span><br><span class="line">                                                                                           delegate: true</span><br><span class="line">                                                                                         ----------&gt; Parent Classloader:</span><br><span class="line">                                                                                         org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3</span><br><span class="line"></span><br><span class="line"> TomcatEmbeddedWebappClassLoader                                  0            8546cd5   org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3</span><br><span class="line">   context: ROOT</span><br><span class="line">   delegate: true</span><br><span class="line"><span class="meta"> ----------&gt;</span><span class="bash"> Parent Classloader:</span></span><br><span class="line"> org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3</span><br><span class="line"></span><br><span class="line"> org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3  5416         1be6f5c3  sun.misc.Launcher$AppClassLoader@3d4eac69</span><br><span class="line"> sun.misc.Launcher$AppClassLoader@3d4eac69                        45           3d4eac69  sun.misc.Launcher$ExtClassLoader@7494e528</span><br><span class="line"> sun.misc.Launcher$ExtClassLoader@7494e528                        4            7494e528  null</span><br></pre></td></tr></table></figure><ul><li>TomcatEmbeddedWebappClassLoader 加载的class数量是0，所以在spring boot embedded tomcat里，它只是一个空壳，所有的类加载都是<code>LaunchedURLClassLoader</code>完成的</li></ul><p>注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。</p><p>如果你使用<code>-c</code>，你需要手动输入hashcode：<code>-c &lt;hashcode&gt;</code></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> classloader -c 65361d9a</span></span><br></pre></td></tr></table></figure><p>对于只有唯一实例的ClassLoader可以通过<code>--classLoaderClass</code>指定class name，使用起来更加方便：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> classloader --classLoaderClass org.apache.jasper.servlet.JasperLoader</span></span><br></pre></td></tr></table></figure><p><code>--classLoaderClass</code> 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而<code>-c &lt;hashcode&gt;</code>是动态变化的。</p><h4><span id="列出classloader里加载的所有类">列出ClassLoader里加载的所有类</span></h4><p>列出上面的<code>org.apache.jasper.servlet.JasperLoader</code>加载的类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader -a --classLoaderClass org.apache.jasper.servlet.JasperLoader</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> classloader -a --classLoaderClass org.apache.jasper.servlet.JasperLoader</span></span><br><span class="line"> hash:1698045338, org.apache.jasper.servlet.JasperLoader@65361d9a</span><br><span class="line"> org.apache.jsp.jsp.hello_jsp</span><br></pre></td></tr></table></figure><h4><span id="查看类的classloader层次">查看类的classloader层次</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d org.apache.jsp.jsp.hello_jsp</span><br></pre></td></tr></table></figure><h4><span id="查看classloader树">查看ClassLoader树</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader -t</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ classloader -t</span><br><span class="line">+-BootstrapClassLoader</span><br><span class="line">+-sun.misc.Launcher$ExtClassLoader@28cbbddd</span><br><span class="line">  +-com.taobao.arthas.agent.ArthasClassloader@8c25e55</span><br><span class="line">  +-sun.misc.Launcher$AppClassLoader@55f96302</span><br><span class="line">    +-org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3</span><br><span class="line">      +-TomcatEmbeddedWebappClassLoader</span><br><span class="line">          context: ROOT</span><br><span class="line">          delegate: true</span><br><span class="line">        ----------&gt; Parent Classloader:</span><br><span class="line">        org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3</span><br><span class="line"></span><br><span class="line">        +-org.apache.jasper.servlet.JasperLoader@21ae0fe2</span><br></pre></td></tr></table></figure><h4><span id="查看urlclassloader实际的urls">查看URLClassLoader实际的urls</span></h4><p>比如上面查看到的spring LaunchedURLClassLoader的 hashcode是<code>1be6f5c3</code>，可以通过<code>-c</code>参数来指定classloader，或者直接使用<code>--classLoaderClass</code>，从而查看URLClassLoader实际的urls：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader</span><br><span class="line">jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/classes!/</span><br><span class="line">jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/lib/spring-boot-starter-aop-1.5</span><br><span class="line">.13.RELEASE.jar!/</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4><span id="加载指定classloader里的资源文件">加载指定ClassLoader里的资源文件</span></h4><p>查找指定的资源文件： <code>classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml</span><br><span class="line"> jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/classes!/logback-spring.xml</span><br></pre></td></tr></table></figure><p>也可以尝试查找类的class文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r java/lang/String.class</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r java/lang/String.class</span></span><br><span class="line"> jar:file:/Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/Home/jre/lib/rt.jar!/java/lang/String.class</span><br></pre></td></tr></table></figure><h4><span id="尝试加载指定的类">尝试加载指定的类</span></h4><p>比如用上面的spring LaunchedURLClassLoader 尝试加载 <code>ch.qos.logback.classic.spi.StackTraceElementProxy</code> ：</p><p>首先使用<code>sc ch.qos.logback.classic.spi.StackTraceElementProxy</code>查看，可发现未加载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc ch.qos.logback.classic.spi.StackTraceElementProxy</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Affect(row-cnt:0) cost in 18 ms.</span><br></pre></td></tr></table></figure><p>因而使用spring LaunchedURLClassLoader 尝试加载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader --load ch.qos.logback.classic.spi.StackTraceElementProxy</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader --load ch.qos.logback.classic.spi.StackTraceElementProxy</span></span><br><span class="line">load class success.</span><br><span class="line"> class-info        ch.qos.logback.classic.spi.StackTraceElementProxy</span><br><span class="line"> code-source       file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/lib/logback-classic-1.</span><br><span class="line">                   1.11.jar!/</span><br><span class="line"> name              ch.qos.logback.classic.spi.StackTraceElementProxy</span><br><span class="line"> isInterface       false</span><br><span class="line"> isAnnotation      false</span><br><span class="line"> isEnum            false</span><br><span class="line"> isAnonymousClass  false</span><br><span class="line"> isArray           false</span><br><span class="line"> isLocalClass      false</span><br><span class="line"> isMemberClass     false</span><br><span class="line"> isPrimitive       false</span><br><span class="line"> isSynthetic       false</span><br><span class="line"> simple-name       StackTraceElementProxy</span><br><span class="line"> modifier          public</span><br><span class="line"> annotation</span><br><span class="line"> interfaces        java.io.Serializable</span><br><span class="line"> super-class       +-java.lang.Object</span><br><span class="line"> class-loader      +-org.springframework.boot.loader.LaunchedURLClassLoader@5674cd4d</span><br><span class="line">                     +-sun.misc.Launcher$AppClassLoader@70dea4e</span><br><span class="line">                       +-sun.misc.Launcher$ExtClassLoader@56a96482</span><br><span class="line"> classLoaderHash   5674cd4d</span><br></pre></td></tr></table></figure><p>再次使用<code>sc ch.qos.logback.classic.spi.StackTraceElementProxy</code>查看，发现已经加载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc ch.qos.logback.classic.spi.StackTraceElementProxy</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch.qos.logback.classic.spi.StackTraceElementProxy</span><br><span class="line">Affect(row-cnt:1) cost in 19 ms.</span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>在“classloader”中，我们演示了了Arthas的classloader命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas dump命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasdump%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasdump%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8arthas-demo">启动arthas demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#dump%E5%91%BD%E4%BB%A4">dump命令</a><ul><li><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">参数说明</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83">使用参考</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasdump%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示dump命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动arthas-demo">启动arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasdump%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="dump命令">dump命令</span></h2><blockquote><p>dump 已加载类的 bytecode 到特定目录</p></blockquote><h4><span id="参数说明">参数说明</span></h4><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr><tr><td><code>[c:]</code></td><td>类所属 ClassLoader 的 hashcode</td></tr><tr><td><code>[d:]</code></td><td>设置类文件的目标目录</td></tr><tr><td><code>[classLoaderClass:]</code></td><td>指定执行表达式的 ClassLoader 的 class name</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr></tbody></table><h4><span id="使用参考">使用参考</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump java.lang.String</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dump java.lang.String</span></span><br><span class="line"> HASHCODE  CLASSLOADER  LOCATION</span><br><span class="line"> null                   /Users/admin/logs/arthas/classdump/java/lang/String.class</span><br><span class="line">Affect(row-cnt:1) cost in 119 ms.</span><br><span class="line">dump demo.*</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dump demo.*</span></span><br><span class="line"> HASHCODE  CLASSLOADER                                    LOCATION</span><br><span class="line"> 3d4eac69  +-sun.misc.Launcher$AppClassLoader@3d4eac69    /Users/admin/logs/arthas/classdump/sun.misc.Launcher$AppClassLoader-3d4eac69/demo/MathGame.class</span><br><span class="line">             +-sun.misc.Launcher$ExtClassLoader@66350f69</span><br><span class="line">Affect(row-cnt:1) cost in 39 ms.</span><br><span class="line">dump -d /tmp/output java.lang.String</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dump -d /tmp/output java.lang.String</span></span><br><span class="line"> HASHCODE  CLASSLOADER  LOCATION</span><br><span class="line"> null                   /tmp/output/java/lang/String.class</span><br><span class="line">Affect(row-cnt:1) cost in 138 ms.</span><br></pre></td></tr></table></figure><ul><li>指定classLoader</li></ul><p>注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。</p><p>如果你使用<code>-c</code>，你需要手动输入hashcode：<code>-c &lt;hashcode&gt;</code></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dump -c 3d4eac69 demo.*</span></span><br></pre></td></tr></table></figure><p>对于只有唯一实例的ClassLoader可以通过<code>--classLoaderClass</code>指定class name，使用起来更加方便：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump --classLoaderClass sun.misc.Launcher<span class="variable">$AppClassLoader</span> demo.*</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dump --classLoaderClass sun.misc.Launcher<span class="variable">$AppClassLoader</span> demo.*</span></span><br><span class="line"> HASHCODE  CLASSLOADER                                    LOCATION</span><br><span class="line"> 3d4eac69  +-sun.misc.Launcher$AppClassLoader@3d4eac69    /Users/admin/logs/arthas/classdump/sun.misc.Launcher$AppClassLoader-3d4eac69/demo/MathGame.class</span><br><span class="line">             +-sun.misc.Launcher$ExtClassLoader@66350f69</span><br><span class="line">Affect(row-cnt:1) cost in 39 ms.</span><br></pre></td></tr></table></figure><ul><li>注: 这里classLoaderClass 在 java 8 是 sun.misc.Launcher$AppClassLoader，而java 11的classloader是jdk.internal.loader.ClassLoaders$AppClassLoader，katacoda目前环境是java8。</li></ul><p><code>--classLoaderClass</code> 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而<code>-c &lt;hashcode&gt;</code>是动态变化的。</p><h2><span id="更多信息">更多信息</span></h2><p>在“dump”中，我们演示了了Arthas的dump命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas jad命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasjad%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasjad%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8arthas-demo">启动arthas demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#jad%E5%91%BD%E4%BB%A4">jad命令</a><ul><li><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">参数说明</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83">使用参考</a><ul><li><a href="#%E7%BC%96%E8%AF%91javalangstring">编译<code>java.lang.String</code></a></li><li><a href="#%E5%8F%8D%E7%BC%96%E8%AF%91%E6%97%B6%E5%8F%AA%E6%98%BE%E7%A4%BA%E6%BA%90%E4%BB%A3%E7%A0%81">反编译时只显示源代码</a></li><li><a href="#%E5%8F%8D%E7%BC%96%E8%AF%91%E6%8C%87%E5%AE%9A%E7%9A%84%E5%87%BD%E6%95%B0">反编译指定的函数</a></li><li><a href="#%E5%8F%8D%E7%BC%96%E8%AF%91%E6%97%B6%E6%8C%87%E5%AE%9Aclassloader">反编译时指定ClassLoader</a></li></ul></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasjad%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示jad命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动arthas-demo">启动arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasjad%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="jad命令">jad命令</span></h2><blockquote><p>反编译指定已加载类的源码</p></blockquote><p><code>jad</code> 命令将 JVM 中实际运行的 class 的 byte code 反编译成 java 代码，便于你理解业务逻辑；</p><ul><li>在 Arthas Console 上，反编译出来的源码是带语法高亮的，阅读更方便</li><li>当然，反编译出来的 java 代码可能会存在语法错误，但不影响你进行阅读理解</li></ul><h4><span id="参数说明">参数说明</span></h4><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr><tr><td><code>[c:]</code></td><td>类所属 ClassLoader 的 hashcode</td></tr><tr><td><code>[classLoaderClass:]</code></td><td>指定执行表达式的 ClassLoader 的 class name</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr></tbody></table><h4><span id="使用参考">使用参考</span></h4><h5><span id="编译javalangstring">编译<code>java.lang.String</code></span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad java.lang.String</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ jad java.lang.String</span><br><span class="line"></span><br><span class="line">ClassLoader:</span><br><span class="line"></span><br><span class="line">Location:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Decompiled with CFR 0_132.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ObjectStreamField;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class"><span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;,</span></span><br><span class="line"><span class="class"><span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = <span class="keyword">new</span> ObjectStreamField[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER = <span class="keyword">new</span> CaseInsensitiveComparator();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] arrby, <span class="keyword">int</span> n, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        String.checkBounds(arrby, n, n2);</span><br><span class="line">        <span class="keyword">this</span>.value = StringCoding.decode(arrby, n, n2);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5><span id="反编译时只显示源代码">反编译时只显示源代码</span></h5><p>默认情况下，反编译结果里会带有<code>ClassLoader</code>信息，通过<code>--source-only</code>选项，可以只打印源代码。方便和<code>mc</code>/<code>redefine</code>命令结合使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad --source-only java.lang.String</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ jad --source-only java.lang.String</span><br><span class="line">...</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(String string, String string2) &#123;</span><br><span class="line">            int n = string.length();</span><br><span class="line">            int n2 = string2.length();</span><br><span class="line">            int n3 = Math.min(n, n2);</span><br><span class="line">            for (int i = 0; i &lt; n3; ++i) &#123;</span><br><span class="line">                char c;</span><br><span class="line">                char c2 = string.charAt(i);</span><br><span class="line">                if (c2 == (c = string2.charAt(i)) || (c2 = Character.toUpperCase(c2)) == (c = Character.toUpperCase(c)) || (c2 = Character.toLowerCase(c2)) == (c = Character.toLowerCase(c))) continue;</span><br><span class="line">                return c2 - c;</span><br><span class="line">            &#125;</span><br><span class="line">            return n - n2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private Object readResolve() &#123;</span><br><span class="line">            return String.CASE_INSENSITIVE_ORDER;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="反编译指定的函数">反编译指定的函数</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad java.lang.String toString</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ jad java.lang.String toString</span><br><span class="line"></span><br><span class="line">ClassLoader:</span><br><span class="line"></span><br><span class="line">Location:</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Affect(row-cnt:<span class="number">2</span>) cost in <span class="number">407</span> ms.</span><br></pre></td></tr></table></figure><h5><span id="反编译时指定classloader">反编译时指定ClassLoader</span></h5><blockquote><p>当有多个 <code>ClassLoader</code> 都加载了这个类时，<code>jad</code> 命令会输出对应 <code>ClassLoader</code> 实例的 <code>hashcode</code>，然后你只需要重新执行 <code>jad</code> 命令，并使用参数 <code>-c &lt;hashcode&gt;</code> 就可以反编译指定 ClassLoader 加载的那个类了；</p></blockquote><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ jad org.apache.log4j.Logger</span><br><span class="line"></span><br><span class="line">Found more than one <span class="class"><span class="keyword">class</span> <span class="title">for</span>: <span class="title">org</span>.<span class="title">apache</span>.<span class="title">log4j</span>.<span class="title">Logger</span>, <span class="title">Please</span> <span class="title">use</span> <span class="title">jad</span> -<span class="title">c</span> <span class="title">hashcode</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">log4j</span>.<span class="title">Logger</span></span></span><br><span class="line"><span class="class"><span class="title">HASHCODE</span>  <span class="title">CLASSLOADER</span></span></span><br><span class="line"><span class="class">69<span class="title">dcaba4</span>  +-<span class="title">monitor</span>&#x27;<span class="title">s</span> <span class="title">ModuleClassLoader</span></span></span><br><span class="line"><span class="class">6<span class="title">e51ad67</span>  +-<span class="title">java</span>.<span class="title">net</span>.<span class="title">URLClassLoader</span>@6<span class="title">e51ad67</span></span></span><br><span class="line"><span class="class">            +-<span class="title">sun</span>.<span class="title">misc</span>.<span class="title">Launcher</span>$<span class="title">AppClassLoader</span>@6951<span class="title">a712</span></span></span><br><span class="line"><span class="class">            +-<span class="title">sun</span>.<span class="title">misc</span>.<span class="title">Launcher</span>$<span class="title">ExtClassLoader</span>@6<span class="title">fafc4c2</span></span></span><br><span class="line"><span class="class">2<span class="title">bdd9114</span>  +-<span class="title">pandora</span>-<span class="title">qos</span>-<span class="title">service</span>&#x27;<span class="title">s</span> <span class="title">ModuleClassLoader</span></span></span><br><span class="line"><span class="class">4<span class="title">c0df5f8</span>  +-<span class="title">pandora</span>-<span class="title">framework</span>&#x27;<span class="title">s</span> <span class="title">ModuleClassLoader</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Affect</span>(<span class="title">row</span>-<span class="title">cnt</span>:0) <span class="title">cost</span> <span class="title">in</span> 38 <span class="title">ms</span>.</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ jad org.apache.log4j.Logger -c 69dcaba4</span><br><span class="line"></span><br><span class="line">ClassLoader:</span><br><span class="line">+-monitor<span class="string">&#x27;s ModuleClassLoader</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Location:</span></span><br><span class="line"><span class="string">/Users/admin/app/log4j-1.2.14.jar</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">package org.apache.log4j;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">import org.apache.log4j.spi.*;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">public class Logger extends Category</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    private static final String FQCN;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    protected Logger(String name)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        super(name);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Affect(row-cnt:1) cost in 190 ms.</span></span><br></pre></td></tr></table></figure><p>对于只有唯一实例的ClassLoader还可以通过<code>--classLoaderClass</code>指定class name，使用起来更加方便：</p><p><code>--classLoaderClass</code> 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而<code>-c &lt;hashcode&gt;</code>是动态变化的。</p><h2><span id="更多信息">更多信息</span></h2><p>在“heapdump”中，我们演示了了Arthas的heapdump命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas mc-redefine命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasmc-redefine%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasmc-redefine%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8demo">启动demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#mc%E5%91%BD%E4%BB%A4">mc命令</a></li><li><a href="#redefine%E5%91%BD%E4%BB%A4">redefine命令</a><ul><li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">常见问题</a></li><li><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">参数说明</a></li><li><a href="#redefine%E7%9A%84%E9%99%90%E5%88%B6">redefine的限制</a></li></ul></li><li><a href="#%E7%83%AD%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81">热更新代码</a><ul><li><a href="#jad%E5%8F%8D%E7%BC%96%E8%AF%91usercontroller">jad反编译UserController</a></li><li><a href="#sc%E6%9F%A5%E6%89%BE%E5%8A%A0%E8%BD%BDusercontroller%E7%9A%84classloader">sc查找加载UserController的ClassLoader</a></li><li><a href="#mc">mc</a></li><li><a href="#redefine">redefine</a></li><li><a href="#%E7%83%AD%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C">热修改代码结果</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasmc-redefine%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个普通的Spring Boot应用为例，演示mc-redefine命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动demo">启动demo</span></h2><p>下载<code>demo-arthas-spring-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar</span><br></pre></td></tr></table></figure><p><code>demo-arthas-spring-boot</code>是一个很简单的spring boot应用，源代码：<a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-arthas-spring-boot">查看</a></p><p>启动之后，可以访问61000端口： 点击查看</p><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasmc-redefine%E5%91%BD%E4%BB%A4/O1CN010Qbzcz1ctPSWSZI6L_!!6000000003658-2-tps-333-182.png" alt="Demo Web"></p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasmc-redefine%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="mc命令">mc命令</span></h2><blockquote><p>Memory Compiler/内存编译器，编译<code>.java</code>文件生成<code>.class</code>。 可以通过<code>-c</code>/<code>--classLoaderClass</code>参数指定classloader，<code>-d</code>参数指定输出目录</p></blockquote><p>编译生成<code>.class</code>文件之后，可以结合<code>redefine</code>命令实现热更新代码。</p><h2><span id="redefine命令">redefine命令</span></h2><blockquote><p>加载外部的<code>.class</code>文件，redefine jvm已加载的类。</p></blockquote><p>参考：<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/Instrumentation.html#redefineClasses-java.lang.instrument.ClassDefinition%E2%80%A6-">Instrumentation#redefineClasses</a></p><h4><span id="常见问题">常见问题</span></h4><ul><li>redefine的class不能修改、添加、删除类的field和method，包括方法参数、方法名称及返回值</li><li>如果mc失败，可以在本地开发环境编译好class文件，上传到目标系统，使用redefine热加载class</li><li>目前redefine 和watch/trace/jad/tt等命令冲突，以后重新实现redefine功能会解决此问题</li></ul><blockquote><p>注意， redefine后的原来的类不能恢复，redefine有可能失败（比如增加了新的field），参考jdk本身的文档。</p><p><code>reset</code>命令对<code>redefine</code>的类无效。如果想重置，需要<code>redefine</code>原始的字节码。</p><p><code>redefine</code>命令和<code>jad</code>/<code>watch</code>/<code>trace</code>/<code>monitor</code>/<code>tt</code>等命令会冲突。执行完<code>redefine</code>之后，如果再执行上面提到的命令，则会把<code>redefine</code>的字节码重置。 原因是jdk本身redefine和Retransform是不同的机制，同时使用两种机制来更新字节码，只有最后修改的会生效。</p></blockquote><h4><span id="参数说明">参数说明</span></h4><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td>[c:]</td><td>ClassLoader的hashcode</td></tr><tr><td><code>[classLoaderClass:]</code></td><td>指定执行表达式的 ClassLoader 的 class name</td></tr><tr><td>[p:]</td><td>外部的<code>.class</code>文件的完整路径，支持多个</td></tr></tbody></table><h4><span id="redefine的限制">redefine的限制</span></h4><ul><li>不允许新增加field/method</li><li>正在跑的函数，没有退出不能生效。</li></ul><h2><span id="热更新代码">热更新代码</span></h2><p>下面介绍通过<code>jad</code>/<code>mc</code>/<code>redefine</code> 命令实现动态更新代码的功能。</p><p>目前，访问 <a href="http://localhost:61000/user/0">http://localhost:61000/user/0</a> ，会返回500异常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:61000/user/0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;timestamp&quot;:1550223186170,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;exception&quot;:&quot;java.lang.IllegalArgumentException&quot;,&quot;message&quot;:&quot;id &lt; 1&quot;,&quot;path&quot;:&quot;/user/0&quot;&#125;</span><br></pre></td></tr></table></figure><p>下面通过热更新代码，修改这个逻辑。</p><h4><span id="jad反编译usercontroller">jad反编译UserController</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java</span><br></pre></td></tr></table></figure><p>jad反编译的结果保存在 <code>/tmp/UserController.java</code>文件里了。</p><p>再打开一个<code>Terminal 3</code>，然后用vim来编辑<code>/tmp/UserController.java</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /tmp/UserController.java</span><br></pre></td></tr></table></figure><p>比如当 user id 小于1时，也正常返回，不抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value=&#123;&quot;/user/&#123;id&#125;&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">&quot;id: &#123;&#125;&quot;</span>, (Object)id);</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="keyword">null</span> &amp;&amp; id &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(id, <span class="string">&quot;name&quot;</span> + id);</span><br><span class="line">        <span class="comment">// throw new IllegalArgumentException(&quot;id &lt; 1&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(id.intValue(), <span class="string">&quot;name&quot;</span> + id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="sc查找加载usercontroller的classloader">sc查找加载UserController的ClassLoader</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d *UserController | grep classLoaderHash</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sc -d *UserController | grep classLoaderHash</span></span><br><span class="line"> classLoaderHash   1be6f5c3</span><br></pre></td></tr></table></figure><p>可以发现是 spring boot <code>LaunchedURLClassLoader@1be6f5c3</code> 加载的。</p><p>注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。</p><p>如果你使用<code>-c</code>，你需要手动输入hashcode：<code>-c &lt;hashcode&gt;</code></p><p>对于只有唯一实例的ClassLoader可以通过<code>--classLoaderClass</code>指定class name，使用起来更加方便.</p><p><code>--classLoaderClass</code> 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而<code>-c &lt;hashcode&gt;</code>是动态变化的。</p><h4><span id="mc">mc</span></h4><p>保存好<code>/tmp/UserController.java</code>之后，使用<code>mc</code>(Memory Compiler)命令来编译，并且通过<code>--classLoaderClass</code>参数指定ClassLoader：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmp</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmp</span></span><br><span class="line">Memory compiler output:</span><br><span class="line">/tmp/com/example/demo/arthas/user/UserController.class</span><br><span class="line">Affect(row-cnt:1) cost in 346 ms</span><br></pre></td></tr></table></figure><p>也可以通过<code>mc -c &lt;classLoaderHash&gt; /tmp/UserController.java -d /tmp</code>，使用<code>-c</code>参数指定ClassLoaderHash:</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mc -c 1be6f5c3 /tmp/UserController.java -d /tmp</span></span><br></pre></td></tr></table></figure><h4><span id="redefine">redefine</span></h4><p>再使用<code>redefine</code>命令重新加载新编译好的<code>UserController.class</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redefine /tmp/com/example/demo/arthas/user/UserController.class</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redefine /tmp/com/example/demo/arthas/user/UserController.class</span><br><span class="line">redefine success, size: 1</span><br></pre></td></tr></table></figure><h4><span id="热修改代码结果">热修改代码结果</span></h4><p><code>redefine</code>成功之后，再次访问 user/0 ，结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 0,</span><br><span class="line">  &quot;name&quot;: &quot;name0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>在“mc-redefine”中，我们演示了了Arthas的mc-redefine命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas sc命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthassc%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthassc%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8arthas-demo">启动arthas demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#sc%E5%91%BD%E4%BB%A4">sc命令</a></li><li><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">参数说明</a><ul><li><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-1">参数说明</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83">使用参考</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthassc%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示sc命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动arthas-demo">启动arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthassc%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="sc命令">sc命令</span></h2><blockquote><p>查看JVM已加载的类信息</p></blockquote><p>“Search-Class” 的简写，这个命令能搜索出所有已经加载到 JVM 中的 Class 信息，这个命令支持的参数有 <code>[d]</code>、<code>[E]</code>、<code>[f]</code> 和 <code>[x:]</code>。</p><h2><span id="参数说明">参数说明</span></h2><h4><span id="参数说明">参数说明</span></h4><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr><tr><td><em>method-pattern</em></td><td>方法名表达式匹配</td></tr><tr><td>[d]</td><td>输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的ClassLoader等详细信息。 如果一个类被多个ClassLoader所加载，则会出现多次</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr><tr><td>[f]</td><td>输出当前类的成员变量信息（需要配合参数-d一起使用）</td></tr><tr><td>[x:]</td><td>指定输出静态变量时属性的遍历深度，默认为 0，即直接使用 <code>toString</code> 输出</td></tr><tr><td><code>[c:]</code></td><td>指定class的 ClassLoader 的 hashcode</td></tr><tr><td><code>[classLoaderClass:]</code></td><td>指定执行表达式的 ClassLoader 的 class name</td></tr><tr><td><code>[n:]</code></td><td>具有详细信息的匹配类的最大数量（默认为100）</td></tr></tbody></table><blockquote><p>class-pattern支持全限定名，如com.taobao.test.AAA，也支持com/taobao/test/AAA这样的格式，这样，我们从异常堆栈里面把类名拷贝过来的时候，不需要在手动把<code>/</code>替换为<code>.</code>啦。</p><p>sc 默认开启了子类匹配功能，也就是说所有当前类的子类也会被搜索出来，想要精确的匹配，请打开<code>options disable-sub-class true</code>开关</p></blockquote><h4><span id="使用参考">使用参考</span></h4><ul><li><p>模糊搜索</p><p><code>sc demo.*</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc demo.*</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sc demo.*</span></span><br><span class="line">demo.MathGame</span><br><span class="line">Affect(row-cnt:1) cost in 55 ms.</span><br></pre></td></tr></table></figure><ul><li><p>打印类的详细信息</p><p><code>sc -d demo.MathGame</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d demo.MathGame</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sc -d demo.MathGame</span></span><br><span class="line">class-info        demo.MathGame</span><br><span class="line">code-source       /private/tmp/arthas-demo.jar</span><br><span class="line">name              demo.MathGame</span><br><span class="line">isInterface       false</span><br><span class="line">isAnnotation      false</span><br><span class="line">isEnum            false</span><br><span class="line">isAnonymousClass  false</span><br><span class="line">isArray           false</span><br><span class="line">isLocalClass      false</span><br><span class="line">isMemberClass     false</span><br><span class="line">isPrimitive       false</span><br><span class="line">isSynthetic       false</span><br><span class="line">simple-name       MathGame</span><br><span class="line">modifier          public</span><br><span class="line">annotation</span><br><span class="line">interfaces</span><br><span class="line">super-class       +-java.lang.Object</span><br><span class="line">class-loader      +-sun.misc.Launcher$AppClassLoader@3d4eac69</span><br><span class="line">                    +-sun.misc.Launcher$ExtClassLoader@66350f69</span><br><span class="line">classLoaderHash   3d4eac69</span><br><span class="line"></span><br><span class="line">Affect(row-cnt:1) cost in 875 ms.</span><br></pre></td></tr></table></figure><ul><li>指定classLoader</li></ul><p>注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。</p><p>如果你使用<code>-c</code>，你需要手动输入hashcode：<code>-c &lt;hashcode&gt;</code></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sc -c 3d4eac69 -d demo*</span></span><br></pre></td></tr></table></figure><p>对于只有唯一实例的ClassLoader可以通过<code>--classLoaderClass</code>指定class name，使用起来更加方便：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc --classLoaderClass sun.misc.Launcher<span class="variable">$AppClassLoader</span> -d demo*</span><br></pre></td></tr></table></figure><ul><li>注: 这里classLoaderClass 在 java 8 是 sun.misc.Launcher$AppClassLoader，而java 11的classloader是jdk.internal.loader.ClassLoaders$AppClassLoader，katacoda目前环境是java8。</li></ul><p><code>--classLoaderClass</code> 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而<code>-c &lt;hashcode&gt;</code>是动态变化的。</p><ul><li><p>打印出类的Field信息</p><p><code>sc -d -f demo.MathGame</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d -f demo.MathGame</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sc -d -f demo.MathGame</span></span><br><span class="line">class-info        demo.MathGame</span><br><span class="line">code-source       /private/tmp/arthas-demo.jar</span><br><span class="line">name              demo.MathGame</span><br><span class="line">isInterface       false</span><br><span class="line">isAnnotation      false</span><br><span class="line">isEnum            false</span><br><span class="line">isAnonymousClass  false</span><br><span class="line">isArray           false</span><br><span class="line">isLocalClass      false</span><br><span class="line">isMemberClass     false</span><br><span class="line">isPrimitive       false</span><br><span class="line">isSynthetic       false</span><br><span class="line">simple-name       MathGame</span><br><span class="line">modifier          public</span><br><span class="line">annotation</span><br><span class="line">interfaces</span><br><span class="line">super-class       +-java.lang.Object</span><br><span class="line">class-loader      +-sun.misc.Launcher$AppClassLoader@3d4eac69</span><br><span class="line">                    +-sun.misc.Launcher$ExtClassLoader@66350f69</span><br><span class="line">classLoaderHash   3d4eac69</span><br><span class="line">fields            modifierprivate,static</span><br><span class="line">                  type    java.util.Random</span><br><span class="line">                  name    random</span><br><span class="line">                  value   java.util.Random@522b4</span><br><span class="line">                          08a</span><br><span class="line"></span><br><span class="line">                  modifierprivate</span><br><span class="line">                  type    int</span><br><span class="line">                  name    illegalArgumentCount</span><br><span class="line">Affect(row-cnt:1) cost in 19 ms.</span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>在“sc”中，我们演示了了Arthas的sc命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas sm命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthassm%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthassm%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8arthas-demo">启动arthas demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#sm%E5%91%BD%E4%BB%A4">sm命令</a><ul><li><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">参数说明</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83">使用参考</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthassm%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示sm命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动arthas-demo">启动arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthassm%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="sm命令">sm命令</span></h2><blockquote><p>查看已加载类的方法信息</p></blockquote><p>“Search-Method” 的简写，这个命令能搜索出所有已经加载了 Class 信息的方法信息。</p><p><code>sm</code> 命令只能看到由当前类所声明 (declaring) 的方法，父类则无法看到。</p><h4><span id="参数说明">参数说明</span></h4><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr><tr><td><em>method-pattern</em></td><td>方法名表达式匹配</td></tr><tr><td>[d]</td><td>展示每个方法的详细信息</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr><tr><td><code>[c:]</code></td><td>指定class的 ClassLoader 的 hashcode</td></tr><tr><td><code>[classLoaderClass:]</code></td><td>指定执行表达式的 ClassLoader 的 class name</td></tr><tr><td><code>[n:]</code></td><td>具有详细信息的匹配类的最大数量（默认为100）</td></tr></tbody></table><h4><span id="使用参考">使用参考</span></h4><ul><li>查找<code>java.lang.String</code>类的具体方法</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sm java.lang.String</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sm java.lang.String</span></span><br><span class="line">java.lang.String-&gt;&lt;init&gt;</span><br><span class="line">java.lang.String-&gt;equals</span><br><span class="line">java.lang.String-&gt;toString</span><br><span class="line">java.lang.String-&gt;hashCode</span><br><span class="line">java.lang.String-&gt;compareTo</span><br><span class="line">java.lang.String-&gt;indexOf</span><br><span class="line">java.lang.String-&gt;valueOf</span><br><span class="line">java.lang.String-&gt;checkBounds</span><br><span class="line">java.lang.String-&gt;length</span><br><span class="line">java.lang.String-&gt;isEmpty</span><br><span class="line">java.lang.String-&gt;charAt</span><br><span class="line">java.lang.String-&gt;codePointAt</span><br><span class="line">java.lang.String-&gt;codePointBefore</span><br><span class="line">java.lang.String-&gt;codePointCount</span><br><span class="line">java.lang.String-&gt;offsetByCodePoints</span><br><span class="line">java.lang.String-&gt;getChars</span><br><span class="line">java.lang.String-&gt;getBytes</span><br><span class="line">java.lang.String-&gt;contentEquals</span><br><span class="line">java.lang.String-&gt;nonSyncContentEquals</span><br><span class="line">java.lang.String-&gt;equalsIgnoreCase</span><br><span class="line">java.lang.String-&gt;compareToIgnoreCase</span><br><span class="line">java.lang.String-&gt;regionMatches</span><br><span class="line">java.lang.String-&gt;startsWith</span><br><span class="line">java.lang.String-&gt;endsWith</span><br><span class="line">java.lang.String-&gt;indexOfSupplementary</span><br><span class="line">java.lang.String-&gt;lastIndexOf</span><br><span class="line">java.lang.String-&gt;lastIndexOfSupplementary</span><br><span class="line">java.lang.String-&gt;substring</span><br><span class="line">java.lang.String-&gt;subSequence</span><br><span class="line">java.lang.String-&gt;concat</span><br><span class="line">java.lang.String-&gt;replace</span><br><span class="line">java.lang.String-&gt;matches</span><br><span class="line">java.lang.String-&gt;contains</span><br><span class="line">java.lang.String-&gt;replaceFirst</span><br><span class="line">java.lang.String-&gt;replaceAll</span><br><span class="line">java.lang.String-&gt;split</span><br><span class="line">java.lang.String-&gt;join</span><br><span class="line">java.lang.String-&gt;toLowerCase</span><br><span class="line">java.lang.String-&gt;toUpperCase</span><br><span class="line">java.lang.String-&gt;trim</span><br><span class="line">java.lang.String-&gt;toCharArray</span><br><span class="line">java.lang.String-&gt;format</span><br><span class="line">java.lang.String-&gt;copyValueOf</span><br><span class="line">java.lang.String-&gt;intern</span><br><span class="line">Affect(row-cnt:44) cost in 1342 ms.</span><br></pre></td></tr></table></figure><ul><li>指定ClassLoader</li></ul><p>查找ClassLoaderHash：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d demo.MathGame | grep classLoaderHash</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sc -d demo.MathGame | grep classLoaderHash</span></span><br><span class="line"> classLoaderHash   70dea4e</span><br></pre></td></tr></table></figure><ul><li>指定classLoader</li></ul><p>注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。</p><p>如果你使用<code>-c</code>，你需要手动输入hashcode：<code>-c &lt;hashcode&gt;</code></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sm -c 70dea4e demo.MathGame</span></span><br></pre></td></tr></table></figure><p>对于只有唯一实例的ClassLoader可以通过<code>--classLoaderClass</code>指定class name，使用起来更加方便：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sm --classLoaderClass sun.misc.Launcher<span class="variable">$AppClassLoader</span> demo.MathGame</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sm --classLoaderClass sun.misc.Launcher<span class="variable">$AppClassLoader</span> demo.MathGame</span></span><br><span class="line">demo.MathGame &lt;init&gt;()V</span><br><span class="line">demo.MathGame primeFactors(I)Ljava/util/List;</span><br><span class="line">demo.MathGame main([Ljava/lang/String;)V</span><br><span class="line">demo.MathGame run()V</span><br><span class="line">demo.MathGame print(ILjava/util/List;)V</span><br><span class="line">Affect(row-cnt:5) cost in 2 ms.</span><br></pre></td></tr></table></figure><ul><li>注: 这里classLoaderClass 在 java 8 是 sun.misc.Launcher$AppClassLoader，而java 11的classloader是jdk.internal.loader.ClassLoaders$AppClassLoader，katacoda目前环境是java8。</li></ul><p><code>--classLoaderClass</code> 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而<code>-c &lt;hashcode&gt;</code>是动态变化的。</p><ul><li>查找<code>java.lang.String#toString</code>函数并打印详细信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sm -d java.lang.String toString</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sm -d java.lang.String toString</span></span><br><span class="line"> declaring-class  java.lang.String</span><br><span class="line"> method-name      toString</span><br><span class="line"> modifier         public</span><br><span class="line"> annotation</span><br><span class="line"> parameters</span><br><span class="line"> return           java.lang.String</span><br><span class="line"> exceptions</span><br><span class="line"></span><br><span class="line">Affect(row-cnt:1) cost in 3 ms.</span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>在“sm”中，我们演示了了Arthas的sm命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas mc-retransform命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasmc-retransform%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasmc-retransform%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8demo">启动demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#mc%E5%91%BD%E4%BB%A4">mc命令</a></li><li><a href="#retransform%E5%91%BD%E4%BB%A4">retransform命令</a><ul><li><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">参数说明</a></li><li><a href="#retransform%E7%9A%84%E9%99%90%E5%88%B6">retransform的限制</a></li></ul></li><li><a href="#%E7%83%AD%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81">热更新代码</a><ul><li><a href="#jad%E5%8F%8D%E7%BC%96%E8%AF%91usercontroller">jad反编译UserController</a></li><li><a href="#sc%E6%9F%A5%E6%89%BE%E5%8A%A0%E8%BD%BDusercontroller%E7%9A%84classloader">sc查找加载UserController的ClassLoader</a></li><li><a href="#mc">mc</a></li><li><a href="#retransform">retransform</a></li><li><a href="#%E7%83%AD%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C">热修改代码结果</a></li></ul></li><li><a href="#retransform%E5%91%BD%E4%BB%A4%E6%9B%B4%E5%A4%9A%E8%AF%B4%E6%98%8E">retransform命令更多说明</a><ul><li><a href="#%E6%9F%A5%E7%9C%8B-retransform-entry">查看 retransform entry</a></li><li><a href="#%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A-retransform-entry">删除指定 retransform entry</a></li><li><a href="#%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89-retransform-entry">删除所有 retransform entry</a></li><li><a href="#%E6%98%BE%E5%BC%8F%E8%A7%A6%E5%8F%91-retransform">显式触发 retransform</a></li><li><a href="#%E6%B6%88%E9%99%A4-retransform-%E7%9A%84%E5%BD%B1%E5%93%8D">消除 retransform 的影响</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasmc-retransform%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个普通的Spring Boot应用为例，演示mc-retransform命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动demo">启动demo</span></h2><p>下载<code>demo-arthas-spring-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar</span><br></pre></td></tr></table></figure><p><code>demo-arthas-spring-boot</code>是一个很简单的spring boot应用，源代码：<a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-arthas-spring-boot">查看</a></p><p>启动之后，可以访问61000端口： 点击查看</p><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasmc-retransform%E5%91%BD%E4%BB%A4/O1CN010Qbzcz1ctPSWSZI6L_!!6000000003658-2-tps-333-182.png" alt="Demo Web"></p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasmc-retransform%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="mc命令">mc命令</span></h2><blockquote><p>Memory Compiler/内存编译器，编译<code>.java</code>文件生成<code>.class</code>。 可以通过<code>-c</code>/<code>--classLoaderClass</code>参数指定classloader，<code>-d</code>参数指定输出目录</p></blockquote><p>编译生成<code>.class</code>文件之后，可以结合<code>retransform</code>命令实现热更新代码。</p><h2><span id="retransform命令">retransform命令</span></h2><blockquote><p>加载外部的<code>.class</code>文件，retransform jvm已加载的类。</p></blockquote><p>参考：<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/Instrumentation.html#retransformClasses-java.lang.Class%E2%80%A6-">Instrumentation#retransformClasses</a></p><h4><span id="参数说明">参数说明</span></h4><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td>[c:]</td><td>ClassLoader的hashcode</td></tr><tr><td><code>[classLoaderClass:]</code></td><td>指定执行表达式的 ClassLoader 的 class name</td></tr><tr><td>[p:]</td><td>外部的<code>.class</code>文件的完整路径，支持多个</td></tr></tbody></table><h4><span id="retransform的限制">retransform的限制</span></h4><ul><li>不允许新增加field/method</li><li>正在跑的函数，没有退出不能生效。</li></ul><h2><span id="热更新代码">热更新代码</span></h2><p>下面介绍通过<code>jad</code>/<code>mc</code>/<code>retransform</code> 命令实现动态更新代码的功能。</p><p>目前，访问 <a href="http://localhost:61000/user/0">http://localhost:61000/user/0</a> ，会返回500异常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:61000/user/0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;timestamp&quot;:1550223186170,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;exception&quot;:&quot;java.lang.IllegalArgumentException&quot;,&quot;message&quot;:&quot;id &lt; 1&quot;,&quot;path&quot;:&quot;/user/0&quot;&#125;</span><br></pre></td></tr></table></figure><p>下面通过热更新代码，修改这个逻辑。</p><h4><span id="jad反编译usercontroller">jad反编译UserController</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java</span><br></pre></td></tr></table></figure><p>jad反编译的结果保存在 <code>/tmp/UserController.java</code>文件里了。</p><p>再打开一个<code>Terminal 3</code>，然后用vim来编辑<code>/tmp/UserController.java</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /tmp/UserController.java</span><br></pre></td></tr></table></figure><p>比如当 user id 小于1时，也正常返回，不抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value=&#123;&quot;/user/&#123;id&#125;&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">&quot;id: &#123;&#125;&quot;</span>, (Object)id);</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="keyword">null</span> &amp;&amp; id &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(id, <span class="string">&quot;name&quot;</span> + id);</span><br><span class="line">        <span class="comment">// throw new IllegalArgumentException(&quot;id &lt; 1&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(id.intValue(), <span class="string">&quot;name&quot;</span> + id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="sc查找加载usercontroller的classloader">sc查找加载UserController的ClassLoader</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d *UserController | grep classLoaderHash</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sc -d *UserController | grep classLoaderHash</span></span><br><span class="line"> classLoaderHash   1be6f5c3</span><br></pre></td></tr></table></figure><p>可以发现是 spring boot <code>LaunchedURLClassLoader@1be6f5c3</code> 加载的。</p><p>注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。</p><p>如果你使用<code>-c</code>，你需要手动输入hashcode：<code>-c &lt;hashcode&gt;</code></p><p>对于只有唯一实例的ClassLoader可以通过<code>--classLoaderClass</code>指定class name，使用起来更加方便.</p><p><code>--classLoaderClass</code> 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而<code>-c &lt;hashcode&gt;</code>是动态变化的。</p><h4><span id="mc">mc</span></h4><p>保存好<code>/tmp/UserController.java</code>之后，使用<code>mc</code>(Memory Compiler)命令来编译，并且通过<code>--classLoaderClass</code>参数指定ClassLoader：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmp</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmp</span></span><br><span class="line">Memory compiler output:</span><br><span class="line">/tmp/com/example/demo/arthas/user/UserController.class</span><br><span class="line">Affect(row-cnt:1) cost in 346 ms</span><br></pre></td></tr></table></figure><p>也可以通过<code>mc -c &lt;classLoaderHash&gt; /tmp/UserController.java -d /tmp</code>，使用<code>-c</code>参数指定ClassLoaderHash:</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mc -c 1be6f5c3 /tmp/UserController.java -d /tmp</span></span><br></pre></td></tr></table></figure><h4><span id="retransform">retransform</span></h4><p>再使用<code>retransform</code>命令重新加载新编译好的<code>UserController.class</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retransform /tmp/com/example/demo/arthas/user/UserController.class</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ retransform /tmp/com/example/demo/arthas/user/UserController.class</span><br><span class="line">retransform success, size: 1</span><br></pre></td></tr></table></figure><h4><span id="热修改代码结果">热修改代码结果</span></h4><p><code>retransform</code>成功之后，再次访问 user/0 ，结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 0,</span><br><span class="line">  &quot;name&quot;: &quot;name0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="retransform命令更多说明">retransform命令更多说明</span></h2><blockquote><p>加载外部的<code>.class</code>文件，retransform jvm已加载的类。</p></blockquote><p>参考：<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/Instrumentation.html#retransformClasses-java.lang.Class%E2%80%A6-">Instrumentation#retransformClasses</a></p><h4><span id="查看-retransform-entry">查看 retransform entry</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retransform -l</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> retransform -l</span></span><br><span class="line">Id              ClassName       TransformCount  LoaderHash      LoaderClassName</span><br><span class="line">1               com.example.dem 1               null            null</span><br><span class="line">                o.arthas.user.U</span><br><span class="line">                serController</span><br></pre></td></tr></table></figure><ul><li>TransformCount 统计在 ClassFileTransformer#transform 函数里尝试返回 entry对应的 .class文件的次数，但并不表明transform一定成功。</li></ul><h4><span id="删除指定-retransform-entry">删除指定 retransform entry</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retransform -d 1</span><br></pre></td></tr></table></figure><p>需要指定 id：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retransform -d 1</span><br></pre></td></tr></table></figure><h4><span id="删除所有-retransform-entry">删除所有 retransform entry</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retransform --deleteAll</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retransform --deleteAll</span><br></pre></td></tr></table></figure><h4><span id="显式触发-retransform">显式触发 retransform</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retransform --classPattern com.example.demo.arthas.user.UserController</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> retransform --classPattern com.example.demo.arthas.user.UserController</span></span><br><span class="line">retransform success, size: 1, classes:</span><br><span class="line">com.example.demo.arthas.user.UserController</span><br></pre></td></tr></table></figure><blockquote><p>注意：对于同一个类，当存在多个 retransform entry时，如果显式触发 retransform ，则最后添加的entry生效(id最大的)。</p></blockquote><h4><span id="消除-retransform-的影响">消除 retransform 的影响</span></h4><p>如果对某个类执行 retransform 之后，想消除影响，则需要：</p><ul><li>删除这个类对应的 retransform entry</li><li>重新触发 retransform</li></ul><blockquote><p>如果不清除掉所有的 retransform entry，并重新触发 retransform ，则arthas stop时，retransform过的类仍然生效。</p></blockquote><p>在上面删掉 retransform entry，再显式触发 retransform之后，可以用 <code>jad</code>命令来确认之前retransform的结果已经被消除了。</p><p>再次访问 user/0 ，会抛出异常。</p><h2><span id="更多信息">更多信息</span></h2><p>在“mc-retransform”中，我们演示了了Arthas的mc-retransform命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas monitor命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasmonitor%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasmonitor%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8arthas-demo">启动arthas demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#monitor%E5%91%BD%E4%BB%A4">monitor命令</a><ul><li><a href="#%E7%9B%91%E6%8E%A7%E7%9A%84%E7%BB%B4%E5%BA%A6%E8%AF%B4%E6%98%8E">监控的维度说明</a></li><li><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">参数说明</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83">使用参考</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasmonitor%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示monitor命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动arthas-demo">启动arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasmonitor%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="monitor命令">monitor命令</span></h2><blockquote><p>方法执行监控</p></blockquote><p>对匹配 <code>class-pattern</code>／<code>method-pattern</code>的类、方法的调用进行监控。</p><p><code>monitor</code> 命令是一个非实时返回命令.</p><p>实时返回命令是输入之后立即返回，而非实时返回的命令，则是不断的等待目标 Java 进程返回信息，直到用户输入 <code>Ctrl+C</code> 为止。</p><p>服务端是以任务的形式在后台跑任务，植入的代码随着任务的中止而不会被执行，所以任务关闭后，不会对原有性能产生太大影响，而且原则上，任何Arthas命令不会引起原有业务逻辑的改变。</p><h4><span id="监控的维度说明">监控的维度说明</span></h4><table><thead><tr><th>监控项</th><th>说明</th></tr></thead><tbody><tr><td>timestamp</td><td>时间戳</td></tr><tr><td>class</td><td>Java类</td></tr><tr><td>method</td><td>方法（构造方法、普通方法）</td></tr><tr><td>total</td><td>调用次数</td></tr><tr><td>success</td><td>成功次数</td></tr><tr><td>fail</td><td>失败次数</td></tr><tr><td>rt</td><td>平均RT</td></tr><tr><td>fail-rate</td><td>失败率</td></tr></tbody></table><h4><span id="参数说明">参数说明</span></h4><p>方法拥有一个命名参数 <code>[c:]</code>，意思是统计周期（cycle of output），拥有一个整型的参数值</p><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr><tr><td><em>method-pattern</em></td><td>方法名表达式匹配</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr><tr><td><code>[c:]</code></td><td>统计周期，默认值为120秒</td></tr></tbody></table><h4><span id="使用参考">使用参考</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitor -c 5 demo.MathGame primeFactors</span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> monitor -c 5 demo.MathGame primeFactors</span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 94 ms.</span><br><span class="line"> timestamp            class          method        total  success  fail  avg-rt(ms)  fail-rate</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line"> 2018-12-03 19:06:38  demo.MathGame  primeFactors  5      1        4     1.15        80.00%</span><br><span class="line"></span><br><span class="line"> timestamp            class          method        total  success  fail  avg-rt(ms)  fail-rate</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line"> 2018-12-03 19:06:43  demo.MathGame  primeFactors  5      3        2     42.29       40.00%</span><br><span class="line"></span><br><span class="line"> timestamp            class          method        total  success  fail  avg-rt(ms)  fail-rate</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line"> 2018-12-03 19:06:48  demo.MathGame  primeFactors  5      3        2     67.92       40.00%</span><br><span class="line"></span><br><span class="line"> timestamp            class          method        total  success  fail  avg-rt(ms)  fail-rate</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line"> 2018-12-03 19:06:53  demo.MathGame  primeFactors  5      2        3     0.25        60.00%</span><br><span class="line"></span><br><span class="line"> timestamp            class          method        total  success  fail  avg-rt(ms)  fail-rate</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line"> 2018-12-03 19:06:58  demo.MathGame  primeFactors  1      1        0     0.45        0.00%</span><br><span class="line"></span><br><span class="line"> timestamp            class          method        total  success  fail  avg-rt(ms)  fail-rate</span><br><span class="line">-----------------------------------------------------------------------------------------------</span><br><span class="line"> 2018-12-03 19:07:03  demo.MathGame  primeFactors  2      2        0     3182.72     0.00%</span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>在“monitor”中，我们演示了了Arthas的monitor命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas profiler命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasprofiler%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasprofiler%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8arthas-demo">启动arthas demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#profiler%E5%91%BD%E4%BB%A4">profiler命令</a><ul><li><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">参数说明</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E6%94%AF%E6%8C%81%E7%9A%84action">查看所有支持的action</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E7%89%88%E6%9C%AC">查看版本</a></li><li><a href="#%E5%90%AF%E5%8A%A8profiler">启动profiler</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E5%B7%B2%E9%87%87%E9%9B%86%E7%9A%84sample%E7%9A%84%E6%95%B0%E9%87%8F">获取已采集的sample的数量</a></li><li><a href="#%E6%9F%A5%E7%9C%8Bprofiler%E7%8A%B6%E6%80%81">查看profiler状态</a></li><li><a href="#%E5%81%9C%E6%AD%A2profiler">停止profiler</a><ul><li><a href="#%E7%94%9F%E6%88%90svg%E6%A0%BC%E5%BC%8F%E7%BB%93%E6%9E%9C">生成svg格式结果</a></li><li><a href="#%E7%94%9F%E6%88%90html%E6%A0%BC%E5%BC%8F%E7%BB%93%E6%9E%9C">生成html格式结果</a></li></ul></li><li><a href="#%E9%80%9A%E8%BF%87%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9F%A5%E7%9C%8Barthas-output%E4%B8%8B%E9%9D%A2%E7%9A%84profiler%E7%BB%93%E6%9E%9C">通过浏览器查看arthas-output下面的profiler结果</a></li><li><a href="#profiler%E6%94%AF%E6%8C%81%E7%9A%84events">profiler支持的events</a></li><li><a href="#%E6%81%A2%E5%A4%8D%E9%87%87%E6%A0%B7">恢复采样</a></li><li><a href="#%E4%BD%BF%E7%94%A8execute%E6%9D%A5%E6%89%A7%E8%A1%8C%E5%A4%8D%E6%9D%82%E7%9A%84%E5%91%BD%E4%BB%A4">使用<code>execute</code>来执行复杂的命令</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasprofiler%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示profiler命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动arthas-demo">启动arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasprofiler%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="profiler命令">profiler命令</span></h2><blockquote><p>使用<a href="https://github.com/jvm-profiling-tools/async-profiler">async-profiler</a>生成火焰图</p></blockquote><p><code>profiler</code> 命令支持生成应用热点的火焰图。本质上是通过不断的采样，然后把收集到的采样结果生成火焰图。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiler` 命令基本运行结构是 `profiler action [actionArg]</span><br></pre></td></tr></table></figure><h4><span id="参数说明">参数说明</span></h4><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>action</em></td><td>要执行的操作</td></tr><tr><td><em>actionArg</em></td><td>属性名模式</td></tr><tr><td>[i:]</td><td>采样间隔（单位：ns）（默认值：10’000’000，即10 ms）</td></tr><tr><td>[f:]</td><td>将输出转储到指定路径</td></tr><tr><td>[d:]</td><td>运行评测指定秒</td></tr><tr><td>[e:]</td><td>要跟踪哪个事件（cpu, alloc, lock, cache-misses等），默认是cpu</td></tr></tbody></table><h4><span id="查看所有支持的action">查看所有支持的action</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiler actions</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> profiler actions</span></span><br><span class="line">Supported Actions: [resume, dumpCollapsed, getSamples, start, list, execute, version, stop, load, dumpFlat, actions, dumpTraces, status]</span><br></pre></td></tr></table></figure><h4><span id="查看版本">查看版本</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiler version</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> profiler version</span></span><br><span class="line">Async-profiler 1.6 built on Sep  9 2019</span><br><span class="line">Copyright 2019 Andrei Pangin</span><br></pre></td></tr></table></figure><h4><span id="启动profiler">启动profiler</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiler start -e itimer</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ profiler start -e itimer</span><br><span class="line">Started [itimer] profiling</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，生成的是cpu的火焰图，即event为<code>cpu</code>。可以用<code>--event</code>参数来指定。 因为katacoda环境不支持perf_events，所以这里使用<code>-e itimer</code>参数指定event为itimer</p></blockquote><h4><span id="获取已采集的sample的数量">获取已采集的sample的数量</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiler getSamples</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ profiler getSamples</span><br><span class="line">23</span><br></pre></td></tr></table></figure><h4><span id="查看profiler状态">查看profiler状态</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiler status</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> profiler status</span></span><br><span class="line">[itimer] profiling is running for 4 seconds</span><br></pre></td></tr></table></figure><p>可以查看当前profiler在采样哪种<code>event</code>和采样时间。</p><h4><span id="停止profiler">停止profiler</span></h4><h5><span id="生成svg格式结果">生成svg格式结果</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiler stop</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ profiler stop</span><br><span class="line">profiler output file: /tmp/demo/arthas-output/20191125-135546.svg</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>默认情况下，生成的结果保存到应用的<code>工作目录</code>下的<code>arthas-output</code>目录。可以通过 <code>--file</code>参数来指定输出结果路径。比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiler stop --file /tmp/output.svg</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> profiler stop --file /tmp/output.svg</span></span><br><span class="line">profiler output file: /tmp/output.svg</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h5><span id="生成html格式结果">生成html格式结果</span></h5><p>默认情况下，结果文件是<code>svg</code>格式，如果想生成<code>html</code>格式，可以用<code>--format</code>参数指定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiler stop --format html</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> profiler stop --format html</span></span><br><span class="line">profiler output file: /tmp/test/arthas-output/20191125-143329.html</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>或者在<code>--file</code>参数里用文件名指名格式。比如<code>--file /tmp/result.html</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiler stop --file /tmp/result.html</span><br></pre></td></tr></table></figure><h4><span id="通过浏览器查看arthas-output下面的profiler结果">通过浏览器查看arthas-output下面的profiler结果</span></h4><p>默认情况下，arthas使用8563http端口，则可以打开： 目录下面的profiler结果：</p><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasprofiler%E5%91%BD%E4%BB%A4/arthas-output.png" alt="img"></p><p>点击可以查看具体的结果：</p><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasprofiler%E5%91%BD%E4%BB%A4/arthas-output-svg.png" alt="img"></p><blockquote><p>如果是chrome浏览器，可能需要多次刷新。</p></blockquote><h4><span id="profiler支持的events">profiler支持的events</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiler list</span><br></pre></td></tr></table></figure><p>在不同的平台，不同的OS下面，支持的events各有不同。比如在macos下面：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> profiler list</span></span><br><span class="line">Basic events:</span><br><span class="line">  cpu</span><br><span class="line">  alloc</span><br><span class="line">  lock</span><br><span class="line">  wall</span><br><span class="line">  itimer</span><br></pre></td></tr></table></figure><p>在linux下面</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> profiler list</span></span><br><span class="line">Basic events:</span><br><span class="line">  cpu</span><br><span class="line">  alloc</span><br><span class="line">  lock</span><br><span class="line">  wall</span><br><span class="line">  itimer</span><br><span class="line">Perf events:</span><br><span class="line">  page-faults</span><br><span class="line">  context-switches</span><br><span class="line">  cycles</span><br><span class="line">  instructions</span><br><span class="line">  cache-references</span><br><span class="line">  cache-misses</span><br><span class="line">  branches</span><br><span class="line">  branch-misses</span><br><span class="line">  bus-cycles</span><br><span class="line">  L1-dcache-load-misses</span><br><span class="line">  LLC-load-misses</span><br><span class="line">  dTLB-load-misses</span><br><span class="line">  mem:breakpoint</span><br><span class="line">  trace:tracepoint</span><br></pre></td></tr></table></figure><p>如果遇到OS本身的权限/配置问题，然后缺少部分event，可以参考<code>async-profiler</code>本身文档：<a href="https://github.com/jvm-profiling-tools/async-profiler">async-profiler</a></p><p>可以用<code>--event</code>参数指定要采样的事件，比如对<code>alloc</code>事件进入采样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiler start --event alloc</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> profiler start --event alloc</span></span><br></pre></td></tr></table></figure><h4><span id="恢复采样">恢复采样</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiler resume</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> profiler resume</span></span><br><span class="line">Started [cpu] profiling</span><br></pre></td></tr></table></figure><p><code>start</code>和<code>resume</code>的区别是：<code>start</code>是新开始采样，<code>resume</code>会保留上次<code>stop</code>时的数据。</p><p>通过执行<code>profiler getSamples</code>可以查看samples的数量来验证。</p><h4><span id="使用execute来执行复杂的命令">使用<code>execute</code>来执行复杂的命令</span></h4><p>比如开始采样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiler execute <span class="string">&#x27;start,framebuf=5000000&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiler execute &#x27;start,framebuf=5000000&#x27;</span><br></pre></td></tr></table></figure><p>停止采样，并保存到指定文件里：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiler execute <span class="string">&#x27;stop,file=/tmp/result.svg&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiler execute &#x27;stop,file=/tmp/result.svg&#x27;</span><br></pre></td></tr></table></figure><p>具体的格式参考： <a href="https://github.com/jvm-profiling-tools/async-profiler/blob/v1.8.1/src/arguments.cpp#L50">arguments.cpp</a></p><h2><span id="更多信息">更多信息</span></h2><p>在“profiler”中，我们演示了了Arthas的profiler命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas stack命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasstack%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasstack%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8arthas-demo">启动arthas demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#stack%E5%91%BD%E4%BB%A4">stack命令</a><ul><li><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">参数说明</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90">使用例子</a><ul><li><a href="#stack">stack</a></li><li><a href="#%E6%8D%AE%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9D%A5%E8%BF%87%E6%BB%A4">据条件表达式来过滤</a></li><li><a href="#%E6%8D%AE%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E6%9D%A5%E8%BF%87%E6%BB%A4">据执行时间来过滤</a></li></ul></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasstack%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示stack命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动arthas-demo">启动arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasstack%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="stack命令">stack命令</span></h2><blockquote><p>输出当前方法被调用的调用路径</p></blockquote><p>很多时候我们都知道一个方法被执行，但这个方法被执行的路径非常多，或者你根本就不知道这个方法是从那里被执行了，此时你需要的是 stack 命令。</p><h4><span id="参数说明">参数说明</span></h4><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr><tr><td><em>method-pattern</em></td><td>方法名表达式匹配</td></tr><tr><td><em>condition-express</em></td><td>条件表达式</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr><tr><td><code>[n:]</code></td><td>执行次数限制</td></tr></tbody></table><p>这里重点要说明的是观察表达式，观察表达式的构成主要由 ognl 表达式组成，所以你可以这样写<code>&quot;&#123;params,returnObj&#125;&quot;</code>，只要是一个合法的 ognl 表达式，都能被正常支持。</p><p>观察的维度也比较多，主要体现在参数 <code>advice</code> 的数据结构上。<code>Advice</code> 参数最主要是封装了通知节点的所有信息。</p><ul><li>特殊用法请参考：<a href="https://github.com/alibaba/arthas/issues/71">https://github.com/alibaba/arthas/issues/71</a></li><li>OGNL表达式官网：<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html">https://commons.apache.org/proper/commons-ognl/language-guide.html</a></li></ul><h4><span id="使用例子">使用例子</span></h4><h5><span id="stack">stack</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack demo.MathGame primeFactors</span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> stack demo.MathGame primeFactors</span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 36 ms.</span><br><span class="line">ts=2018-12-04 01:32:19;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69</span><br><span class="line">    @demo.MathGame.run()</span><br><span class="line">        at demo.MathGame.main(MathGame.java:16)</span><br></pre></td></tr></table></figure><h5><span id="据条件表达式来过滤">据条件表达式来过滤</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack demo.MathGame primeFactors <span class="string">&#x27;params[0]&lt;0&#x27;</span> -n 2</span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> stack demo.MathGame primeFactors <span class="string">&#x27;params[0]&lt;0&#x27;</span> -n 2</span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 30 ms.</span><br><span class="line">ts=2018-12-04 01:34:27;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69</span><br><span class="line">    @demo.MathGame.run()</span><br><span class="line">        at demo.MathGame.main(MathGame.java:16)</span><br><span class="line"></span><br><span class="line">ts=2018-12-04 01:34:30;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69</span><br><span class="line">    @demo.MathGame.run()</span><br><span class="line">        at demo.MathGame.main(MathGame.java:16)</span><br><span class="line"></span><br><span class="line">Command execution times exceed limit: 2, so command will exit. You can set it with -n option.</span><br></pre></td></tr></table></figure><h5><span id="据执行时间来过滤">据执行时间来过滤</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack demo.MathGame primeFactors <span class="string">&#x27;#cost&gt;5&#x27;</span></span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> stack demo.MathGame primeFactors <span class="string">&#x27;#cost&gt;5&#x27;</span></span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 35 ms.</span><br><span class="line">ts=2018-12-04 01:35:58;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69</span><br><span class="line">    @demo.MathGame.run()</span><br><span class="line">        at demo.MathGame.main(MathGame.java:16)</span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>在“stack”中，我们演示了了Arthas的stack命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas trace命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthastrace%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthastrace%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8arthas-demo">启动arthas demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#trace%E5%91%BD%E4%BB%A4">trace命令</a><ul><li><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">参数说明</a></li><li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83">使用参考</a><ul><li><a href="#trace%E5%87%BD%E6%95%B0">trace函数</a></li><li><a href="#trace%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6">trace次数限制</a></li><li><a href="#%E5%8C%85%E5%90%ABjdk%E7%9A%84%E5%87%BD%E6%95%B0">包含jdk的函数</a></li><li><a href="#%E6%8D%AE%E8%B0%83%E7%94%A8%E8%80%97%E6%97%B6%E8%BF%87%E6%BB%A4">据调用耗时过滤</a></li><li><a href="#trace%E5%A4%9A%E4%B8%AA%E7%B1%BB%E6%88%96%E8%80%85%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0">trace多个类或者多个函数</a></li></ul></li><li><a href="#%E5%8A%A8%E6%80%81trace">动态trace</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthastrace%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示trace命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动arthas-demo">启动arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthastrace%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="trace命令">trace命令</span></h2><blockquote><p>方法内部调用路径，并输出方法路径上的每个节点上耗时</p></blockquote><p><code>trace</code> 命令能主动搜索 <code>class-pattern</code>／<code>method-pattern</code> 对应的方法调用路径，渲染和统计整个调用链路上的所有性能开销和追踪调用链路。</p><h4><span id="参数说明">参数说明</span></h4><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr><tr><td><em>method-pattern</em></td><td>方法名表达式匹配</td></tr><tr><td><em>condition-express</em></td><td>条件表达式</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr><tr><td><code>[n:]</code></td><td>命令执行次数</td></tr><tr><td><code>#cost</code></td><td>方法执行耗时</td></tr></tbody></table><p>这里重点要说明的是观察表达式，观察表达式的构成主要由 ognl 表达式组成，所以你可以这样写<code>&quot;&#123;params,returnObj&#125;&quot;</code>，只要是一个合法的 ognl 表达式，都能被正常支持。</p><p>观察的维度也比较多，主要体现在参数 <code>advice</code> 的数据结构上。<code>Advice</code> 参数最主要是封装了通知节点的所有信息。 请参考<a href="https://shell.aliyun.com/tutorial">表达式核心变量</a>中关于该节点的描述。</p><ul><li>特殊用法请参考：<a href="https://github.com/alibaba/arthas/issues/71">https://github.com/alibaba/arthas/issues/71</a></li><li>OGNL表达式官网：<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html">https://commons.apache.org/proper/commons-ognl/language-guide.html</a></li></ul><p>很多时候我们只想看到某个方法的rt大于某个时间之后的trace结果，现在Arthas可以按照方法执行的耗时来进行过滤了，例如<code>trace *StringUtils isBlank &#39;#cost&gt;100&#39;</code>表示当执行时间超过100ms的时候，才会输出trace的结果。</p><blockquote><p>watch/stack/trace这个三个命令都支持<code>#cost</code></p></blockquote><h4><span id="注意事项">注意事项</span></h4><p><code>trace</code> 能方便的帮助你定位和发现因 RT 高而导致的性能问题缺陷，但其每次只能跟踪一级方法的调用链路。</p><p>参考：<a href="https://github.com/alibaba/arthas/issues/597">Trace命令的实现原理</a></p><p>3.3.0 版本后，可以使用动态Trace功能，不断增加新的匹配类，参考下面的示例。</p><h4><span id="使用参考">使用参考</span></h4><h5><span id="trace函数">trace函数</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace demo.MathGame run</span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> trace demo.MathGame run</span></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 28 ms.</span><br><span class="line">`---ts=2019-12-04 00:45:08;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69;    `---[0.617465ms] demo.MathGame:run()</span><br><span class="line">        `---[0.078946ms] demo.MathGame:primeFactors() #24 [throws Exception]</span><br><span class="line"></span><br><span class="line">`---ts=2019-12-04 00:45:09;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69;    `---[1.276874ms] demo.MathGame:run()</span><br><span class="line">        `---[0.03752ms] demo.MathGame:primeFactors() #24 [throws Exception]</span><br></pre></td></tr></table></figure><h5><span id="trace次数限制">trace次数限制</span></h5><p>如果方法调用的次数很多，那么可以用<code>-n</code>参数指定捕捉结果的次数。比如下面的例子里，捕捉到一次调用就退出命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace demo.MathGame run -n 1</span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> trace demo.MathGame run -n 1</span></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 20 ms.</span><br><span class="line">`---ts=2019-12-04 00:45:53;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69;    `---[0.549379ms] demo.MathGame:run()</span><br><span class="line">        +---[0.059839ms] demo.MathGame:primeFactors() #24</span><br><span class="line">        `---[0.232887ms] demo.MathGame:print() #25</span><br><span class="line"></span><br><span class="line">Command execution times exceed limit: 1, so command will exit. You can set it with -n option.</span><br></pre></td></tr></table></figure><h5><span id="包含jdk的函数">包含jdk的函数</span></h5><ul><li><code>--skipJDKMethod &lt;value&gt;</code> skip jdk method trace, default value true.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace --skipJDKMethod <span class="literal">false</span> demo.MathGame run</span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><p>默认情况下，trace不会包含jdk里的函数调用，如果希望trace jdk里的函数，需要显式设置<code>--skipJDKMethod false</code>。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> trace --skipJDKMethod <span class="literal">false</span> demo.MathGame run</span></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 60 ms.</span><br><span class="line">`---ts=2019-12-04 00:44:41;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69;    `---[1.357742ms] demo.MathGame:run()</span><br><span class="line">        +---[0.028624ms] java.util.Random:nextInt() #23</span><br><span class="line">        +---[0.045534ms] demo.MathGame:primeFactors() #24 [throws Exception]</span><br><span class="line">        +---[0.005372ms] java.lang.StringBuilder:&lt;init&gt;() #28</span><br><span class="line">        +---[0.012257ms] java.lang.Integer:valueOf() #28</span><br><span class="line">        +---[0.234537ms] java.lang.String:format() #28</span><br><span class="line">        +---[min=0.004539ms,max=0.005778ms,total=0.010317ms,count=2] java.lang.StringBuilder:append() #28</span><br><span class="line">        +---[0.013777ms] java.lang.Exception:getMessage() #28</span><br><span class="line">        +---[0.004935ms] java.lang.StringBuilder:toString() #28</span><br><span class="line">        `---[0.06941ms] java.io.PrintStream:println() #28</span><br><span class="line"></span><br><span class="line">`---ts=2019-12-04 00:44:42;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69;    `---[3.030432ms] demo.MathGame:run()</span><br><span class="line">        +---[0.010473ms] java.util.Random:nextInt() #23</span><br><span class="line">        +---[0.023715ms] demo.MathGame:primeFactors() #24 [throws Exception]</span><br><span class="line">        +---[0.005198ms] java.lang.StringBuilder:&lt;init&gt;() #28</span><br><span class="line">        +---[0.006405ms] java.lang.Integer:valueOf() #28</span><br><span class="line">        +---[0.178583ms] java.lang.String:format() #28</span><br><span class="line">        +---[min=0.011636ms,max=0.838077ms,total=0.849713ms,count=2] java.lang.StringBuilder:append() #28</span><br><span class="line">        +---[0.008747ms] java.lang.Exception:getMessage() #28</span><br><span class="line">        +---[0.019768ms] java.lang.StringBuilder:toString() #28</span><br><span class="line">        `---[0.076457ms] java.io.PrintStream:println() #28</span><br></pre></td></tr></table></figure><h5><span id="据调用耗时过滤">据调用耗时过滤</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace demo.MathGame run <span class="string">&#x27;#cost &gt; 10&#x27;</span></span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> trace demo.MathGame run <span class="string">&#x27;#cost &gt; 10&#x27;</span></span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 41 ms.</span><br><span class="line">`---ts=2018-12-04 01:12:02;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69;    `---[12.033735ms] demo.MathGame:run()</span><br><span class="line">        +---[0.006783ms] java.util.Random:nextInt()</span><br><span class="line">        +---[11.852594ms] demo.MathGame:primeFactors()</span><br><span class="line">        `---[0.05447ms] demo.MathGame:print()</span><br></pre></td></tr></table></figure><blockquote><p>只会展示耗时大于10ms的调用路径，有助于在排查问题的时候，只关注异常情况</p></blockquote><ul><li>是不是很眼熟，没错，在 JProfiler 等收费软件中你曾经见识类似的功能，这里你将可以通过命令就能打印出指定调用路径。 友情提醒下，<code>trace</code> 在执行的过程中本身是会有一定的性能开销，在统计的报告中并未像 JProfiler 一样预先减去其自身的统计开销。所以这统计出来有些许的不准，渲染路径上调用的类、方法越多，性能偏差越大。但还是能让你看清一些事情的。</li><li>[12.033735ms] 的含义，<code>12.033735</code> 的含义是：当前节点在当前步骤的耗时，单位为毫秒</li><li>[0,0,0ms,11]xxx:yyy() [throws Exception]，对该方法中相同的方法调用进行了合并，<code>0,0,0ms,11</code> 表示方法调用耗时，<code>min,max,total,count</code>；<code>throws Exception</code> 表明该方法调用中存在异常返回</li><li>这里存在一个统计不准确的问题，就是所有方法耗时加起来可能会小于该监测方法的总耗时，这个是由于 Arthas 本身的逻辑会有一定的耗时</li></ul><h5><span id="trace多个类或者多个函数">trace多个类或者多个函数</span></h5><p>trace命令只会trace匹配到的函数里的子调用，并不会向下trace多层。因为trace是代价比较贵的，多层trace可能会导致最终要trace的类和函数非常多。</p><p>可以用正则表匹配路径上的多个类和函数，一定程度上达到多层trace的效果。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace -E com.test.ClassA|org.test.ClassB method1|method2|method3</span><br></pre></td></tr></table></figure><h4><span id="动态trace">动态trace</span></h4><p>3.3.0 版本后支持。 打开终端1，trace <code>run</code>函数，可以看到打印出 <code>listenerId: 1</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace demo.MathGame run</span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@59161]$</span><span class="bash"> trace demo.MathGame run</span></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class count: 1 , method count: 1) cost in 112 ms, listenerId: 1</span><br><span class="line">`---ts=2020-07-09 16:48:11;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69;    `---[1.389634ms] demo.MathGame:run()</span><br><span class="line">        `---[0.123934ms] demo.MathGame:primeFactors() #24 [throws Exception]</span><br><span class="line"></span><br><span class="line">`---ts=2020-07-09 16:48:12;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69;    `---[3.716391ms] demo.MathGame:run()</span><br><span class="line">        +---[3.182813ms] demo.MathGame:primeFactors() #24</span><br><span class="line">        `---[0.167786ms] demo.MathGame:print() #25</span><br></pre></td></tr></table></figure><p>现在想要深入子函数<code>primeFactors</code>，可以打开一个新终端2，使用<code>telnet localhost 3658</code>连接上arthas，再trace <code>primeFactors</code>时，指定<code>listenerId</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace demo.MathGame primeFactors --listenerId 1</span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@59161]$</span><span class="bash"> trace demo.MathGame primeFactors --listenerId 1</span></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class count: 1 , method count: 1) cost in 34 ms, listenerId: 1</span><br></pre></td></tr></table></figure><p>这时终端2打印的结果，说明已经增强了一个函数：<code>Affect(class count: 1 , method count: 1)</code>，但不再打印更多的结果。</p><p>再查看终端1，可以发现trace的结果增加了一层，打印了<code>primeFactors</code>函数里的内容：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">`---ts=2020-07-09 16:49:29;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69;    `---[0.492551ms] demo.MathGame:run()</span><br><span class="line">        `---[0.113929ms] demo.MathGame:primeFactors() #24 [throws Exception]</span><br><span class="line">            `---[0.061462ms] demo.MathGame:primeFactors()</span><br><span class="line">                `---[0.001018ms] throw:java.lang.IllegalArgumentException() #46</span><br><span class="line"></span><br><span class="line">`---ts=2020-07-09 16:49:30;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69;    `---[0.409446ms] demo.MathGame:run()</span><br><span class="line">        +---[0.232606ms] demo.MathGame:primeFactors() #24</span><br><span class="line">        |   `---[0.1294ms] demo.MathGame:primeFactors()</span><br><span class="line">        `---[0.084025ms] demo.MathGame:print() #25</span><br></pre></td></tr></table></figure><p>通过指定<code>listenerId</code>的方式动态trace，可以不断深入。另外 <code>watch</code>/<code>tt</code>/<code>monitor</code>等命令也支持类似的功能。</p><h2><span id="更多信息">更多信息</span></h2><p>在“trace”中，我们演示了了Arthas的trace命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas tt命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthastt%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthastt%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8arthas-demo">启动arthas demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#tt%E5%91%BD%E4%BB%A4">tt命令</a><ul><li><a href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83">使用参考</a><ul><li><a href="#%E8%AE%B0%E5%BD%95%E8%B0%83%E7%94%A8">记录调用</a></li><li><a href="#%E6%A3%80%E7%B4%A2%E8%B0%83%E7%94%A8%E8%AE%B0%E5%BD%95">检索调用记录</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E8%B0%83%E7%94%A8%E4%BF%A1%E6%81%AF">查看调用信息</a></li><li><a href="#%E9%87%8D%E5%81%9A%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8">重做一次调用</a></li></ul></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthastt%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示tt命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动arthas-demo">启动arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthastt%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="tt命令">tt命令</span></h2><blockquote><p>方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</p></blockquote><p><code>watch</code> 虽然很方便和灵活，但需要提前想清楚观察表达式的拼写，这对排查问题而言要求太高，因为很多时候我们并不清楚问题出自于何方，只能靠蛛丝马迹进行猜测。</p><p>这个时候如果能记录下当时方法调用的所有入参和返回值、抛出的异常会对整个问题的思考与判断非常有帮助。</p><p>于是乎，TimeTunnel 命令就诞生了。</p><h4><span id="使用参考">使用参考</span></h4><h5><span id="记录调用">记录调用</span></h5><p>对于一个最基本的使用来说，就是记录下当前方法的每次调用环境现场。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -t demo.MathGame primeFactors</span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tt -t demo.MathGame primeFactors</span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 66 ms.</span><br><span class="line"> INDEX   TIMESTAMP            COST(ms)  IS-RET  IS-EXP   OBJECT         CLASS                          METHOD</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> 1000    2018-12-04 11:15:38  1.096236  false   true     0x4b67cf4d     MathGame                       primeFactors</span><br><span class="line"> 1001    2018-12-04 11:15:39  0.191848  false   true     0x4b67cf4d     MathGame                       primeFactors</span><br><span class="line"> 1002    2018-12-04 11:15:40  0.069523  false   true     0x4b67cf4d     MathGame                       primeFactors</span><br><span class="line"> 1003    2018-12-04 11:15:41  0.186073  false   true     0x4b67cf4d     MathGame                       primeFactors</span><br><span class="line"> 1004    2018-12-04 11:15:42  17.76437  true    false    0x4b67cf4d     MathGame                       primeFactors</span><br></pre></td></tr></table></figure><ul><li><p>命令参数解析</p><ul><li><p><code>-t</code></p><p>tt 命令有很多个主参数，<code>-t</code> 就是其中之一。这个参数的表明希望记录下类 <code>*Test</code> 的 <code>print</code> 方法的每次执行情况。</p></li><li><p><code>-n 3</code></p><p>当你执行一个调用量不高的方法时可能你还能有足够的时间用 <code>CTRL+C</code> 中断 tt 命令记录的过程，但如果遇到调用量非常大的方法，瞬间就能将你的 JVM 内存撑爆。</p><p>此时你可以通过 <code>-n</code> 参数指定你需要记录的次数，当达到记录次数时 Arthas 会主动中断tt命令的记录过程，避免人工操作无法停止的情况。</p></li></ul></li><li><p>表格字段说明</p></li></ul><table><thead><tr><th>表格字段</th><th>字段解释</th></tr></thead><tbody><tr><td>INDEX</td><td>时间片段记录编号，每一个编号代表着一次调用，后续tt还有很多命令都是基于此编号指定记录操作，非常重要。</td></tr><tr><td>TIMESTAMP</td><td>方法执行的本机时间，记录了这个时间片段所发生的本机时间</td></tr><tr><td>COST(ms)</td><td>方法执行的耗时</td></tr><tr><td>IS-RET</td><td>方法是否以正常返回的形式结束</td></tr><tr><td>IS-EXP</td><td>方法是否以抛异常的形式结束</td></tr><tr><td>OBJECT</td><td>执行对象的<code>hashCode()</code>，注意，曾经有人误认为是对象在JVM中的内存地址，但很遗憾他不是。但他能帮助你简单的标记当前执行方法的类实体</td></tr><tr><td>CLASS</td><td>执行的类名</td></tr><tr><td>METHOD</td><td>执行的方法名</td></tr></tbody></table><ul><li><p>条件表达式</p><p>不知道大家是否有在使用过程中遇到以下困惑</p><ul><li>Arthas 似乎很难区分出重载的方法</li><li>我只需要观察特定参数，但是 tt 却全部都给我记录了下来</li></ul><p>条件表达式也是用 <code>OGNL</code> 来编写，核心的判断对象依然是 <code>Advice</code> 对象。除了 <code>tt</code> 命令之外，<code>watch</code>、<code>trace</code>、<code>stack</code> 命令也都支持条件表达式。</p></li><li><p>解决方法重载</p><p><code>tt -t *Test print params.length==1</code></p><p>通过制定参数个数的形式解决不同的方法签名，如果参数个数一样，你还可以这样写</p><p><code>tt -t *Test print &#39;params[1] instanceof Integer&#39;</code></p></li><li><p>解决指定参数</p><p><code>tt -t *Test print params[0].mobile==&quot;13989838402&quot;</code></p></li><li><p>构成条件表达式的 <code>Advice</code> 对象</p><p>前边看到了很多条件表达式中，都使用了 <code>params[0]</code>，有关这个变量的介绍，请参考<a href="https://arthas.aliyun.com/doc/advice-class.html">表达式核心变量</a></p></li></ul><h5><span id="检索调用记录">检索调用记录</span></h5><p>当你用 <code>tt</code> 记录了一大片的时间片段之后，你希望能从中筛选出自己需要的时间片段，这个时候你就需要对现有记录进行检索。</p><p>假设我们有这些记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -l</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tt -l</span></span><br><span class="line"> INDEX   TIMESTAMP            COST(ms)  IS-RET  IS-EXP   OBJECT         CLASS                          METHOD</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> 1000    2018-12-04 11:15:38  1.096236  false   true     0x4b67cf4d     MathGame                       primeFactors</span><br><span class="line"> 1001    2018-12-04 11:15:39  0.191848  false   true     0x4b67cf4d     MathGame                       primeFactors</span><br><span class="line"> 1002    2018-12-04 11:15:40  0.069523  false   true     0x4b67cf4d     MathGame                       primeFactors</span><br><span class="line"> 1003    2018-12-04 11:15:41  0.186073  false   true     0x4b67cf4d     MathGame                       primeFactors</span><br><span class="line"> 1004    2018-12-04 11:15:42  17.76437  true    false    0x4b67cf4d     MathGame                       primeFactors</span><br><span class="line">                              9</span><br><span class="line"> 1005    2018-12-04 11:15:43  0.4776    false   true     0x4b67cf4d     MathGame                       primeFactors</span><br><span class="line">Affect(row-cnt:6) cost in 4 ms.</span><br></pre></td></tr></table></figure><p>我需要筛选出 <code>primeFactors</code> 方法的调用信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -s <span class="string">&#x27;method.name==&quot;primeFactors&quot;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tt -s <span class="string">&#x27;method.name==&quot;primeFactors&quot;&#x27;</span></span></span><br><span class="line"> INDEX   TIMESTAMP            COST(ms)  IS-RET  IS-EXP   OBJECT         CLASS                          METHOD</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> 1000    2018-12-04 11:15:38  1.096236  false   true     0x4b67cf4d     MathGame                       primeFactors</span><br><span class="line"> 1001    2018-12-04 11:15:39  0.191848  false   true     0x4b67cf4d     MathGame                       primeFactors</span><br><span class="line"> 1002    2018-12-04 11:15:40  0.069523  false   true     0x4b67cf4d     MathGame                       primeFactors</span><br><span class="line"> 1003    2018-12-04 11:15:41  0.186073  false   true     0x4b67cf4d     MathGame                       primeFactors</span><br><span class="line"> 1004    2018-12-04 11:15:42  17.76437  true    false    0x4b67cf4d     MathGame                       primeFactors</span><br><span class="line">                              9</span><br><span class="line"> 1005    2018-12-04 11:15:43  0.4776    false   true     0x4b67cf4d     MathGame                       primeFactors</span><br><span class="line">Affect(row-cnt:6) cost in 607 ms.</span><br></pre></td></tr></table></figure><p>你需要一个 <code>-s</code> 参数。同样的，搜索表达式的核心对象依旧是 <code>Advice</code> 对象。</p><h5><span id="查看调用信息">查看调用信息</span></h5><p>对于具体一个时间片的信息而言，你可以通过 <code>-i</code> 参数后边跟着对应的 <code>INDEX</code> 编号查看到他的详细信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -i 1003</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tt -i 1003</span></span><br><span class="line"> INDEX            1003</span><br><span class="line"> GMT-CREATE       2018-12-04 11:15:41</span><br><span class="line"> COST(ms)         0.186073</span><br><span class="line"> OBJECT           0x4b67cf4d</span><br><span class="line"> CLASS            demo.MathGame</span><br><span class="line"> METHOD           primeFactors</span><br><span class="line"> IS-RETURN        false</span><br><span class="line"> IS-EXCEPTION     true</span><br><span class="line"> PARAMETERS[0]    @Integer[-564322413]</span><br><span class="line"> THROW-EXCEPTION  java.lang.IllegalArgumentException: number is: -564322413, need &gt;= 2</span><br><span class="line">                      at demo.MathGame.primeFactors(MathGame.java:46)</span><br><span class="line">                      at demo.MathGame.run(MathGame.java:24)</span><br><span class="line">                      at demo.MathGame.main(MathGame.java:16)</span><br><span class="line"></span><br><span class="line">Affect(row-cnt:1) cost in 11 ms.</span><br></pre></td></tr></table></figure><h5><span id="重做一次调用">重做一次调用</span></h5><p>当你稍稍做了一些调整之后，你可能需要前端系统重新触发一次你的调用，此时得求爷爷告奶奶的需要前端配合联调的同学再次发起一次调用。而有些场景下，这个调用不是这么好触发的。</p><p><code>tt</code> 命令由于保存了当时调用的所有现场信息，所以我们可以自己主动对一个 <code>INDEX</code> 编号的时间片自主发起一次调用，从而解放你的沟通成本。此时你需要 <code>-p</code> 参数。通过 <code>--replay-times</code> 指定 调用次数，通过 <code>--replay-interval</code> 指定多次调用间隔(单位ms, 默认1000ms)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -i 1004 -p</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tt -i 1004 -p</span></span><br><span class="line"> RE-INDEX       1004</span><br><span class="line"> GMT-REPLAY     2018-12-04 11:26:00</span><br><span class="line"> OBJECT         0x4b67cf4d</span><br><span class="line"> CLASS          demo.MathGame</span><br><span class="line"> METHOD         primeFactors</span><br><span class="line"> PARAMETERS[0]  @Integer[946738738]</span><br><span class="line"> IS-RETURN      true</span><br><span class="line"> IS-EXCEPTION   false</span><br><span class="line"> COST(ms)         0.186073</span><br><span class="line"> RETURN-OBJ     @ArrayList[</span><br><span class="line">                    @Integer[2],</span><br><span class="line">                    @Integer[11],</span><br><span class="line">                    @Integer[17],</span><br><span class="line">                    @Integer[2531387],</span><br><span class="line">                ]</span><br><span class="line">Time fragment[1004] successfully replayed.</span><br><span class="line">Affect(row-cnt:1) cost in 14 ms.</span><br></pre></td></tr></table></figure><p>你会发现结果虽然一样，但调用的路径发生了变化，有原来的程序发起变成了 Arthas 自己的内部线程发起的调用了。</p><ul><li><p>需要强调的点</p><ol><li><p><strong>ThreadLocal 信息丢失</strong></p><p>很多框架偷偷的将一些环境变量信息塞到了发起调用线程的 ThreadLocal 中，由于调用线程发生了变化，这些 ThreadLocal 线程信息无法通过 Arthas 保存，所以这些信息将会丢失。</p><p>一些常见的 CASE 比如：鹰眼的 TraceId 等。</p></li><li><p><strong>引用的对象</strong></p><p>需要强调的是，<code>tt</code> 命令是将当前环境的对象引用保存起来，但仅仅也只能保存一个引用而已。如果方法内部对入参进行了变更，或者返回的对象经过了后续的处理，那么在 <code>tt</code> 查看的时候将无法看到当时最准确的值。这也是为什么 <code>watch</code> 命令存在的意义。</p></li></ol></li></ul><h2><span id="更多信息">更多信息</span></h2><p>在“tt”中，我们演示了了Arthas的tt命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas watch命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthaswatch%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthaswatch%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8arthas-demo">启动arthas demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#watch%E5%91%BD%E4%BB%A4">watch命令</a><ul><li><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">参数说明</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83">使用参考</a><ul><li><a href="#%E8%A7%82%E5%AF%9F%E6%96%B9%E6%B3%95%E5%87%BA%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC">观察方法出参和返回值</a></li><li><a href="#%E8%A7%82%E5%AF%9F%E6%96%B9%E6%B3%95%E5%85%A5%E5%8F%82">观察方法入参</a></li><li><a href="#%E5%90%8C%E6%97%B6%E8%A7%82%E5%AF%9F%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%89%8D%E5%92%8C%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%90%8E">同时观察方法调用前和方法返回后</a></li><li><a href="#%E8%B0%83%E6%95%B4-x%E7%9A%84%E5%80%BC%E8%A7%82%E5%AF%9F%E5%85%B7%E4%BD%93%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%80%BC">调整<code>-x</code>的值，观察具体的方法参数值</a></li><li><a href="#%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BE%8B%E5%AD%90">条件表达式的例子</a></li><li><a href="#%E8%A7%82%E5%AF%9F%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF%E7%9A%84%E4%BE%8B%E5%AD%90">观察异常信息的例子</a></li><li><a href="#%E6%8C%89%E7%85%A7%E8%80%97%E6%97%B6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4">按照耗时进行过滤</a></li><li><a href="#%E8%A7%82%E5%AF%9F%E5%BD%93%E5%89%8D%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7">观察当前对象中的属性</a></li></ul></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthaswatch%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示watch命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动arthas-demo">启动arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthaswatch%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="watch命令">watch命令</span></h2><blockquote><p>方法执行数据观测</p></blockquote><p>让你能方便的观察到指定方法的调用情况。能观察到的范围为：<code>返回值</code>、<code>抛出异常</code>、<code>入参</code>，通过编写 OGNL 表达式进行对应变量的查看。</p><h4><span id="参数说明">参数说明</span></h4><p>watch 的参数比较多，主要是因为它能在 4 个不同的场景观察对象</p><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td><em>class-pattern</em></td><td>类名表达式匹配</td></tr><tr><td><em>method-pattern</em></td><td>方法名表达式匹配</td></tr><tr><td><em>express</em></td><td>观察表达式</td></tr><tr><td><em>condition-express</em></td><td>条件表达式</td></tr><tr><td>[b]</td><td>在<strong>方法调用之前</strong>观察</td></tr><tr><td>[e]</td><td>在<strong>方法异常之后</strong>观察</td></tr><tr><td>[s]</td><td>在<strong>方法返回之后</strong>观察</td></tr><tr><td>[f]</td><td>在<strong>方法结束之后</strong>(正常返回和异常返回)观察</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配</td></tr><tr><td>[x:]</td><td>指定输出结果的属性遍历深度，默认为 1</td></tr></tbody></table><p>这里重点要说明的是观察表达式，观察表达式的构成主要由 ognl 表达式组成，所以你可以这样写<code>&quot;&#123;params,returnObj&#125;&quot;</code>，只要是一个合法的 ognl 表达式，都能被正常支持。</p><p>观察的维度也比较多，主要体现在参数 <code>advice</code> 的数据结构上。<code>Advice</code> 参数最主要是封装了通知节点的所有信息。请参考<a href="https://shell.aliyun.com/tutorial">表达式核心变量</a>中关于该节点的描述。</p><ul><li>特殊用法请参考：<a href="https://github.com/alibaba/arthas/issues/71">https://github.com/alibaba/arthas/issues/71</a></li><li>OGNL表达式官网：<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html">https://commons.apache.org/proper/commons-ognl/language-guide.html</a></li></ul><p><strong>特别说明</strong>：</p><ul><li>watch 命令定义了4个观察事件点，即 <code>-b</code> 方法调用前，<code>-e</code> 方法异常后，<code>-s</code> 方法返回后，<code>-f</code> 方法结束后</li><li>4个观察事件点 <code>-b</code>、<code>-e</code>、<code>-s</code> 默认关闭，<code>-f</code> 默认打开，当指定观察点被打开后，在相应事件点会对观察表达式进行求值并输出</li><li>这里要注意<code>方法入参</code>和<code>方法出参</code>的区别，有可能在中间被修改导致前后不一致，除了 <code>-b</code> 事件点 <code>params</code> 代表方法入参外，其余事件都代表方法出参</li><li>当使用 <code>-b</code> 时，由于观察事件点是在方法调用前，此时返回值或异常均不存在</li></ul><h4><span id="使用参考">使用参考</span></h4><h5><span id="观察方法出参和返回值">观察方法出参和返回值</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch demo.MathGame primeFactors <span class="string">&quot;&#123;params,returnObj&#125;&quot;</span> -x 2</span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch demo.MathGame primeFactors <span class="string">&quot;&#123;params,returnObj&#125;&quot;</span> -x 2</span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 44 ms.</span><br><span class="line">ts=2018-12-03 19:16:51; [cost=1.280502ms] result=@ArrayList[</span><br><span class="line">    @Object[][</span><br><span class="line">        @Integer[535629513],</span><br><span class="line">    ],</span><br><span class="line">    @ArrayList[</span><br><span class="line">        @Integer[3],</span><br><span class="line">        @Integer[19],</span><br><span class="line">        @Integer[191],</span><br><span class="line">        @Integer[49199],</span><br><span class="line">    ],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5><span id="观察方法入参">观察方法入参</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch demo.MathGame primeFactors <span class="string">&quot;&#123;params,returnObj&#125;&quot;</span> -x 2 -b</span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch demo.MathGame primeFactors <span class="string">&quot;&#123;params,returnObj&#125;&quot;</span> -x 2 -b</span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 50 ms.</span><br><span class="line">ts=2018-12-03 19:23:23; [cost=0.0353ms] result=@ArrayList[</span><br><span class="line">    @Object[][</span><br><span class="line">        @Integer[-1077465243],</span><br><span class="line">    ],</span><br><span class="line">    null,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>对比前一个例子，返回值为空（事件点为方法执行前，因此获取不到返回值）</li></ul><h5><span id="同时观察方法调用前和方法返回后">同时观察方法调用前和方法返回后</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch demo.MathGame primeFactors <span class="string">&quot;&#123;params,target,returnObj&#125;&quot;</span> -x 2 -b -s -n 2</span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch demo.MathGame primeFactors <span class="string">&quot;&#123;params,target,returnObj&#125;&quot;</span> -x 2 -b -s -n 2</span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 46 ms.</span><br><span class="line">ts=2018-12-03 19:29:54; [cost=0.01696ms] result=@ArrayList[</span><br><span class="line">    @Object[][</span><br><span class="line">        @Integer[1544665400],</span><br><span class="line">    ],</span><br><span class="line">    @MathGame[</span><br><span class="line">        random=@Random[java.util.Random@522b408a],</span><br><span class="line">        illegalArgumentCount=@Integer[13038],</span><br><span class="line">    ],</span><br><span class="line">    null,</span><br><span class="line">]</span><br><span class="line">ts=2018-12-03 19:29:54; [cost=4.277392ms] result=@ArrayList[</span><br><span class="line">    @Object[][</span><br><span class="line">        @Integer[1544665400],</span><br><span class="line">    ],</span><br><span class="line">    @MathGame[</span><br><span class="line">        random=@Random[java.util.Random@522b408a],</span><br><span class="line">        illegalArgumentCount=@Integer[13038],</span><br><span class="line">    ],</span><br><span class="line">    @ArrayList[</span><br><span class="line">        @Integer[2],</span><br><span class="line">        @Integer[2],</span><br><span class="line">        @Integer[2],</span><br><span class="line">        @Integer[5],</span><br><span class="line">        @Integer[5],</span><br><span class="line">        @Integer[73],</span><br><span class="line">        @Integer[241],</span><br><span class="line">        @Integer[439],</span><br><span class="line">    ],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>参数里<code>-n 2</code>，表示只执行两次</li><li>这里输出结果中，第一次输出的是方法调用前的观察表达式的结果，第二次输出的是方法返回后的表达式的结果</li><li>结果的输出顺序和事件发生的先后顺序一致，和命令中 <code>-s -b</code> 的顺序无关</li></ul><h5><span id="调整-x的值观察具体的方法参数值">调整<code>-x</code>的值，观察具体的方法参数值</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch demo.MathGame primeFactors <span class="string">&quot;&#123;params,target&#125;&quot;</span> -x 3</span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch demo.MathGame primeFactors <span class="string">&quot;&#123;params,target&#125;&quot;</span> -x 3</span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 58 ms.</span><br><span class="line">ts=2018-12-03 19:34:19; [cost=0.587833ms] result=@ArrayList[</span><br><span class="line">    @Object[][</span><br><span class="line">        @Integer[47816758],</span><br><span class="line">    ],</span><br><span class="line">    @MathGame[</span><br><span class="line">        random=@Random[</span><br><span class="line">            serialVersionUID=@Long[3905348978240129619],</span><br><span class="line">            seed=@AtomicLong[3133719055989],</span><br><span class="line">            multiplier=@Long[25214903917],</span><br><span class="line">            addend=@Long[11],</span><br><span class="line">            mask=@Long[281474976710655],</span><br><span class="line">            DOUBLE_UNIT=@Double[1.1102230246251565E-16],</span><br><span class="line">            BadBound=@String[bound must be positive],</span><br><span class="line">            BadRange=@String[bound must be greater than origin],</span><br><span class="line">            BadSize=@String[size must be non-negative],</span><br><span class="line">            seedUniquifier=@AtomicLong[-3282039941672302964],</span><br><span class="line">            nextNextGaussian=@Double[0.0],</span><br><span class="line">            haveNextNextGaussian=@Boolean[false],</span><br><span class="line">            serialPersistentFields=@ObjectStreamField[][isEmpty=false;size=3],</span><br><span class="line">            unsafe=@Unsafe[sun.misc.Unsafe@2eaa1027],</span><br><span class="line">            seedOffset=@Long[24],</span><br><span class="line">        ],</span><br><span class="line">        illegalArgumentCount=@Integer[13159],</span><br><span class="line">    ],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li><code>-x</code>表示遍历深度，可以调整来打印具体的参数和结果内容，默认值是1。</li></ul><h5><span id="条件表达式的例子">条件表达式的例子</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch demo.MathGame primeFactors <span class="string">&quot;&#123;params[0],target&#125;&quot;</span> <span class="string">&quot;params[0]&lt;0&quot;</span></span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch demo.MathGame primeFactors <span class="string">&quot;&#123;params[0],target&#125;&quot;</span> <span class="string">&quot;params[0]&lt;0&quot;</span></span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 68 ms.</span><br><span class="line">ts=2018-12-03 19:36:04; [cost=0.530255ms] result=@ArrayList[</span><br><span class="line">    @Integer[-18178089],</span><br><span class="line">    @MathGame[demo.MathGame@41cf53f9],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>只有满足条件的调用，才会有响应。</li><li><code>watch-express</code> 单个值可以不加’{}’，多个值需要加’{a,b,c}’。</li><li><code>condition-express</code> 不能加’{}’，可以使用逗号分隔子表达式，取表达式最后一个值来判断。</li></ul><p>如果watch的方法存在同名的其它重载方法，可以通过下面的办法进行过滤：</p><ul><li><p>根据参数类型进行过滤</p><p><code>watch demo.MathGame primeFactors &#39;&#123;params, params[0].class.name&#125;&#39; &#39;params[0].class.name == &quot;java.lang.Integer&quot;&#39;</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch demo.MathGame primeFactors <span class="string">&#x27;&#123;params, params[0].class.name&#125;&#x27;</span> <span class="string">&#x27;params[0].class.name == &quot;java.lang.Integer&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><ul><li><p>根据参数个数进行过滤</p><p><code>watch demo.MathGame primeFactors &#39;&#123;params, params.length&#125;&#39; &#39;params.length==1&#39;</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch demo.MathGame primeFactors <span class="string">&#x27;&#123;params, params.length&#125;&#x27;</span> <span class="string">&#x27;params.length==1&#x27;</span></span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><h5><span id="观察异常信息的例子">观察异常信息的例子</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch demo.MathGame primeFactors <span class="string">&quot;&#123;params[0],throwExp&#125;&quot;</span> -e -x 2</span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch demo.MathGame primeFactors <span class="string">&quot;&#123;params[0],throwExp&#125;&quot;</span> -e -x 2</span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 62 ms.</span><br><span class="line">ts=2018-12-03 19:38:00; [cost=1.414993ms] result=@ArrayList[</span><br><span class="line">    @Integer[-1120397038],</span><br><span class="line">    java.lang.IllegalArgumentException: number is: -1120397038, need &gt;= 2</span><br><span class="line">    at demo.MathGame.primeFactors(MathGame.java:46)</span><br><span class="line">    at demo.MathGame.run(MathGame.java:24)</span><br><span class="line">    at demo.MathGame.main(MathGame.java:16)</span><br><span class="line">,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li><code>-e</code>表示抛出异常时才触发</li><li>express中，表示异常信息的变量是<code>throwExp</code></li></ul><p>根据异常类型或者message进行过滤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch demo.MathGame primeFactors <span class="string">&#x27;&#123;params, throwExp&#125;&#x27;</span> <span class="string">&#x27;#msg=throwExp.toString(), #msg.contains(&quot;IllegalArgumentException&quot;)&#x27;</span> -e -x 2</span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><h5><span id="按照耗时进行过滤">按照耗时进行过滤</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch demo.MathGame primeFactors <span class="string">&#x27;&#123;params, returnObj&#125;&#x27;</span> <span class="string">&#x27;#cost&gt;200&#x27;</span> -x 2</span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch demo.MathGame primeFactors <span class="string">&#x27;&#123;params, returnObj&#125;&#x27;</span> <span class="string">&#x27;#cost&gt;200&#x27;</span> -x 2</span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 66 ms.</span><br><span class="line">ts=2018-12-03 19:40:28; [cost=2112.168897ms] result=@ArrayList[</span><br><span class="line">    @Object[][</span><br><span class="line">        @Integer[2141897465],</span><br><span class="line">    ],</span><br><span class="line">    @ArrayList[</span><br><span class="line">        @Integer[5],</span><br><span class="line">        @Integer[428379493],</span><br><span class="line">    ],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li><code>#cost&gt;200</code>(单位是<code>ms</code>)表示只有当耗时大于200ms时才会输出，过滤掉执行时间小于200ms的调用</li></ul><h5><span id="观察当前对象中的属性">观察当前对象中的属性</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch demo.MathGame primeFactors <span class="string">&#x27;target&#x27;</span></span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><p>如果想查看方法运行前后，当前对象中的属性，可以使用<code>target</code>关键字，代表当前对象</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch demo.MathGame primeFactors <span class="string">&#x27;target&#x27;</span></span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 52 ms.</span><br><span class="line">ts=2018-12-03 19:41:52; [cost=0.477882ms] result=@MathGame[</span><br><span class="line">    random=@Random[java.util.Random@522b408a],</span><br><span class="line">    illegalArgumentCount=@Integer[13355],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后使用<code>target.field_name</code>访问当前对象的某个属性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch demo.MathGame primeFactors <span class="string">&#x27;target.illegalArgumentCount&#x27;</span></span><br></pre></td></tr></table></figure><p>按<code>q</code>或者<code>Ctrl+c</code>退出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch demo.MathGame primeFactors <span class="string">&#x27;target.illegalArgumentCount&#x27;</span></span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 67 ms.</span><br><span class="line">ts=2018-12-03 20:04:34; [cost=131.303498ms] result=@Integer[8]</span><br><span class="line">ts=2018-12-03 20:04:35; [cost=0.961441ms] result=@Integer[8]</span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>在“watch”中，我们演示了了Arthas的watch命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas getstatic命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasgetstatic%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasgetstatic%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8arthas-demo">启动arthas demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#getstatic%E5%91%BD%E4%BB%A4">getstatic命令</a></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasgetstatic%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示getstatic命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动arthas-demo">启动arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasgetstatic%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="getstatic命令">getstatic命令</span></h2><ul><li>推荐直接使用<a href="https://arthas.aliyun.com/doc/arthas-tutorials.html?language=cn&id=command-ognl">ognl</a>命令，更加灵活。</li></ul><p>通过getstatic命令可以方便的查看类的静态属性。使用方法为<code>getstatic class_name field_name</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getstatic demo.MathGame random</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> getstatic demo.MathGame random</span></span><br><span class="line">field: random</span><br><span class="line">@Random[</span><br><span class="line">    serialVersionUID=@Long[3905348978240129619],</span><br><span class="line">    seed=@AtomicLong[120955813885284],</span><br><span class="line">    multiplier=@Long[25214903917],</span><br><span class="line">    addend=@Long[11],</span><br><span class="line">    mask=@Long[281474976710655],</span><br><span class="line">    DOUBLE_UNIT=@Double[1.1102230246251565E-16],</span><br><span class="line">    BadBound=@String[bound must be positive],</span><br><span class="line">    BadRange=@String[bound must be greater than origin],</span><br><span class="line">    BadSize=@String[size must be non-negative],</span><br><span class="line">    seedUniquifier=@AtomicLong[-3282039941672302964],</span><br><span class="line">    nextNextGaussian=@Double[0.0],</span><br><span class="line">    haveNextNextGaussian=@Boolean[false],</span><br><span class="line">    serialPersistentFields=@ObjectStreamField[][isEmpty=false;size=3],</span><br><span class="line">    unsafe=@Unsafe[sun.misc.Unsafe@2eaa1027],</span><br><span class="line">    seedOffset=@Long[24],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>指定classLoader</li></ul><p>注意hashcode是变化的，需要先查看当前的ClassLoader信息，使用<code>sc -d &lt;ClassName&gt;</code>提取对应ClassLoader的hashcode。</p><p>如果你使用<code>-c</code>，你需要手动输入hashcode：<code>-c &lt;hashcode&gt;</code></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> getstatic -c 3d4eac69 demo.MathGame random</span></span><br></pre></td></tr></table></figure><p>对于只有唯一实例的ClassLoader可以通过<code>--classLoaderClass</code>指定class name，使用起来更加方便：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getstatic --classLoaderClass sun.misc.Launcher<span class="variable">$AppClassLoader</span> demo.MathGame random</span><br></pre></td></tr></table></figure><ul><li>注: 这里classLoaderClass 在 java 8 是 sun.misc.Launcher$AppClassLoader，而java 11的classloader是jdk.internal.loader.ClassLoaders$AppClassLoader，katacoda目前环境是java8。</li></ul><p><code>--classLoaderClass</code> 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而<code>-c &lt;hashcode&gt;</code>是动态变化的。</p><p>如果该静态属性是一个复杂对象，还可以支持在该属性上通过ognl表示进行遍历，过滤，访问对象的内部属性等操作。</p><ul><li>OGNL特殊用法请参考：<a href="https://github.com/alibaba/arthas/issues/71">https://github.com/alibaba/arthas/issues/71</a></li><li>OGNL表达式官方指南：<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html">https://commons.apache.org/proper/commons-ognl/language-guide.html</a></li></ul><h2><span id="更多信息">更多信息</span></h2><p>在“getstatic”中，我们演示了了Arthas的getstatic命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas dashboard命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasdashboard%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasdashboard%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8arthas-demo">启动arthas-demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#dashboard-%E5%91%BD%E4%BB%A4">dashboard 命令</a><ul><li><a href="#%E6%95%B0%E6%8D%AE%E8%AF%B4%E6%98%8E">数据说明</a><ul><li><a href="#jvm%E5%86%85%E9%83%A8%E7%BA%BF%E7%A8%8B">JVM内部线程</a></li></ul></li></ul></li><li><a href="#dashboard-%E6%95%B0%E6%8D%AE%E8%AF%B4%E6%98%8E">dashboard 数据说明</a><ul><li><a href="#%E6%88%AA%E5%9B%BE%E5%B1%95%E7%A4%BA">截图展示</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasdashboard%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示dashboard命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动arthas-demo">启动arthas-demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasdashboard%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="dashboard-命令">dashboard 命令</span></h2><p><code>dashboard</code> 命令可以查看当前系统的实时数据面板。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dashboard</span><br></pre></td></tr></table></figure><p>当运行在Ali-tomcat时，会显示当前tomcat的实时信息，如HTTP请求的qps, rt, 错误数, 线程池信息等等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ dashboard</span><br><span class="line">ID   NAME                           GROUP           PRIORITY   STATE     %CPU      DELTA_TIME TIME      INTERRUPTE DAEMON</span><br><span class="line">-1   C2 CompilerThread0             -               -1         -         1.55      0.077      0:8.684   false      true</span><br><span class="line">53   Timer-for-arthas-dashboard-07b system          5          RUNNABLE  0.08      0.004      0:0.004   false      true</span><br><span class="line">22   scheduling-1                   main            5          TIMED_WAI 0.06      0.003      0:0.287   false      false</span><br><span class="line">-1   C1 CompilerThread0             -               -1         -         0.06      0.003      0:2.171   false      true</span><br><span class="line">-1   VM Periodic Task Thread        -               -1         -         0.03      0.001      0:0.092   false      true</span><br><span class="line">49   arthas-NettyHttpTelnetBootstra system          5          RUNNABLE  0.02      0.001      0:0.156   false      true</span><br><span class="line">16   Catalina-utility-1             main            1          TIMED_WAI 0.0       0.000      0:0.029   false      false</span><br><span class="line">-1   G1 Young RemSet Sampling       -               -1         -         0.0       0.000      0:0.019   false      true</span><br><span class="line">17   Catalina-utility-2             main            1          WAITING   0.0       0.000      0:0.025   false      false</span><br><span class="line">34   http-nio-8080-ClientPoller     main            5          RUNNABLE  0.0       0.000      0:0.016   false      true</span><br><span class="line">23   http-nio-8080-BlockPoller      main            5          RUNNABLE  0.0       0.000      0:0.011   false      true</span><br><span class="line">-1   VM Thread                      -               -1         -         0.0       0.000      0:0.032   false      true</span><br><span class="line">-1   Service Thread                 -               -1         -         0.0       0.000      0:0.006   false      true</span><br><span class="line">-1   GC Thread#5                    -               -1         -         0.0       0.000      0:0.043   false      true</span><br><span class="line">Memory                     used     total    max      usage    GC</span><br><span class="line">heap                       36M      70M      4096M    0.90%    gc.g1_young_generation.count   12</span><br><span class="line">g1_eden_space              6M       18M      -1       33.33%                                  86</span><br><span class="line">g1_old_gen                 30M      50M      4096M    0.74%    gc.g1_old_generation.count     0</span><br><span class="line">g1_survivor_space          491K     2048K    -1       24.01%   gc.g1_old_generation.time(ms)  0</span><br><span class="line">nonheap                    66M      69M      -1       96.56%</span><br><span class="line">codeheap_&#x27;non-nmethods&#x27;    1M       2M       5M       22.39%</span><br><span class="line">metaspace                  46M      47M      -1       98.01%</span><br><span class="line">Runtime</span><br><span class="line">os.name                                                        Mac OS X</span><br><span class="line">os.version                                                     10.15.4</span><br><span class="line">java.version                                                   15</span><br><span class="line">java.home                                                      /Library/Java/JavaVirtualMachines/jdk-15.jdk/Contents/Home</span><br><span class="line">systemload.average                                             10.68</span><br><span class="line">processors                                                     8</span><br><span class="line">uptime                                                         272s</span><br></pre></td></tr></table></figure><p>输入 <code>q</code> 或者 <code>Ctrl+C</code> 可以退出dashboard命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><h4><span id="数据说明">数据说明</span></h4><ul><li>ID: Java级别的线程ID，注意这个ID不能跟jstack中的nativeID一一对应。</li><li>NAME: 线程名</li><li>GROUP: 线程组名</li><li>PRIORITY: 线程优先级, 1~10之间的数字，越大表示优先级越高</li><li>STATE: 线程的状态</li><li>CPU%: 线程的cpu使用率。比如采样间隔1000ms，某个线程的增量cpu时间为100ms，则cpu使用率=100/1000=10%</li><li>DELTA_TIME: 上次采样之后线程运行增量CPU时间，数据格式为<code>秒</code></li><li>TIME: 线程运行总CPU时间，数据格式为<code>分:秒</code></li><li>INTERRUPTED: 线程当前的中断位状态</li><li>DAEMON: 是否是daemon线程</li></ul><h5><span id="jvm内部线程">JVM内部线程</span></h5><p>Java 8之后支持获取JVM内部线程CPU时间，这些线程只有名称和CPU时间，没有ID及状态等信息（显示ID为-1）。 通过内部线程可以观测到JVM活动，如GC、JIT编译等占用CPU情况，方便了解JVM整体运行状况。</p><ul><li>当JVM 堆(heap)/元数据(metaspace)空间不足或OOM时，可以看到GC线程的CPU占用率明显高于其他的线程。</li><li>当执行<code>trace/watch/tt/redefine</code>等命令后，可以看到JIT线程活动变得更频繁。因为JVM热更新class字节码时清除了此class相关的JIT编译结果，需要重新编译。</li></ul><p>JVM内部线程包括下面几种：</p><ul><li>JIT编译线程: 如 <code>C1 CompilerThread0</code>, <code>C2 CompilerThread0</code></li><li>GC线程: 如<code>GC Thread0</code>, <code>G1 Young RemSet Sampling</code></li><li>其它内部线程: 如<code>VM Periodic Task Thread</code>, <code>VM Thread</code>, <code>Service Thread</code></li></ul><h2><span id="dashboard-数据说明">dashboard 数据说明</span></h2><ul><li><em>ID</em>: Java级别的线程ID，注意这个ID不能跟jstack中的nativeID一一对应</li><li><em>NAME</em>: 线程名</li><li><em>GROUP</em>: 线程组名</li><li><em>PRIORITY</em>: 线程优先级, 1~10之间的数字，越大表示优先级越高</li><li><em>STATE</em>: 线程的状态</li><li><em>CPU%</em>: 线程消耗的cpu占比，采样100ms，将所有线程在这100ms内的cpu使用量求和，再算出每个线程的cpu使用占比。</li><li><em>TIME</em>: 线程运行总时间，数据格式为<code>分：秒</code></li><li><em>INTERRUPTED</em>: 线程当前的中断位状态</li><li><em>DAEMON</em>: 是否是daemon线程</li></ul><h3><span id="截图展示">截图展示</span></h3><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasdashboard%E5%91%BD%E4%BB%A4/dashboard.png" alt="img"></p><h2><span id="更多信息">更多信息</span></h2><p>通过本教程基本掌握了Arthas dashboard的用法。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas heapdump命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasheapdump%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasheapdump%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8arthas-demo">启动arthas demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#heapdump%E5%91%BD%E4%BB%A4">heapdump命令</a><ul><li><a href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83">使用参考</a><ul><li><a href="#dump%E5%88%B0%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6">dump到指定文件</a></li><li><a href="#%E5%8F%AAdump-live%E5%AF%B9%E8%B1%A1">只dump live对象</a></li></ul></li><li><a href="#dump%E5%88%B0%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6">dump到临时文件</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasheapdump%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示heapdump命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动arthas-demo">启动arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasheapdump%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="heapdump命令">heapdump命令</span></h2><blockquote><p>dump java heap, 类似jmap命令的heap dump功能。</p><h4><span id="使用参考">使用参考</span></h4></blockquote><h5><span id="dump到指定文件">dump到指定文件</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heapdump /tmp/dump.hprof</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@58205]$</span><span class="bash"> heapdump /tmp/dump.hprof</span></span><br><span class="line">Dumping heap to /tmp/dump.hprof...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure><h5><span id="只dump-live对象">只dump live对象</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heapdump --live /tmp/dump.hprof</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@58205]$</span><span class="bash"> heapdump --live /tmp/dump.hprof</span></span><br><span class="line">Dumping heap to /tmp/dump.hprof...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure><h4><span id="dump到临时文件">dump到临时文件</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heapdump</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@58205]$</span><span class="bash"> heapdump</span></span><br><span class="line">Dumping heap to /var/folders/my/wy7c9w9j5732xbkcyt1mb4g40000gp/T/heapdump2019-09-03-16-385121018449645518991.hprof...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>在“heapdump”中，我们演示了了Arthas的heapdump命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas jvm命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasjvm%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasjvm%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#arthas-demo">Arthas demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#jvm%E5%91%BD%E4%BB%A4">jvm命令</a><ul><li><a href="#%E6%9F%A5%E6%89%BEjava%E5%BA%94%E7%94%A8%E7%9A%84classpath">查找Java应用的classpath</a></li></ul></li><li><a href="#jvm%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83">jvm使用参考</a></li><li><a href="#jvm%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83-1">jvm使用参考</a><ul><li><a href="#thread%E7%9B%B8%E5%85%B3">THREAD相关</a></li><li><a href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9B%B8%E5%85%B3">文件描述符相关</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasjvm%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示jvm命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="arthas-demo">Arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasjvm%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="jvm命令">jvm命令</span></h2><p><code>jvm</code> 命令可以查看当前JVM信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jvm</span><br></pre></td></tr></table></figure><h3><span id="查找java应用的classpath">查找Java应用的classpath</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jvm | grep PATH</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@41064]$</span><span class="bash"> jvm | grep PATH</span></span><br><span class="line"> CLASS-PATH                             packaging/target/arthas-bin/arthas-demo.jar</span><br><span class="line"> BOOT-CLASS-PATH                        /Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home/jre/lib/resources.jar:/Librar</span><br><span class="line"> LIBRARY-PATH                           /Users/gongdewei/Library/Java/Extensions:/Library/Java/Extensions:/Network/Library/Java/Extens</span><br></pre></td></tr></table></figure><h2><span id="jvm使用参考">jvm使用参考</span></h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jvm</span></span><br><span class="line">RUNTIME</span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line"> MACHINE-NAME                   37@ff267334bb65</span><br><span class="line"> JVM-START-TIME                 2020-07-23 07:50:36</span><br><span class="line"> MANAGEMENT-SPEC-VERSION        1.2</span><br><span class="line"> SPEC-NAME                      Java Virtual Machine Specification</span><br><span class="line"> SPEC-VENDOR                    Oracle Corporation</span><br><span class="line"> SPEC-VERSION                   1.8</span><br><span class="line"> VM-NAME                        Java HotSpot(TM) 64-Bit Server VM</span><br><span class="line"> VM-VENDOR                      Oracle Corporation</span><br><span class="line"> VM-VERSION                     25.201-b09</span><br><span class="line"> INPUT-ARGUMENTS                []</span><br><span class="line"> CLASS-PATH                     demo-arthas-spring-boot.jar</span><br><span class="line"> BOOT-CLASS-PATH                /usr/lib/jvm/java-8-oracle/jre/lib/resources.jar:/usr/lib/jvm/java-8-oracle/j</span><br><span class="line">                                re/lib/rt.jar:/usr/lib/jvm/java-8-oracle/jre/lib/sunrsasign.jar:/usr/lib/jvm/</span><br><span class="line">                                java-8-oracle/jre/lib/jsse.jar:/usr/lib/jvm/java-8-oracle/jre/lib/jce.jar:/us</span><br><span class="line">                                r/lib/jvm/java-8-oracle/jre/lib/charsets.jar:/usr/lib/jvm/java-8-oracle/jre/l</span><br><span class="line">                                ib/jfr.jar:/usr/lib/jvm/java-8-oracle/jre/classes</span><br><span class="line"> LIBRARY-PATH                   /usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line"> CLASS-LOADING</span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line"> LOADED-CLASS-COUNT             7529</span><br><span class="line"> TOTAL-LOADED-CLASS-COUNT       7529</span><br><span class="line"> UNLOADED-CLASS-COUNT           0</span><br><span class="line"> IS-VERBOSE                     false</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line"> COMPILATION</span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line"> NAME                           HotSpot 64-Bit Tiered Compilers</span><br><span class="line"> TOTAL-COMPILE-TIME             14921(ms)</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line"> GARBAGE-COLLECTORS</span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line"> PS Scavenge                            name : PS Scavenge                                                                             </span><br><span class="line"> [count/time (ms)]                      collectionCount : 7                                                                            </span><br><span class="line">                                        collectionTime : 68                                                                            </span><br><span class="line"></span><br><span class="line"> PS MarkSweep                           name : PS MarkSweep                                                                            </span><br><span class="line"> [count/time (ms)]                      collectionCount : 1                                                                            </span><br><span class="line">                                        collectionTime : 47 </span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line"> MEMORY-MANAGERS</span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line"> CodeCacheManager               Code Cache</span><br><span class="line"></span><br><span class="line"> Metaspace Manager              Metaspace</span><br><span class="line">                                Compressed Class Space</span><br><span class="line"></span><br><span class="line"> Copy                           Eden Space</span><br><span class="line">                                Survivor Space</span><br><span class="line"></span><br><span class="line"> MarkSweepCompact               Eden Space</span><br><span class="line">                                Survivor Space</span><br><span class="line">                                Tenured Gen</span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line"> MEMORY</span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line"> HEAP-MEMORY-USAGE                      init : 268435456(256.0 MiB)                                                                    </span><br><span class="line"> [memory in bytes]                      used : 18039504(17.2 MiB)                                                                      </span><br><span class="line">                                        committed : 181403648(173.0 MiB)                                                               </span><br><span class="line">                                        max : 3817865216(3.6 GiB)                                                                      </span><br><span class="line"></span><br><span class="line"> NO-HEAP-MEMORY-USAGE                   init : 2555904(2.4 MiB)                                                                        </span><br><span class="line"> [memory in bytes]                      used : 33926216(32.4 MiB)                                                                      </span><br><span class="line">                                        committed : 35176448(33.5 MiB)                                                                 </span><br><span class="line">                                        max : -1(-1 B)  </span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line"> OPERATING-SYSTEM</span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line"> OS                             Linux</span><br><span class="line"> ARCH                           amd64</span><br><span class="line"> PROCESSORS-COUNT               3</span><br><span class="line"> LOAD-AVERAGE                   29.53</span><br><span class="line"> VERSION                        4.15.0-52-generic</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line"> THREAD</span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line"> COUNT                          30</span><br><span class="line"> DAEMON-COUNT                   24</span><br><span class="line"> PEAK-COUNT                     31</span><br><span class="line"> STARTED-COUNT                  36</span><br><span class="line"> DEADLOCK-COUNT                 0</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line"> FILE-DESCRIPTOR</span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line"> MAX-FILE-DESCRIPTOR-COUNT      1048576</span><br><span class="line"> OPEN-FILE-DESCRIPTOR-COUNT     100</span><br><span class="line">Affect(row-cnt:0) cost in 88 ms.</span><br></pre></td></tr></table></figure><h2><span id="jvm使用参考">jvm使用参考</span></h2><h4><span id="thread相关">THREAD相关</span></h4><ul><li><code>COUNT</code>: JVM当前活跃的线程数</li><li><code>DAEMON-COUNT</code>: JVM当前活跃的守护线程数</li><li><code>PEAK-COUNT</code>: 从JVM启动开始曾经活着的最大线程数</li><li><code>STARTED-COUNT</code>: 从JVM启动开始总共启动过的线程次数</li><li><code>DEADLOCK-COUNT</code>: JVM当前死锁的线程数</li></ul><h4><span id="文件描述符相关">文件描述符相关</span></h4><ul><li><code>MAX-FILE-DESCRIPTOR-COUNT</code>：JVM进程最大可以打开的文件描述符数</li><li><code>OPEN-FILE-DESCRIPTOR-COUNT</code>：JVM当前打开的文件描述符数</li></ul><h2><span id="更多信息">更多信息</span></h2><p>在“jvm”中，我们演示了了Arthas的jvm命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas mbean命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasmbean%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasmbean%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#arthas-demo">Arthas demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#mbean%E5%91%BD%E4%BB%A4">mbean命令</a><ul><li><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">参数说明</a></li></ul><ul><li><a href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83">使用参考</a><ul><li><a href="#%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89-mbean-%E7%9A%84%E5%90%8D%E7%A7%B0">列出所有 Mbean 的名称</a></li><li><a href="#%E6%9F%A5%E7%9C%8B-mbean-%E7%9A%84%E5%85%83%E4%BF%A1%E6%81%AF">查看 Mbean 的元信息</a></li><li><a href="#%E6%9F%A5%E7%9C%8Bmbean%E5%B1%9E%E6%80%A7%E4%BF%A1%E6%81%AF">查看mbean属性信息</a></li><li><a href="#mbean%E7%9A%84name%E6%94%AF%E6%8C%81%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D">mbean的name支持通配符匹配</a></li><li><a href="#%E5%A4%9A%E5%B1%9E%E6%80%A7%E5%90%8D%E7%A7%B0%E7%9A%84%E5%8C%B9%E9%85%8D">多属性名称的匹配</a></li><li><a href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D%E7%89%B9%E5%AE%9A%E7%9A%84%E5%B1%9E%E6%80%A7%E5%AD%97%E6%AE%B5">通配符匹配特定的属性字段</a></li><li><a href="#%E4%BD%BF%E7%94%A8-e%E5%91%BD%E4%BB%A4%E5%88%87%E6%8D%A2%E4%B8%BA%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D">使用<code>-E</code>命令切换为正则匹配</a></li><li><a href="#%E4%BD%BF%E7%94%A8-i%E5%91%BD%E4%BB%A4%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7">使用<code>-i</code>命令实时监控</a></li></ul></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasmbean%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示mbean命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="arthas-demo">Arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasmbean%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="mbean命令">mbean命令</span></h2><p>查看 Mbean 的信息</p><p>这个命令可以便捷的查看或监控 Mbean 的属性信息。</p><h4><span id="参数说明">参数说明</span></h4><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td>name-pattern</td><td>名称表达式匹配</td></tr><tr><td>attribute-pattern</td><td>属性名表达式匹配</td></tr><tr><td>[m]</td><td>查看元信息</td></tr><tr><td>[i:]</td><td>刷新属性值的时间间隔 (ms)</td></tr><tr><td>[n:]</td><td>刷新属性值的次数</td></tr><tr><td>[E]</td><td>开启正则表达式匹配，默认为通配符匹配。仅对属性名有效</td></tr></tbody></table><h3><span id="使用参考">使用参考</span></h3><h4><span id="列出所有-mbean-的名称">列出所有 Mbean 的名称</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbean</span><br></pre></td></tr></table></figure><h4><span id="查看-mbean-的元信息">查看 Mbean 的元信息</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbean -m java.lang:<span class="built_in">type</span>=Threading</span><br></pre></td></tr></table></figure><h4><span id="查看mbean属性信息">查看mbean属性信息</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbean java.lang:<span class="built_in">type</span>=Threading </span><br></pre></td></tr></table></figure><h4><span id="mbean的name支持通配符匹配">mbean的name支持通配符匹配</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbean java.lang:<span class="built_in">type</span>=Th*</span><br></pre></td></tr></table></figure><p>注意：ObjectName 的匹配规则与正常的通配符存在差异，详细参见：<a href="https://docs.oracle.com/javase/8/docs/api/javax/management/ObjectName.html?is-external=true">javax.management.ObjectName</a></p><h4><span id="多属性名称的匹配">多属性名称的匹配</span></h4><p>查看内存池：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbean java.lang:name=*,<span class="built_in">type</span>=MemoryPool</span><br></pre></td></tr></table></figure><h4><span id="通配符匹配特定的属性字段">通配符匹配特定的属性字段</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbean java.lang:<span class="built_in">type</span>=Threading *Count</span><br></pre></td></tr></table></figure><h4><span id="使用-e命令切换为正则匹配">使用<code>-E</code>命令切换为正则匹配</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbean -E java.lang:<span class="built_in">type</span>=Threading PeakThreadCount|ThreadCount|DaemonThreadCount</span><br></pre></td></tr></table></figure><p>查看内存池：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbean -E java.lang:name=*,<span class="built_in">type</span>=MemoryPool Name|Usage|Type | grep <span class="string">&quot; HEAP&quot;</span> -A3 -B1</span><br></pre></td></tr></table></figure><h4><span id="使用-i命令实时监控">使用<code>-i</code>命令实时监控</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbean -i 1000 java.lang:<span class="built_in">type</span>=Threading *Count</span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>在“mbean”中，我们演示了了Arthas的mbean命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas logger命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthaslogger%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthaslogger%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8demo">启动demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#logger%E5%91%BD%E4%BB%A4">logger命令</a><ul><li><a href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83">使用参考</a><ul><li><a href="#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89logger%E4%BF%A1%E6%81%AF">查看所有logger信息</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E6%8C%87%E5%AE%9A%E5%90%8D%E5%AD%97%E7%9A%84logger%E4%BF%A1%E6%81%AF">查看指定名字的logger信息</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E6%8C%87%E5%AE%9Aclassloader%E7%9A%84logger%E4%BF%A1%E6%81%AF">查看指定classloader的logger信息</a></li><li><a href="#%E6%9B%B4%E6%96%B0logger-level">更新logger level</a></li><li><a href="#%E6%8C%87%E5%AE%9Aclassloader%E6%9B%B4%E6%96%B0-logger-level">指定classloader更新 logger level</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E6%B2%A1%E6%9C%89appender%E7%9A%84logger%E7%9A%84%E4%BF%A1%E6%81%AF">查看没有appender的logger的信息</a></li></ul></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthaslogger%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个普通的Spring Boot应用为例，演示logger命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动demo">启动demo</span></h2><p>下载<code>demo-arthas-spring-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar</span><br></pre></td></tr></table></figure><p><code>demo-arthas-spring-boot</code>是一个很简单的spring boot应用，源代码：<a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-arthas-spring-boot">查看</a></p><p>启动之后，可以访问61000端口： 点击查看</p><p><img src="https://img.alicdn.com/imgextra/i2/O1CN010Qbzcz1ctPSWSZI6L_!!6000000003658-2-tps-333-182.png" alt="Demo Web"></p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthaslogger%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="logger命令">logger命令</span></h2><p>查看logger信息，更新logger level</p><h4><span id="使用参考">使用参考</span></h4><h5><span id="查看所有logger信息">查看所有logger信息</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@2062]$</span><span class="bash"> logger</span></span><br><span class="line"> name              ROOT</span><br><span class="line"> class             ch.qos.logback.classic.Logger</span><br><span class="line"> classLoader       org.springframework.boot.loader.LaunchedURLClassLoader@5674cd4d</span><br><span class="line"> classLoaderHash   5674cd4d</span><br><span class="line"> level             INFO</span><br><span class="line"> effectiveLevel    INFO</span><br><span class="line"> additivity        true</span><br><span class="line"> codeSource        jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/lib/logback-classi</span><br><span class="line">                   c-1.1.11.jar!/</span><br><span class="line"> appenders         name            CONSOLE</span><br><span class="line">                   class           ch.qos.logback.core.ConsoleAppender</span><br><span class="line">                   classLoader     org.springframework.boot.loader.LaunchedURLClassLoader@5674cd4d</span><br><span class="line">                   classLoaderHash 5674cd4d</span><br><span class="line">                   target          System.out</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5><span id="查看指定名字的logger信息">查看指定名字的logger信息</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger -n org.springframework.web</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@2062]$</span><span class="bash"> logger -n org.springframework.web</span></span><br><span class="line"> name              org.springframework.web</span><br><span class="line"> class             ch.qos.logback.classic.Logger</span><br><span class="line"> classLoader       org.springframework.boot.loader.LaunchedURLClassLoader@5674cd4d</span><br><span class="line"> classLoaderHash   5674cd4d</span><br><span class="line"> level             null</span><br><span class="line"> effectiveLevel    INFO</span><br><span class="line"> additivity        true</span><br><span class="line"> codeSource        jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/lib/logback-classi</span><br><span class="line">                   c-1.1.11.jar!/</span><br></pre></td></tr></table></figure><p>请记下你的classLoaderHash，后面需要使用它。在这里，它是 <code>5674cd4d</code>。</p><p>注意：请使用你的classLoaderHash值覆盖 <code>&lt;classLoaderHash&gt;</code> ，然后手动执行下面所述命令：</p><h5><span id="查看指定classloader的logger信息">查看指定classloader的logger信息</span></h5><p>注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。</p><p>如果你使用<code>-c</code>，你需要手动输入hashcode：<code>-c &lt;hashcode&gt;</code></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> logger -c 5674cd4d</span></span><br></pre></td></tr></table></figure><p>对于只有唯一实例的ClassLoader可以通过<code>--classLoaderClass</code>指定class name，使用起来更加方便：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@2062]$</span><span class="bash"> logger --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader</span></span><br><span class="line">name              ROOT</span><br><span class="line"> class             ch.qos.logback.classic.Logger</span><br><span class="line"> classLoader       org.springframework.boot.loader.LaunchedURLClassLoader@5674cd4d</span><br><span class="line"> classLoaderHash   5674cd4d</span><br><span class="line"> level             INFO</span><br><span class="line"> effectiveLevel    INFO</span><br><span class="line"> additivity        true</span><br><span class="line"> codeSource        jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/lib/logback-classi</span><br><span class="line">                   c-1.1.11.jar!/</span><br><span class="line"> appenders         name            CONSOLE</span><br><span class="line">                   class           ch.qos.logback.core.ConsoleAppender</span><br><span class="line">                   classLoader     org.springframework.boot.loader.LaunchedURLClassLoader@5674cd4d</span><br><span class="line">                   classLoaderHash 5674cd4d</span><br><span class="line">                   target          System.out</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>--classLoaderClass</code> 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而<code>-c &lt;hashcode&gt;</code>是动态变化的。</p><h5><span id="更新logger-level">更新logger level</span></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger --name ROOT --level debug</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@2062]$</span><span class="bash"> logger --name ROOT --level debug</span></span><br><span class="line">update logger level success.</span><br></pre></td></tr></table></figure><p>注意：在教程中执行会提示错误，需要指定classloader</p><h5><span id="指定classloader更新-logger-level">指定classloader更新 logger level</span></h5><p>默认情况下，logger命令会在SystemClassloader下执行，如果应用是传统的<code>war</code>应用，或者spring boot fat jar启动的应用，那么需要指定classloader。</p><p>可以先用 <code>sc -d yourClassName</code> 来查看具体的 classloader hashcode，然后在更新level时指定classloader：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader --name ROOT --level debug</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@2062]$</span><span class="bash"> logger --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader --name ROOT --level debug</span></span><br></pre></td></tr></table></figure><h5><span id="查看没有appender的logger的信息">查看没有appender的logger的信息</span></h5><p>默认情况下，<code>logger</code>命令只打印有appender的logger的信息。如果想查看没有<code>appender</code>的logger的信息，可以加上参数<code>--include-no-appender</code>。</p><p>注意，通常输出结果会很长。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger --include-no-appender</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@2062]$</span><span class="bash"> logger --include-no-appender</span></span><br><span class="line"> name              org.thymeleaf</span><br><span class="line"> class             ch.qos.logback.classic.Logger</span><br><span class="line"> classLoader       org.springframework.boot.loader.LaunchedURLClassLoader@5674cd4d</span><br><span class="line"> classLoaderHash   5674cd4d</span><br><span class="line"> level             null</span><br><span class="line"> effectiveLevel    INFO</span><br><span class="line"> additivity        false</span><br><span class="line"> codeSource        jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/lib/logback-classi</span><br><span class="line">                   c-1.1.11.jar!/</span><br><span class="line"> appenders         name            DEBUG_LEVEL_REMAPPER</span><br><span class="line">                   class           org.springframework.boot.logging.logback.LevelRemappingAppender</span><br><span class="line">                   classLoader     org.springframework.boot.loader.LaunchedURLClassLoader@5674cd4d</span><br><span class="line">                   classLoaderHash 5674cd4d</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>在“logger”中，我们演示了了Arthas的logger命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas ognl</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasognl%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasognl%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8demo">启动demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boothelp%E5%91%BD%E4%BB%A4">启动arthas-boot，help命令</a></li><li><a href="#ognl%E8%AF%A6%E8%A7%A3">Ognl详解</a><ul><li><a href="#%E8%B0%83%E7%94%A8static%E5%87%BD%E6%95%B0">调用static函数</a></li><li><a href="#%E6%9F%A5%E6%89%BEusercontroller%E7%9A%84classloader">查找UserController的ClassLoader</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E9%9D%99%E6%80%81%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5">获取静态类的静态字段</a></li><li><a href="#%E6%89%A7%E8%A1%8C%E5%A4%9A%E8%A1%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%B5%8B%E5%80%BC%E7%BB%99%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAlist">执行多行表达式，赋值给临时变量，返回一个List</a></li><li><a href="#%E6%9B%B4%E5%A4%9A">更多</a></li></ul></li><li><a href="#%E6%A1%88%E4%BE%8B-%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E5%BA%94%E7%94%A8logger-level">案例: 动态更新应用Logger Level</a><ul><li><a href="#%E6%9F%A5%E6%89%BEusercontroller%E7%9A%84classloader-1">查找UserController的ClassLoader</a></li><li><a href="#%E7%94%A8ognl%E8%8E%B7%E5%8F%96logger">用ognl获取logger</a></li><li><a href="#%E5%8D%95%E7%8B%AC%E8%AE%BE%E7%BD%AEusercontroller%E7%9A%84logger-level">单独设置UserController的logger level</a></li><li><a href="#%E4%BF%AE%E6%94%B9logback%E7%9A%84%E5%85%A8%E5%B1%80logger-level">修改logback的全局logger level</a></li></ul></li><li><a href="#%E6%A1%88%E4%BE%8B-%E6%8E%92%E6%9F%A5logger%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98">案例: 排查logger冲突问题</a><ul><li><a href="#%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%94%A8%E4%BD%BF%E7%94%A8%E7%9A%84logger%E7%B3%BB%E7%BB%9F">确认应用使用的logger系统</a></li><li><a href="#%E8%8E%B7%E5%8F%96logback%E5%AE%9E%E9%99%85%E5%8A%A0%E8%BD%BD%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">获取logback实际加载的配置文件</a></li><li><a href="#%E4%BD%BF%E7%94%A8classloader%E5%91%BD%E4%BB%A4%E6%9F%A5%E6%89%BE%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84logger%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">使用classloader命令查找可能存在的logger配置文件</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasognl%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个普通的Spring Boot应用为例，演示ognl命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动demo">启动demo</span></h2><p>下载<code>demo-arthas-spring-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar</span><br></pre></td></tr></table></figure><p><code>demo-arthas-spring-boot</code>是一个很简单的spring boot应用，源代码：<a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-arthas-spring-boot">查看</a></p><p>启动之后，可以访问61000端口： 点击查看</p><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasognl%E5%91%BD%E4%BB%A4/O1CN010Qbzcz1ctPSWSZI6L_!!6000000003658-2-tps-333-182.png" alt="Demo Web"></p><h2><span id="启动arthas-boothelp命令">启动arthas-boot，help命令</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasognl%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="ognl详解">Ognl详解</span></h2><p>在Arthas里，有一个单独的<code>ognl</code>命令，可以动态执行代码。 查看用法：<code>ognl --help</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h4><span id="调用static函数">调用static函数</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl <span class="string">&#x27;@java.lang.System@out.println(&quot;hello ognl&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><p>可以检查<code>Terminal 1</code>里的进程输出，可以发现打印出了<code>hello ognl</code>。</p><h4><span id="查找usercontroller的classloader">查找UserController的ClassLoader</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span></span><br><span class="line"> classLoaderHash   1be6f5c3</span><br></pre></td></tr></table></figure><p>注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。</p><p>如果你使用<code>-c</code>，你需要手动输入hashcode：<code>-c &lt;hashcode&gt;</code></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl -c 1be6f5c3 @com.example.demo.arthas.user.UserController@logger</span></span><br></pre></td></tr></table></figure><p>对于只有唯一实例的ClassLoader可以通过<code>--classLoaderClass</code>指定class name，使用起来更加方便：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader  @org.springframework.boot.SpringApplication@logger</span></span><br><span class="line">@Slf4jLocationAwareLog[</span><br><span class="line">    FQCN=@String[org.apache.commons.logging.LogAdapter$Slf4jLocationAwareLog],</span><br><span class="line">    name=@String[org.springframework.boot.SpringApplication],</span><br><span class="line">    logger=@Logger[Logger[org.springframework.boot.SpringApplication]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>--classLoaderClass</code> 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而<code>-c &lt;hashcode&gt;</code>是动态变化的。</p><h4><span id="获取静态类的静态字段">获取静态类的静态字段</span></h4><p>获取<code>UserController</code>类里的<code>logger</code>字段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader @com.example.demo.arthas.user.UserController@logger</span><br></pre></td></tr></table></figure><p>还可以通过<code>-x</code>参数控制返回值的展开层数。比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -x 2 @com.example.demo.arthas.user.UserController@logger</span><br></pre></td></tr></table></figure><h4><span id="执行多行表达式赋值给临时变量返回一个list">执行多行表达式，赋值给临时变量，返回一个List</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl <span class="string">&#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl <span class="string">&#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27;</span></span></span><br><span class="line">@ArrayList[</span><br><span class="line">    @String[/Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre],</span><br><span class="line">    @String[Java(TM) SE Runtime Environment],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4><span id="更多">更多</span></h4><p>在Arthas里<code>ognl</code>表达式是很重要的功能，在很多命令里都可以使用<code>ognl</code>表达式。</p><p>一些更复杂的用法，可以参考：</p><ul><li>OGNL特殊用法请参考：<a href="https://github.com/alibaba/arthas/issues/71">https://github.com/alibaba/arthas/issues/71</a></li><li>OGNL表达式官方指南：<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html">https://commons.apache.org/proper/commons-ognl/language-guide.html</a></li></ul><h2><span id="案例-动态更新应用logger-level">案例: 动态更新应用Logger Level</span></h2><p>在这个案例里，动态修改应用的Logger Level。</p><h4><span id="查找usercontroller的classloader">查找UserController的ClassLoader</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span></span><br><span class="line"> classLoaderHash   1be6f5c3</span><br></pre></td></tr></table></figure><h4><span id="用ognl获取logger">用ognl获取logger</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span></span></span><br><span class="line">@Logger[</span><br><span class="line">    serialVersionUID=@Long[5454405123156820674],</span><br><span class="line">    FQCN=@String[ch.qos.logback.classic.Logger],</span><br><span class="line">    name=@String[com.example.demo.arthas.user.UserController],</span><br><span class="line">    level=null,</span><br><span class="line">    effectiveLevelInt=@Integer[20000],</span><br><span class="line">    parent=@Logger[Logger[com.example.demo.arthas.user]],</span><br><span class="line">    childrenList=null,</span><br><span class="line">    aai=null,</span><br><span class="line">    additive=@Boolean[true],</span><br><span class="line">    loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以知道<code>UserController@logger</code>实际使用的是logback。可以看到<code>level=null</code>，则说明实际最终的level是从<code>root</code> logger里来的。</p><h4><span id="单独设置usercontroller的logger-level">单独设置UserController的logger level</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger.setLevel(@ch.qos.logback.classic.Level@DEBUG)&#x27;</span></span><br></pre></td></tr></table></figure><p>再次获取<code>UserController@logger</code>，可以发现已经是<code>DEBUG</code>了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span></span></span><br><span class="line">@Logger[</span><br><span class="line">    serialVersionUID=@Long[5454405123156820674],</span><br><span class="line">    FQCN=@String[ch.qos.logback.classic.Logger],</span><br><span class="line">    name=@String[com.example.demo.arthas.user.UserController],</span><br><span class="line">    level=@Level[DEBUG],</span><br><span class="line">    effectiveLevelInt=@Integer[10000],</span><br><span class="line">    parent=@Logger[Logger[com.example.demo.arthas.user]],</span><br><span class="line">    childrenList=null,</span><br><span class="line">    aai=null,</span><br><span class="line">    additive=@Boolean[true],</span><br><span class="line">    loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4><span id="修改logback的全局logger-level">修改logback的全局logger level</span></h4><p>通过获取<code>root</code> logger，可以修改全局的logger level：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@org.slf4j.LoggerFactory@getLogger(&quot;root&quot;).setLevel(@ch.qos.logback.classic.Level@DEBUG)&#x27;</span></span><br></pre></td></tr></table></figure><h2><span id="案例-排查logger冲突问题">案例: 排查logger冲突问题</span></h2><p>在这个案例里，展示排查logger冲突的方法。</p><h4><span id="确认应用使用的logger系统">确认应用使用的logger系统</span></h4><p>以<code>UserController</code>为例，它使用的是slf4j api，但实际使用到的logger系统是logback。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span></span></span><br><span class="line">@Logger[</span><br><span class="line">    serialVersionUID=@Long[5454405123156820674],</span><br><span class="line">    FQCN=@String[ch.qos.logback.classic.Logger],</span><br><span class="line">    name=@String[com.example.demo.arthas.user.UserController],</span><br><span class="line">    level=null,</span><br><span class="line">    effectiveLevelInt=@Integer[20000],</span><br><span class="line">    parent=@Logger[Logger[com.example.demo.arthas.user]],</span><br><span class="line">    childrenList=null,</span><br><span class="line">    aai=null,</span><br><span class="line">    additive=@Boolean[true],</span><br><span class="line">    loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4><span id="获取logback实际加载的配置文件">获取logback实际加载的配置文件</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;#map1=@org.slf4j.LoggerFactory@getLogger(&quot;root&quot;).loggerContext.objectMap, #map1.get(&quot;CONFIGURATION_WATCH_LIST&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h4><span id="使用classloader命令查找可能存在的logger配置文件">使用classloader命令查找可能存在的logger配置文件</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml</span><br><span class="line"> jar:file:/Users/hengyunabc/code/java/spring-boot-inside/demo-arthas-spring-boot/target/demo-arthas-spring-boot-0.0.1-SNAPSHOT.jar!/BOOT-INF/classes!/logback-spring.xml</span><br><span class="line"></span><br><span class="line">Affect(row-cnt:1) cost in 13 ms.</span><br></pre></td></tr></table></figure><p>可以知道加载的配置的具体来源。</p><p>可以尝试加载容易冲突的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback.xml</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r log4j.properties</span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>在“ognl”中，我们演示了了Arthas的ognl命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas perfcounter命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasperfcounter%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasperfcounter%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#arthas-demo">Arthas demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#perfcounter%E5%91%BD%E4%BB%A4">perfcounter命令</a><ul><li><a href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83">使用参考</a></li><li><a href="#%E5%A4%87%E6%B3%A8-%E5%AF%B9%E4%BA%8Ejdk9%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8">备注: 对于jdk9以上的应用</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasperfcounter%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示perfcounter命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="arthas-demo">Arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasperfcounter%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="perfcounter命令">perfcounter命令</span></h2><p>查看当前JVM的 Perf Counter信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perfcounter -h</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">USAGE:</span><br><span class="line">  perfcounter [-d] [-h]</span><br><span class="line"></span><br><span class="line">SUMMARY:</span><br><span class="line">  Display the perf counter information.</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">  perfcounter</span><br><span class="line">  perfcounter -d</span><br><span class="line"></span><br><span class="line">WIKI:</span><br><span class="line">  https://arthas.aliyun.com/doc/perfcounter</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">-d, --details                        print all perf counter details</span><br><span class="line">-h, --help                           this help</span><br></pre></td></tr></table></figure><h3><span id="使用参考">使用参考</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perfcounter</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> perfcounter</span></span><br><span class="line"> java.ci.totalTime                            2325637411</span><br><span class="line"> java.cls.loadedClasses                       3403</span><br><span class="line"> java.cls.sharedLoadedClasses                 0</span><br><span class="line"> java.cls.sharedUnloadedClasses               0</span><br><span class="line"> java.cls.unloadedClasses                     0</span><br><span class="line"> java.property.java.version                   11.0.4</span><br><span class="line"> java.property.java.vm.info                   mixed mode</span><br><span class="line"> java.property.java.vm.name                   OpenJDK 64-Bit Server VM</span><br></pre></td></tr></table></figure><p>可以用-d参数打印更多信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perfcounter -d</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> perfcounter -d</span></span><br><span class="line"> Name                                   Variability   Units        Value</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line"> java.ci.totalTime                      Monotonic     Ticks        3242526906</span><br><span class="line"> java.cls.loadedClasses                 Monotonic     Events       3404</span><br><span class="line"> java.cls.sharedLoadedClasses           Monotonic     Events       0</span><br><span class="line"> java.cls.sharedUnloadedClasses         Monotonic     Events       0</span><br><span class="line"> java.cls.unloadedClasses               Monotonic     Events       0</span><br></pre></td></tr></table></figure><h3><span id="备注-对于jdk9以上的应用">备注: 对于jdk9以上的应用</span></h3><p>如果没有打印出信息，应用在启动时，加下面的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--add-opens java.base/jdk.internal.perf=ALL-UNNAMED --add-exports java.base/jdk.internal.perf=ALL-UNNAMED</span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>在“perfcounter”中，我们演示了了Arthas的perfcounter命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas sysprop命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthassysprop%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthassysprop%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#arthas-demo">Arthas demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#sysprop%E5%91%BD%E4%BB%A4">sysprop命令</a><ul><li><a href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83">使用参考</a></li></ul></li><li><a href="#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7">查看所有属性</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E5%8D%95%E4%B8%AA%E5%B1%9E%E6%80%A7">查看单个属性</a><ul><li><a href="#%E4%BF%AE%E6%94%B9%E5%8D%95%E4%B8%AA%E5%B1%9E%E6%80%A7">修改单个属性</a></li></ul></li><li><a href="#%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8">自动补全</a></li><li><a href="#%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4%E7%9A%84%E8%A1%A5%E5%85%A8">历史命令的补全</a></li><li><a href="#%E7%AE%A1%E9%81%93">管道</a><ul><li><a href="#%E9%80%9A%E8%BF%87grep%E6%9D%A5%E8%BF%87%E6%BB%A4">通过<code>grep</code>来过滤</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthassysprop%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示sysprop命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="arthas-demo">Arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthassysprop%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="sysprop命令">sysprop命令</span></h2><p><code>sysprop</code> 命令可以查看当前JVM的系统属性(<code>System Property</code>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysprop</span><br></pre></td></tr></table></figure><h3><span id="使用参考">使用参考</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysprop -h</span><br><span class="line">sysprop -h</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">USAGE:</span><br><span class="line">   sysprop [-h] [property-name] [property-value]</span><br><span class="line"></span><br><span class="line"> SUMMARY:</span><br><span class="line">   Display, and change all the system properties.</span><br><span class="line"></span><br><span class="line"> EXAMPLES:</span><br><span class="line"> sysprop</span><br><span class="line"> sysprop file.encoding</span><br><span class="line"> sysprop production.mode true</span><br><span class="line"></span><br><span class="line"> WIKI:</span><br><span class="line">   https://arthas.aliyun.com/doc/sysprop</span><br><span class="line"></span><br><span class="line"> OPTIONS:</span><br><span class="line"> -h, --help                                  this help</span><br><span class="line"> &lt;property-name&gt;                             property name</span><br><span class="line"> &lt;property-value&gt;                            property value</span><br></pre></td></tr></table></figure><h2><span id="查看所有属性">查看所有属性</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysprop</span><br><span class="line">sysprop</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sysprop</span></span><br><span class="line"> KEY                                                  VALUE</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> java.runtime.name                                    Java(TM) SE Runtime Environment</span><br><span class="line"> sun.boot.library.path                                /Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Contents/Home/jre/lib</span><br><span class="line"> java.vm.version                                      25.51-b03</span><br><span class="line"> user.country.format                                  CN</span><br><span class="line"> gopherProxySet                                       false</span><br><span class="line"> java.vm.vendor                                       Oracle Corporation</span><br><span class="line"> java.vendor.url                                      http://java.oracle.com/</span><br><span class="line"> path.separator                                       :</span><br><span class="line"> java.vm.name                                         Java HotSpot(TM) 64-Bit Server VM</span><br><span class="line"> file.encoding.pkg                                    sun.io</span><br><span class="line"> user.country                                         US</span><br><span class="line"> sun.java.launcher                                    SUN_STANDARD</span><br><span class="line"> sun.os.patch.level                                   unknown</span><br><span class="line"> java.vm.specification.name                           Java Virtual Machine Specification</span><br><span class="line"> user.dir                                             /private/var/tmp</span><br><span class="line"> java.runtime.version                                 1.8.0_51-b16</span><br><span class="line"> java.awt.graphicsenv                                 sun.awt.CGraphicsEnvironment</span><br><span class="line"> java.endorsed.dirs                                   /Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Contents/Home/jre/lib/endors</span><br><span class="line">                                                      ed</span><br><span class="line"> os.arch                                              x86_64</span><br><span class="line"> java.io.tmpdir                                       /var/folders/2c/tbxwzs4s4sbcvh7frbcc7n000000gn/T/</span><br><span class="line"> line.separator</span><br><span class="line"></span><br><span class="line"> java.vm.specification.vendor                         Oracle Corporation</span><br><span class="line"> os.name                                              Mac OS X</span><br><span class="line"> sun.jnu.encoding                                     UTF-8</span><br><span class="line"> java.library.path                                    /Users/wangtao/Library/Java/Extensions:/Library/Java/Extensions:/Network/Libra</span><br><span class="line">                                                      ry/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java:.</span><br><span class="line"> sun.nio.ch.bugLevel</span><br><span class="line"> java.specification.name                              Java Platform API Specification</span><br><span class="line"> java.class.version                                   52.0</span><br><span class="line"> sun.management.compiler                              HotSpot 64-Bit Tiered Compilers</span><br><span class="line"> os.version                                           10.12.6</span><br><span class="line"> user.home                                            /Users/wangtao</span><br><span class="line"> user.timezone                                        Asia/Shanghai</span><br><span class="line"> java.awt.printerjob                                  sun.lwawt.macosx.CPrinterJob</span><br><span class="line"> file.encoding                                        UTF-8</span><br><span class="line"> java.specification.version                           1.8</span><br><span class="line"> user.name                                            wangtao</span><br><span class="line"> java.class.path                                      .</span><br><span class="line"> java.vm.specification.version                        1.8</span><br><span class="line"> sun.arch.data.model                                  64</span><br><span class="line"> java.home                                            /Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Contents/Home/jre</span><br><span class="line"> sun.java.command                                     Test</span><br><span class="line"> java.specification.vendor                            Oracle Corporation</span><br><span class="line"> user.language                                        en</span><br><span class="line"> awt.toolkit                                          sun.lwawt.macosx.LWCToolkit</span><br><span class="line"> java.vm.info                                         mixed mode</span><br><span class="line"> java.version                                         1.8.0_51</span><br><span class="line"> java.ext.dirs                                        /Users/wangtao/Library/Java/Extensions:/Library/Java/JavaVirtualMachines/jdk1.</span><br><span class="line">                                                      8.0_51.jdk/Contents/Home/jre/lib/ext:/Library/Java/Extensions:/Network/Library</span><br><span class="line">                                                      /Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java</span><br><span class="line"> sun.boot.class.path                                  /Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Contents/Home/jre/lib/resour</span><br><span class="line">                                                      ces.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Contents/Home/jre/li</span><br><span class="line">                                                      b/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Contents/Home/jre/l</span><br><span class="line">                                                      ib/sunrsasign.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Contents/H</span><br><span class="line">                                                      ome/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Content</span><br><span class="line">                                                      s/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_51.jdk/Conte</span><br><span class="line">                                                      nts/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_51.jd</span><br><span class="line">                                                      k/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_51.</span><br><span class="line">                                                      jdk/Contents/Home/jre/classes</span><br><span class="line"> java.vendor                                          Oracle Corporation</span><br><span class="line"> file.separator                                       /</span><br><span class="line"> java.vendor.url.bug                                  http://bugreport.sun.com/bugreport/</span><br><span class="line"> sun.cpu.endian                                       little</span><br><span class="line"> sun.io.unicode.encoding                              UnicodeBig</span><br><span class="line"> sun.cpu.isalist</span><br></pre></td></tr></table></figure><h2><span id="查看单个属性">查看单个属性</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysprop java.version</span><br><span class="line">sysprop java.version</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sysprop java.version</span></span><br><span class="line">java.version=1.8.0_51</span><br></pre></td></tr></table></figure><h3><span id="修改单个属性">修改单个属性</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysprop user.country</span><br><span class="line">sysprop user.country</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysprop user.country CN</span><br><span class="line">sysprop user.country CN</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sysprop user.country</span></span><br><span class="line">user.country=US</span><br><span class="line"><span class="meta">$</span><span class="bash"> sysprop user.country CN</span></span><br><span class="line">Successfully changed the system property.</span><br><span class="line">user.country=CN</span><br></pre></td></tr></table></figure><h2><span id="自动补全">自动补全</span></h2><p>Arthas支持丰富的自动补全功能，在使用有疑惑时，可以输入<code>Tab</code>来获取更多信息。</p><p>比如输入 <code>sysprop java.</code> 之后，再输入<code>Tab</code>，会补全出对应的key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sysprop java.</span><br><span class="line">java.runtime.name             java.protocol.handler.pkgs    java.vm.version</span><br><span class="line">java.vm.vendor                java.vendor.url               java.vm.name</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2><span id="历史命令的补全">历史命令的补全</span></h2><p>支持通过<code>TAB</code>键自动补全</p><p>如果想再执行之前的命令，可以在输入一半时，按<code>Up/↑</code> 或者 <code>Ddown/↓</code>，来匹配到之前的命令。</p><p>比如之前执行过<code>sysprop java.version</code>，那么在输入<code>sysprop ja</code>之后，可以输入<code>Up/↑</code>，就会自动补全为<code>sysprop java.version</code>。</p><p>如果想查看所有的历史命令，也可以通过 <code>history</code> 命令查看到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span></span><br></pre></td></tr></table></figure><h2><span id="管道">管道</span></h2><p>Arthas支持在pipeline之后，执行一些简单的命令，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysprop | grep java</span><br><span class="line">sysprop | grep java</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysprop | wc -l</span><br><span class="line">sysprop | wc -l</span><br></pre></td></tr></table></figure><h3><span id="通过grep来过滤">通过<code>grep</code>来过滤</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysprop | grep user</span><br><span class="line">sysprop | grep user</span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>在“sysprop”中，我们演示了了Arthas的sysprop命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas sysenv命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthassysenv%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthassysenv%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8arthas-demo">启动arthas demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#sysenv%E5%91%BD%E4%BB%A4">sysenv命令</a><ul><li><a href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83">使用参考</a></li></ul></li><li><a href="#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">查看所有环境变量</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E5%8D%95%E4%B8%AA%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">查看单个环境变量</a></li><li><a href="#%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8">自动补全</a></li><li><a href="#%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4%E7%9A%84%E8%A1%A5%E5%85%A8">历史命令的补全</a></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthassysenv%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示sysenv命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动arthas-demo">启动arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthassysenv%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="sysenv命令">sysenv命令</span></h2><p><code>sysenv</code> 命令可以查看当前JVM的环境属性(<code>System Property</code>)，与<code>sysprop</code>类似</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysenv</span><br></pre></td></tr></table></figure><h3><span id="使用参考">使用参考</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysenv -h</span><br><span class="line">sysenv -h</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">USAGE:</span><br><span class="line">  sysenv [-h] [env-name]</span><br><span class="line"></span><br><span class="line">SUMMARY:</span><br><span class="line">  Display the system env.</span><br><span class="line"></span><br><span class="line">EXAMPLES:</span><br><span class="line">  sysenv</span><br><span class="line">  sysenv USER</span><br><span class="line"></span><br><span class="line">WIKI:</span><br><span class="line">  https://arthas.aliyun.com/doc/sysenv</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">-h, --help                                                 this help</span><br><span class="line">&lt;env-name&gt;                                                 env name</span><br></pre></td></tr></table></figure><h2><span id="查看所有环境变量">查看所有环境变量</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysenv</span><br><span class="line">sysenv</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sysenv</span></span><br><span class="line"> KEY                      VALUE</span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> PATH                     /Users/admin/.sdkman/candidates/visualvm/current/bin:/Users/admin/.sdkman/candidates/ja</span><br><span class="line">                          va/current/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Wireshark.app/Contents/</span><br><span class="line">                          MacOS</span><br><span class="line"> SDKMAN_VERSION           5.7.3+337</span><br><span class="line"> JAVA_HOME                /Users/admin/.sdkman/candidates/java/current</span><br><span class="line"> JAVA_MAIN_CLASS_65244    demo.MathGame</span><br><span class="line"> TERM                     xterm-256color</span><br><span class="line"> LANG                     zh_CN.UTF-8</span><br><span class="line"> AUTOJUMP_SOURCED         1</span><br><span class="line"> COLORTERM                truecolor</span><br><span class="line"> LOGNAME                  admin</span><br><span class="line"> XPC_SERVICE_NAME         0</span><br><span class="line"> PWD                      /Users/admin/code/ali/arthas/demo</span><br><span class="line"> TERM_PROGRAM_VERSION     3.2.5</span><br><span class="line"> _                        /Users/admin/.sdkman/candidates/java/current/bin/java</span><br><span class="line"> SHELL                    /bin/bash</span><br><span class="line"> TERM_PROGRAM             iTerm.app</span><br><span class="line"> SDKMAN_PLATFORM          Darwin</span><br><span class="line"> USER                     admin</span><br><span class="line"> ITERM_PROFILE            Default</span><br><span class="line"> TMPDIR                   /var/folders/0r/k561bkk917gg972stqclbz9h0000gn/T/</span><br><span class="line"> XPC_FLAGS                0x0</span><br><span class="line"> TERM_SESSION_ID          w0t4p0:60BC264D-9649-42AC-A7E4-AF85B69F93F8</span><br><span class="line"> __CF_USER_TEXT_ENCODING  0x1F5:0x19:0x34</span><br><span class="line"> Apple_PubSub_Socket_Ren  /private/tmp/com.apple.launchd.DwmmjSQsll/Render</span><br><span class="line"> der</span><br><span class="line"> COLORFGBG                7;0</span><br><span class="line"> HOME                     /Users/admin</span><br><span class="line"> SHLVL                    1</span><br><span class="line"> AUTOJUMP_ERROR_PATH      /Users/admin/Library/autojump/errors.log</span><br></pre></td></tr></table></figure><h2><span id="查看单个环境变量">查看单个环境变量</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysenv USER</span><br><span class="line">sysenv USER</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sysenv USER</span></span><br><span class="line">USER=admin</span><br></pre></td></tr></table></figure><h2><span id="自动补全">自动补全</span></h2><p>Arthas支持丰富的自动补全功能，在使用有疑惑时，可以输入<code>Tab</code>来获取更多信息。</p><p>比如输入 <code>sysenv US</code> 之后，再输入<code>Tab</code>，会补全出对应的key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sysenv US</span><br><span class="line">USER</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2><span id="历史命令的补全">历史命令的补全</span></h2><p>支持通过<code>TAB</code>键自动补全</p><p>如果想再执行之前的命令，可以在输入一半时，按<code>Up/↑</code> 或者 <code>Ddown/↓</code>，来匹配到之前的命令。</p><p>比如之前执行过<code>sysenv USER</code>，那么在输入<code>sysenv US</code>之后，可以输入<code>Up/↑</code>，就会自动补全为<code>sysenv USER</code>。</p><p>如果想查看所有的历史命令，也可以通过 <code>history</code> 命令查看到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span></span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>在“sysenv”中，我们演示了了Arthas的sysenv命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas thread命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasthread%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasthread%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#arthas-demo">Arthas demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#thread%E5%91%BD%E4%BB%A4">Thread命令</a><ul><li><a href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">参数说明</a></li></ul></li><li><a href="#cpu%E5%8D%A0%E6%AF%94%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%9F%E8%AE%A1%E5%87%BA%E6%9D%A5%E7%9A%84">cpu占比是如何统计出来的？</a><ul><li><a href="#cpu%E4%BD%BF%E7%94%A8%E7%8E%87%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%9F%E8%AE%A1%E5%87%BA%E6%9D%A5%E7%9A%84">cpu使用率是如何统计出来的？</a></li></ul></li><li><a href="#thread%E7%94%A8%E6%B3%95">Thread用法</a><ul><li><a href="#%E6%94%AF%E6%8C%81%E4%B8%80%E9%94%AE%E5%B1%95%E7%A4%BA%E5%BD%93%E5%89%8D%E6%9C%80%E5%BF%99%E7%9A%84%E5%89%8Dn%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%B9%B6%E6%89%93%E5%8D%B0%E5%A0%86%E6%A0%88">支持一键展示当前最忙的前N个线程并打印堆栈：</a></li><li><a href="#%E5%BD%93%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E6%97%B6%E6%98%BE%E7%A4%BA%E7%AC%AC%E4%B8%80%E9%A1%B5%E7%BA%BF%E7%A8%8B%E4%BF%A1%E6%81%AF">当没有参数时，显示第一页线程信息</a></li><li><a href="#thread-all-%E6%98%BE%E7%A4%BA%E6%89%80%E6%9C%89%E5%8C%B9%E9%85%8D%E7%9A%84%E7%BA%BF%E7%A8%8B">thread –all, 显示所有匹配的线程</a></li><li><a href="#thread-id-%E6%98%BE%E7%A4%BA%E6%8C%87%E5%AE%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E5%A0%86%E6%A0%88">thread id， 显示指定线程的运行堆栈</a></li><li><a href="#thread-b-%E6%89%BE%E5%87%BA%E5%BD%93%E5%89%8D%E9%98%BB%E5%A1%9E%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B">thread -b, 找出当前阻塞其他线程的线程</a></li><li><a href="#thread-i-%E6%8C%87%E5%AE%9A%E9%87%87%E6%A0%B7%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94">thread -i, 指定采样时间间隔</a></li><li><a href="#thread-state-%E6%9F%A5%E7%9C%8B%E6%8C%87%E5%AE%9A%E7%8A%B6%E6%80%81%E7%9A%84%E7%BA%BF%E7%A8%8B">thread –state ，查看指定状态的线程</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasthread%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示thread命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="arthas-demo">Arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasthread%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="thread命令">Thread命令</span></h2><p>查看当前线程信息，查看线程的堆栈</p><h4><span id="参数说明">参数说明</span></h4><table><thead><tr><th>参数名称</th><th>参数说明</th></tr></thead><tbody><tr><td>id</td><td>线程id</td></tr><tr><td>[n:]</td><td>指定最忙的前N个线程并打印堆栈</td></tr><tr><td>[b]</td><td>找出当前阻塞其他线程的线程</td></tr><tr><td>[i <value>]</value></td><td>指定cpu占比统计的采样间隔，单位为毫秒</td></tr><tr><td>[–all]</td><td>显示所有匹配的线程</td></tr></tbody></table><h2><span id="cpu占比是如何统计出来的">cpu占比是如何统计出来的？</span></h2><h4><span id="cpu使用率是如何统计出来的">cpu使用率是如何统计出来的？</span></h4><p>这里的cpu使用率与linux 命令<code>top -H -p &lt;pid&gt;</code> 的线程<code>%CPU</code>类似，一段采样间隔时间内，当前JVM里各个线程的增量cpu时间与采样间隔时间的比例。</p><blockquote><p>工作原理说明：</p></blockquote><ul><li>首先第一次采样，获取所有线程的CPU时间(调用的是<code>java.lang.management.ThreadMXBean#getThreadCpuTime()</code>及<code>sun.management.HotspotThreadMBean.getInternalThreadCpuTimes()</code>接口)</li><li>然后睡眠等待一个间隔时间（默认为200ms，可以通过<code>-i</code>指定间隔时间）</li><li>再次第二次采样，获取所有线程的CPU时间，对比两次采样数据，计算出每个线程的增量CPU时间</li><li>线程CPU使用率 = 线程增量CPU时间 / 采样间隔时间 * 100%</li></ul><blockquote><p>注意： 这个统计也会产生一定的开销（JDK这个接口本身开销比较大），因此会看到as的线程占用一定的百分比，为了降低统计自身的开销带来的影响，可以把采样间隔拉长一些，比如5000毫秒。</p><p>另外一种查看Java进程的线程cpu使用率方法：可以使用<a href="https://github.com/oldratlee/useful-scripts/blob/master/docs/java.md#-show-busy-java-threads">show-busy-java-threads</a>这个脚本</p><h2><span id="thread用法">Thread用法</span></h2></blockquote><h4><span id="支持一键展示当前最忙的前n个线程并打印堆栈">支持一键展示当前最忙的前N个线程并打印堆栈：</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread -n 3</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> thread -n 3</span></span><br><span class="line">&quot;C1 CompilerThread0&quot; [Internal] cpuUsage=1.63% deltaTime=3ms time=1170ms</span><br><span class="line">&quot;arthas-command-execute&quot; Id=23 cpuUsage=0.11% deltaTime=0ms time=401ms RUNNABLE</span><br><span class="line">    at java.management@11.0.7/sun.management.ThreadImpl.dumpThreads0(Native Method)</span><br><span class="line">    at java.management@11.0.7/sun.management.ThreadImpl.getThreadInfo(ThreadImpl.java:466)</span><br><span class="line">    at com.taobao.arthas.core.command.monitor200.ThreadCommand.processTopBusyThreads(ThreadCommand.java:199)</span><br><span class="line">    at com.taobao.arthas.core.command.monitor200.ThreadCommand.process(ThreadCommand.java:122)</span><br><span class="line">    at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl.process(AnnotatedCommandImpl.java:82)</span><br><span class="line">    at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl.access$100(AnnotatedCommandImpl.java:18)</span><br><span class="line">    at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl$ProcessHandler.handle(AnnotatedCommandImpl.java:111)</span><br><span class="line">    at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl$ProcessHandler.handle(AnnotatedCommandImpl.java:108)</span><br><span class="line">    at com.taobao.arthas.core.shell.system.impl.ProcessImpl$CommandProcessTask.run(ProcessImpl.java:385)</span><br><span class="line">    at java.base@11.0.7/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)</span><br><span class="line">    at java.base@11.0.7/java.util.concurrent.FutureTask.run(FutureTask.java:264)</span><br><span class="line">    at java.base@11.0.7/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)</span><br><span class="line">    at java.base@11.0.7/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)</span><br><span class="line">    at java.base@11.0.7/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)</span><br><span class="line">    at java.base@11.0.7/java.lang.Thread.run(Thread.java:834)</span><br><span class="line">&quot;VM Periodic Task Thread&quot; [Internal] cpuUsage=0.07% deltaTime=0ms time=584ms</span><br></pre></td></tr></table></figure><ul><li>没有线程ID，包含<code>[Internal]</code>表示为JVM内部线程，参考<code>dashboard</code>命令的介绍。</li><li><code>cpuUsage</code>为采样间隔时间内线程的CPU使用率，与<code>dashboard</code>命令的数据一致。</li><li><code>deltaTime</code>为采样间隔时间内线程的增量CPU时间，小于1ms时被取整显示为0ms。</li><li><code>time</code> 线程运行总CPU时间。</li></ul><p>注意：线程栈为第二采样结束时获取，不能表明采样间隔时间内该线程都是在处理相同的任务。建议间隔时间不要太长，可能间隔时间越大越不准确。 可以根据具体情况尝试指定不同的间隔时间，观察输出结果。</p><h4><span id="当没有参数时显示第一页线程信息">当没有参数时，显示第一页线程信息</span></h4><p>默认按照CPU增量时间降序排列，只显示第一页数据，避免滚屏。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> thread</span></span><br><span class="line">Threads Total: 33, NEW: 0, RUNNABLE: 9, BLOCKED: 0, WAITING: 3, TIMED_WAITING: 4, TERMINATED: 0, Internal threads: 17</span><br><span class="line">ID   NAME                           GROUP          PRIORITY  STATE     %CPU      DELTA_TIME TIME      INTERRUPT DAEMON</span><br><span class="line">-1   C2 CompilerThread0             -              -1        -         5.06      0.010      0:0.973   false     true</span><br><span class="line">-1   C1 CompilerThread0             -              -1        -         0.95      0.001      0:0.603   false     true</span><br><span class="line">23   arthas-command-execute         system         5         RUNNABLE  0.17      0.000      0:0.226   false     true</span><br><span class="line">-1   VM Periodic Task Thread        -              -1        -         0.05      0.000      0:0.094   false     true</span><br><span class="line">-1   Sweeper thread                 -              -1        -         0.04      0.000      0:0.011   false     true</span><br><span class="line">-1   G1 Young RemSet Sampling       -              -1        -         0.02      0.000      0:0.025   false     true</span><br><span class="line">12   Attach Listener                system         9         RUNNABLE  0.0       0.000      0:0.022   false     true</span><br><span class="line">11   Common-Cleaner                 InnocuousThrea 8         TIMED_WAI 0.0       0.000      0:0.000   false     true</span><br><span class="line">3    Finalizer                      system         8         WAITING   0.0       0.000      0:0.000   false     true</span><br><span class="line">2    Reference Handler              system         10        RUNNABLE  0.0       0.000      0:0.000   false     true</span><br><span class="line">4    Signal Dispatcher              system         9         RUNNABLE  0.0       0.000      0:0.000   false     true</span><br><span class="line">15   arthas-NettyHttpTelnetBootstra system         5         RUNNABLE  0.0       0.000      0:0.029   false     true</span><br><span class="line">22   arthas-NettyHttpTelnetBootstra system         5         RUNNABLE  0.0       0.000      0:0.196   false     true</span><br><span class="line">24   arthas-NettyHttpTelnetBootstra system         5         RUNNABLE  0.0       0.000      0:0.038   false     true</span><br><span class="line">16   arthas-NettyWebsocketTtyBootst system         5         RUNNABLE  0.0       0.000      0:0.001   false     true</span><br><span class="line">17   arthas-NettyWebsocketTtyBootst system         5         RUNNABLE  0.0       0.000      0:0.001   false     true</span><br></pre></td></tr></table></figure><h4><span id="thread-all-显示所有匹配的线程">thread –all, 显示所有匹配的线程</span></h4><p>显示所有匹配线程信息，有时需要获取全部JVM的线程数据进行分析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread --all</span><br></pre></td></tr></table></figure><h4><span id="thread-id-显示指定线程的运行堆栈">thread id， 显示指定线程的运行堆栈</span></h4><p>查看线程ID 16的栈：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread 16</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> thread 1</span></span><br><span class="line">&quot;main&quot; Id=1 WAITING on java.util.concurrent.CountDownLatch$Sync@29fafb28</span><br><span class="line">    at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">    -  waiting on java.util.concurrent.CountDownLatch$Sync@29fafb28</span><br><span class="line">    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">    at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)</span><br><span class="line">    at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:997)</span><br><span class="line">    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1304)</span><br><span class="line">    at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)</span><br></pre></td></tr></table></figure><h4><span id="thread-b-找出当前阻塞其他线程的线程">thread -b, 找出当前阻塞其他线程的线程</span></h4><p>有时候我们发现应用卡住了， 通常是由于某个线程拿住了某个锁， 并且其他线程都在等待这把锁造成的。 为了排查这类问题， arthas提供了<code>thread -b</code>， 一键找出那个罪魁祸首。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread -b</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> thread -b</span></span><br><span class="line">&quot;http-bio-8080-exec-4&quot; Id=27 TIMED_WAITING</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at test.arthas.TestThreadBlocking.doGet(TestThreadBlocking.java:22)</span><br><span class="line">    -  locked java.lang.Object@725be470 &lt;---- but blocks 4 other threads!</span><br><span class="line">    at javax.servlet.http.HttpServlet.service(HttpServlet.java:624)</span><br><span class="line">    at javax.servlet.http.HttpServlet.service(HttpServlet.java:731)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:303)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)</span><br><span class="line">    at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)</span><br><span class="line">    at test.filter.TestDurexFilter.doFilter(TestDurexFilter.java:46)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)</span><br><span class="line">    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)</span><br><span class="line">    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:220)</span><br><span class="line">    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:122)</span><br><span class="line">    at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:505)</span><br><span class="line">    at com.taobao.tomcat.valves.ContextLoadFilterValve$FilterChainAdapter.doFilter(ContextLoadFilterValve.java:191)</span><br><span class="line">    at com.taobao.eagleeye.EagleEyeFilter.doFilter(EagleEyeFilter.java:81)</span><br><span class="line">    at com.taobao.tomcat.valves.ContextLoadFilterValve.invoke(ContextLoadFilterValve.java:150)</span><br><span class="line">    at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:170)</span><br><span class="line">    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:103)</span><br><span class="line">    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:116)</span><br><span class="line">    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:429)</span><br><span class="line">    at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1085)</span><br><span class="line">    at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:625)</span><br><span class="line">    at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:318)</span><br><span class="line">    -  locked org.apache.tomcat.util.net.SocketWrapper@7127ee12</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">    at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br><span class="line">    Number of locked synchronizers = 1</span><br><span class="line">    - java.util.concurrent.ThreadPoolExecutor$Worker@31a6493e</span><br></pre></td></tr></table></figure><p><strong>注意</strong>， 目前只支持找出synchronized关键字阻塞住的线程， 如果是<code>java.util.concurrent.Lock</code>， 目前还不支持。</p><h4><span id="thread-i-指定采样时间间隔">thread -i, 指定采样时间间隔</span></h4><ul><li><code>thread -i 1000</code> : 统计最近1000ms内的线程CPU时间。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread -i 1000</span><br></pre></td></tr></table></figure><ul><li><code>thread -n 3 -i 1000</code> : 列出1000ms内最忙的3个线程栈</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread -n 3 -i 1000</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> thread -n 3 -i 1000</span></span><br><span class="line">&quot;as-command-execute-daemon&quot; Id=4759 cpuUsage=23% RUNNABLE</span><br><span class="line">    at sun.management.ThreadImpl.dumpThreads0(Native Method)</span><br><span class="line">    at sun.management.ThreadImpl.getThreadInfo(ThreadImpl.java:440)</span><br><span class="line">    at com.taobao.arthas.core.command.monitor200.ThreadCommand.processTopBusyThreads(ThreadCommand.java:133)</span><br><span class="line">    at com.taobao.arthas.core.command.monitor200.ThreadCommand.process(ThreadCommand.java:79)</span><br><span class="line">    at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl.process(AnnotatedCommandImpl.java:96)</span><br><span class="line">    at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl.access$100(AnnotatedCommandImpl.java:27)</span><br><span class="line">    at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl$ProcessHandler.handle(AnnotatedCommandImpl.java:125)</span><br><span class="line">    at com.taobao.arthas.core.shell.command.impl.AnnotatedCommandImpl$ProcessHandler.handle(AnnotatedCommandImpl.java:122)</span><br><span class="line">    at com.taobao.arthas.core.shell.system.impl.ProcessImpl$CommandProcessTask.run(ProcessImpl.java:332)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:756)</span><br><span class="line"></span><br><span class="line">    Number of locked synchronizers = 1</span><br><span class="line">    - java.util.concurrent.ThreadPoolExecutor$Worker@546aeec1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4><span id="thread-state-查看指定状态的线程">thread –state ，查看指定状态的线程</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread --state WAITING</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@28114]$</span><span class="bash"> thread --state WAITING</span></span><br><span class="line">Threads Total: 16, NEW: 0, RUNNABLE: 9, BLOCKED: 0, WAITING: 3, TIMED_WAITING: 4, TERMINATED: 0</span><br><span class="line">ID   NAME                           GROUP           PRIORITY   STATE     %CPU      DELTA_TIME TIME      INTERRUPTE DAEMON</span><br><span class="line">3    Finalizer                      system          8          WAITING   0.0       0.000      0:0.000   false      true</span><br><span class="line">20   arthas-UserStat                system          9          WAITING   0.0       0.000      0:0.001   false      true</span><br><span class="line">14   arthas-timer                   system          9          WAITING   0.0       0.000      0:0.000   false      true</span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>在“thread”中，我们演示了了Arthas的thread命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas vmoption命令</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasvmoption%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasvmoption%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8arthas-demo">启动arthas demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#vmoption%E5%91%BD%E4%BB%A4">vmoption命令</a><ul><li><a href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83">使用参考</a><ul><li><a href="#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%9A%84option">查看所有的option：</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E6%8C%87%E5%AE%9A%E7%9A%84option">查看指定的option</a></li><li><a href="#%E6%9B%B4%E6%96%B0%E6%8C%87%E5%AE%9A%E7%9A%84option">更新指定的option</a></li></ul></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasvmoption%E5%91%BD%E4%BB%A4/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示vmoption命令。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动arthas-demo">启动arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><p>为了和使用vmoption后的效果作对比，此时使用<code>Ctrl+c</code>，程序很自然地退出。 Ctrl+C</p><p>再次启动<code>arthas-demo</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E6%95%99%E7%A8%8B/Arthasvmoption%E5%91%BD%E4%BB%A4/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="vmoption命令">vmoption命令</span></h2><p>查看，更新VM诊断相关的参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmoption -h</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@48]$</span><span class="bash"> vmoption -h</span></span><br><span class="line"> USAGE:</span><br><span class="line">   vmoption [-h] [name] [value]</span><br><span class="line"></span><br><span class="line"> SUMMARY:</span><br><span class="line">   Display, and update the vm diagnostic options.</span><br><span class="line"></span><br><span class="line"> Examples:</span><br><span class="line">   vmoption</span><br><span class="line">   vmoption PrintGCDetails</span><br><span class="line">   vmoption PrintGCDetails true</span><br><span class="line"></span><br><span class="line"> WIKI:</span><br><span class="line">   https://arthas.aliyun.com/doc/vmoption</span><br><span class="line"></span><br><span class="line"> OPTIONS:</span><br><span class="line"> -h, --help                           this help</span><br><span class="line"> &lt;name&gt;                               VMOption name</span><br><span class="line"> &lt;value&gt;                              VMOption value</span><br></pre></td></tr></table></figure><h3><span id="使用参考">使用参考</span></h3><h4><span id="查看所有的option">查看所有的option：</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmoption</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@56963]$</span><span class="bash"> vmoption</span></span><br><span class="line"> KEY                    VALUE                   ORIGIN                 WRITEABLE</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"> HeapDumpBeforeFullGC   false                   DEFAULT                true</span><br><span class="line"> HeapDumpAfterFullGC    false                   DEFAULT                true</span><br><span class="line"> HeapDumpOnOutOfMemory  false                   DEFAULT                true</span><br><span class="line"> Error</span><br><span class="line"> HeapDumpPath                                   DEFAULT                true</span><br><span class="line"> CMSAbortablePrecleanW  100                     DEFAULT                true</span><br><span class="line"> aitMillis</span><br><span class="line"> CMSWaitDuration        2000                    DEFAULT                true</span><br><span class="line"> CMSTriggerInterval     -1                      DEFAULT                true</span><br><span class="line"> PrintGC                false                   DEFAULT                true</span><br><span class="line"> PrintGCDetails         true                    MANAGEMENT             true</span><br><span class="line"> PrintGCDateStamps      false                   DEFAULT                true</span><br><span class="line"> PrintGCTimeStamps      false                   DEFAULT                true</span><br><span class="line"> PrintGCID              false                   DEFAULT                true</span><br><span class="line"> PrintClassHistogramBe  false                   DEFAULT                true</span><br><span class="line"> foreFullGC</span><br><span class="line"> PrintClassHistogramAf  false                   DEFAULT                true</span><br><span class="line"> terFullGC</span><br><span class="line"> PrintClassHistogram    false                   DEFAULT                true</span><br><span class="line"> MinHeapFreeRatio       0                       DEFAULT                true</span><br><span class="line"> MaxHeapFreeRatio       100                     DEFAULT                true</span><br><span class="line"> PrintConcurrentLocks   false                   DEFAULT                true</span><br></pre></td></tr></table></figure><h4><span id="查看指定的option">查看指定的option</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmoption PrintGCDetails</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@56963]$</span><span class="bash"> vmoption PrintGCDetails</span></span><br><span class="line"> KEY                    VALUE                   ORIGIN                 WRITEABLE</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"> PrintGCDetails         false                   MANAGEMENT             true</span><br></pre></td></tr></table></figure><h4><span id="更新指定的option">更新指定的option</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmoption PrintGCDetails <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[arthas@56963]$</span><span class="bash"> vmoption PrintGCDetails <span class="literal">true</span></span></span><br><span class="line">Successfully updated the vm option.</span><br><span class="line">PrintGCDetails=true</span><br></pre></td></tr></table></figure><p>此时，切换到arthas demo 运行所在的<code>Terminal</code>，使用<code>Ctrl+c</code>退出，发现比之前多打印了GC垃圾回收信息：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def new generation   total 10432K, used 5682K [0x00000000f4800000, 0x00000000f5350000, 0x00000000f8550000)</span><br><span class="line">  eden space 9280K,  61% used [0x00000000f4800000, 0x00000000f4d8cad0, 0x00000000f5110000)</span><br><span class="line">  from space 1152K,   0% used [0x00000000f5110000, 0x00000000f5110000, 0x00000000f5230000)</span><br><span class="line">  to   space 1152K,   0% used [0x00000000f5230000, 0x00000000f5230000, 0x00000000f5350000)</span><br><span class="line"> tenured generation   total 22992K, used 13795K [0x00000000f8550000, 0x00000000f9bc4000, 0x0000000100000000)</span><br><span class="line">   the space 22992K,  59% used [0x00000000f8550000, 0x00000000f92c8cc8, 0x00000000f92c8e00, 0x00000000f9bc4000)</span><br><span class="line"> Metaspace       used 14926K, capacity 15128K, committed 15360K, reserved 1062912K</span><br><span class="line">  class space    used 1895K, capacity 1954K, committed 2048K, reserved 1048576K</span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>在“vmoption”中，我们演示了了Arthas的vmoption命令。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 高级命令教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas 动态更新应用Logger Level 案例</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E5%BA%94%E7%94%A8LoggerLevel%E6%A1%88%E4%BE%8B/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E5%BA%94%E7%94%A8LoggerLevel%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#start-demo">Start demo</a></li><li><a href="#start-arthas-boot">Start arthas-boot</a></li><li><a href="#%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E5%BA%94%E7%94%A8logger-level">动态更新应用Logger Level</a><ul><li><a href="#%E6%9F%A5%E6%89%BEusercontroller%E7%9A%84classloader">查找UserController的ClassLoader</a></li><li><a href="#%E7%94%A8ognl%E8%8E%B7%E5%8F%96logger">用ognl获取logger</a></li><li><a href="#%E5%8D%95%E7%8B%AC%E8%AE%BE%E7%BD%AEusercontroller%E7%9A%84logger-level">单独设置UserController的logger level</a></li><li><a href="#%E4%BF%AE%E6%94%B9logback%E7%9A%84%E5%85%A8%E5%B1%80logger-level">修改logback的全局logger level</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E5%BA%94%E7%94%A8LoggerLevel%E6%A1%88%E4%BE%8B/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个普通的Spring Boot应用为例，演示动态更新应用Logger Level。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="start-demo">Start demo</span></h2><p>下载<code>demo-arthas-spring-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar</span><br></pre></td></tr></table></figure><p><code>demo-arthas-spring-boot</code>是一个很简单的spring boot应用，源代码：<a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-arthas-spring-boot">查看</a></p><p>启动之后，可以访问61000端口： 点击查看</p><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E5%BA%94%E7%94%A8LoggerLevel%E6%A1%88%E4%BE%8B/O1CN010Qbzcz1ctPSWSZI6L_!!6000000003658-2-tps-333-182.png" alt="Demo Web"></p><h2><span id="start-arthas-boot">Start arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E5%BA%94%E7%94%A8LoggerLevel%E6%A1%88%E4%BE%8B/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="动态更新应用logger-level">动态更新应用Logger Level</span></h2><p>在这个案例里，动态修改应用的Logger Level。</p><h4><span id="查找usercontroller的classloader">查找UserController的ClassLoader</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span><br></pre></td></tr></table></figure><p></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span></span><br><span class="line"> classLoaderHash   1be6f5c3</span><br></pre></td></tr></table></figure><p>注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。</p><p>如果你使用<code>-c</code>，你需要手动输入hashcode：<code>-c &lt;hashcode&gt;</code></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl -c 1be6f5c3 @com.example.demo.arthas.user.UserController@logger</span></span><br></pre></td></tr></table></figure><p>对于只有唯一实例的ClassLoader可以通过<code>--classLoaderClass</code>指定class name，使用起来更加方便：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader  @org.springframework.boot.SpringApplication@logger</span></span><br><span class="line">@Slf4jLocationAwareLog[</span><br><span class="line">    FQCN=@String[org.apache.commons.logging.LogAdapter$Slf4jLocationAwareLog],</span><br><span class="line">    name=@String[org.springframework.boot.SpringApplication],</span><br><span class="line">    logger=@Logger[Logger[org.springframework.boot.SpringApplication]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>--classLoaderClass</code> 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而<code>-c &lt;hashcode&gt;</code>是动态变化的。</p><h4><span id="用ognl获取logger">用ognl获取logger</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span></span></span><br><span class="line">@Logger[</span><br><span class="line">    serialVersionUID=@Long[5454405123156820674],</span><br><span class="line">    FQCN=@String[ch.qos.logback.classic.Logger],</span><br><span class="line">    name=@String[com.example.demo.arthas.user.UserController],</span><br><span class="line">    level=null,</span><br><span class="line">    effectiveLevelInt=@Integer[20000],</span><br><span class="line">    parent=@Logger[Logger[com.example.demo.arthas.user]],</span><br><span class="line">    childrenList=null,</span><br><span class="line">    aai=null,</span><br><span class="line">    additive=@Boolean[true],</span><br><span class="line">    loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以知道<code>UserController@logger</code>实际使用的是logback。可以看到<code>level=null</code>，则说明实际最终的level是从<code>root</code> logger里来的。</p><h4><span id="单独设置usercontroller的logger-level">单独设置UserController的logger level</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger.setLevel(@ch.qos.logback.classic.Level@DEBUG)&#x27;</span></span><br></pre></td></tr></table></figure><p>再次获取<code>UserController@logger</code>，可以发现已经是<code>DEBUG</code>了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span></span></span><br><span class="line">@Logger[</span><br><span class="line">    serialVersionUID=@Long[5454405123156820674],</span><br><span class="line">    FQCN=@String[ch.qos.logback.classic.Logger],</span><br><span class="line">    name=@String[com.example.demo.arthas.user.UserController],</span><br><span class="line">    level=@Level[DEBUG],</span><br><span class="line">    effectiveLevelInt=@Integer[10000],</span><br><span class="line">    parent=@Logger[Logger[com.example.demo.arthas.user]],</span><br><span class="line">    childrenList=null,</span><br><span class="line">    aai=null,</span><br><span class="line">    additive=@Boolean[true],</span><br><span class="line">    loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4><span id="修改logback的全局logger-level">修改logback的全局logger level</span></h4><p>通过获取<code>root</code> logger，可以修改全局的logger level：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@org.slf4j.LoggerFactory@getLogger(&quot;root&quot;).setLevel(@ch.qos.logback.classic.Level@DEBUG)&#x27;</span></span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>通过本教程基本掌握了Arthas动态更新应用Logger Level。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 最佳实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas Web Console 案例</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/ArthasWebConsole%E6%A1%88%E4%BE%8B/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/ArthasWebConsole%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8arthas-demo">启动arthas demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#web-console">Web Console</a><ul><li><a href="#%E6%9C%AC%E5%9C%B0%E4%BD%93%E9%AA%8C">本地体验</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/ArthasWebConsole%E6%A1%88%E4%BE%8B/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示Web Console。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动arthas-demo">启动arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar --target-ip 0.0.0.0</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/ArthasWebConsole%E6%A1%88%E4%BE%8B/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="web-console">Web Console</span></h2><p>Arthas支持通过Web Socket来连接。</p><h3><span id="本地体验">本地体验</span></h3><p>当在本地启动时，可以访问 <a href="http://127.0.0.1:8563/">http://127.0.0.1:8563/</a> ，通过浏览器来使用Arthas。</p><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/ArthasWebConsole%E6%A1%88%E4%BE%8B/O1CN01i041kW1lw0FCaSKNn_!!6000000004882-2-tps-1231-284.png" alt="Arthas WebConsole"></p><p>推荐通过“快速入门”来体验： <a href="https://arthas.aliyun.com/doc/quick-start.html">https://arthas.aliyun.com/doc/quick-start.html</a></p><h2><span id="更多信息">更多信息</span></h2><p>通过本教程基本掌握了Arthas Web Console。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 最佳实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas 排查函数调用异常 案例</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%BC%82%E5%B8%B8%E6%A1%88%E4%BE%8B/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%BC%82%E5%B8%B8%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#start-demo">Start demo</a></li><li><a href="#start-arthas-boot">Start arthas-boot</a></li><li><a href="#%E6%8E%92%E6%9F%A5%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%BC%82%E5%B8%B8">排查函数调用异常</a><ul><li><a href="#%E7%8E%B0%E8%B1%A1">现象</a></li><li><a href="#%E6%9F%A5%E7%9C%8Busercontroller%E7%9A%84-%E5%8F%82%E6%95%B0%E5%BC%82%E5%B8%B8">查看UserController的 参数/异常</a></li><li><a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F">返回值表达式</a></li><li><a href="#%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F">条件表达式</a></li><li><a href="#%E5%BD%93%E5%BC%82%E5%B8%B8%E6%97%B6%E6%8D%95%E8%8E%B7">当异常时捕获</a></li><li><a href="#%E6%8C%89%E7%85%A7%E8%80%97%E6%97%B6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4">按照耗时进行过滤</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%BC%82%E5%B8%B8%E6%A1%88%E4%BE%8B/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个普通的Spring Boot应用为例，演示排查函数调用异常。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="start-demo">Start demo</span></h2><p>下载<code>demo-arthas-spring-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar</span><br></pre></td></tr></table></figure><p><code>demo-arthas-spring-boot</code>是一个很简单的spring boot应用，源代码：<a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-arthas-spring-boot">查看</a></p><p>启动之后，可以访问61000端口： 点击查看</p><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%BC%82%E5%B8%B8%E6%A1%88%E4%BE%8B/O1CN010Qbzcz1ctPSWSZI6L_!!6000000003658-2-tps-333-182.png" alt="Demo Web"></p><h2><span id="start-arthas-boot">Start arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%BC%82%E5%B8%B8%E6%A1%88%E4%BE%8B/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="排查函数调用异常">排查函数调用异常</span></h2><h4><span id="现象">现象</span></h4><p>目前，访问 <a href="http://localhost:61000/user/0">http://localhost:61000/user/0</a> ，会返回500异常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:61000/user/0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;timestamp&quot;:1550223186170,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;exception&quot;:&quot;java.lang.IllegalArgumentException&quot;,&quot;message&quot;:&quot;id &lt; 1&quot;,&quot;path&quot;:&quot;/user/0&quot;&#125;</span><br></pre></td></tr></table></figure><p>但请求的具体参数，异常栈是什么呢？</p><h4><span id="查看usercontroller的-参数异常">查看UserController的 参数/异常</span></h4><p>在Arthas里执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch com.example.demo.arthas.user.UserController * <span class="string">&#x27;&#123;params, throwExp&#125;&#x27;</span></span><br></pre></td></tr></table></figure><ol><li>第一个参数是类名，支持通配</li><li>第二个参数是函数名，支持通配 访问 <code>curl http://localhost:61000/user/0</code> ,<code>watch</code>命令会打印调用的参数和异常</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:61000/user/0</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch com.example.demo.arthas.user.UserController * <span class="string">&#x27;&#123;params, throwExp&#125;&#x27;</span></span></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:2) cost in 53 ms.</span><br><span class="line">ts=2019-02-15 01:35:25; [cost=0.996655ms] result=@ArrayList[</span><br><span class="line">    @Object[][isEmpty=false;size=1],</span><br><span class="line">    @IllegalArgumentException[java.lang.IllegalArgumentException: id &lt; 1],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以看到实际抛出的异常是<code>IllegalArgumentException</code>。</p><p>可以输入 <code>q</code> 或者 <code>Ctrl+C</code> 退出watch命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><p>如果想把获取到的结果展开，可以用<code>-x</code>参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch com.example.demo.arthas.user.UserController * <span class="string">&#x27;&#123;params, throwExp&#125;&#x27;</span> -x 2</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch com.example.demo.arthas.user.UserController * <span class="string">&#x27;&#123;params, throwExp&#125;&#x27;</span> -x 2</span></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class count: 1 , method count: 2) cost in 190 ms, listenerId: 1</span><br><span class="line">ts=2020-08-13 05:22:45; [cost=4.805432ms] result=@ArrayList[</span><br><span class="line">    @Object[][</span><br><span class="line">        @Integer[0],</span><br><span class="line">    ],</span><br><span class="line">    java.lang.IllegalArgumentException: id &lt; 1</span><br><span class="line">        at com.example.demo.arthas.user.UserController.findUserById(UserController.java:19)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">    ...</span><br><span class="line">,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4><span id="返回值表达式">返回值表达式</span></h4><p>在上面的例子里，第三个参数是<code>返回值表达式</code>，它实际上是一个<code>ognl</code>表达式，它支持一些内置对象：</p><ul><li>loader</li><li>clazz</li><li>method</li><li>target</li><li>params</li><li>returnObj</li><li>throwExp</li><li>isBefore</li><li>isThrow</li><li>isReturn</li></ul><p>你可以利用这些内置对象来组成不同的表达式。比如返回一个数组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch com.example.demo.arthas.user.UserController * <span class="string">&#x27;&#123;params[0], target, returnObj&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>更多参考： <a href="https://arthas.aliyun.com/doc/advice-class.html">https://arthas.aliyun.com/doc/advice-class.html</a></p><h4><span id="条件表达式">条件表达式</span></h4><p><code>watch</code>命令支持在第4个参数里写条件表达式，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch com.example.demo.arthas.user.UserController * returnObj <span class="string">&#x27;params[0] &gt; 100&#x27;</span></span><br></pre></td></tr></table></figure><p>当访问 user/1 时，<code>watch</code>命令没有输出</p><p>当访问 user/101 时，<code>watch</code>会打印出结果。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch com.example.demo.arthas.user.UserController * returnObj <span class="string">&#x27;params[0] &gt; 100&#x27;</span></span></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:2) cost in 47 ms.</span><br><span class="line">ts=2019-02-13 19:42:12; [cost=0.821443ms] result=@User[</span><br><span class="line">    id=@Integer[101],</span><br><span class="line">    name=@String[name101],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4><span id="当异常时捕获">当异常时捕获</span></h4><p><code>watch</code>命令支持<code>-e</code>选项，表示只捕获抛出异常时的请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch com.example.demo.arthas.user.UserController * <span class="string">&quot;&#123;params[0],throwExp&#125;&quot;</span> -e</span><br></pre></td></tr></table></figure><h4><span id="按照耗时进行过滤">按照耗时进行过滤</span></h4><p>watch命令支持按请求耗时进行过滤，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch com.example.demo.arthas.user.UserController * <span class="string">&#x27;&#123;params, returnObj&#125;&#x27;</span> <span class="string">&#x27;#cost&gt;200&#x27;</span></span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>通过本教程基本掌握了Arthas排查函数调用异常。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 最佳实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas 执行结果存日志 案例</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%AD%98%E6%97%A5%E5%BF%97%E6%A1%88%E4%BE%8B/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%AD%98%E6%97%A5%E5%BF%97%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#arthas-demo">Arthas demo</a></li><li><a href="#start-arthas-boot">Start arthas-boot</a></li><li><a href="#%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%AD%98%E6%97%A5%E5%BF%97">执行结果存日志</a><ul><li><a href="#%E4%BD%BF%E7%94%A8%E6%96%B0%E7%89%88%E6%9C%ACarthas%E7%9A%84%E5%BC%82%E6%AD%A5%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1%E5%B0%86%E7%BB%93%E6%9E%9C%E5%AD%98%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6">使用新版本Arthas的异步后台任务将结果存日志文件</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%AD%98%E6%97%A5%E5%BF%97%E6%A1%88%E4%BE%8B/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示Arthas执行结果存日志。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="arthas-demo">Arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="start-arthas-boot">Start arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%AD%98%E6%97%A5%E5%BF%97%E6%A1%88%E4%BE%8B/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="执行结果存日志">执行结果存日志</span></h2><p>将命令的结果完整保存在日志文件中，便于后续进行分析</p><ul><li>默认情况下，该功能是关闭的，如果需要开启，请执行以下命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options save-result <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> options save-result <span class="literal">true</span></span></span><br><span class="line"> NAME         BEFORE-VALUE  AFTER-VALUE</span><br><span class="line">----------------------------------------</span><br><span class="line"> save-result  false         true</span><br><span class="line">Affect(row-cnt:1) cost in 3 ms.</span><br></pre></td></tr></table></figure><p>看到上面的输出，即表示成功开启该功能；</p><ul><li>日志文件路径</li></ul><p>结果会异步保存在：<code>&#123;user.home&#125;/logs/arthas-cache/result.log</code>，请定期进行清理，以免占据磁盘空间</p><h3><span id="使用新版本arthas的异步后台任务将结果存日志文件">使用新版本Arthas的异步后台任务将结果存日志文件</span></h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> trace Test t &gt;&gt;  &amp;</span></span><br><span class="line">job id  : 2</span><br><span class="line">cache location  : /Users/admin/logs/arthas-cache/28198/2</span><br></pre></td></tr></table></figure><p>此时命令会在后台异步执行，并将结果异步保存在文件<code>（~/logs/arthas-cache/$&#123;PID&#125;/$&#123;JobId&#125;）</code>中;</p><ul><li>此时任务的执行不受session断开的影响；任务默认超时时间是1天，可以通过全局 <code>options</code> 命令修改默认超时时间；</li><li>此命令的结果将异步输出到文件中；此时不管 <code>save-result</code> 是否为true，都不会再往<code>~/logs/arthas-cache/result.log</code> 中异步写结果</li></ul><h2><span id="更多信息">更多信息</span></h2><p>通过本教程基本掌握了Arthas执行结果存日志。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 最佳实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas 查找Top N线程 案例</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%9F%A5%E6%89%BETopN%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%9F%A5%E6%89%BETopN%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#arthas-demo">Arthas demo</a></li><li><a href="#start-arthas-boot">Start arthas-boot</a></li><li><a href="#%E6%9F%A5%E6%89%BEtop-n%E7%BA%BF%E7%A8%8B">查找Top N线程</a><ul><li><a href="#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E4%BF%A1%E6%81%AF">查看所有线程信息</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E5%85%B7%E4%BD%93%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A0%88">查看具体线程的栈</a></li><li><a href="#%E6%9F%A5%E7%9C%8Bcpu%E4%BD%BF%E7%94%A8%E7%8E%87top-n%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A0%88">查看CPU使用率top n线程的栈</a></li><li><a href="#%E6%9F%A5%E6%89%BE%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E6%9C%89%E9%98%BB%E5%A1%9E">查找线程是否有阻塞</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%9F%A5%E6%89%BETopN%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示查找Top N线程。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="arthas-demo">Arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="start-arthas-boot">Start arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%9F%A5%E6%89%BETopN%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="查找top-n线程">查找Top N线程</span></h2><h4><span id="查看所有线程信息">查看所有线程信息</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread</span><br></pre></td></tr></table></figure><h4><span id="查看具体线程的栈">查看具体线程的栈</span></h4><p>查看线程ID 16的栈：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread 16</span><br></pre></td></tr></table></figure><h4><span id="查看cpu使用率top-n线程的栈">查看CPU使用率top n线程的栈</span></h4><p>参数<code>n</code>用来指定最忙的前N个线程并打印堆栈</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread -n 3</span><br></pre></td></tr></table></figure><p>参数<code>i</code>用来指定cpu占比统计的采样间隔，单位为毫秒</p><p>查看5秒内的CPU使用率top n线程栈</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread -n 3 -i 5000</span><br></pre></td></tr></table></figure><h4><span id="查找线程是否有阻塞">查找线程是否有阻塞</span></h4><p>参数<code>b</code>用来指定找出当前阻塞其他线程的线程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread -b</span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>通过本教程基本掌握了Arthas查找Top N线程。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 最佳实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas 排查logger冲突问题 案例</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5logger%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%E6%A1%88%E4%BE%8B/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5logger%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#start-demo">Start demo</a></li><li><a href="#start-arthas-boot">Start arthas-boot</a></li><li><a href="#%E6%8E%92%E6%9F%A5logger%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98">排查logger冲突问题</a><ul><li><a href="#%E6%9F%A5%E6%89%BEusercontroller%E7%9A%84classloader">查找UserController的ClassLoader</a></li><li><a href="#%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%94%A8%E4%BD%BF%E7%94%A8%E7%9A%84logger%E7%B3%BB%E7%BB%9F">确认应用使用的logger系统</a></li><li><a href="#%E8%8E%B7%E5%8F%96logback%E5%AE%9E%E9%99%85%E5%8A%A0%E8%BD%BD%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">获取logback实际加载的配置文件</a></li><li><a href="#%E4%BD%BF%E7%94%A8classloader%E5%91%BD%E4%BB%A4%E6%9F%A5%E6%89%BE%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84logger%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">使用classloader命令查找可能存在的logger配置文件</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5logger%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%E6%A1%88%E4%BE%8B/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个普通的Spring Boot应用为例，演示排查logger冲突问题。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="start-demo">Start demo</span></h2><p>下载<code>demo-arthas-spring-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar</span><br></pre></td></tr></table></figure><p><code>demo-arthas-spring-boot</code>是一个很简单的spring boot应用，源代码：<a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-arthas-spring-boot">查看</a></p><p>启动之后，可以访问61000端口： 点击查看</p><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5logger%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%E6%A1%88%E4%BE%8B/O1CN010Qbzcz1ctPSWSZI6L_!!6000000003658-2-tps-333-182.png" alt="Demo Web"></p><h2><span id="start-arthas-boot">Start arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5logger%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%E6%A1%88%E4%BE%8B/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="排查logger冲突问题">排查logger冲突问题</span></h2><p>在这个案例里，展示排查logger冲突的方法。</p><h4><span id="查找usercontroller的classloader">查找UserController的ClassLoader</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span></span><br><span class="line"> classLoaderHash   1be6f5c3</span><br></pre></td></tr></table></figure><p>注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。</p><p>如果你使用<code>-c</code>，你需要手动输入hashcode：<code>-c &lt;hashcode&gt;</code></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl -c 1be6f5c3 @com.example.demo.arthas.user.UserController@logger</span></span><br></pre></td></tr></table></figure><p>对于只有唯一实例的ClassLoader可以通过<code>--classLoaderClass</code>指定class name，使用起来更加方便：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader  @org.springframework.boot.SpringApplication@logger</span></span><br><span class="line">@Slf4jLocationAwareLog[</span><br><span class="line">    FQCN=@String[org.apache.commons.logging.LogAdapter$Slf4jLocationAwareLog],</span><br><span class="line">    name=@String[org.springframework.boot.SpringApplication],</span><br><span class="line">    logger=@Logger[Logger[org.springframework.boot.SpringApplication]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>--classLoaderClass</code> 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而<code>-c &lt;hashcode&gt;</code>是动态变化的。</p><h4><span id="确认应用使用的logger系统">确认应用使用的logger系统</span></h4><p>以<code>UserController</code>为例，它使用的是slf4j api，但实际使用到的logger系统是logback。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span></span></span><br><span class="line">@Logger[</span><br><span class="line">    serialVersionUID=@Long[5454405123156820674],</span><br><span class="line">    FQCN=@String[ch.qos.logback.classic.Logger],</span><br><span class="line">    name=@String[com.example.demo.arthas.user.UserController],</span><br><span class="line">    level=null,</span><br><span class="line">    effectiveLevelInt=@Integer[20000],</span><br><span class="line">    parent=@Logger[Logger[com.example.demo.arthas.user]],</span><br><span class="line">    childrenList=null,</span><br><span class="line">    aai=null,</span><br><span class="line">    additive=@Boolean[true],</span><br><span class="line">    loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4><span id="获取logback实际加载的配置文件">获取logback实际加载的配置文件</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;#map1=@org.slf4j.LoggerFactory@getLogger(&quot;root&quot;).loggerContext.objectMap, #map1.get(&quot;CONFIGURATION_WATCH_LIST&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h4><span id="使用classloader命令查找可能存在的logger配置文件">使用classloader命令查找可能存在的logger配置文件</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml</span><br><span class="line"> jar:file:/Users/hengyunabc/code/java/spring-boot-inside/demo-arthas-spring-boot/target/demo-arthas-spring-boot-0.0.1-SNAPSHOT.jar!/BOOT-INF/classes!/logback-spring.xml</span><br><span class="line"></span><br><span class="line">Affect(row-cnt:1) cost in 13 ms.</span><br></pre></td></tr></table></figure><p>可以知道加载的配置的具体来源。</p><p>可以尝试加载容易冲突的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback.xml</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r log4j.properties</span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>通过本教程基本掌握了Arthas排查logger冲突问题。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 最佳实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas 热更新代码 案例</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E7%83%AD%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E7%83%AD%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#start-demo">Start demo</a></li><li><a href="#start-arthas-boot">Start arthas-boot</a></li><li><a href="#%E7%83%AD%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81">热更新代码</a><ul><li><a href="#jad%E5%8F%8D%E7%BC%96%E8%AF%91usercontroller">jad反编译UserController</a></li><li><a href="#sc%E6%9F%A5%E6%89%BE%E5%8A%A0%E8%BD%BDusercontroller%E7%9A%84classloader">sc查找加载UserController的ClassLoader</a></li><li><a href="#mc">mc</a></li><li><a href="#redefine">redefine</a></li><li><a href="#%E7%83%AD%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C">热修改代码结果</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E7%83%AD%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个普通的Spring Boot应用为例，演示热更新代码。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="start-demo">Start demo</span></h2><p>下载<code>demo-arthas-spring-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar</span><br></pre></td></tr></table></figure><p><code>demo-arthas-spring-boot</code>是一个很简单的spring boot应用，源代码：<a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-arthas-spring-boot">查看</a></p><p>启动之后，可以访问61000端口： 点击查看</p><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E7%83%AD%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B/O1CN010Qbzcz1ctPSWSZI6L_!!6000000003658-2-tps-333-182.png" alt="Demo Web"></p><h2><span id="start-arthas-boot">Start arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E7%83%AD%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="热更新代码">热更新代码</span></h2><p>下面介绍通过<code>jad</code>/<code>mc</code>/<code>redefine</code> 命令实现动态更新代码的功能。</p><p>目前，访问 <a href="http://localhost:61000/user/0">http://localhost:61000/user/0</a> ，会返回500异常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:61000/user/0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;timestamp&quot;:1550223186170,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;exception&quot;:&quot;java.lang.IllegalArgumentException&quot;,&quot;message&quot;:&quot;id &lt; 1&quot;,&quot;path&quot;:&quot;/user/0&quot;&#125;</span><br></pre></td></tr></table></figure><p>下面通过热更新代码，修改这个逻辑。</p><h4><span id="jad反编译usercontroller">jad反编译UserController</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java</span><br></pre></td></tr></table></figure><p>jad反编译的结果保存在 <code>/tmp/UserController.java</code>文件里了。</p><p>再打开一个<code>Terminal 3</code>，然后用vim来编辑<code>/tmp/UserController.java</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /tmp/UserController.java</span><br></pre></td></tr></table></figure><p>比如当 user id 小于1时，也正常返回，不抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value=&#123;&quot;/user/&#123;id&#125;&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">&quot;id: &#123;&#125;&quot;</span>, (Object)id);</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="keyword">null</span> &amp;&amp; id &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(id, <span class="string">&quot;name&quot;</span> + id);</span><br><span class="line">        <span class="comment">// throw new IllegalArgumentException(&quot;id &lt; 1&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(id.intValue(), <span class="string">&quot;name&quot;</span> + id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="sc查找加载usercontroller的classloader">sc查找加载UserController的ClassLoader</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d *UserController | grep classLoaderHash</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sc -d *UserController | grep classLoaderHash</span></span><br><span class="line"> classLoaderHash   1be6f5c3</span><br></pre></td></tr></table></figure><p>可以发现是 spring boot <code>LaunchedURLClassLoader@1be6f5c3</code> 加载的。</p><p>注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。</p><p>如果你使用<code>-c</code>，你需要手动输入hashcode：<code>-c &lt;hashcode&gt;</code></p><p>对于只有唯一实例的ClassLoader可以通过<code>--classLoaderClass</code>指定class name，使用起来更加方便.</p><p><code>--classLoaderClass</code> 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而<code>-c &lt;hashcode&gt;</code>是动态变化的。</p><h4><span id="mc">mc</span></h4><p>保存好<code>/tmp/UserController.java</code>之后，使用<code>mc</code>(Memory Compiler)命令来编译，并且通过<code>--classLoaderClass</code>参数指定ClassLoader：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmp</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmp</span></span><br><span class="line">Memory compiler output:</span><br><span class="line">/tmp/com/example/demo/arthas/user/UserController.class</span><br><span class="line">Affect(row-cnt:1) cost in 346 ms</span><br></pre></td></tr></table></figure><p>也可以通过<code>mc -c &lt;classLoaderHash&gt; /tmp/UserController.java -d /tmp</code>，使用<code>-c</code>参数指定ClassLoaderHash:</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mc -c 1be6f5c3 /tmp/UserController.java -d /tmp</span></span><br></pre></td></tr></table></figure><h4><span id="redefine">redefine</span></h4><p>再使用<code>redefine</code>命令重新加载新编译好的<code>UserController.class</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redefine /tmp/com/example/demo/arthas/user/UserController.class</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redefine /tmp/com/example/demo/arthas/user/UserController.class</span><br><span class="line">redefine success, size: 1</span><br></pre></td></tr></table></figure><h4><span id="热修改代码结果">热修改代码结果</span></h4><p><code>redefine</code>成功之后，再次访问 user/0 ，结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 0,</span><br><span class="line">  &quot;name&quot;: &quot;name0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>通过本教程基本掌握了Arthas热更新代码。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 最佳实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas Http API案例</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/ArthasHttpAPI%E6%A1%88%E4%BE%8B/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/ArthasHttpAPI%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8arthas-demo">启动arthas demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#http-api">Http API</a><ul><li><a href="#%E6%AD%A4%E6%95%99%E7%A8%8B%E6%9A%82%E6%97%B6%E6%97%A0%E6%B3%95%E5%9C%A8handson%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%BF%90%E8%A1%8C%E5%90%8C%E5%AD%A6%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%9C%AC%E5%9C%B0%E5%B0%9D%E8%AF%95">此教程暂时无法在Handson环境下运行,同学们可以在本地尝试</a><ul><li><a href="#%E6%A6%82%E8%A7%88">概览</a><ul><li><a href="#%E8%AE%BF%E9%97%AE%E5%9C%B0%E5%9D%80">访问地址</a></li><li><a href="#%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F">请求数据格式</a></li><li><a href="#%E8%AF%B7%E6%B1%82action">请求Action</a></li><li><a href="#%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81">响应状态</a></li></ul></li></ul></li></ul></li><li><a href="#%E4%B8%80%E6%AC%A1%E6%80%A7%E5%91%BD%E4%BB%A4">一次性命令</a></li><li><a href="#%E4%BC%9A%E8%AF%9D%E4%BA%A4%E4%BA%92">会话交互</a><pre><code>* [创建会话](#创建会话)* [加入会话](#加入会话)* [拉取命令结果](#拉取命令结果)* [异步执行命令](#异步执行命令)* [中断命令执行](#中断命令执行)* [关闭会话](#关闭会话)</code></pre></li><li><a href="#web-ui">Web UI</a></li><li><a href="#watch%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BAmap%E5%AF%B9%E8%B1%A1">watch命令输出map对象</a></li></ul><ul><li><a href="#foo-foo-value-bar-bar-value">{ “foo” : “foo value”, “bar” : “bar value” }</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/ArthasHttpAPI%E6%A1%88%E4%BE%8B/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示http-api案例。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><h2><span id="启动arthas-demo">启动arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/ArthasHttpAPI%E6%A1%88%E4%BE%8B/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="http-api">Http API</span></h2><h3><span id="此教程暂时无法在handson环境下运行同学们可以在本地尝试">此教程暂时无法在Handson环境下运行,同学们可以在本地尝试</span></h3><h4><span id="概览">概览</span></h4><p>Http API 提供类似RESTful的交互接口，请求和响应均为JSON格式的数据。相对于Telnet/WebConsole的输出非结构化文本数据，Http API可以提供结构化的数据，支持更复杂的交互功能，比如特定应用场景的一系列诊断操作。</p><h5><span id="访问地址">访问地址</span></h5><p>Http API接口地址为：<code>http://ip:port/api</code>，必须使用POST方式提交请求参数。如POST <code>http://127.0.0.1:8563/api</code> 。</p><p>注意：telnet服务的3658端口与Chrome浏览器有兼容性问题，建议使用http端口8563来访问http接口。</p><h5><span id="请求数据格式">请求数据格式</span></h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;action&quot;</span>: <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;requestId&quot;</span>: <span class="string">&quot;req112&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;sessionId&quot;</span>: <span class="string">&quot;94766d3c-8b39-42d3-8596-98aee3ccbefb&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;consumerId&quot;</span>: <span class="string">&quot;955dbd1325334a84972b0f3ac19de4f7_2&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;version&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;execTimeout&quot;</span>: <span class="string">&quot;10000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求数据格式说明：</p><ul><li><code>action</code> : 请求的动作/行为，可选值请参考”请求Action”小节。</li><li><code>requestId</code> : 可选请求ID，由客户端生成。</li><li><code>sessionId</code> : Arthas会话ID，一次性命令不需要设置会话ID。</li><li><code>consumerId</code> : Arthas消费者ID，用于多人共享会话。</li><li><code>command</code> : Arthas command line 。</li><li><code>execTimeout</code> : 命令同步执行的超时时间(ms)，默认为30000。</li></ul><p>注意: 不同的action使用到参数不同，根据具体的action来设置参数。</p><h5><span id="请求action">请求Action</span></h5><p>目前支持的请求Action如下：</p><ul><li><code>exec</code> : 同步执行命令，命令正常结束或者超时后中断命令执行后返回命令的执行结果。</li><li><code>async_exec</code> : 异步执行命令，立即返回命令的调度结果，命令执行结果通过<code>pull_results</code>获取。</li><li><code>interrupt_job</code> : 中断会话当前的命令，类似Telnet <code>Ctrl + c</code>的功能。</li><li><code>pull_results</code> : 获取异步执行的命令的结果，以http 长轮询（long-polling）方式重复执行</li><li><code>init_session</code> : 创建会话</li><li><code>join_session</code> : 加入会话，用于支持多人共享同一个Arthas会话</li><li><code>close_session</code> : 关闭会话</li></ul><h5><span id="响应状态">响应状态</span></h5><p>响应中的state属性表示请求处理状态，取值如下：</p><ul><li><code>SCHEDULED</code>：异步执行命令时表示已经创建job并已提交到命令执行队列，命令可能还没开始执行或者执行中；</li><li><code>SUCCEEDED</code>：请求处理成功（完成状态）；</li><li><code>FAILED</code>：请求处理失败（完成状态），通常附带message说明原因；</li><li><code>REFUSED</code>：请求被拒绝（完成状态），通常附带message说明原因；</li></ul><h2><span id="一次性命令">一次性命令</span></h2><p>与执行批处理命令类似，一次性命令以同步方式执行。不需要创建会话，不需要设置<code>sessionId</code>选项。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;action&quot;</span>: <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;&lt;Arthas command line&gt;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如获取Arthas版本号：</p><p><code>curl -Ss -XPOST http://localhost:8563/api -d &#39;;&#123; &quot;action&quot;:&quot;exec&quot;, &quot;command&quot;:&quot;version&quot; &#125;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; | json_pp</span></span><br></pre></td></tr></table></figure><p>响应内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;state&quot;</span> : <span class="string">&quot;SUCCEEDED&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;sessionId&quot;</span> : <span class="string">&quot;ee3bc004-4586-43de-bac0-b69d6db7a869&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;body&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;results&quot;</span> : [</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;version&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;version&quot;</span> : <span class="string">&quot;3.3.7&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;jobId&quot;</span> : <span class="number">5</span></span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">&quot;jobId&quot;</span> : <span class="number">5</span>,</span><br><span class="line">            <span class="attr">&quot;statusCode&quot;</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;status&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;timeExpired&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;command&quot;</span> : <span class="string">&quot;version&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;jobStatus&quot;</span> : <span class="string">&quot;TERMINATED&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;jobId&quot;</span> : <span class="number">5</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>响应数据解析：</p><ul><li><code>state</code>: 请求处理状态，参考“接口响应状态”说明</li><li><code>sessionId</code>: Arthas会话ID，一次性命令自动创建及销毁临时会话</li><li><code>body.jobId</code>: 命令的任务ID，同一任务输出的所有Result都是相同的jobId</li><li><code>body.jobStatus</code>: 任务状态，同步执行正常结束为<code>TERMINATED</code></li><li><code>body.timeExpired</code>: 任务执行是否超时</li><li><code>body/results</code>: 命令执行的结果列表</li></ul><p><strong>命令结果格式说明</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">   <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;version&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;version&quot;</span> : <span class="string">&quot;3.3.7&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;jobId&quot;</span> : <span class="number">5</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;jobId&quot;</span> : <span class="number">5</span>,</span><br><span class="line">   <span class="attr">&quot;statusCode&quot;</span> : <span class="number">0</span>,</span><br><span class="line">   <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;status&quot;</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><ul><li><code>type</code> : 命令结果类型，除了<code>status</code>等特殊的几个外，其它的保持与Arthas命令名称一致。请参考”特殊命令结果”小节。</li><li><code>jobId</code> : 处理命令的任务ID。</li><li>其它字段为每个不同命令的数据。</li></ul><p>注意：也可以使用一次性命令的方式执行watch/trace等连续输出的命令，但不能中断命令执行，可能出现长时间没有结束的问题。请参考”watch命令输出map对象”小节的示例。</p><p>请尽量按照以下方式处理：</p><ul><li>设置合理的<code>execTimeout</code>，到达超时时间后强制中断命令执行，避免长时间挂起。</li><li>通过<code>-n</code>参数指定较少的执行次数。</li><li>保证命令匹配的方法可以成功命中和condition-express编写正确，如果watch/trace没有命中就算指定<code>-n 1</code>也会挂起等待到执行超时。</li></ul><h2><span id="会话交互">会话交互</span></h2><p>由用户创建及管理Arthas会话，适用于复杂的交互过程。访问流程如下：</p><ul><li>创建会话</li><li>加入会话(可选）</li><li>拉取命令结果</li><li>执行一系列命令</li><li>中断命令执行</li><li>关闭会话</li></ul><h5><span id="创建会话">创建会话</span></h5><p>创建会话, 保存输出到bash环境变量</p><p><code>session*data=$(curl -Ss -XPOST http://localhost:8563/api -d &#39;;&#123; &quot;action&quot;:&quot;init*session&quot; &#125; &#39;)</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$session_data</span> | json_pp</span><br></pre></td></tr></table></figure><p>注： <code>json_pp</code> 工具将输出内容格式化为pretty json。</p><p>响应结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;sessionId&quot;</span> : <span class="string">&quot;b09f1353-202c-407b-af24-701b744f971e&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;consumerId&quot;</span> : <span class="string">&quot;5ae4e5fbab8b4e529ac404f260d4e2d1_1&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;state&quot;</span> : <span class="string">&quot;SUCCEEDED&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提取会话ID和消费者ID。</p><p>当前会话ID为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session_id=$(<span class="built_in">echo</span> <span class="variable">$session_data</span> | sed <span class="string">&#x27;s/.*&quot;sessionId&quot;:&quot;\([^&quot;]*\)&quot;.*/\1/g&#x27;</span>);<span class="built_in">echo</span> <span class="variable">$session_id</span></span><br></pre></td></tr></table></figure><p><code>b09f1353-202c-407b-af24-701b744f971e</code>;</p><p>请记下这里的会话ID，在Terminal 4中需要手动输入。</p><p>当前消费者ID为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer_id=$(<span class="built_in">echo</span> <span class="variable">$session_data</span> | sed <span class="string">&#x27;s/.*&quot;consumerId&quot;:&quot;\([^&quot;]*\)&quot;.*/\1/g&#x27;</span>);<span class="built_in">echo</span> <span class="variable">$consumer_id</span></span><br></pre></td></tr></table></figure><p><code>5ae4e5fbab8b4e529ac404f260d4e2d1_1</code>。</p><h5><span id="加入会话">加入会话</span></h5><p>指定要加入的会话ID，服务端将分配一个新的消费者ID。多个消费者可以接收到同一个会话的命令结果。本接口用于支持多人共享同一个会话或刷新页面后重新拉取会话历史记录。</p><p>加入会话，保存输出到bash环境变量</p><p><code>session*data=$(curl -Ss -XPOST http://localhost:8563/api -d &#39;;&#123; &quot;action&quot;:&quot;join*session&quot;, &quot;sessionId&quot; : &quot;&#39;&quot;$session_id&quot;&#39;&quot; &#125; &#39;)</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$session_data</span> | json_pp</span><br></pre></td></tr></table></figure><p>响应结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;consumerId&quot;</span> : <span class="string">&quot;8f7f6ad7bc2d4cb5aa57a530927a95cc_2&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;sessionId&quot;</span> : <span class="string">&quot;b09f1353-202c-407b-af24-701b744f971e&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;state&quot;</span> : <span class="string">&quot;SUCCEEDED&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提取消费者ID。</p><p>新的消费者ID为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer_id=$(<span class="built_in">echo</span> <span class="variable">$session_data</span> | sed <span class="string">&#x27;s/.*&quot;consumerId&quot;:&quot;\([^&quot;]*\)&quot;.*/\1/g&#x27;</span>);<span class="built_in">echo</span> <span class="variable">$consumer_id</span></span><br></pre></td></tr></table></figure><p><code>8f7f6ad7bc2d4cb5aa57a530927a95cc_2</code> 。</p><p>请记下这里的消费者ID，在Terminal 4中需要手动输入。</p><h5><span id="拉取命令结果">拉取命令结果</span></h5><p>拉取命令结果消息的action为<code>pull_results</code>。请使用Http long-polling方式，定时循环拉取结果消息。 消费者的超时时间为5分钟，超时后需要调用<code>join_session</code>分配新的消费者。每个消费者单独分配一个缓存队列，按顺序拉取命令结果，不会影响到其它消费者。</p><p>请求参数需要指定会话ID及消费者ID:</p><p><code>curl -Ss -XPOST http://localhost:8563/api -d &#39;;&#123; &quot;action&quot;:&quot;pull*results&quot;, &quot;sessionId&quot; : &quot;&#39;&quot;$session*id&quot;&#39;&quot;, &quot;consumerId&quot; : &quot;&#39;&quot;$consumer_id&quot;&#39;&quot; &#125;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; | json_pp</span></span><br></pre></td></tr></table></figure><p>用Bash脚本定时拉取结果消息:</p><p>请在Terminal 4中输入Terminal 3中的会话ID，这里的例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b09f1353-202c-407b-af24-701b744f971e</span><br><span class="line">echo -n &quot;Enter your sessionId in T3:&quot;;read  session_id</span><br></pre></td></tr></table></figure><p>同样，接着输入Terminal 3中的消费者ID，这里的例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8f7f6ad7bc2d4cb5aa57a530927a95cc_2</span><br><span class="line">echo -n &quot;Enter your consumerId in T3:&quot;;read  consumer_id</span><br></pre></td></tr></table></figure><p><code>while true; do curl -Ss -XPOST http://localhost:8563/api -d &#39;;&#123; &quot;action&quot;:&quot;pull*results&quot;, &quot;sessionId&quot; : &quot;&#39;&quot;$session*id&quot;&#39;&quot;, &quot;consumerId&quot; : &quot;&#39;&quot;$consumer_id&quot;&#39;&quot; &#125;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; | json_pp; sleep 2; done</span></span><br></pre></td></tr></table></figure><p>响应内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;body&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;results&quot;</span> : [</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">&quot;inputStatus&quot;</span> : <span class="string">&quot;DISABLED&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;jobId&quot;</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;input_status&quot;</span></span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;message&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;jobId&quot;</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;message&quot;</span> : <span class="string">&quot;Welcome to arthas!&quot;</span></span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">&quot;tutorials&quot;</span> : <span class="string">&quot;https://arthas.aliyun.com/doc/arthas-tutorials.html&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;time&quot;</span> : <span class="string">&quot;2020-08-06 15:56:43&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;welcome&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;jobId&quot;</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;pid&quot;</span> : <span class="string">&quot;7909&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;wiki&quot;</span> : <span class="string">&quot;https://arthas.aliyun.com/doc&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;version&quot;</span> : <span class="string">&quot;3.3.7&quot;</span></span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">&quot;inputStatus&quot;</span> : <span class="string">&quot;ALLOW_INPUT&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;input_status&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;jobId&quot;</span> : <span class="number">0</span></span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">&quot;sessionId&quot;</span> : <span class="string">&quot;b09f1353-202c-407b-af24-701b744f971e&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;consumerId&quot;</span> : <span class="string">&quot;8f7f6ad7bc2d4cb5aa57a530927a95cc_2&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;state&quot;</span> : <span class="string">&quot;SUCCEEDED&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="异步执行命令">异步执行命令</span></h5><p><code>curl -Ss -XPOST http://localhost:8563/api -d &#39;&#39;&#39;;&#123; &quot;action&quot;:&quot;async*exec&quot;, &quot;command&quot;:&quot;watch demo.MathGame primeFactors \&quot;&#123;params, returnObj, throwExp&#125;\&quot; &quot;, &quot;sessionId&quot; : &quot;&#39;&quot;$session*id&quot;&#39;&quot; &#125;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27; | json_pp</span></span><br></pre></td></tr></table></figure><p><code>async_exec</code> 的结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;sessionId&quot;</span> : <span class="string">&quot;2b085b5d-883b-4914-ab35-b2c5c1d5aa2a&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;state&quot;</span> : <span class="string">&quot;SCHEDULED&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;body&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;jobStatus&quot;</span> : <span class="string">&quot;READY&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;jobId&quot;</span> : <span class="number">3</span>,</span><br><span class="line">      <span class="attr">&quot;command&quot;</span> : <span class="string">&quot;watch demo.MathGame primeFactors \&quot;&#123;params, returnObj, throwExp&#125;\&quot; &quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>state</code> : <code>SCHEDULED</code> 状态表示已经解析命令生成任务，但未开始执行。</li><li><code>body.jobId</code> : 异步执行命令的任务ID，可以根据此任务ID来过滤在<code>pull_results</code>输出的命令结果。</li><li><code>body.jobStatus</code> : 任务状态<code>READY</code>表示未开始执行。 切换到上面自动拉取结果消息脚本的shell（Terminal 4），查看输出：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;body&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;results&quot;</span> : [</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;command&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;jobId&quot;</span> : <span class="number">3</span>,</span><br><span class="line">            <span class="attr">&quot;state&quot;</span> : <span class="string">&quot;SCHEDULED&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span> : <span class="string">&quot;watch demo.MathGame primeFactors \&quot;&#123;params, returnObj, throwExp&#125;\&quot; &quot;</span></span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">&quot;inputStatus&quot;</span> : <span class="string">&quot;ALLOW_INTERRUPT&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;jobId&quot;</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;input_status&quot;</span></span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">&quot;success&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">&quot;jobId&quot;</span> : <span class="number">3</span>,</span><br><span class="line">            <span class="attr">&quot;effect&quot;</span> : &#123;</span><br><span class="line">               <span class="attr">&quot;listenerId&quot;</span> : <span class="number">3</span>,</span><br><span class="line">               <span class="attr">&quot;cost&quot;</span> : <span class="number">24</span>,</span><br><span class="line">               <span class="attr">&quot;classCount&quot;</span> : <span class="number">1</span>,</span><br><span class="line">               <span class="attr">&quot;methodCount&quot;</span> : <span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;enhancer&quot;</span></span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">&quot;sizeLimit&quot;</span> : <span class="number">10485760</span>,</span><br><span class="line">            <span class="attr">&quot;expand&quot;</span> : <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;jobId&quot;</span> : <span class="number">3</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;watch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;cost&quot;</span> : <span class="number">0.071499</span>,</span><br><span class="line">            <span class="attr">&quot;ts&quot;</span> : <span class="number">1596703453237</span>,</span><br><span class="line">            <span class="attr">&quot;value&quot;</span> : [</span><br><span class="line">               [</span><br><span class="line">                  <span class="number">-170365</span></span><br><span class="line">               ],</span><br><span class="line">               <span class="literal">null</span>,</span><br><span class="line">               &#123;</span><br><span class="line">                  <span class="attr">&quot;stackTrace&quot;</span> : [</span><br><span class="line">                     &#123;</span><br><span class="line">                        <span class="attr">&quot;className&quot;</span> : <span class="string">&quot;demo.MathGame&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;classLoaderName&quot;</span> : <span class="string">&quot;app&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;methodName&quot;</span> : <span class="string">&quot;primeFactors&quot;</span>,</span><br><span class="line">                        <span class="attr">&quot;nativeMethod&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">                        <span class="attr">&quot;lineNumber&quot;</span> : <span class="number">46</span>,</span><br><span class="line">                        <span class="attr">&quot;fileName&quot;</span> : <span class="string">&quot;MathGame.java&quot;</span></span><br><span class="line">                     &#125;,</span><br><span class="line">                     ...</span><br><span class="line">                  ],</span><br><span class="line">                  <span class="attr">&quot;localizedMessage&quot;</span> : <span class="string">&quot;number is: -170365, need &gt;= 2&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;@type&quot;</span> : <span class="string">&quot;java.lang.IllegalArgumentException&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;message&quot;</span> : <span class="string">&quot;number is: -170365, need &gt;= 2&quot;</span></span><br><span class="line">               &#125;</span><br><span class="line">            ]</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;watch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;cost&quot;</span> : <span class="number">0.033375</span>,</span><br><span class="line">            <span class="attr">&quot;jobId&quot;</span> : <span class="number">3</span>,</span><br><span class="line">            <span class="attr">&quot;ts&quot;</span> : <span class="number">1596703454241</span>,</span><br><span class="line">            <span class="attr">&quot;value&quot;</span> : [</span><br><span class="line">               [</span><br><span class="line">                  <span class="number">1</span></span><br><span class="line">               ],</span><br><span class="line">               [</span><br><span class="line">                  <span class="number">2</span>,</span><br><span class="line">                  <span class="number">2</span>,</span><br><span class="line">                  <span class="number">2</span>,</span><br><span class="line">                  <span class="number">2</span>,</span><br><span class="line">                  <span class="number">13</span>,</span><br><span class="line">                  <span class="number">491</span></span><br><span class="line">               ],</span><br><span class="line">               <span class="literal">null</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;sizeLimit&quot;</span> : <span class="number">10485760</span>,</span><br><span class="line">            <span class="attr">&quot;expand&quot;</span> : <span class="number">1</span></span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">&quot;consumerId&quot;</span> : <span class="string">&quot;8ecb9cb7c7804d5d92e258b23d5245cc_1&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;sessionId&quot;</span> : <span class="string">&quot;2b085b5d-883b-4914-ab35-b2c5c1d5aa2a&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;state&quot;</span> : <span class="string">&quot;SUCCEEDED&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>watch命令结果的<code>value</code>为watch-experss的值，上面命令中为<code>&#123;params, returnObj, throwExp&#125;</code>，所以watch结果的value为一个长度为3的数组，每个元素分别对应相应顺序的表达式。 请参考”watch命令输出map对象”小节。</p><h5><span id="中断命令执行">中断命令执行</span></h5><p>中断会话正在运行的前台Job（前台任务）：</p><p><code>curl -Ss -XPOST http://localhost:8563/api -d &#39;&#39;&#39;;&#123; &quot;action&quot;:&quot;interrupt*job&quot;, &quot;sessionId&quot; : &quot;&#39;&quot;$session*id&quot;&#39;&quot; &#125;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27; | json_pp</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;state&quot;</span> : <span class="string">&quot;SUCCEEDED&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;body&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;jobStatus&quot;</span> : <span class="string">&quot;TERMINATED&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;jobId&quot;</span> : <span class="number">3</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="关闭会话">关闭会话</span></h5><p>指定会话ID，关闭会话。</p><p><code>curl -Ss -XPOST http://localhost:8563/api -d &#39;&#39;&#39;;&#123; &quot;action&quot;:&quot;close*session&quot;, &quot;sessionId&quot; : &quot;&#39;&quot;$session*id&quot;&#39;&quot; &#125;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27; | json_pp</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;state&quot;</span> : <span class="string">&quot;SUCCEEDED&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="web-ui">Web UI</span></h2><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/ArthasHttpAPI%E6%A1%88%E4%BE%8B/arthas-web-ui.png" alt="arthas web ui"></p><p>一个基于Http API接口实现的Web UI，访问地址为： 。</p><p>已实现功能：</p><ul><li>创建会话</li><li>复制并打开url加入会话，多人共享会话</li><li>周期性拉取会话命令结果消息</li><li>刷新页面或者加入会话拉取会话历史命令消息</li><li>输入命令/中断命令状态控制</li></ul><p>待开发功能：</p><ul><li>改进将命令结果消息可读性</li><li>命令输入支持自动完成及命令模板</li><li>提供命令帮助</li><li>支持个人选项设置</li></ul><h2><span id="watch命令输出map对象">watch命令输出map对象</span></h2><p>watch的结果值由计算<code>watch-express</code> ognl表达式产生，可以通过改变ognl表达式来生成想要的值，请参考<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html">OGNL文档</a>。</p><blockquote><p>Maps can also be created using a special syntax.</p><h1><span id="foo-foo-value-bar-bar-value">{ “foo” : “foo value”, “bar” : “bar value” }</span></h1></blockquote><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 最佳实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas 排查HTTP请求返回404 案例</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5HTTP%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E404%E6%A1%88%E4%BE%8B/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5HTTP%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E404%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#start-demo">Start demo</a></li><li><a href="#start-arthas-boot">Start arthas-boot</a></li><li><a href="#%E6%8E%92%E6%9F%A5http%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E404">排查HTTP请求返回404</a><ul><li><a href="#%E8%B7%9F%E8%B8%AA%E6%89%80%E6%9C%89%E7%9A%84servlet%E5%87%BD%E6%95%B0">跟踪所有的Servlet函数</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5HTTP%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E404%E6%A1%88%E4%BE%8B/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个普通的Spring Boot应用为例，演示排查HTTP请求返回404。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="start-demo">Start demo</span></h2><p>下载<code>demo-arthas-spring-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar</span><br></pre></td></tr></table></figure><p><code>demo-arthas-spring-boot</code>是一个很简单的spring boot应用，源代码：<a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-arthas-spring-boot">查看</a></p><p>启动之后，可以访问61000端口： 点击查看</p><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5HTTP%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E404%E6%A1%88%E4%BE%8B/O1CN010Qbzcz1ctPSWSZI6L_!!6000000003658-2-tps-333-182.png" alt="Demo Web"></p><h2><span id="start-arthas-boot">Start arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5HTTP%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E404%E6%A1%88%E4%BE%8B/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="排查http请求返回404">排查HTTP请求返回404</span></h2><p>在这个案例里，展示排查HTTP 404问题的技巧。</p><p>访问： a.txt</p><p>结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Something went wrong: 404 Not Found</span><br></pre></td></tr></table></figure><p>那么到底是哪个Servlet处理了这个请求，返回了404？</p><h4><span id="跟踪所有的servlet函数">跟踪所有的Servlet函数</span></h4><p>开始trace：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace javax.servlet.Servlet * &gt; /tmp/servlet.txt</span><br></pre></td></tr></table></figure><p>访问： a.txt</p><p>在<code>Terminal 3</code>里，查看<code>/tmp/servlet.txt</code>的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less /tmp/servlet.txt</span><br></pre></td></tr></table></figure><p><code>/tmp/servlet.txt</code>里的内容会比较多，需要耐心找到调用树里最长的地方。</p><p>可以发现请求最终是被<code>freemarker</code>处理的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">`---[13.974188ms] org.springframework.web.servlet.ViewResolver:resolveViewName();    +---[0.045561ms] javax.servlet.GenericServlet:&lt;init&gt;()</span><br><span class="line">    +---[min=0.045545ms,max=0.074342ms,total=0.119887ms,count=2] org.springframework.web.servlet.view.freemarker.FreeMarkerView$GenericServletAdapter:&lt;init&gt;()</span><br><span class="line">    +---[0.170895ms] javax.servlet.GenericServlet:init()</span><br><span class="line">    |   `---[0.068578ms] javax.servlet.GenericServlet:init()</span><br><span class="line">    |       `---[0.021793ms] javax.servlet.GenericServlet:init()</span><br><span class="line">    `---[0.164035ms] javax.servlet.GenericServlet:getServletContext()</span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>通过本教程基本掌握了Arthas排查HTTP请求返回404。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 最佳实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas 排查HTTP请求返回401 案例</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5HTTP%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E401%E6%A1%88%E4%BE%8B/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5HTTP%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E401%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#start-demo">Start demo</a></li><li><a href="#start-arthas-boot">Start arthas-boot</a></li><li><a href="#%E6%8E%92%E6%9F%A5http%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E401">排查HTTP请求返回401</a><ul><li><a href="#%E8%B7%9F%E8%B8%AA%E6%89%80%E6%9C%89%E7%9A%84filter%E5%87%BD%E6%95%B0">跟踪所有的Filter函数</a></li><li><a href="#%E9%80%9A%E8%BF%87stack%E8%8E%B7%E5%8F%96%E8%B0%83%E7%94%A8%E6%A0%88">通过stack获取调用栈</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5HTTP%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E401%E6%A1%88%E4%BE%8B/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个普通的Spring Boot应用为例，演示排查HTTP请求返回401。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="start-demo">Start demo</span></h2><p>下载<code>demo-arthas-spring-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar</span><br></pre></td></tr></table></figure><p><code>demo-arthas-spring-boot</code>是一个很简单的spring boot应用，源代码：<a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-arthas-spring-boot">查看</a></p><p>启动之后，可以访问61000端口： 点击查看</p><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5HTTP%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E401%E6%A1%88%E4%BE%8B/O1CN010Qbzcz1ctPSWSZI6L_!!6000000003658-2-tps-333-182.png" alt="Demo Web"></p><h2><span id="start-arthas-boot">Start arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E6%8E%92%E6%9F%A5HTTP%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E401%E6%A1%88%E4%BE%8B/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="排查http请求返回401">排查HTTP请求返回401</span></h2><p>在这个案例里，展示排查HTTP 401问题的技巧。</p><p>访问： admin</p><p>结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Something went wrong: 401 Unauthorized</span><br></pre></td></tr></table></figure><p>我们知道<code>401</code>通常是被权限管理的<code>Filter</code>拦截了，那么到底是哪个<code>Filter</code>处理了这个请求，返回了401？</p><h4><span id="跟踪所有的filter函数">跟踪所有的Filter函数</span></h4><p>开始trace：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace javax.servlet.Filter *</span><br></pre></td></tr></table></figure><p>访问： admin</p><p>可以在调用树的最深层，找到<code>AdminFilterConfig$AdminFilter</code>返回了<code>401</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+---[3.806273ms] javax.servlet.FilterChain:doFilter()</span><br><span class="line">|   `---[3.447472ms] com.example.demo.arthas.AdminFilterConfig$AdminFilter:doFilter()</span><br><span class="line">|       `---[0.17259ms] javax.servlet.http.HttpServletResponse:sendError()</span><br></pre></td></tr></table></figure><h4><span id="通过stack获取调用栈">通过stack获取调用栈</span></h4><p>上面是通过<code>trace</code>命令来获取信息，从结果里，我们可以知道通过<code>stack</code>跟踪<code>HttpServletResponse:sendError()</code>，同样可以知道是哪个<code>Filter</code>返回了<code>401</code></p><p>执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack javax.servlet.http.HttpServletResponse sendError <span class="string">&#x27;params[0]==401&#x27;</span></span><br></pre></td></tr></table></figure><p>访问： admin</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> stack javax.servlet.http.HttpServletResponse sendError <span class="string">&#x27;params[0]==401&#x27;</span></span></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:2 , method-cnt:4) cost in 87 ms.</span><br><span class="line">ts=2019-02-15 16:44:06;thread_name=http-nio-8080-exec-6;id=16;is_daemon=true;priority=5;TCCL=org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedWebappClassLoader@8546cd5</span><br><span class="line">    @org.apache.catalina.connector.ResponseFacade.sendError()</span><br><span class="line">        at com.example.demo.arthas.AdminFilterConfig$AdminFilter.doFilter(AdminFilterConfig.java:38)</span><br><span class="line">        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">        at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)</span><br><span class="line">        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>通过本教程基本掌握了Arthas排查HTTP请求返回401。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 最佳实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas 获取Spring Context 案例</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E8%8E%B7%E5%8F%96Spring%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A1%88%E4%BE%8B/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E8%8E%B7%E5%8F%96Spring%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#start-demo">Start demo</a></li><li><a href="#start-arthas-boot">Start arthas-boot</a></li><li><a href="#%E8%8E%B7%E5%8F%96spring-context">获取Spring Context</a><ul><li><a href="#%E4%BD%BF%E7%94%A8tt%E5%91%BD%E4%BB%A4%E8%8E%B7%E5%8F%96%E5%88%B0spring-context">使用tt命令获取到spring context</a></li><li><a href="#%E4%BD%BF%E7%94%A8tt%E5%91%BD%E4%BB%A4%E4%BB%8E%E8%B0%83%E7%94%A8%E8%AE%B0%E5%BD%95%E9%87%8C%E8%8E%B7%E5%8F%96%E5%88%B0spring-context">使用tt命令从调用记录里获取到spring context</a></li></ul><ul><li><a href="#%E8%8E%B7%E5%8F%96spring-bean%E5%B9%B6%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0">获取spring bean，并调用函数</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E8%8E%B7%E5%8F%96Spring%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A1%88%E4%BE%8B/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个普通的Spring Boot应用为例，演示获取Spring Context 案例。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="start-demo">Start demo</span></h2><p>下载<code>demo-arthas-spring-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar</span><br></pre></td></tr></table></figure><p><code>demo-arthas-spring-boot</code>是一个很简单的spring boot应用，源代码：<a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-arthas-spring-boot">查看</a></p><p>启动之后，可以访问61000端口： 点击查看</p><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E8%8E%B7%E5%8F%96Spring%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A1%88%E4%BE%8B/O1CN010Qbzcz1ctPSWSZI6L_!!6000000003658-2-tps-333-182.png" alt="Demo Web"></p><h2><span id="start-arthas-boot">Start arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E8%8E%B7%E5%8F%96Spring%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A1%88%E4%BE%8B/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="获取spring-context">获取Spring Context</span></h2><p>在这个案例里，展示获取spring context，再获取bean，然后调用函数。</p><h4><span id="使用tt命令获取到spring-context">使用tt命令获取到spring context</span></h4><p><code>tt</code>即 TimeTunnel，它可以记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测。</p><ul><li><a href="https://arthas.aliyun.com/doc/tt.html">https://arthas.aliyun.com/doc/tt.html</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter invokeHandlerMethod</span><br></pre></td></tr></table></figure><p>访问：user/1</p><p>可以看到<code>tt</code>命令捕获到了一个请求：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdaptePress Q or Ctrl+C to abort.</span></span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 252 ms.</span><br><span class="line"> INDE  TIMESTAMP    COST(  IS-R  IS-  OBJECT     CLASS               METHOD</span><br><span class="line"> X                  ms)    ET    EXP</span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"> 1000  2019-02-15   4.583  true  fal  0xc93cf1a  RequestMappingHand  invokeHandlerMethod</span><br><span class="line">       15:38:32     923          se              lerAdapter</span><br></pre></td></tr></table></figure><h4><span id="使用tt命令从调用记录里获取到spring-context">使用tt命令从调用记录里获取到spring context</span></h4><p>输入 <code>q</code> 或者 <code>Ctrl + C</code> 退出上面的 <code>tt -t</code>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -i 1000 -w <span class="string">&#x27;target.getApplicationContext()&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tt -i 1000 -w <span class="string">&#x27;target.getApplicationContext()&#x27;</span>@AnnotationConfigEmbeddedWebApplicationContext[    reader=@AnnotatedBeanDefinitionReader[org.springframework.context.annotation.AnnotatedBeanDefinitionReader@2e457641],    scanner=@ClassPathBeanDefinitionScanner[org.springframework.context.annotation.ClassPathBeanDefinitionScanner@6eb38026],    annotatedClasses=null,    basePackages=null,]Affect(row-cnt:1) cost <span class="keyword">in</span> 439 ms.</span></span><br></pre></td></tr></table></figure><h3><span id="获取spring-bean并调用函数">获取spring bean，并调用函数</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -i 1000 -w <span class="string">&#x27;target.getApplicationContext().getBean(&quot;helloWorldService&quot;).getHelloMessage()&#x27;</span></span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tt -i 1000 -w <span class="string">&#x27;target.getApplicationContext().getBean(&quot;helloWorldService&quot;).getHelloMessage()&#x27;</span>@String[Hello World]Affect(row-cnt:1) cost <span class="keyword">in</span> 52 ms.</span></span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>通过本教程基本掌握了Arthas获取Spring Context。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 最佳实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas arthas-boot支持的参数 案例</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%AD%A6%E4%B9%A0Arthasarthas-boot%E6%94%AF%E6%8C%81%E7%9A%84%E5%8F%82%E6%95%B0%E6%A1%88%E4%BE%8B/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%AD%A6%E4%B9%A0Arthasarthas-boot%E6%94%AF%E6%8C%81%E7%9A%84%E5%8F%82%E6%95%B0%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#arthas-demo">Arthas demo</a></li><li><a href="#arthas-boot%E6%94%AF%E6%8C%81%E7%9A%84%E5%8F%82%E6%95%B0">arthas-boot支持的参数</a></li><li><a href="#%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3">参数详解</a><ul><li><a href="#%E6%8C%87%E5%AE%9A%E7%9B%AE%E6%A0%87pid">指定目标pid</a></li><li><a href="#%E5%85%81%E8%AE%B8%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE">允许外部访问</a></li><li><a href="#%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E7%9A%84%E7%89%88%E6%9C%AC">列出所有的版本</a></li><li><a href="#%E6%89%93%E5%8D%B0%E8%BF%90%E8%A1%8C%E7%9A%84%E8%AF%A6%E6%83%85">打印运行的详情</a></li><li><a href="#%E6%8C%87%E5%AE%9A%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%E5%91%BD%E4%BB%A4%E7%9B%AE%E6%A0%87pid">指定需要执行的命令目标pid</a></li><li><a href="#%E6%8C%87%E5%AE%9A%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E7%9B%AE%E6%A0%87pid">指定需要执行的批处理文件目标pid</a></li><li><a href="#%E9%80%9A%E8%BF%87%E7%B1%BB%E5%90%8D%E6%88%96%E8%80%85jar%E6%96%87%E4%BB%B6%E5%90%8D%E6%8C%87%E5%AE%9A%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B">通过类名或者jar文件名指定目标进程</a></li><li><a href="#%E6%8C%87%E5%AE%9A%E4%BC%9A%E8%AF%9D%E8%B6%85%E6%97%B6%E7%A7%92%E6%95%B0">指定会话超时秒数</a></li><li><a href="#%E4%BB%85%E9%99%84%E5%8A%A0%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B%E4%B8%8D%E8%BF%9E%E6%8E%A5">仅附加目标进程，不连接</a></li><li><a href="#%E6%8C%87%E5%AE%9A%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8http">指定镜像仓库，强制使用http</a></li><li><a href="#%E6%8C%87%E5%AE%9Aarthas%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%BD%E9%AB%98">指定arthas客户端命令行宽高</a></li><li><a href="#%E6%8C%87%E5%AE%9Aarthas%E4%B8%BB%E7%9B%AE%E5%BD%95">指定arthas主目录</a></li><li><a href="#%E4%BB%A5java-agent%E7%9A%84%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8">以Java Agent的方式启动</a></li></ul></li><li><a href="#%E4%BD%BF%E7%94%A8assh">使用as.sh</a></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%AD%A6%E4%B9%A0Arthasarthas-boot%E6%94%AF%E6%8C%81%E7%9A%84%E5%8F%82%E6%95%B0%E6%A1%88%E4%BE%8B/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示arthas-boot支持的参数。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="arthas-demo">Arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p></p><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="arthas-boot支持的参数">arthas-boot支持的参数</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot.jar</code> 支持很多参数，可以执行 <code>java -jar arthas-boot.jar -h</code> 来查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar -h</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -jar arthas-boot.jar -h</span></span><br><span class="line">[INFO] arthas-boot version: 3.3.6</span><br><span class="line">Usage: arthas-boot [-h] [--target-ip &lt;value&gt;] [--telnet-port &lt;value&gt;]</span><br><span class="line">       [--http-port &lt;value&gt;] [--session-timeout &lt;value&gt;] [--arthas-home &lt;value&gt;]</span><br><span class="line">       [--use-version &lt;value&gt;] [--repo-mirror &lt;value&gt;] [--versions] [--use-http]</span><br><span class="line">       [--attach-only] [-c &lt;value&gt;] [-f &lt;value&gt;] [--height &lt;value&gt;] [--width</span><br><span class="line">       &lt;value&gt;] [-v] [--tunnel-server &lt;value&gt;] [--agent-id &lt;value&gt;] [--stat-url</span><br><span class="line">       &lt;value&gt;] [--select &lt;value&gt;] [pid]</span><br><span class="line"></span><br><span class="line">Bootstrap Arthas</span><br><span class="line"></span><br><span class="line">EXAMPLES:</span><br><span class="line">  java -jar arthas-boot.jar &lt;pid&gt;</span><br><span class="line">  java -jar arthas-boot.jar --target-ip 0.0.0.0</span><br><span class="line">  java -jar arthas-boot.jar --telnet-port 9999 --http-port -1</span><br><span class="line">  java -jar arthas-boot.jar --tunnel-server &#x27;ws://192.168.10.11:7777/ws&#x27;</span><br><span class="line">  java -jar arthas-boot.jar --tunnel-server &#x27;ws://192.168.10.11:7777/ws&#x27;</span><br><span class="line">--agent-id bvDOe8XbTM2pQWjF4cfw</span><br><span class="line">  java -jar arthas-boot.jar --stat-url &#x27;http://192.168.10.11:8080/api/stat&#x27;</span><br><span class="line">  java -jar arthas-boot.jar -c &#x27;sysprop; thread&#x27; &lt;pid&gt;</span><br><span class="line">  java -jar arthas-boot.jar -f batch.as &lt;pid&gt;</span><br><span class="line">  java -jar arthas-boot.jar --use-version 3.3.6</span><br><span class="line">  java -jar arthas-boot.jar --versions</span><br><span class="line">  java -jar arthas-boot.jar --select arthas-demo</span><br><span class="line">  java -jar arthas-boot.jar --session-timeout 3600</span><br><span class="line">  java -jar arthas-boot.jar --attach-only</span><br><span class="line">  java -jar arthas-boot.jar --repo-mirror aliyun --use-http</span><br><span class="line">WIKI:</span><br><span class="line">  https://arthas.aliyun.com/doc</span><br><span class="line"></span><br><span class="line">Options and Arguments:</span><br><span class="line"> -h,--help                      Print usage</span><br><span class="line">    --target-ip &lt;value&gt;         The target jvm listen ip, default 127.0.0.1</span><br><span class="line">    --telnet-port &lt;value&gt;       The target jvm listen telnet port, default 3658</span><br><span class="line">    --http-port &lt;value&gt;         The target jvm listen http port, default 8563</span><br><span class="line">    --session-timeout &lt;value&gt;   The session timeout seconds, default 1800</span><br><span class="line">                                (30min)</span><br><span class="line">    --arthas-home &lt;value&gt;       The arthas home</span><br><span class="line">    --use-version &lt;value&gt;       Use special version arthas</span><br><span class="line">    --repo-mirror &lt;value&gt;       Use special maven repository mirror, value is</span><br><span class="line">                                center/aliyun or http repo url.</span><br><span class="line">    --versions                  List local and remote arthas versions</span><br><span class="line">    --use-http                  Enforce use http to download, default use https</span><br><span class="line">    --attach-only               Attach target process only, do not connect</span><br><span class="line"> -c,--command &lt;value&gt;           Command to execute, multiple commands separated</span><br><span class="line">                                by ;</span><br><span class="line"> -f,--batch-file &lt;value&gt;        The batch file to execute</span><br><span class="line">    --height &lt;value&gt;            arthas-client terminal height</span><br><span class="line">    --width &lt;value&gt;             arthas-client terminal width</span><br><span class="line"> -v,--verbose                   Verbose, print debug info.</span><br><span class="line">    --tunnel-server &lt;value&gt;     The tunnel server url</span><br><span class="line">    --agent-id &lt;value&gt;          The agent id register to tunnel server</span><br><span class="line">    --stat-url &lt;value&gt;          The report stat url</span><br><span class="line">    --select &lt;value&gt;            select target process by classname or</span><br><span class="line">                                JARfilename</span><br><span class="line"> &lt;pid&gt;                          Target pid</span><br></pre></td></tr></table></figure><h2><span id="参数详解">参数详解</span></h2><h3><span id="指定目标pid">指定目标pid</span></h3><p>可以使用<code>jps</code>命令查看pid。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure><p>直接在参数中添加pid，可指定目标pid。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar 1</span><br></pre></td></tr></table></figure><h3><span id="允许外部访问">允许外部访问</span></h3><p>默认情况下， arthas server侦听的是 <code>127.0.0.1</code> 这个IP，如果希望远程可以访问，可以使用<code>--target-ip</code>的参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar --target-ip 0.0.0.0</span><br></pre></td></tr></table></figure><h3><span id="列出所有的版本">列出所有的版本</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar --versions</span><br></pre></td></tr></table></figure><p>使用指定版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar --use-version 3.1.0</span><br></pre></td></tr></table></figure><h3><span id="打印运行的详情">打印运行的详情</span></h3><p>使用<code>-v</code>或者<code>-verbose</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar -v</span><br></pre></td></tr></table></figure><h3><span id="指定需要执行的命令目标pid">指定需要执行的命令目标pid</span></h3><p>可以使用<code>--command</code>或者<code>-c</code>参数指定，并同时指定pid，多个命令之间用<code>;</code>分隔。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar -c <span class="string">&#x27;sysprop; thread&#x27;</span> 1</span><br></pre></td></tr></table></figure><h3><span id="指定需要执行的批处理文件目标pid">指定需要执行的批处理文件目标pid</span></h3><p>可以使用<code>--command</code>或者<code>-c</code>参数指定，并同时指定pid。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar -f batch.as 1</span><br></pre></td></tr></table></figure><h3><span id="通过类名或者jar文件名指定目标进程">通过类名或者jar文件名指定目标进程</span></h3><p>通过<code>--select</code>参数类名或者jar文件名指定目标进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar --select arthas-demo</span><br></pre></td></tr></table></figure><h3><span id="指定会话超时秒数">指定会话超时秒数</span></h3><p>使用<code>--session-timeout</code>参数指定，默认为1800(30分钟)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar --session-timeout 3600</span><br></pre></td></tr></table></figure><h3><span id="仅附加目标进程不连接">仅附加目标进程，不连接</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar --attach-only</span><br></pre></td></tr></table></figure><h3><span id="指定镜像仓库强制使用http">指定镜像仓库，强制使用http</span></h3><p><code>--repo-mirror</code>使用特定maven仓库镜像，参数可以为<code>center/aliyun</code>或http仓库地址。</p><p><code>--use-http</code>强制使用http下载，默认使用https。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar --repo-mirror aliyun --use-http</span><br></pre></td></tr></table></figure><h3><span id="指定arthas客户端命令行宽高">指定arthas客户端命令行宽高</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar --height 25 --width 80</span><br></pre></td></tr></table></figure><h3><span id="指定arthas主目录">指定arthas主目录</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar --arthas-home .</span><br></pre></td></tr></table></figure><h3><span id="以java-agent的方式启动">以Java Agent的方式启动</span></h3><p>通常Arthas是以动态attach的方式来诊断应用，但从3.2.0版本起，Arthas支持直接以 java agent的方式启动。</p><p>比如下载全量的arthas zip包，解压之后以 -javaagent 的参数指定arthas-agent.jar来启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:/tmp/test/arthas-agent.jar -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p>默认的配置项在解压目录里的arthas.properties文件里。</p><p>参考： <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html">https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html</a></p><h2><span id="使用assh">使用as.sh</span></h2><p>Arthas 支持在 Linux/Unix/Mac 等平台上一键安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://arthas.aliyun.com/install.sh | sh</span><br></pre></td></tr></table></figure><p>上述命令会下载启动脚本文件 <code>as.sh</code> 到当前目录，你可以放在任何地方或将其加入到 <code>$PATH</code> 中。</p><p>直接在shell下面执行<code>./as.sh</code>，就会进入交互界面。</p><p>也可以执行<code>./as.sh -h</code>来获取更多参数信息, 具体用法与<code>java -jar arthas-boot.jar</code>类似。</p><h2><span id="更多信息">更多信息</span></h2><p>通过本教程基本掌握了Arthas boot支持的参数。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 最佳实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas 理解Spring Boot应用的ClassLoader结构 案例</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%AD%A6%E4%B9%A0Arthasclassloader%E6%A1%88%E4%BE%8B/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%AD%A6%E4%B9%A0Arthasclassloader%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#start-demo">Start demo</a></li><li><a href="#start-arthas-boot">Start arthas-boot</a></li><li><a href="#%E7%90%86%E8%A7%A3spring-boot%E5%BA%94%E7%94%A8%E7%9A%84classloader%E7%BB%93%E6%9E%84">理解Spring Boot应用的ClassLoader结构</a><ul><li><a href="#%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89classloader">列出所有ClassLoader</a></li><li><a href="#%E5%88%97%E5%87%BAclassloader%E9%87%8C%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%89%80%E6%9C%89%E7%B1%BB">列出ClassLoader里加载的所有类</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E7%B1%BB%E7%9A%84classloader%E5%B1%82%E6%AC%A1">查看类的classloader层次</a></li><li><a href="#%E6%9F%A5%E7%9C%8Bclassloader%E6%A0%91">查看ClassLoader树</a></li><li><a href="#%E6%9F%A5%E7%9C%8Burlclassloader%E5%AE%9E%E9%99%85%E7%9A%84urls">查看URLClassLoader实际的urls</a></li><li><a href="#%E5%8A%A0%E8%BD%BD%E6%8C%87%E5%AE%9Aclassloader%E9%87%8C%E7%9A%84%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6">加载指定ClassLoader里的资源文件</a></li><li><a href="#%E5%B0%9D%E8%AF%95%E5%8A%A0%E8%BD%BD%E6%8C%87%E5%AE%9A%E7%9A%84%E7%B1%BB">尝试加载指定的类</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%AD%A6%E4%B9%A0Arthasclassloader%E6%A1%88%E4%BE%8B/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个普通的Spring Boot应用为例，演示Arthas Spring Boot应用的ClassLoader结构。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="start-demo">Start demo</span></h2><p>下载<code>demo-arthas-spring-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar</span><br></pre></td></tr></table></figure><p><code>demo-arthas-spring-boot</code>是一个很简单的spring boot应用，源代码：<a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-arthas-spring-boot">查看</a></p><p>启动之后，可以访问61000端口： 点击查看</p><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%AD%A6%E4%B9%A0Arthasclassloader%E6%A1%88%E4%BE%8B/O1CN010Qbzcz1ctPSWSZI6L_!!6000000003658-2-tps-333-182.png" alt="Demo Web"></p><h2><span id="start-arthas-boot">Start arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/%E5%AD%A6%E4%B9%A0Arthasclassloader%E6%A1%88%E4%BE%8B/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="理解spring-boot应用的classloader结构">理解Spring Boot应用的ClassLoader结构</span></h2><p>下面介绍<code>classloader</code>命令的功能。</p><p>先访问一个jsp网页，触发jsp的加载： hello</p><h4><span id="列出所有classloader">列出所有ClassLoader</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader -l</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> classloader -l</span></span><br><span class="line"> name                                                             loadedCount  hash      parent</span><br><span class="line"> BootstrapClassLoader                                             2724         null      null</span><br><span class="line"> com.taobao.arthas.agent.ArthasClassloader@411ce1ab               2009         411ce1ab  sun.misc.Launcher$ExtClassLoader@7494e528</span><br><span class="line"> com.taobao.arthas.agent.ArthasClassloader@22ae1234               1253         22ae1234  sun.misc.Launcher$ExtClassLoader@7494e528</span><br><span class="line"> org.apache.jasper.servlet.JasperLoader@65361d9a                  1            65361d9a  TomcatEmbeddedWebappClassLoader</span><br><span class="line">                                                                                           context: ROOT</span><br><span class="line">                                                                                           delegate: true</span><br><span class="line">                                                                                         ----------&gt; Parent Classloader:</span><br><span class="line">                                                                                         org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3</span><br><span class="line"></span><br><span class="line"> TomcatEmbeddedWebappClassLoader                                  0            8546cd5   org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3</span><br><span class="line">   context: ROOT</span><br><span class="line">   delegate: true</span><br><span class="line"><span class="meta"> ----------&gt;</span><span class="bash"> Parent Classloader:</span></span><br><span class="line"> org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3</span><br><span class="line"></span><br><span class="line"> org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3  5416         1be6f5c3  sun.misc.Launcher$AppClassLoader@3d4eac69</span><br><span class="line"> sun.misc.Launcher$AppClassLoader@3d4eac69                        45           3d4eac69  sun.misc.Launcher$ExtClassLoader@7494e528</span><br><span class="line"> sun.misc.Launcher$ExtClassLoader@7494e528                        4            7494e528  null</span><br></pre></td></tr></table></figure><ul><li>TomcatEmbeddedWebappClassLoader 加载的class数量是0，所以在spring boot embedded tomcat里，它只是一个空壳，所有的类加载都是<code>LaunchedURLClassLoader</code>完成的</li></ul><p>请记下你的classLoaderHash，后面需要使用它。在这里，它是 <code>65361d9a</code>。</p><p>注意：请使用你的classLoaderHash值覆盖 <code>&lt;classLoaderHash&gt;</code> ，然后手动执行下面所有所述命令：</p><h4><span id="列出classloader里加载的所有类">列出ClassLoader里加载的所有类</span></h4><p>列出上面的<code>org.apache.jasper.servlet.JasperLoader</code>加载的类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classloader -a -c &lt;classLoaderHash&gt;</span><br><span class="line">$ classloader -a -c 65361d9a</span><br><span class="line"> hash:1698045338, org.apache.jasper.servlet.JasperLoader@65361d9a</span><br><span class="line"> org.apache.jsp.jsp.hello_jsp</span><br></pre></td></tr></table></figure><h4><span id="查看类的classloader层次">查看类的classloader层次</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d org.apache.jsp.jsp.hello_jsp</span><br></pre></td></tr></table></figure><h4><span id="查看classloader树">查看ClassLoader树</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader -t</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ classloader -t+-BootstrapClassLoader+-sun.misc.Launcher$ExtClassLoader@28cbbddd  +-com.taobao.arthas.agent.ArthasClassloader@8c25e55  +-sun.misc.Launcher$AppClassLoader@55f96302    +-org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3      +-TomcatEmbeddedWebappClassLoader          context: ROOT          delegate: true        ----------&gt; Parent Classloader:        org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3        +-org.apache.jasper.servlet.JasperLoader@21ae0fe2</span><br></pre></td></tr></table></figure><h4><span id="查看urlclassloader实际的urls">查看URLClassLoader实际的urls</span></h4><p>比如上面查看到的spring LaunchedURLClassLoader的 hashcode是<code>1be6f5c3</code>，可以通过<code>-c</code>参数来指定classloader，从而查看URLClassLoader实际的urls：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader -c &lt;classLoaderHash&gt;$ classloader -c 1be6f5c3jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/classes!/jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/lib/spring-boot-starter-aop-1.5.13.RELEASE.jar!/...</span><br></pre></td></tr></table></figure><h4><span id="加载指定classloader里的资源文件">加载指定ClassLoader里的资源文件</span></h4><p>查找指定的资源文件： <code>classloader -c &lt;classLoaderHash&gt; -r logback-spring.xml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ classloader -c 1be6f5c3 -r logback-spring.xml jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/classes!/logback-spring.xml</span><br></pre></td></tr></table></figure><p>也可以尝试查找类的class文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader -c &lt;classLoaderHash&gt; -r java/lang/String.class$ classloader -c 1b6d3586 -r java/lang/String.class jar:file:/Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/Home/jre/lib/rt.jar!/java/lang/String.class</span><br></pre></td></tr></table></figure><h4><span id="尝试加载指定的类">尝试加载指定的类</span></h4><p>比如用上面的spring LaunchedURLClassLoader 尝试加载 <code>ch.qos.logback.classic.spi.StackTraceElementProxy</code> ：</p><p>首先使用<code>sc ch.qos.logback.classic.spi.StackTraceElementProxy</code>查看，可发现未加载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc ch.qos.logback.classic.spi.StackTraceElementProxy</span><br></pre></td></tr></table></figure><p></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Affect(row-cnt:0) cost in 18 ms.</span><br></pre></td></tr></table></figure><p>因而使用spring LaunchedURLClassLoader 尝试加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader -c &lt;classLoaderHash&gt; --load ch.qos.logback.classic.spi.StackTraceElementProxy$ classloader -c 1be6f5c3 --load ch.qos.logback.classic.spi.StackTraceElementProxyload class success. class-info        ch.qos.logback.classic.spi.StackTraceElementProxy code-source       file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/lib/logback-classic-1.                   1.11.jar!/ name              ch.qos.logback.classic.spi.StackTraceElementProxy isInterface       false isAnnotation      false isEnum            false isAnonymousClass  false isArray           false isLocalClass      false isMemberClass     false isPrimitive       false isSynthetic       false simple-name       StackTraceElementProxy modifier          public annotation interfaces        java.io.Serializable super-class       +-java.lang.Object class-loader      +-org.springframework.boot.loader.LaunchedURLClassLoader@5674cd4d                     +-sun.misc.Launcher$AppClassLoader@70dea4e                       +-sun.misc.Launcher$ExtClassLoader@56a96482 classLoaderHash   5674cd4d</span><br></pre></td></tr></table></figure><p>再次使用<code>sc ch.qos.logback.classic.spi.StackTraceElementProxy</code>查看，发现已经加载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc ch.qos.logback.classic.spi.StackTraceElementProxy</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.qos.logback.classic.spi.StackTraceElementProxyAffect(row-cnt:1) cost in 19 ms.</span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>通过本教程基本掌握了Arthas Spring Boot应用的ClassLoader结构。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 最佳实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas 后台异步任务 案例</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E5%90%8E%E5%8F%B0%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%A1%88%E4%BE%8B/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E5%90%8E%E5%8F%B0%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#arthas-demo">Arthas demo</a></li><li><a href="#start-arthas-boot">Start arthas-boot</a></li><li><a href="#%E5%90%8E%E5%8F%B0%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1">后台异步任务</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%9C%A8%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1">使用&amp;在后台执行任务</a></li><li><a href="#%E9%80%9A%E8%BF%87jobs%E6%9F%A5%E7%9C%8B%E4%BB%BB%E5%8A%A1">通过jobs查看任务</a></li><li><a href="#%E4%BB%BB%E5%8A%A1%E6%9A%82%E5%81%9C%E5%92%8C%E5%8F%96%E6%B6%88">任务暂停和取消</a></li><li><a href="#fg-bg%E5%91%BD%E4%BB%A4%E5%B0%86%E5%91%BD%E4%BB%A4%E8%BD%AC%E5%88%B0%E5%89%8D%E5%8F%B0-%E5%90%8E%E5%8F%B0%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C">fg、bg命令，将命令转到前台、后台继续执行</a></li><li><a href="#%E4%BB%BB%E5%8A%A1%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91">任务输出重定向</a></li><li><a href="#%E5%81%9C%E6%AD%A2%E5%91%BD%E4%BB%A4">停止命令</a></li><li><a href="#%E5%85%B6%E4%BB%96">其他</a></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E5%90%8E%E5%8F%B0%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%A1%88%E4%BE%8B/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>本教程会以一个简单的应用为例，演示后台异步任务。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="arthas-demo">Arthas demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="start-arthas-boot">Start arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/Arthas%E5%90%8E%E5%8F%B0%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%A1%88%E4%BE%8B/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="后台异步任务">后台异步任务</span></h2><p>arthas中的后台异步任务，使用了仿linux系统任务相关的命令。<a href="https://ehlxr.me/2017/01/18/Linux-%E4%B8%AD-fg%E3%80%81bg%E3%80%81jobs%E3%80%81-%E6%8C%87%E4%BB%A4/">linux任务相关介绍</a>。</p><h2><span id="使用amp在后台执行任务">使用&amp;在后台执行任务</span></h2><p>比如希望执行后台执行trace命令，那么调用下面命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace demo.MathGame primeFactors &amp;</span><br></pre></td></tr></table></figure><p>这时命令在后台执行，可以在console中继续执行其他命令。</p><h2><span id="通过jobs查看任务">通过jobs查看任务</span></h2><p>如果希望查看当前有哪些arthas任务在执行，可以执行jobs命令，执行结果如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">jobs</span></span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">jobs</span></span></span><br><span class="line">[1]*</span><br><span class="line">       Running           trace demo.MathGame primeFactors &amp;</span><br><span class="line">       execution count : 49</span><br><span class="line">       start time      : Wed Jul 22 05:47:52 GMT 2020</span><br><span class="line">       timeout date    : Thu Jul 23 05:47:52 GMT 2020</span><br><span class="line">       session         : aa75753d-74f1-4929-a829-7ff965345183 (current)</span><br></pre></td></tr></table></figure><p>可以看到目前有一个后台任务在执行。</p><p>job id是10, <code>*</code> 表示此job是当前session创建</p><p>状态是Stopped</p><p>execution count是执行次数，从启动开始已经执行了19次</p><p>timeout date是超时的时间，到这个时间，任务将会自动超时退出</p><h2><span id="任务暂停和取消">任务暂停和取消</span></h2><p>当任务正在前台执行，比如直接调用命令<code>trace Test t</code>或者调用后台执行命令<code>trace Test t &amp;</code>后又通过fg命令将任务转到前台。这时console中无法继续执行命令，但是可以接收并处理以下事件：</p><p><code>ctrl + z</code>：将任务暂停。通过jbos查看任务状态将会变为Stopped，通过<code>bg &lt;job-id&gt;</code>或者<code>fg &lt;job-id&gt;</code>可让任务重新开始执行</p><p><code>ctrl + c</code>：停止任务</p><p><code>ctrl + d</code>：按照linux语义应当是退出终端，目前arthas中是空实现，不处理</p><h2><span id="fg-bg命令将命令转到前台-后台继续执行">fg、bg命令，将命令转到前台、后台继续执行</span></h2><ul><li>任务在后台执行或者暂停状态（<code>ctrl + z</code>暂停任务）时，执行<code>fg &lt;job-id&gt;</code>将可以把对应的任务转到前台继续执行。在前台执行时，无法在console中执行其他命令</li><li>当任务处于暂停状态时（<code>ctrl + z</code>暂停任务），执行<code>bg &lt;job-id&gt;</code>将可以把对应的任务在后台继续执行</li><li>非当前session创建的job，只能由当前session <code>fg</code>到前台执行</li></ul><h2><span id="任务输出重定向">任务输出重定向</span></h2><p>可通过&gt;或者&gt;&gt;将任务输出结果输出到指定的文件中，可以和&amp;一起使用，实现arthas命令的后台异步任务。比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace demo.MathGame primeFactors &gt;&gt; test.out &amp;</span><br></pre></td></tr></table></figure><p>这时trace命令会在后台执行，并且把结果输出到<code>~/logs/arthas-cache/test.out</code>。可继续执行其他命令。并可查看文件中的命令执行结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test.out</span><br></pre></td></tr></table></figure><p>当连接到远程的arthas server时，可能无法查看远程机器的文件，arthas同时支持了自动重定向到本地缓存路径。使用方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace demo.MathGame primeFactors &gt;&gt; &amp;</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> trace Test t &gt;&gt;  &amp;</span></span><br><span class="line">job id  : 2</span><br><span class="line">cache location  : /Users/gehui/logs/arthas-cache/28198/2</span><br></pre></td></tr></table></figure><p>可以看到并没有指定重定向文件位置，arthas自动重定向到缓存中了，执行命令后会输出<code>job id</code>和<code>cache location</code>。<code>cache location</code>就是重定向文件的路径，在系统logs目录下，路径包括<code>pid</code>和<code>job id</code>，避免和其他任务冲突。命令输出结果到<code>/Users/gehui/logs/arthas-cache/28198/2</code>中，<code>job id</code>为2。</p><h2><span id="停止命令">停止命令</span></h2><p>异步执行的命令，如果希望停止，可执行<code>kill</code></p><h2><span id="其他">其他</span></h2><ul><li>最多同时支持8个命令使用重定向将结果写日志</li><li>请勿同时开启过多的后台异步命令，以免对目标JVM性能造成影响</li><li>如果不想停止arthas，继续执行后台任务，可以执行 <code>quit</code> 退出arthas控制台（<code>stop</code> 会停止arthas 服务）</li></ul><h2><span id="更多信息">更多信息</span></h2><p>通过本教程基本掌握了Arthas后台异步任务。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=PaiFAkJM</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 最佳实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas 进阶</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/Arthas-%E8%BF%9B%E9%98%B6/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/Arthas-%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8demo">启动demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#%E6%9F%A5%E7%9C%8Bjvm%E4%BF%A1%E6%81%AF">查看JVM信息</a><ul><li><a href="#sysprop">sysprop</a></li><li><a href="#sysenv">sysenv</a></li><li><a href="#jvm">jvm</a></li><li><a href="#dashboard">dashboard</a></li></ul></li><li><a href="#tips">Tips</a><ul><li><a href="#help">help</a></li><li><a href="#%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8">自动补全</a></li><li><a href="#readline%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%94%AF%E6%8C%81">readline的快捷键支持</a></li><li><a href="#%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4%E7%9A%84%E8%A1%A5%E5%85%A8">历史命令的补全</a></li><li><a href="#pipeline">pipeline</a></li></ul></li><li><a href="#scsm-%E6%9F%A5%E7%9C%8B%E5%B7%B2%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%B1%BB">sc/sm 查看已加载的类</a><ul><li><a href="#sc">sc</a></li><li><a href="#sm">sm</a></li></ul></li><li><a href="#jad">Jad</a></li><li><a href="#ognl">Ognl</a><ul><li><a href="#%E8%B0%83%E7%94%A8static%E5%87%BD%E6%95%B0">调用static函数</a></li><li><a href="#%E6%9F%A5%E6%89%BEusercontroller%E7%9A%84classloader">查找UserController的ClassLoader</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E9%9D%99%E6%80%81%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5">获取静态类的静态字段</a></li><li><a href="#%E6%89%A7%E8%A1%8C%E5%A4%9A%E8%A1%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%B5%8B%E5%80%BC%E7%BB%99%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAlist">执行多行表达式，赋值给临时变量，返回一个List</a></li><li><a href="#%E6%9B%B4%E5%A4%9A">更多</a></li></ul></li><li><a href="#%E6%A1%88%E4%BE%8B-%E6%8E%92%E6%9F%A5%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%BC%82%E5%B8%B8">案例: 排查函数调用异常</a><ul><li><a href="#%E7%8E%B0%E8%B1%A1">现象</a></li><li><a href="#%E6%9F%A5%E7%9C%8Busercontroller%E7%9A%84-%E5%8F%82%E6%95%B0%E5%BC%82%E5%B8%B8">查看UserController的 参数/异常</a></li><li><a href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F">返回值表达式</a></li><li><a href="#%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F">条件表达式</a></li><li><a href="#%E5%BD%93%E5%BC%82%E5%B8%B8%E6%97%B6%E6%8D%95%E8%8E%B7">当异常时捕获</a></li><li><a href="#%E6%8C%89%E7%85%A7%E8%80%97%E6%97%B6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4">按照耗时进行过滤</a></li></ul></li><li><a href="#%E6%A1%88%E4%BE%8B-%E7%83%AD%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81">案例: 热更新代码</a><ul><li><a href="#jad%E5%8F%8D%E7%BC%96%E8%AF%91usercontroller">jad反编译UserController</a></li><li><a href="#sc%E6%9F%A5%E6%89%BE%E5%8A%A0%E8%BD%BDusercontroller%E7%9A%84classloader">sc查找加载UserController的ClassLoader</a></li><li><a href="#mc">mc</a></li><li><a href="#redefine">redefine</a></li><li><a href="#%E7%83%AD%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%9C">热修改代码结果</a></li></ul></li><li><a href="#%E6%A1%88%E4%BE%8B-%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E5%BA%94%E7%94%A8logger-level">案例: 动态更新应用Logger Level</a><ul><li><a href="#%E6%9F%A5%E6%89%BEusercontroller%E7%9A%84classloader-1">查找UserController的ClassLoader</a></li><li><a href="#%E7%94%A8ognl%E8%8E%B7%E5%8F%96logger">用ognl获取logger</a></li><li><a href="#%E5%8D%95%E7%8B%AC%E8%AE%BE%E7%BD%AEusercontroller%E7%9A%84logger-level">单独设置UserController的logger level</a></li><li><a href="#%E4%BF%AE%E6%94%B9logback%E7%9A%84%E5%85%A8%E5%B1%80logger-level">修改logback的全局logger level</a></li></ul></li><li><a href="#%E6%A1%88%E4%BE%8B-%E6%8E%92%E6%9F%A5logger%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98">案例: 排查logger冲突问题</a><ul><li><a href="#%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%94%A8%E4%BD%BF%E7%94%A8%E7%9A%84logger%E7%B3%BB%E7%BB%9F">确认应用使用的logger系统</a></li><li><a href="#%E8%8E%B7%E5%8F%96logback%E5%AE%9E%E9%99%85%E5%8A%A0%E8%BD%BD%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">获取logback实际加载的配置文件</a></li><li><a href="#%E4%BD%BF%E7%94%A8classloader%E5%91%BD%E4%BB%A4%E6%9F%A5%E6%89%BE%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84logger%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">使用classloader命令查找可能存在的logger配置文件</a></li></ul></li><li><a href="#%E6%A1%88%E4%BE%8B-%E8%8E%B7%E5%8F%96spring-context">案例: 获取Spring Context</a><ul><li><a href="#%E4%BD%BF%E7%94%A8tt%E5%91%BD%E4%BB%A4%E8%8E%B7%E5%8F%96%E5%88%B0spring-context">使用tt命令获取到spring context</a></li><li><a href="#%E4%BD%BF%E7%94%A8tt%E5%91%BD%E4%BB%A4%E4%BB%8E%E8%B0%83%E7%94%A8%E8%AE%B0%E5%BD%95%E9%87%8C%E8%8E%B7%E5%8F%96%E5%88%B0spring-context">使用tt命令从调用记录里获取到spring context</a></li></ul><ul><li><a href="#%E8%8E%B7%E5%8F%96spring-bean%E5%B9%B6%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0">获取spring bean，并调用函数</a></li></ul></li><li><a href="#%E6%A1%88%E4%BE%8B-%E6%8E%92%E6%9F%A5http%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E401">案例: 排查HTTP请求返回401</a><ul><li><a href="#%E8%B7%9F%E8%B8%AA%E6%89%80%E6%9C%89%E7%9A%84filter%E5%87%BD%E6%95%B0">跟踪所有的Filter函数</a></li><li><a href="#%E9%80%9A%E8%BF%87stack%E8%8E%B7%E5%8F%96%E8%B0%83%E7%94%A8%E6%A0%88">通过stack获取调用栈</a></li></ul></li><li><a href="#%E6%A1%88%E4%BE%8B-%E6%8E%92%E6%9F%A5http%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E404">案例: 排查HTTP请求返回404</a><ul><li><a href="#%E8%B7%9F%E8%B8%AA%E6%89%80%E6%9C%89%E7%9A%84servlet%E5%87%BD%E6%95%B0">跟踪所有的Servlet函数</a></li></ul></li><li><a href="#%E6%A1%88%E4%BE%8B-%E7%90%86%E8%A7%A3spring-boot%E5%BA%94%E7%94%A8%E7%9A%84classloader%E7%BB%93%E6%9E%84">案例: 理解Spring Boot应用的ClassLoader结构</a><ul><li><a href="#%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89classloader">列出所有ClassLoader</a></li><li><a href="#%E5%88%97%E5%87%BAclassloader%E9%87%8C%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%89%80%E6%9C%89%E7%B1%BB">列出ClassLoader里加载的所有类</a></li><li><a href="#%E5%8F%8D%E7%BC%96%E8%AF%91jsp%E7%9A%84%E4%BB%A3%E7%A0%81">反编译jsp的代码</a></li><li><a href="#%E6%9F%A5%E7%9C%8Bclassloader%E6%A0%91">查看ClassLoader树</a></li><li><a href="#%E5%88%97%E5%87%BAclassloader%E7%9A%84urls">列出ClassLoader的urls</a></li><li><a href="#%E5%8A%A0%E8%BD%BD%E6%8C%87%E5%AE%9Aclassloader%E9%87%8C%E7%9A%84%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6">加载指定ClassLoader里的资源文件</a></li><li><a href="#%E5%B0%9D%E8%AF%95%E5%8A%A0%E8%BD%BD%E6%8C%87%E5%AE%9A%E7%9A%84%E7%B1%BB">尝试加载指定的类</a></li></ul></li><li><a href="#%E6%A1%88%E4%BE%8B%E6%9F%A5%E6%89%BEtop-n%E7%BA%BF%E7%A8%8B">案例：查找Top N线程</a><ul><li><a href="#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E4%BF%A1%E6%81%AF">查看所有线程信息</a></li><li><a href="#%E6%9F%A5%E7%9C%8B%E5%85%B7%E4%BD%93%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A0%88">查看具体线程的栈</a></li><li><a href="#%E6%9F%A5%E7%9C%8Bcpu%E4%BD%BF%E7%94%A8%E7%8E%87top-n%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A0%88">查看CPU使用率top n线程的栈</a></li><li><a href="#%E6%9F%A5%E6%89%BE%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E6%9C%89%E9%98%BB%E5%A1%9E">查找线程是否有阻塞</a></li></ul></li><li><a href="#web-console">Web Console</a><ul><li><a href="#%E6%9C%AC%E5%9C%B0%E4%BD%93%E9%AA%8C">本地体验</a></li></ul></li><li><a href="#exitstop">Exit/Stop</a><ul><li><a href="#reset">reset</a></li><li><a href="#%E9%80%80%E5%87%BAarthas">退出Arthas</a></li><li><a href="#%E5%BD%BB%E5%BA%95%E9%80%80%E5%87%BAarthas">彻底退出Arthas</a></li></ul></li><li><a href="#arthas-boot%E6%94%AF%E6%8C%81%E7%9A%84%E5%8F%82%E6%95%B0">arthas-boot支持的参数</a><ul><li><a href="#%E5%85%81%E8%AE%B8%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE">允许外部访问</a></li><li><a href="#%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E7%9A%84%E7%89%88%E6%9C%AC">列出所有的版本</a></li><li><a href="#%E5%8F%AA%E4%BE%A6%E5%90%ACtelnet%E7%AB%AF%E5%8F%A3%E4%B8%8D%E4%BE%A6%E5%90%AChttp%E7%AB%AF%E5%8F%A3">只侦听Telnet端口，不侦听HTTP端口</a></li><li><a href="#%E6%89%93%E5%8D%B0%E8%BF%90%E8%A1%8C%E7%9A%84%E8%AF%A6%E6%83%85">打印运行的详情</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/Arthas-%E8%BF%9B%E9%98%B6/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。</p><p>本教程会以一个普通的Spring Boot应用为例，演示Arthas命令的详细用法。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动demo">启动demo</span></h2><p>下载<code>demo-arthas-spring-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://code.aliyun.com/middleware-container/handsonLabExternedFiles/raw/master/demo-arthas-spring-boot.jar;java -jar demo-arthas-spring-boot.jar</span><br></pre></td></tr></table></figure><p><code>demo-arthas-spring-boot</code>是一个很简单的spring boot应用，源代码：<a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-arthas-spring-boot">查看</a></p><p>启动之后，可以访问61000端口： 点击查看</p><p><img src="https://img.alicdn.com/imgextra/i2/O1CN010Qbzcz1ctPSWSZI6L_!!6000000003658-2-tps-333-182.png" alt="Demo Web"></p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar --target-ip 0.0.0.0</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/Arthas-%E8%BF%9B%E9%98%B6/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="查看jvm信息">查看JVM信息</span></h2><p>下面介绍Arthas里查看<code>JVM</code>信息的命令。</p><h4><span id="sysprop">sysprop</span></h4><p><code>sysprop</code> 可以打印所有的System Properties信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysprop</span><br></pre></td></tr></table></figure><p>也可以指定单个key： <code>sysprop java.version</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysprop java.version</span><br></pre></td></tr></table></figure><p>也可以通过<code>grep</code>来过滤： <code>sysprop | grep user</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysprop | grep user</span><br></pre></td></tr></table></figure><p>可以设置新的value： <code>sysprop testKey testValue</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysprop testKey testValue</span><br></pre></td></tr></table></figure><h4><span id="sysenv">sysenv</span></h4><p><code>sysenv</code> 命令可以获取到环境变量。和<code>sysprop</code>命令类似。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysenv</span><br></pre></td></tr></table></figure><h4><span id="jvm">jvm</span></h4><p><code>jvm</code> 命令会打印出<code>JVM</code>的各种详细信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jvm</span><br></pre></td></tr></table></figure><h4><span id="dashboard">dashboard</span></h4><p><code>dashboard</code> 命令可以查看当前系统的实时数据面板。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dashboard</span><br></pre></td></tr></table></figure><p>输入 <code>q</code> 或者 <code>Ctrl+C</code> 可以退出dashboard命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><h2><span id="tips">Tips</span></h2><p>为了更好使用Arthas，下面先介绍Arthas里的一些使用技巧。</p><h4><span id="help">help</span></h4><p>Arthas里每一个命令都有详细的帮助信息。可以用<code>-h</code>来查看。帮助信息里有<code>EXAMPLES</code>和<code>WIKI</code>链接。</p><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysprop -h</span><br></pre></td></tr></table></figure><h4><span id="自动补全">自动补全</span></h4><p>Arthas支持丰富的自动补全功能，在使用有疑惑时，可以输入<code>Tab</code>来获取更多信息。</p><p>比如输入 <code>sysprop java.</code> 之后，再输入<code>Tab</code>，会补全出对应的key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sysprop java.</span><br><span class="line">java.runtime.name             java.protocol.handler.pkgs    java.vm.version</span><br><span class="line">java.vm.vendor                java.vendor.url               java.vm.name</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4><span id="readline的快捷键支持">readline的快捷键支持</span></h4><p>Arthas支持常见的命令行快捷键，比如<code>Ctrl + A</code>跳转行首，<code>Ctrl + E</code>跳转行尾。</p><p>更多的快捷键可以用 <code>keymap</code> 命令查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keymap</span><br></pre></td></tr></table></figure><h4><span id="历史命令的补全">历史命令的补全</span></h4><p>如果想再执行之前的命令，可以在输入一半时，按<code>Up/↑</code> 或者 <code>Ddown/↓</code>，来匹配到之前的命令。</p><p>比如之前执行过<code>sysprop java.version</code>，那么在输入<code>sysprop ja</code>之后，可以输入<code>Up/↑</code>，就会自动补全为<code>sysprop java.version</code>。</p><p>如果想查看所有的历史命令，也可以通过 <code>history</code> 命令查看到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span></span><br></pre></td></tr></table></figure><h4><span id="pipeline">pipeline</span></h4><p>Arthas支持在pipeline之后，执行一些简单的命令，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysprop | grep java</span><br><span class="line">sysprop | grep java</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysprop | wc -l</span><br><span class="line">sysprop | wc -l</span><br></pre></td></tr></table></figure><h2><span id="scsm-查看已加载的类">sc/sm 查看已加载的类</span></h2><p>下面介绍Arthas里查找已加载类的命令。</p><h4><span id="sc">sc</span></h4><p><code>sc</code> 命令可以查找到所有JVM已经加载到的类。 如果搜索的是接口，还会搜索所有的实现类。比如查看所有的<code>Filter</code>实现类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc javax.servlet.Filter</span><br></pre></td></tr></table></figure><p>通过<code>-d</code>参数，可以打印出类加载的具体信息，很方便查找类加载问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d javax.servlet.Filter</span><br></pre></td></tr></table></figure><p><code>sc</code>支持通配，比如搜索所有的<code>StringUtils</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc *StringUtils</span><br></pre></td></tr></table></figure><h4><span id="sm">sm</span></h4><p><code>sm</code>命令则是查找类的具体函数。比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sm java.math.RoundingMode</span><br></pre></td></tr></table></figure><p>通过<code>-d</code>参数可以打印函数的具体属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sm -d java.math.RoundingMode</span><br></pre></td></tr></table></figure><p>也可以查找特定的函数，比如查找构造函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sm java.math.RoundingMode &lt;init&gt;</span><br></pre></td></tr></table></figure><h2><span id="jad">Jad</span></h2><p>可以通过 <code>jad</code> 命令来反编译代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad com.example.demo.arthas.user.UserController</span><br></pre></td></tr></table></figure><p>通过<code>--source-only</code>参数可以只打印出在反编译的源代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad --source-only com.example.demo.arthas.user.UserController</span><br></pre></td></tr></table></figure><h2><span id="ognl">Ognl</span></h2><p>在Arthas里，有一个单独的<code>ognl</code>命令，可以动态执行代码。</p><h4><span id="调用static函数">调用static函数</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl <span class="string">&#x27;@java.lang.System@out.println(&quot;hello ognl&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><p>可以检查<code>Terminal 1</code>里的进程输出，可以发现打印出了<code>hello ognl</code>。</p><h4><span id="查找usercontroller的classloader">查找UserController的ClassLoader</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span></span><br><span class="line"> classLoaderHash   1be6f5c3</span><br></pre></td></tr></table></figure><p>注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。</p><p>如果你使用<code>-c</code>，你需要手动输入hashcode：<code>-c &lt;hashcode&gt;</code></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl -c 1be6f5c3 @com.example.demo.arthas.user.UserController@logger</span></span><br></pre></td></tr></table></figure><p>对于只有唯一实例的ClassLoader可以通过<code>--classLoaderClass</code>指定class name，使用起来更加方便：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader  @org.springframework.boot.SpringApplication@logger</span></span><br><span class="line">@Slf4jLocationAwareLog[</span><br><span class="line">    FQCN=@String[org.apache.commons.logging.LogAdapter$Slf4jLocationAwareLog],</span><br><span class="line">    name=@String[org.springframework.boot.SpringApplication],</span><br><span class="line">    logger=@Logger[Logger[org.springframework.boot.SpringApplication]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>--classLoaderClass</code> 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而<code>-c &lt;hashcode&gt;</code>是动态变化的。</p><h4><span id="获取静态类的静态字段">获取静态类的静态字段</span></h4><p>获取<code>UserController</code>类里的<code>logger</code>字段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader @com.example.demo.arthas.user.UserController@logger</span><br></pre></td></tr></table></figure><p>还可以通过<code>-x</code>参数控制返回值的展开层数。比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -x 2 @com.example.demo.arthas.user.UserController@logger</span><br></pre></td></tr></table></figure><h4><span id="执行多行表达式赋值给临时变量返回一个list">执行多行表达式，赋值给临时变量，返回一个List</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl <span class="string">&#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl <span class="string">&#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27;</span></span></span><br><span class="line">@ArrayList[</span><br><span class="line">    @String[/Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre],</span><br><span class="line">    @String[Java(TM) SE Runtime Environment],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4><span id="更多">更多</span></h4><p>在Arthas里<code>ognl</code>表达式是很重要的功能，在很多命令里都可以使用<code>ognl</code>表达式。</p><p>一些更复杂的用法，可以参考：</p><ul><li>OGNL特殊用法请参考：<a href="https://github.com/alibaba/arthas/issues/71">https://github.com/alibaba/arthas/issues/71</a></li><li>OGNL表达式官方指南：<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html">https://commons.apache.org/proper/commons-ognl/language-guide.html</a></li></ul><h2><span id="案例-排查函数调用异常">案例: 排查函数调用异常</span></h2><h4><span id="现象">现象</span></h4><p>目前，访问 <a href="http://localhost:61000/user/0">http://localhost:61000/user/0</a> ，会返回500异常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:61000/user/0</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;timestamp&quot;:1550223186170,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;exception&quot;:&quot;java.lang.IllegalArgumentException&quot;,&quot;message&quot;:&quot;id &lt; 1&quot;,&quot;path&quot;:&quot;/user/0&quot;&#125;</span><br></pre></td></tr></table></figure><p>但请求的具体参数，异常栈是什么呢？</p><h4><span id="查看usercontroller的-参数异常">查看UserController的 参数/异常</span></h4><p>在Arthas里执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch com.example.demo.arthas.user.UserController * <span class="string">&#x27;&#123;params, throwExp&#125;&#x27;</span></span><br></pre></td></tr></table></figure><ol><li>第一个参数是类名，支持通配</li><li>第二个参数是函数名，支持通配 访问 <code>curl http://localhost:61000/user/0</code> ,<code>watch</code>命令会打印调用的参数和异常</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:61000/user/0</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch com.example.demo.arthas.user.UserController * <span class="string">&#x27;&#123;params, throwExp&#125;&#x27;</span></span></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:2) cost in 53 ms.</span><br><span class="line">ts=2019-02-15 01:35:25; [cost=0.996655ms] result=@ArrayList[</span><br><span class="line">    @Object[][isEmpty=false;size=1],</span><br><span class="line">    @IllegalArgumentException[java.lang.IllegalArgumentException: id &lt; 1],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以看到实际抛出的异常是<code>IllegalArgumentException</code>。</p><p>可以输入 <code>q</code> 或者 <code>Ctrl+C</code> 退出watch命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><p>如果想把获取到的结果展开，可以用<code>-x</code>参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch com.example.demo.arthas.user.UserController * <span class="string">&#x27;&#123;params, throwExp&#125;&#x27;</span> -x 2</span><br></pre></td></tr></table></figure><h4><span id="返回值表达式">返回值表达式</span></h4><p>在上面的例子里，第三个参数是<code>返回值表达式</code>，它实际上是一个<code>ognl</code>表达式，它支持一些内置对象：</p><ul><li>loader</li><li>clazz</li><li>method</li><li>target</li><li>params</li><li>returnObj</li><li>throwExp</li><li>isBefore</li><li>isThrow</li><li>isReturn</li></ul><p>你可以利用这些内置对象来组成不同的表达式。比如返回一个数组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch com.example.demo.arthas.user.UserController * <span class="string">&#x27;&#123;params[0], target, returnObj&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>更多参考： <a href="https://arthas.aliyun.com/doc/advice-class.html">https://arthas.aliyun.com/doc/advice-class.html</a></p><h4><span id="条件表达式">条件表达式</span></h4><p><code>watch</code>命令支持在第4个参数里写条件表达式，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch com.example.demo.arthas.user.UserController * returnObj <span class="string">&#x27;params[0] &gt; 100&#x27;</span></span><br></pre></td></tr></table></figure><p>当访问 user/1 时，<code>watch</code>命令没有输出</p><p>当访问 user/101 时，<code>watch</code>会打印出结果。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch com.example.demo.arthas.user.UserController * returnObj <span class="string">&#x27;params[0] &gt; 100&#x27;</span></span></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:2) cost in 47 ms.</span><br><span class="line">ts=2019-02-13 19:42:12; [cost=0.821443ms] result=@User[</span><br><span class="line">    id=@Integer[101],</span><br><span class="line">    name=@String[name101],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4><span id="当异常时捕获">当异常时捕获</span></h4><p><code>watch</code>命令支持<code>-e</code>选项，表示只捕获抛出异常时的请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch com.example.demo.arthas.user.UserController * <span class="string">&quot;&#123;params[0],throwExp&#125;&quot;</span> -e</span><br></pre></td></tr></table></figure><h4><span id="按照耗时进行过滤">按照耗时进行过滤</span></h4><p>watch命令支持按请求耗时进行过滤，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch com.example.demo.arthas.user.UserController * <span class="string">&#x27;&#123;params, returnObj&#125;&#x27;</span> <span class="string">&#x27;#cost&gt;200&#x27;</span></span><br></pre></td></tr></table></figure><h2><span id="案例-热更新代码">案例: 热更新代码</span></h2><p>下面介绍通过<code>jad</code>/<code>mc</code>/<code>redefine</code> 命令实现动态更新代码的功能。</p><p>目前，访问 <a href="http://localhost:61000/user/0">http://localhost:61000/user/0</a> ，会返回500异常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:61000/user/0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;timestamp&quot;:1550223186170,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;exception&quot;:&quot;java.lang.IllegalArgumentException&quot;,&quot;message&quot;:&quot;id &lt; 1&quot;,&quot;path&quot;:&quot;/user/0&quot;&#125;</span><br></pre></td></tr></table></figure><p>下面通过热更新代码，修改这个逻辑。</p><h4><span id="jad反编译usercontroller">jad反编译UserController</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java</span><br></pre></td></tr></table></figure><p>jad反编译的结果保存在 <code>/tmp/UserController.java</code>文件里了。</p><p>再打开一个<code>Terminal 3</code>，然后用vim来编辑<code>/tmp/UserController.java</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /tmp/UserController.java</span><br></pre></td></tr></table></figure><p>比如当 user id 小于1时，也正常返回，不抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value=&#123;&quot;/user/&#123;id&#125;&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">&quot;id: &#123;&#125;&quot;</span>, (Object)id);</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="keyword">null</span> &amp;&amp; id &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(id, <span class="string">&quot;name&quot;</span> + id);</span><br><span class="line">        <span class="comment">// throw new IllegalArgumentException(&quot;id &lt; 1&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(id.intValue(), <span class="string">&quot;name&quot;</span> + id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="sc查找加载usercontroller的classloader">sc查找加载UserController的ClassLoader</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d *UserController | grep classLoaderHash</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sc -d *UserController | grep classLoaderHash</span></span><br><span class="line"> classLoaderHash   1be6f5c3</span><br></pre></td></tr></table></figure><p>可以发现是 spring boot <code>LaunchedURLClassLoader@1be6f5c3</code> 加载的。</p><p>请记下你的classLoaderHash，后面需要使用它。在这里，它是 <code>1be6f5c3</code>。</p><h4><span id="mc">mc</span></h4><p>保存好<code>/tmp/UserController.java</code>之后，使用<code>mc</code>(Memory Compiler)命令来编译，并且通过<code>-c</code>或者<code>--classLoaderClass</code>参数指定ClassLoader：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmp</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmp</span></span><br><span class="line">Memory compiler output:</span><br><span class="line">/tmp/com/example/demo/arthas/user/UserController.class</span><br><span class="line">Affect(row-cnt:1) cost in 346 ms</span><br></pre></td></tr></table></figure><p>也可以通过<code>mc -c &lt;classLoaderHash&gt; /tmp/UserController.java -d /tmp</code>，使用<code>-c</code>参数指定ClassLoaderHash:</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mc -c 1be6f5c3 /tmp/UserController.java -d /tmp</span></span><br></pre></td></tr></table></figure><h4><span id="redefine">redefine</span></h4><p>再使用<code>redefine</code>命令重新加载新编译好的<code>UserController.class</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redefine /tmp/com/example/demo/arthas/user/UserController.class</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redefine /tmp/com/example/demo/arthas/user/UserController.class</span><br><span class="line">redefine success, size: 1</span><br></pre></td></tr></table></figure><h4><span id="热修改代码结果">热修改代码结果</span></h4><p><code>redefine</code>成功之后，再次访问 user/0 ，结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 0,</span><br><span class="line">  &quot;name&quot;: &quot;name0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="案例-动态更新应用logger-level">案例: 动态更新应用Logger Level</span></h2><p>在这个案例里，动态修改应用的Logger Level。</p><h4><span id="查找usercontroller的classloader">查找UserController的ClassLoader</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span></span><br><span class="line"> classLoaderHash   1be6f5c3</span><br></pre></td></tr></table></figure><h4><span id="用ognl获取logger">用ognl获取logger</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span></span></span><br><span class="line">@Logger[</span><br><span class="line">    serialVersionUID=@Long[5454405123156820674],</span><br><span class="line">    FQCN=@String[ch.qos.logback.classic.Logger],</span><br><span class="line">    name=@String[com.example.demo.arthas.user.UserController],</span><br><span class="line">    level=null,</span><br><span class="line">    effectiveLevelInt=@Integer[20000],</span><br><span class="line">    parent=@Logger[Logger[com.example.demo.arthas.user]],</span><br><span class="line">    childrenList=null,</span><br><span class="line">    aai=null,</span><br><span class="line">    additive=@Boolean[true],</span><br><span class="line">    loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以知道<code>UserController@logger</code>实际使用的是logback。可以看到<code>level=null</code>，则说明实际最终的level是从<code>root</code> logger里来的。</p><h4><span id="单独设置usercontroller的logger-level">单独设置UserController的logger level</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger.setLevel(@ch.qos.logback.classic.Level@DEBUG)&#x27;</span></span><br></pre></td></tr></table></figure><p>再次获取<code>UserController@logger</code>，可以发现已经是<code>DEBUG</code>了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span></span></span><br><span class="line">@Logger[</span><br><span class="line">    serialVersionUID=@Long[5454405123156820674],</span><br><span class="line">    FQCN=@String[ch.qos.logback.classic.Logger],</span><br><span class="line">    name=@String[com.example.demo.arthas.user.UserController],</span><br><span class="line">    level=@Level[DEBUG],</span><br><span class="line">    effectiveLevelInt=@Integer[10000],</span><br><span class="line">    parent=@Logger[Logger[com.example.demo.arthas.user]],</span><br><span class="line">    childrenList=null,</span><br><span class="line">    aai=null,</span><br><span class="line">    additive=@Boolean[true],</span><br><span class="line">    loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4><span id="修改logback的全局logger-level">修改logback的全局logger level</span></h4><p>通过获取<code>root</code> logger，可以修改全局的logger level：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@org.slf4j.LoggerFactory@getLogger(&quot;root&quot;).setLevel(@ch.qos.logback.classic.Level@DEBUG)&#x27;</span></span><br></pre></td></tr></table></figure><h2><span id="案例-排查logger冲突问题">案例: 排查logger冲突问题</span></h2><p>在这个案例里，展示排查logger冲突的方法。</p><h4><span id="确认应用使用的logger系统">确认应用使用的logger系统</span></h4><p>以<code>UserController</code>为例，它使用的是slf4j api，但实际使用到的logger系统是logback。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span></span></span><br><span class="line">@Logger[</span><br><span class="line">    serialVersionUID=@Long[5454405123156820674],</span><br><span class="line">    FQCN=@String[ch.qos.logback.classic.Logger],</span><br><span class="line">    name=@String[com.example.demo.arthas.user.UserController],</span><br><span class="line">    level=null,</span><br><span class="line">    effectiveLevelInt=@Integer[20000],</span><br><span class="line">    parent=@Logger[Logger[com.example.demo.arthas.user]],</span><br><span class="line">    childrenList=null,</span><br><span class="line">    aai=null,</span><br><span class="line">    additive=@Boolean[true],</span><br><span class="line">    loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4><span id="获取logback实际加载的配置文件">获取logback实际加载的配置文件</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;#map1=@org.slf4j.LoggerFactory@getLogger(&quot;root&quot;).loggerContext.objectMap, #map1.get(&quot;CONFIGURATION_WATCH_LIST&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h4><span id="使用classloader命令查找可能存在的logger配置文件">使用classloader命令查找可能存在的logger配置文件</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml</span><br><span class="line"> jar:file:/Users/hengyunabc/code/java/spring-boot-inside/demo-arthas-spring-boot/target/demo-arthas-spring-boot-0.0.1-SNAPSHOT.jar!/BOOT-INF/classes!/logback-spring.xml</span><br><span class="line"></span><br><span class="line">Affect(row-cnt:1) cost in 13 ms.</span><br></pre></td></tr></table></figure><p>可以知道加载的配置的具体来源。</p><p>可以尝试加载容易冲突的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback.xml</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r log4j.properties</span><br></pre></td></tr></table></figure><h2><span id="案例-获取spring-context">案例: 获取Spring Context</span></h2><p>在这个案例里，展示获取spring context，再获取bean，然后调用函数。</p><h4><span id="使用tt命令获取到spring-context">使用tt命令获取到spring context</span></h4><p><code>tt</code>即 TimeTunnel，它可以记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测。</p><ul><li><a href="https://arthas.aliyun.com/doc/tt.html">https://arthas.aliyun.com/doc/tt.html</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter invokeHandlerMethod</span><br></pre></td></tr></table></figure><p>访问：user/1</p><p>可以看到<code>tt</code>命令捕获到了一个请求：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdaptePress Q or Ctrl+C to abort.</span></span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost in 252 ms.</span><br><span class="line"> INDE  TIMESTAMP    COST(  IS-R  IS-  OBJECT     CLASS               METHOD</span><br><span class="line"> X                  ms)    ET    EXP</span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"> 1000  2019-02-15   4.583  true  fal  0xc93cf1a  RequestMappingHand  invokeHandlerMethod</span><br><span class="line">       15:38:32     923          se              lerAdapter</span><br></pre></td></tr></table></figure><h4><span id="使用tt命令从调用记录里获取到spring-context">使用tt命令从调用记录里获取到spring context</span></h4><p>输入 <code>q</code> 或者 <code>Ctrl + C</code> 退出上面的 <code>tt -t</code>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -i 1000 -w <span class="string">&#x27;target.getApplicationContext()&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tt -i 1000 -w <span class="string">&#x27;target.getApplicationContext()&#x27;</span></span></span><br><span class="line">@AnnotationConfigEmbeddedWebApplicationContext[</span><br><span class="line">    reader=@AnnotatedBeanDefinitionReader[org.springframework.context.annotation.AnnotatedBeanDefinitionReader@2e457641],</span><br><span class="line">    scanner=@ClassPathBeanDefinitionScanner[org.springframework.context.annotation.ClassPathBeanDefinitionScanner@6eb38026],</span><br><span class="line">    annotatedClasses=null,</span><br><span class="line">    basePackages=null,</span><br><span class="line">]</span><br><span class="line">Affect(row-cnt:1) cost in 439 ms.</span><br></pre></td></tr></table></figure><h3><span id="获取spring-bean并调用函数">获取spring bean，并调用函数</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -i 1000 -w <span class="string">&#x27;target.getApplicationContext().getBean(&quot;helloWorldService&quot;).getHelloMessage()&#x27;</span></span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tt -i 1000 -w <span class="string">&#x27;target.getApplicationContext().getBean(&quot;helloWorldService&quot;).getHelloMessage()&#x27;</span></span></span><br><span class="line">@String[Hello World]</span><br><span class="line">Affect(row-cnt:1) cost in 52 ms.</span><br></pre></td></tr></table></figure><h2><span id="案例-排查http请求返回401">案例: 排查HTTP请求返回401</span></h2><p>在这个案例里，展示排查HTTP 401问题的技巧。</p><p>访问： admin</p><p>结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Something went wrong: 401 Unauthorized</span><br></pre></td></tr></table></figure><p>我们知道<code>401</code>通常是被权限管理的<code>Filter</code>拦截了，那么到底是哪个<code>Filter</code>处理了这个请求，返回了401？</p><h4><span id="跟踪所有的filter函数">跟踪所有的Filter函数</span></h4><p>开始trace：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace javax.servlet.Filter *</span><br></pre></td></tr></table></figure><p>访问： admin</p><p>可以在调用树的最深层，找到<code>AdminFilterConfig$AdminFilter</code>返回了<code>401</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+---[3.806273ms] javax.servlet.FilterChain:doFilter()</span><br><span class="line">|   `---[3.447472ms] com.example.demo.arthas.AdminFilterConfig$AdminFilter:doFilter()</span><br><span class="line">|       `---[0.17259ms] javax.servlet.http.HttpServletResponse:sendError()</span><br></pre></td></tr></table></figure><h4><span id="通过stack获取调用栈">通过stack获取调用栈</span></h4><p>上面是通过<code>trace</code>命令来获取信息，从结果里，我们可以知道通过<code>stack</code>跟踪<code>HttpServletResponse:sendError()</code>，同样可以知道是哪个<code>Filter</code>返回了<code>401</code></p><p>执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack javax.servlet.http.HttpServletResponse sendError <span class="string">&#x27;params[0]==401&#x27;</span></span><br></pre></td></tr></table></figure><p>访问： admin</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> stack javax.servlet.http.HttpServletResponse sendError <span class="string">&#x27;params[0]==401&#x27;</span></span></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:2 , method-cnt:4) cost in 87 ms.</span><br><span class="line">ts=2019-02-15 16:44:06;thread_name=http-nio-8080-exec-6;id=16;is_daemon=true;priority=5;TCCL=org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedWebappClassLoader@8546cd5</span><br><span class="line">    @org.apache.catalina.connector.ResponseFacade.sendError()</span><br><span class="line">        at com.example.demo.arthas.AdminFilterConfig$AdminFilter.doFilter(AdminFilterConfig.java:38)</span><br><span class="line">        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">        at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)</span><br><span class="line">        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br></pre></td></tr></table></figure><h2><span id="案例-排查http请求返回404">案例: 排查HTTP请求返回404</span></h2><p>在这个案例里，展示排查HTTP 404问题的技巧。</p><p>访问： a.txt</p><p>结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Something went wrong: 404 Not Found</span><br></pre></td></tr></table></figure><p>那么到底是哪个Servlet处理了这个请求，返回了404？</p><h4><span id="跟踪所有的servlet函数">跟踪所有的Servlet函数</span></h4><p>开始trace：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace javax.servlet.Servlet * &gt; /tmp/servlet.txt</span><br></pre></td></tr></table></figure><p>访问： a.txt</p><p>在<code>Terminal 3</code>里，查看<code>/tmp/servlet.txt</code>的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less /tmp/servlet.txt</span><br></pre></td></tr></table></figure><p><code>/tmp/servlet.txt</code>里的内容会比较多，需要耐心找到调用树里最长的地方。</p><p>可以发现请求最终是被<code>freemarker</code>处理的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">`---[13.974188ms] org.springframework.web.servlet.ViewResolver:resolveViewName();    +---[0.045561ms] javax.servlet.GenericServlet:&lt;init&gt;()</span><br><span class="line">    +---[min=0.045545ms,max=0.074342ms,total=0.119887ms,count=2] org.springframework.web.servlet.view.freemarker.FreeMarkerView$GenericServletAdapter:&lt;init&gt;()</span><br><span class="line">    +---[0.170895ms] javax.servlet.GenericServlet:init()</span><br><span class="line">    |   `---[0.068578ms] javax.servlet.GenericServlet:init()</span><br><span class="line">    |       `---[0.021793ms] javax.servlet.GenericServlet:init()</span><br><span class="line">    `---[0.164035ms] javax.servlet.GenericServlet:getServletContext()</span><br></pre></td></tr></table></figure><h2><span id="案例-理解spring-boot应用的classloader结构">案例: 理解Spring Boot应用的ClassLoader结构</span></h2><p>下面介绍<code>classloader</code>命令的功能。</p><p>先访问一个jsp网页，触发jsp的加载： hello</p><h4><span id="列出所有classloader">列出所有ClassLoader</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader -l</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> classloader -l</span></span><br><span class="line"> name                                                             loadedCount  hash      parent</span><br><span class="line"> BootstrapClassLoader                                             2724         null      null</span><br><span class="line"> com.taobao.arthas.agent.ArthasClassloader@411ce1ab               2009         411ce1ab  sun.misc.Launcher$ExtClassLoader@7494e528</span><br><span class="line"> com.taobao.arthas.agent.ArthasClassloader@22ae1234               1253         22ae1234  sun.misc.Launcher$ExtClassLoader@7494e528</span><br><span class="line"> org.apache.jasper.servlet.JasperLoader@65361d9a                  1            65361d9a  TomcatEmbeddedWebappClassLoader</span><br><span class="line">                                                                                           context: ROOT</span><br><span class="line">                                                                                           delegate: true</span><br><span class="line">                                                                                         ----------&gt; Parent Classloader:</span><br><span class="line">                                                                                         org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3</span><br><span class="line"></span><br><span class="line"> TomcatEmbeddedWebappClassLoader                                  0            8546cd5   org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3</span><br><span class="line">   context: ROOT</span><br><span class="line">   delegate: true</span><br><span class="line"><span class="meta"> ----------&gt;</span><span class="bash"> Parent Classloader:</span></span><br><span class="line"> org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3</span><br><span class="line"></span><br><span class="line"> org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3  5416         1be6f5c3  sun.misc.Launcher$AppClassLoader@3d4eac69</span><br><span class="line"> sun.misc.Launcher$AppClassLoader@3d4eac69                        45           3d4eac69  sun.misc.Launcher$ExtClassLoader@7494e528</span><br><span class="line"> sun.misc.Launcher$ExtClassLoader@7494e528                        4            7494e528  null</span><br></pre></td></tr></table></figure><ul><li>TomcatEmbeddedWebappClassLoader 加载的class数量是0，所以在spring boot embedded tomcat里，它只是一个空壳，所有的类加载都是<code>LaunchedURLClassLoader</code>完成的</li></ul><h4><span id="列出classloader里加载的所有类">列出ClassLoader里加载的所有类</span></h4><p>列出上面的<code>org.apache.jasper.servlet.JasperLoader</code>加载的类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader -a --classLoaderClass apache.jasper.servlet.JasperLoader</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> classloader -a --classLoaderClass apache.jasper.servlet.JasperLoader</span></span><br><span class="line"> hash:1698045338, org.apache.jasper.servlet.JasperLoader@65361d9a</span><br><span class="line"> org.apache.jsp.jsp.hello_jsp</span><br></pre></td></tr></table></figure><ul><li>注：同ognl, 也可用<code>-c &lt;hashcode&gt;</code>而不用<code>--classLoaderClass</code>指定</li></ul><h4><span id="反编译jsp的代码">反编译jsp的代码</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad org.apache.jsp.jsp.hello_jsp</span><br></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jad org.apache.jsp.jsp.hello_jsp</span></span><br><span class="line"></span><br><span class="line">ClassLoader:</span><br><span class="line">+-org.apache.jasper.servlet.JasperLoader@65361d9a</span><br><span class="line">  +-TomcatEmbeddedWebappClassLoader</span><br><span class="line">      context: ROOT</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4><span id="查看classloader树">查看ClassLoader树</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader -t</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ classloader -t</span><br><span class="line">+-BootstrapClassLoader</span><br><span class="line">+-sun.misc.Launcher$ExtClassLoader@28cbbddd</span><br><span class="line">  +-com.taobao.arthas.agent.ArthasClassloader@8c25e55</span><br><span class="line">  +-sun.misc.Launcher$AppClassLoader@55f96302</span><br><span class="line">    +-org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3</span><br><span class="line">      +-TomcatEmbeddedWebappClassLoader</span><br><span class="line">          context: ROOT</span><br><span class="line">          delegate: true</span><br><span class="line">        ----------&gt; Parent Classloader:</span><br><span class="line">        org.springframework.boot.loader.LaunchedURLClassLoader@1be6f5c3</span><br><span class="line"></span><br><span class="line">        +-org.apache.jasper.servlet.JasperLoader@21ae0fe2</span><br></pre></td></tr></table></figure><p>注意：请使用你的classLoaderHash值覆盖 <code>&lt;classLoaderHash&gt;</code> ，然后手动执行下面相关命令：</p><h4><span id="列出classloader的urls">列出ClassLoader的urls</span></h4><p>比如上面查看到的spring LaunchedURLClassLoader的 hashcode是<code>1be6f5c3</code>，可以通过<code>-c</code>或者<code>--classLoaderClass</code>参数来列出它的所有urls：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader</span><br><span class="line">jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/classes!/</span><br><span class="line">jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/lib/spring-boot-starter-aop-1.5</span><br><span class="line">.13.RELEASE.jar!/</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4><span id="加载指定classloader里的资源文件">加载指定ClassLoader里的资源文件</span></h4><p>查找指定的资源文件： <code>classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml</span><br><span class="line"> jar:file:/home/scrapbook/tutorial/demo-arthas-spring-boot.jar!/BOOT-INF/classes!/logback-spring.xml</span><br></pre></td></tr></table></figure><h4><span id="尝试加载指定的类">尝试加载指定的类</span></h4><p>比如用上面的spring LaunchedURLClassLoader 尝试加载 <code>java.lang.String</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader --load java.lang.String</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader --load java.lang.String</span><br><span class="line">load class success.</span><br><span class="line"> class-info        java.lang.String</span><br><span class="line"> code-source</span><br><span class="line"> name              java.lang.String</span><br><span class="line"> isInterface       false</span><br><span class="line"> isAnnotation      false</span><br><span class="line"> isEnum            false</span><br><span class="line"> isAnonymousClass  false</span><br><span class="line"> isArray           false</span><br><span class="line"> isLocalClass      false</span><br><span class="line"> isMemberClass     false</span><br><span class="line"> isPrimitive       false</span><br><span class="line"> isSynthetic       false</span><br><span class="line"> simple-name       String</span><br><span class="line"> modifier          final,public</span><br><span class="line"> annotation</span><br><span class="line"> interfaces        java.io.Serializable,java.lang.Comparable,java.lang.CharSequence</span><br><span class="line"> super-class       +-java.lang.Object</span><br><span class="line"> class-loader</span><br><span class="line"> classLoaderHash   null</span><br></pre></td></tr></table></figure><h2><span id="案例查找top-n线程">案例：查找Top N线程</span></h2><h4><span id="查看所有线程信息">查看所有线程信息</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread</span><br></pre></td></tr></table></figure><h4><span id="查看具体线程的栈">查看具体线程的栈</span></h4><p>查看线程ID 16的栈：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread 16</span><br></pre></td></tr></table></figure><h4><span id="查看cpu使用率top-n线程的栈">查看CPU使用率top n线程的栈</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread -n 3</span><br></pre></td></tr></table></figure><p>查看5秒内的CPU使用率top n线程栈</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread -n 3 -i 5000</span><br></pre></td></tr></table></figure><h4><span id="查找线程是否有阻塞">查找线程是否有阻塞</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread -b</span><br></pre></td></tr></table></figure><h2><span id="web-console">Web Console</span></h2><p>Arthas支持通过Web Socket来连接。</p><h3><span id="本地体验">本地体验</span></h3><p>当在本地启动时，可以访问 <a href="http://127.0.0.1:8563/">http://127.0.0.1:8563/</a> ，通过浏览器来使用Arthas。</p><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/Arthas-%E8%BF%9B%E9%98%B6/O1CN01i041kW1lw0FCaSKNn_!!6000000004882-2-tps-1231-284.png" alt="Arthas WebConsole"></p><p>推荐通过“快速入门”来体验： <a href="https://arthas.aliyun.com/doc/quick-start.html">https://arthas.aliyun.com/doc/quick-start.html</a></p><h2><span id="exitstop">Exit/Stop</span></h2><h3><span id="reset">reset</span></h3><p>Arthas在 watch/trace 等命令时，实际上是修改了应用的字节码，插入增强的代码。显式执行 <code>reset</code> 命令，可以清除掉这些增强代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reset</span><br></pre></td></tr></table></figure><h3><span id="退出arthas">退出Arthas</span></h3><p>用 <code>exit</code> 或者 <code>quit</code> 命令可以退出Arthas。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>Ctrl+C</p><p>退出Arthas之后，还可以再次用 <code>java -jar arthas-boot.jar</code> 来连接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p>Ctrl+C</p><h3><span id="彻底退出arthas">彻底退出Arthas</span></h3><p><code>exit/quit</code>命令只是退出当前session，arthas server还在目标进程中运行。</p><p>想完全退出Arthas，可以执行 <code>stop</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop</span><br></pre></td></tr></table></figure><p>Ctrl+C</p><h2><span id="arthas-boot支持的参数">arthas-boot支持的参数</span></h2><p><code>arthas-boot.jar</code> 支持很多参数，可以执行 <code>java -jar arthas-boot.jar -h</code> 来查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar -h</span><br></pre></td></tr></table></figure><h3><span id="允许外部访问">允许外部访问</span></h3><p>默认情况下， arthas server侦听的是 <code>127.0.0.1</code> 这个IP，如果希望远程可以访问，可以使用<code>--target-ip</code>的参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar --target-ip</span><br></pre></td></tr></table></figure><h3><span id="列出所有的版本">列出所有的版本</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar --versions</span><br></pre></td></tr></table></figure><p>使用指定版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar --use-version 3.1.0</span><br></pre></td></tr></table></figure><h3><span id="只侦听telnet端口不侦听http端口">只侦听Telnet端口，不侦听HTTP端口</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar --telnet-port 9999 --http-port -1</span><br></pre></td></tr></table></figure><h3><span id="打印运行的详情">打印运行的详情</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar -v</span><br></pre></td></tr></table></figure><h2><span id="更多信息">更多信息</span></h2><p>在“进阶教程”，演示了Arthas的大部分高级用法，希望对大家排查问题有帮助。如果有更多的技巧或者使用疑问，欢迎在Issue里提出。</p><ul><li>Issues: <a href="https://github.com/alibaba/arthas/issues">https://github.com/alibaba/arthas/issues</a></li><li>文档： <a href="https://arthas.aliyun.com/doc">https://arthas.aliyun.com/doc</a></li></ul><p>如果您在使用Arthas，请让我们知道。您的使用对我们非常重要：<a href="https://github.com/alibaba/arthas/issues/111">查看</a></p><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=qDlgqpBT">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=qDlgqpBT</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 入门教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas 基础教程</title>
      <link href="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/Arthas-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
      <url>/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/Arthas-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%90%AF%E5%8A%A8arthas-demo">启动arthas-demo</a></li><li><a href="#%E5%90%AF%E5%8A%A8arthas-boot">启动arthas-boot</a></li><li><a href="#dashboard">Dashboard</a></li><li><a href="#thread">Thread</a></li><li><a href="#sc">Sc</a></li><li><a href="#jad">Jad</a></li><li><a href="#watch">Watch</a></li><li><a href="#exitstop">Exit/Stop</a><ul><li><a href="#%E9%80%80%E5%87%BAarthas">退出Arthas</a></li><li><a href="#%E5%BD%BB%E5%BA%95%E9%80%80%E5%87%BAarthas">彻底退出Arthas</a></li></ul></li><li><a href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF">更多信息</a></li></ul><!-- tocstop --><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/Arthas-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/arthas.png" alt="Arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</p><p><code>Arthas</code> 支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><ul><li>Github: <a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></li><li>文档: <a href="https://arthas.aliyun.com/doc/">https://arthas.aliyun.com/doc/</a></li></ul><h2><span id="启动arthas-demo">启动arthas-demo</span></h2><p>下载<code>arthas-demo.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-demo.jar;java -jar arthas-demo.jar</span><br></pre></td></tr></table></figure><p><code>arthas-demo</code>是一个很简单的程序，它随机生成整数，再执行因式分解，把结果打印出来。如果生成的随机数是负数，则会打印提示信息。</p><h2><span id="启动arthas-boot">启动arthas-boot</span></h2><p>在新的<code>Terminal 2</code>里，下载<code>arthas-boot.jar</code>，再用<code>java -jar</code>命令启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://arthas.aliyun.com/arthas-boot.jar;java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><code>arthas-boot</code>是<code>Arthas</code>的启动程序，它启动后，会列出所有的Java进程，用户可以选择需要诊断的目标进程。</p><p>选择第一个进程，输入 <code>1</code> ，再<code>Enter/回车</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>Attach成功之后，会打印Arthas LOGO。输入 <code>help</code> 可以获取到更多的帮助信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/07/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/Arthas-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/O1CN01HzatXZ1RgccrlT90M_!!6000000002141-2-tps-529-244.png" alt="Arthas Boot"></p><h2><span id="dashboard">Dashboard</span></h2><p><code>dashboard</code> 命令可以查看当前系统的实时数据面板。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dashboard</span><br></pre></td></tr></table></figure><p>输入 <code>q</code> 或者 <code>Ctrl+C</code> 可以退出dashboard命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><h2><span id="thread">Thread</span></h2><p><code>thread 1</code> 命令会打印线程ID 1的栈。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread 1</span><br></pre></td></tr></table></figure><p>Ctrl+C Arthas支持管道，可以用 <code>thread 1 | grep &#39;main(&#39;</code> 查找到<code>main class</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread 1 | grep <span class="string">&#x27;main(&#x27;</span></span><br></pre></td></tr></table></figure><p>可以看到<code>main class</code>是<code>demo.MathGame</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ thread 1 | grep &#x27;main(&#x27;</span><br><span class="line">    at demo.MathGame.main(MathGame.java:17)</span><br></pre></td></tr></table></figure><h2><span id="sc">Sc</span></h2><p>可以通过 <code>sc</code> 命令来查找JVM里已加载的类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -d *MathGame</span><br></pre></td></tr></table></figure><h2><span id="jad">Jad</span></h2><p>可以通过 <code>jad</code> 命令来反编译代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jad demo.MathGame</span><br></pre></td></tr></table></figure><h2><span id="watch">Watch</span></h2><p>通过<code>watch</code>命令可以查看函数的参数/返回值/异常信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch demo.MathGame primeFactors returnObj</span><br></pre></td></tr></table></figure><p></p><p>输入 <code>q</code> 或者 <code>Ctrl+C</code> 退出watch命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><h2><span id="exitstop">Exit/Stop</span></h2><h3><span id="退出arthas">退出Arthas</span></h3><p>用 <code>exit</code> 或者 <code>quit</code> 命令可以退出Arthas。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>Ctrl+C</p><p>退出Arthas之后，还可以再次用 <code>java -jar arthas-boot.jar</code> 来连接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p>Ctrl+C</p><h3><span id="彻底退出arthas">彻底退出Arthas</span></h3><p><code>exit/quit</code>命令只是退出当前session，arthas server还在目标进程中运行。</p><p>想完全退出Arthas，可以执行 <code>stop</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop</span><br></pre></td></tr></table></figure><p>Ctrl+C</p><h2><span id="更多信息">更多信息</span></h2><p>通过本教程基本掌握了Arthas的用法。更多高级特性，可以在下面的进阶指南里继续了解。</p><ul><li><a href="https://arthas.aliyun.com/doc/arthas-tutorials.html?language=cn&id=arthas-advanced">Arthas进阶</a></li><li><a href="https://github.com/alibaba/arthas">Arthas Github</a></li><li><a href="https://arthas.aliyun.com/doc/">Arthas 文档</a></li></ul><p>文章拷贝来源：<a href="https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=qDlgqpBT">https://start.aliyun.com/course?spm=a2ck6.17690074.0.0.28bc2e7dHTphXs&amp;id=qDlgqpBT</a></p>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 诊断工具 Arthas 入门教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>awk命令使用介绍</title>
      <link href="/2021/07/31/awk%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
      <url>/2021/07/31/awk%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://www.oschina.net/action/GoToLink?url=http://en.wikipedia.org/wiki/Awk">awk</a></strong> 是一门非常优秀的文本处理工具，甚至可以上升作为一门程序设计语言。<br>它处理文本的速度是快得惊人的，现在很多基于shell 日志分析工具都可以用它完成。特点是设计简单，速度表现很好，本文将介绍awk内置变量。<br>格式： awk [ -F re] [parameter…] [‘pattern {action}’ ] [-f progfile][in_file…]</p><p><strong>一、内置变量</strong></p><table><thead><tr><th><strong>属 性</strong></th><th><strong>说 明</strong></th></tr></thead><tbody><tr><td>$0</td><td>当前记录行，代表一行记录</td></tr><tr><td>1~1 n</td><td>当前记录的第n个字段，字段间由FS分隔</td></tr><tr><td>FS</td><td>输入字段分隔符，默认是空格</td></tr><tr><td>NF</td><td>当前记录中的字段个数，就是有多少列，一般取最后一列字段</td></tr><tr><td>NR</td><td>已经读出的记录数，就是行号，从1开始</td></tr><tr><td>RS</td><td>输入的记录分隔符，默认为换行符</td></tr><tr><td>OFS</td><td>输出字段分隔符，默是空格</td></tr><tr><td>ORS</td><td>输出的记录分隔符，默认为换行符</td></tr><tr><td>ARGC</td><td>命令行参数个数</td></tr><tr><td>ARGV</td><td>命令行参数数组</td></tr><tr><td>FILENAME</td><td>当前输入文件的名字</td></tr><tr><td>IGNORECASE</td><td>如果为真，则进行忽略大小写的匹配</td></tr><tr><td>ARGIND</td><td>当前被处理文件的ARGV标志符</td></tr><tr><td>CONVFMT</td><td>数字转换格式 %.6g</td></tr><tr><td>ENVIRON</td><td>UNIX环境变量</td></tr><tr><td>ERRNO</td><td>UNIX系统错误消息</td></tr><tr><td>FIELDWIDTHS</td><td>输入字段宽度的空白分隔字符串</td></tr><tr><td>FNR</td><td>当前记录数</td></tr><tr><td>OFMT</td><td>数字的输出格式 %.6g</td></tr><tr><td>RSTART</td><td>被匹配函数匹配的字符串首</td></tr><tr><td>RLENGTH</td><td>被匹配函数匹配的字符串长度</td></tr><tr><td>SUBSEP</td><td>\034</td></tr></tbody></table><h3><span id="built-in-variables">Built-in variables</span></h3><p>Awk’s built-in variables include the field variables: 1,1,2, 3, and so on (3,<em>a<strong>n</strong>d<strong>s</strong>o<strong>o</strong>n</em>(0 represents the entire record). They hold the text or values in the individual text-fields in a record.</p><p>Other variables include:</p><ul><li>NR: Keeps a current count of the number of input records.</li><li>NF: Keeps a count of the number of fields in an input record. The last field in the input record can be designated by $NF.</li><li>FS: Contains the “field separator” character used to divide fields on the input record. The default, “white space”, includes any space and tab characters. FS can be reassigned to another character to change the field separator.</li><li>RS: Stores the current “record separator” character. Since, by default, an input line is the input record, the default record separator character is a “newline”.</li><li>OFS: Stores the “output field separator”, which separates the fields when Awk prints them. The default is a “space” character.</li><li>ORS: Stores the “output record separator”, which separates the output records when Awk prints them. The default is a “newline” character.</li><li>OFMT: Stores the format for numeric output. The default format is “%.6g”.</li><li>FILENAME: Contains the name of the current input-file.</li></ul><p><strong>二、 变量实例</strong><br><strong>1） 常用操作</strong><br>awk ‘/^root/ {print $0}’ /etc/passwd<br>结果： root:x:0:0:root:/root:/bin/bash            # /^root/ 为正则过滤表达式，$0代表是逐行</p><p><strong>2） FS 分隔符</strong><br>awk ‘BEGIN{FS=”:”} /^root/ {print 1,1,NF}’ /etc/passwd<br>结果： root /bin/bash<br>注： FS为字段分隔符，默认是空格。因为passwd里是”:”分隔，所以需要修改默认分隔符。NF是字段总数，0代表当前行记录，0代表当前行记录，1-n是当前行各个字段对应值，<em>n</em>是当前行各个字段对应值，NF代表最后一列。</p><p><strong>3）</strong> <strong>记录条数</strong>（NR，FNR）<br>awk ‘BEGIN{FS=”:”}{print NR, 1,1,NF, “\t”, $0}’ /etc/passwd<br>结果：<br>1 root /bin/bash  root:x:0:0:root:/root:/bin/bash<br>2 daemon /bin/sh  daemon:x:1:1:daemon:/usr/sbin:/bin/sh<br>3 bin /bin/sh  bin:x:2:2:bin:/bin:/bin/sh<br>4 sys /bin/sh  sys:x:3:3:sys:/dev:/bin/sh<br>5 sync /bin/sync  sync:x:4:65534:sync:/bin:/bin/sync</p><p>……..</p><p>awk ‘BEGIN{FS=”:”}/^s/{print NR, 1,1,NF, “\t”, $0}’ /etc/passwd          # 过滤以首字符”s“开头的所有行<br>结果：<br>4 sys /bin/sh  sys:x:3:3:sys:/dev:/bin/sh<br>5 sync /bin/sync  sync:x:4:65534:sync:/bin:/bin/sync<br>20 syslog /bin/false  syslog:x:101:103::/home/syslog:/bin/false<br>……..<br>注： NR得到当前记录所在行</p><p><strong>4） 字段分隔符</strong>（OFS）<br>awk ‘BEGIN{FS=”:”; OFS=”##”} /^root/ {print FNR, 1,1,NF}’ /etc/passwd<br>结果： 1##root##/bin/bash<br>注： OFS设置默认字段分隔符， FNR当前记录行</p><p><strong>5） 行记录分隔符</strong>（ORS）<br>awk ‘BEGIN{FS=”:”; ORS=”##”}{print FNR, 1,1,NF}’ /etc/passwd<br>结果： 1 root /bin/bash##2 daemon /bin/sh##3 bin /bin/sh##4 sys /bin/sh##5 sync /bin/sync##……<br>awk ‘BEGIN{FS=”:”; ORS=”\n”}{print FNR, 1,1,NF}’ /etc/passwd          #   “/n” 是linux 中换行符<br>结果：<br>1 root /bin/bash<br>2 daemon /bin/sh<br>3 bin /bin/sh<br>4 sys /bin/sh<br>5 sync /bin/sync<br>…….<br>注： ORS默认是换行符，这里修改为：”##”，所有行之间用”##”分隔了</p><p><strong>6） 参数获取</strong>（ARGC ，ARGV）<br>awk ‘BEGIN{FS=”:”; print “ARGC=”ARGC; for(k in ARGV) {print k”=”ARGV[k];}}’ /etc/passwd<br>结果：<br>ARGC=2<br>0=awk<br>1=/etc/passwd<br>注： ARGC得到所有输入参数个数，ARGV获得输入参数内容是一个数组</p><p><strong>7） 获得传入的文件名</strong>（FILENAME）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;FS=&quot;:&quot;;&#125;/^r/ &#123;print FILENAME, &quot;\t&quot;, $0&#125;&#x27; /etc/passwd</span><br></pre></td></tr></table></figure><p>结果：<br>/etc/passwd  root:x:0:0:root:/root:/bin/bash<br>/etc/passwd  rtkit:x:110:117:RealtimeKit,,,:/proc:/bin/false<br>注： FILENAME, 0-0−N,NF 不能使用在BEGIN中，BEGIN中不能获得任何与文件记录操作的变量</p><p><strong>8） 获得linux环境变量</strong>（ENVIRON）<br>awk ‘BEGIN{print ENVIRON[“PATH”];}’ /etc/passwd<br>结果： <code>/home/homer/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games</code><br>注：  ENVIRON是子典型数组，可以通过对应键值获得它的值，linux 环境变量还有HOME，<code>*H**O**M**E*</code>，PWD等，可以通过linux 命令 env 查看</p><p><strong>9） 输出数据格式设置</strong>（OFMT）<br>awk ‘BEGIN{OFMT=”%.3f”; print 1, 2.0, 3.1, 2/3, 123.11111111;}’ /etc/passwd<br>结果： 1   2   3.100   0.667   123.111<br>注： OFMT默认输出格式是：%.6g 保留六位小数，这里修改OFMT会修改默认数据输出格式，如保留三位小数</p><p><strong>10） 按宽度指定分隔符</strong>（FIELDWIDTHS）<br>echo 20130108122448 | awk ‘BEGIN{FIELDWIDTHS=”4 2 2 2 2 3”}{print 1”-“1”−”2”-“3,3,4”:”5”:”5”:”6}’<br>结果： 2013-01-08 12:24:48<br>注： FIELDWIDTHS其格式为空格分隔的一串数字，用以对记录进行域的分隔，FIELDWIDTHS=”4 2 2 2 2 2”就表示1宽度是4，1宽度是4，2是2，$3是2 …. 这个时候会忽略FS分隔符</p><p><strong>11） RSTART，RLENGTH使用</strong><br>awk ‘BEGIN{start=match(“this is 1 teststr”, /[a-z]+$/); print start, RSTART, RLENGTH }’<br>结果： 11 11 7<br>awk ‘BEGIN{start=match(“this is a test”,/^[a-z ]+$/); print start, RSTART, RLENGTH }’<br>结果： 0 0 -1<br>awk ‘BEGIN{start=match(“this is a test”,/^[a-z ]+$/); print start, RSTART, RLENGTH }’<br>结果： 1 1 14         # 增加了一个空格“ ”匹配<br>注： RSTART 被匹配正则表达式首位置，RLENGTH 匹配字符长度，没有找到为-1</p><p><strong>三、外部变量</strong><br><strong>1） 基本用法</strong><br>awk 中两个特别的表达式，BEGIN和END<br>这两者都可用于pattern中，提供BEGIN和END的作用是给程序赋予 初始状态 和 程序结束 之后执行一些扫尾的工作。<br>a） 任何在BEGIN之后列出的操作（在{}内），将在awk开始扫描输入之前执行<br>b） 任何在END之后列出的操作，将在扫描完全部的输入之后执行<br>因此，通常使用BEGIN来显示变量和初始化变量，使用END来输出最终结果。<br>示例： echo ‘awk test’ | awk ‘BEGIN{print “start….”} {print $0} END{print “end….”}’<br>结果：<br>start….<br>awk test<br>end….<br><strong>2） 获取外部变量</strong><br>格式如： awk ‘{action}’ 变量名=变量值 ，这样传入变量可以在action中获得值。<br>示例：<br>test=’awk test’<br>echo | awk  ‘{print test}’ test=”$test”<br>结果： awk test<br>echo | awk  test=”$test” ‘{print test}’<br>结果： awk: cmd. line:1: fatal: cannot open file ‘{print test}’ for reading (No such file or directory)<br>注：变量名与值放到’{action}’后面，即 test=”$test” 在 print 后面</p><p><strong>3） BEGIN程序块中变量</strong><br>格式如：awk –v 变量名=变量值 [–v 变量2=值2 …] ‘BEGIN{action}’<br>示例：<br>test=’awk test’<br>echo | awk -v test=”$test” ‘BEGIN{print test}’<br>结果： awk test<br>echo | awk -v test=”$test” ‘{print test}’<br>结果： awk test<br>注：用-v 传入变量，可以在3中类型的action 中都可以获得到，但顺序在 action前面</p><p><strong>4） 外部环境变量</strong><br>awk  ‘BEGIN{for (i in ENVIRON) {print i”=”ENVIRON[i];}}’<br>结果：<br>HLVL=1<br>PWD=/home/homer<br>JAVA_HOME=/home/homer/eclipse/jdk1.7.0_05<br>SHELL=/bin/bash<br>PATH=/home/homer/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games<br>……….<br>注：  ENVIRON是子典型数组，可以通过对应键值获得它的值，linux 环境变量还有HOME，<em>H<strong>O</strong>M**E</em>，PWD等，可以通过linux 命令 env 查看</p>]]></content>
      
      
      <categories>
          
          <category> linux技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术笔记 </tag>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas安装使用</title>
      <link href="/2021/07/30/Arthas%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/07/30/Arthas%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>arthas-boot:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar -h</span><br><span class="line">java -jar arthas-boot.jar #选择进程号</span><br><span class="line">java -jar arthas-boot.jar 18095 #指定进程号</span><br><span class="line">java -jar arthas-boot.jar $(ps -ef |grep $USER| grep &quot;PortalWebMain&quot;| grep 8001 | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;)</span><br></pre></td></tr></table></figure><p>arthas-client:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-client.jar -h</span><br><span class="line">java -jar arthas-client.jar 127.0.0.1 3658</span><br><span class="line">java -jar arthas-client.jar -c &#x27;dashboard -n 1&#x27;</span><br><span class="line">java -jar arthas-client.jar -f batch.as 127.0.0.1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术笔记 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JsonFormatTool 跨平台json 格式化工具</title>
      <link href="/2021/07/28/JsonFormatTool/"/>
      <url>/2021/07/28/JsonFormatTool/</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于Qt5 框架开发的 JsonFormatTool，一款跨平台的json格式化工具</p></blockquote><p>依托强大跨平台和高效的qt5框架，简洁明了的UI界面布局，使用便捷的文本按操作功能</p><p><img src="/2021/07/28/JsonFormatTool/JsonFormatTool-01.png" alt="文本操作展示模板"></p><p>支持搜索高亮的json树展示结构</p><p><img src="/2021/07/28/JsonFormatTool/JsonFormatTool-02.png" alt="树状操作展示模板"></p><p>下载地址：</p><p><a href="https://download.csdn.net/download/qq_37865186/86501798" target="_blank">window 系统</a><br><a href="https://download.csdn.net/download/qq_37865186/86501796" target="_blank">macOS 系统</a><br><a href="https://download.csdn.net/download/qq_37865186/86501797" target="_blank">macOS（universal）系统，支持原生M1</a><br><a href="https://download.csdn.net/download/qq_37865186/86501795" target="_blank">linux 系统</a><br><a href="https://download.csdn.net/download/qq_37865186/87269042" target="_blank">跨平台 WebAssembly（基于浏览器）</a></p><p>更新记录：</p><p>2019年11月29日  v1.0 初始版本创建<br>2020年1月2日  v1.5 修复加载文件解析异常<br>2021年7月6日  v1.5.1 增加右侧复制分支功能<br>2022年6月25日 v1.5.2 增加去除json中的转义字符<br>2022年8月07日 v1.5.2 增加M1原生支持<br>2022年12月11日 v1.5.2 增加WebAssembly支持</p>]]></content>
      
      
      <categories>
          
          <category> 个人作品展示 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Lockbox跨平台密码记事本管理工具</title>
      <link href="/2021/07/28/Lockbox/"/>
      <url>/2021/07/28/Lockbox/</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于Qt5/Qt6框架开发的Lockbox，一款跨平台密码记事本管理工具。</p></blockquote><p><img src="/2021/07/28/Lockbox/Lockbox-00.png" alt="创建密码箱"></p><p><img src="/2021/07/28/Lockbox/Lockbox-01.png" alt="登录界面"></p><p><img src="/2021/07/28/Lockbox/Lockbox-02.png" alt="主界面"></p><p><img src="/2021/07/28/Lockbox/Lockbox-02-1.png" alt="笔记记事本类型保存"></p><p><img src="/2021/07/28/Lockbox/Lockbox-02-2.png" alt="银行类笔记类型保存"></p><p><img src="/2021/07/28/Lockbox/Lockbox-02-3.png" alt="电子信箱网站类保存"></p><p><img src="/2021/07/28/Lockbox/Lockbox-03.png" alt="分类界面标题搜索"></p>]]></content>
      
      
      <categories>
          
          <category> 个人作品展示 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>swagger2word 跨平台的代码生成与接口设计文档导出工具</title>
      <link href="/2021/07/28/swagger2word/"/>
      <url>/2021/07/28/swagger2word/</url>
      
        <content type="html"><![CDATA[<blockquote><p>基于java 框架开发的 swagger2word代码生成与接口设计文档导出工具，并具备按照swagger2规范定义的接口协议导出对应的接口文档与项目代码。</p></blockquote><p><img src="/2021/07/28/swagger2word/swagger2word-01.png" alt="树状操作展示模板"></p>]]></content>
      
      
      <categories>
          
          <category> 个人作品展示 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo命令说明</title>
      <link href="/2021/07/28/hexo%E5%91%BD%E4%BB%A4%E8%AF%B4%E6%98%8E/"/>
      <url>/2021/07/28/hexo%E5%91%BD%E4%BB%A4%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>安装：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo hexo-cli --registry=https://registry.npmmirror.com</span><br></pre></td></tr></tbody></table></figure><p>创建并初始化</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/myappWeb &amp;&amp; <span class="built_in">cd</span> ~/myappWeb</span><br><span class="line">hexo init <span class="comment"># 初始化</span></span><br><span class="line">npm install <span class="comment"># 安装组件</span></span><br><span class="line">npm install hexo-deployer-git --save <span class="comment">#git 部署插件</span></span><br></pre></td></tr></tbody></table></figure><p>配置SSH key</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/. ssh <span class="comment">#检查本机已存在的ssh密钥</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"GitHub 邮箱"</span></span><br></pre></td></tr></tbody></table></figure><p>进入部署目录设置git递交信息</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> .deploy_git</span><br><span class="line">$ git config user.name <span class="string">"liuxianan"</span>// 你的github⽤户名，⾮昵称</span><br><span class="line">$ git config user.email <span class="string">" xxx@qq.com "</span>// <span class="string">"// 填写你的github注册邮箱</span></span><br></pre></td></tr></tbody></table></figure><p>测试是否成功</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com <span class="comment"># # 注意邮箱地址不⽤改</span></span><br></pre></td></tr></tbody></table></figure><p>常见命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"postName"</span> <span class="comment">#新建⽂章</span></span><br><span class="line">$ hexo new page <span class="string">"pageName"</span> <span class="comment">#新建⻚⾯</span></span><br><span class="line">$ hexo generate <span class="comment">#⽣⽣成成静静态态⻚⾯⻚⾯⾄⾄public public⽬⽬录录</span></span><br><span class="line">$ hexo server <span class="comment">#开启预览访问端⼝（默认端⼝4000，，'ctrl + c'关闭server）</span></span><br><span class="line">$ hexo deploy <span class="comment">#部署到GitHub</span></span><br><span class="line">$ hexo <span class="built_in">help</span> <span class="comment"># 查看帮助</span></span><br><span class="line">$ hexo version <span class="comment">#查看Hexo的版本</span></span><br><span class="line">$ hexo clean <span class="comment">#清楚</span></span><br></pre></td></tr></tbody></table></figure><p>缩写：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo n == hexo new</span><br><span class="line">$ hexo g == hexo generate</span><br><span class="line">$ hexo s == hexo server</span><br><span class="line">$ hexo d == hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>组合命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g <span class="comment">#⽣成并本地预览</span></span><br><span class="line">hexo d -g <span class="comment">#⽣成并上传</span></span><br></pre></td></tr></tbody></table></figure><h1><span id="文字里面添加图片">文字里面添加图片</span></h1><blockquote><p>在<code>_config.yml</code>配置文件中，修改为 <code>post_asset_folder: true</code> 网站切割域名路径前缀位置 <code>post_asset_folder_position_length: 4</code></p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/ai930/hexo-asset-image --save</span><br></pre></td></tr></tbody></table></figure><blockquote><p>此时再执行命令 <code>hexo n article_name</code> 创建新的文章，在 <code>source/_posts</code> 中会生成文章 <code>post_name.md</code> 和同名文件夹 post_name,我们将文章中所使用到的将图片资源均放在 post_name 中，这时就可以在文章中使用相对路径引用图片资源了<br><code>![img_name](img_name.jpg) #文章中的图片资源路径格式</code></p></blockquote><h1><span id="给文章添加目录">给文章添加目录</span></h1><p>安装</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-toc --save</span><br></pre></td></tr></tbody></table></figure><p>使用方法跟显示文章摘要类似，在Markdown中需要显示文章目录的地方添加 `</p><!-- toc --><ul><li><a href="#yilia%E4%B8%8A%E4%B8%80%E9%A1%B5%E4%B8%8B%E4%B8%80%E9%A1%B5%E6%98%BE%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98">yilia上一页下一页显示的问题</a></li></ul><!-- tocstop --><p><code>在博客根目录下的</code>_config.yml` 中如下配置：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">maxDepth:</span> <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure><p><code>maxDepth</code> 表示目录深度为3，即最多生成三级目录。<br>找到主题下的文章模版，我的是<code>themes\yilia\layout\_partial\article.ejs</code>。<br>在其末尾增加代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (!index &amp;&amp; theme.toc){ %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  var tocEx = function(el){</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    var toc = document.querySelector(el), content = toc.innerHTML;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    content = content.replace('<span class="comment">&lt;!-- toc --&gt;</span>', '<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toc"</span>&gt;</span>').replace('<span class="comment">&lt;!-- tocstop --&gt;</span>', '<span class="tag">&lt;/<span class="name">div</span>&gt;</span>');</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    toc.innerHTML = content;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  }('.article-entry');</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&lt;% } %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.toc</span> {</span></span><br><span class="line"><span class="css">  <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="css">  <span class="attribute">margin-left</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background</span>: <span class="number">#f1f1f1</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">3px</span> <span class="number">#bbb</span>;</span></span><br><span class="line"><span class="css">}</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h1><span id="yilia上一页下一页显示的问题">yilia上一页下一页显示的问题</span></h1><p>修改<code>themes/yilia-plus/layout/_partial/archive.ejs</code> 文件</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.......</span><br><span class="line">&lt;% if (page.total &gt; 1){ %&gt;</span><br><span class="line">    &lt;nav id="page-nav"&gt;</span><br><span class="line">      &lt;%- paginator({</span><br><span class="line">        prev_text: '上一页',</span><br><span class="line">        next_text: '下一页'</span><br><span class="line">      }) %&gt;</span><br><span class="line">    &lt;/nav&gt;</span><br><span class="line">  &lt;% } %&gt;</span><br><span class="line">.......</span><br><span class="line">&lt;% if (page.total &gt; 1){ %&gt;</span><br><span class="line">    &lt;nav id="page-nav"&gt;</span><br><span class="line">      &lt;%- paginator({</span><br><span class="line">        prev_text: '上一页',</span><br><span class="line">        next_text: '下一页'</span><br><span class="line">      }) %&gt;</span><br><span class="line">    &lt;/nav&gt;</span><br><span class="line">  &lt;% } %&gt;</span><br><span class="line">.......</span><br></pre></td></tr></tbody></table></figure><p>修改<code>/Volumes/macData/Documents/jlynet_project/www.jlynet.cn/themes/yilia-plus/source-src/js/fix.js</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var $nav = document.querySelector('#page-nav')</span><br><span class="line">  if ($nav &amp;&amp; !document.querySelector('#page-nav .extend.prev')) {</span><br><span class="line">    $nav.innerHTML = '&lt;a class="extend prev disabled" rel="prev"&gt;&amp;laquo; Prev&lt;/a&gt;' + $nav.innerHTML</span><br><span class="line">  }</span><br><span class="line">  if ($nav &amp;&amp; !document.querySelector('#page-nav .extend.next')) {</span><br><span class="line">    $nav.innerHTML = $nav.innerHTML + '&lt;a class="extend next disabled" rel="next"&gt;Next &amp;raquo;&lt;/a&gt;'</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>修改成</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var $nav = document.querySelector('#page-nav')</span><br><span class="line">  if ($nav &amp;&amp; !document.querySelector('#page-nav .extend.prev')) {</span><br><span class="line">    $nav.innerHTML = '&lt;a class="extend prev disabled" rel="prev"&gt;&lt;/a&gt;' + $nav.innerHTML</span><br><span class="line">  }</span><br><span class="line">  if ($nav &amp;&amp; !document.querySelector('#page-nav .extend.next')) {</span><br><span class="line">    $nav.innerHTML = $nav.innerHTML + '&lt;a class="extend next disabled" rel="next"&gt;&lt;/a&gt;'</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>Hexo 字数和阅读时间统计插件</p><p>项目地址</p><p>链接: hexo-symbols-count-time</p><p>安装配置</p><p>安装插件：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></tbody></table></figure><p>在站点配置文件_config.yml 中添加以下代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true</span><br></pre></td></tr></tbody></table></figure><p>然后由于此插件集成在 NexT 中，然后只需修改主题配置文件_config.yml：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  item_text_post: true</span><br><span class="line">  item_text_total: false</span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></tbody></table></figure><p>最后一步，hexo三步走</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; hexo s</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 默认分类 </category>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术笔记 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
